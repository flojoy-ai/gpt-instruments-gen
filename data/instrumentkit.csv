,Field 1,Vendor,Device,Library,Device Description,Python docs link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Corrected device name,Device picture,Device Description Link,Device Category,Vendor logo,Vendor wikipedia or cruncbase description,Vendor website,Device datasheet (PDF),Vendor headquarters,"Yearly revenue (millions, USD)",Category Description,Category description link,ChatGPT prompt,Image URL,Vendor logo URL,Device Price,ChatGPT code,Obsolete,QA Notes,docstring
2,606.0,Thorlabs,PM 100 USB,Instrumentkit,"The PM100USB Power and Energy Meter Interface is compatible with all our C-Series photodiode, thermal, and pyroelectric sensors except for the ES408C Fast Pyroelectric Sensor. Our C-Type standard photodiode, slim photodiode, integrating sphere, and fiber sensors can collectively measure optical powers from 100 pW to 20 W. Our thermal power sensors measure optical powers from 10 µW to 200 W. Compatible C-Series pyroelectric energy sensors can measure energies from 10 µJ to 15 J and repetition rates up to 2 kHz. Note that the ES408C sensor for repetition rates up to 10 kHz, also available below, is not recommended for use with the PM100USB interface, which supports a maximum repetition rate of 3 kHz. Alternatively, other unamplified anode- or cathode-grounded photodiodes with up to 5 mA photocurrent, thermal elements with a maximum output voltage of 1 V, or energy sensors with voltage outputs from 100 mV to 100 V may be used.

This interface can be operated and powered by a PC via the mini-USB port. A readout rate of 300 samples per second allows active signal monitoring while the interface is in use.",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#pm100usb-usb-power-meter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/pm100usb.py,PM100USB,"[OrderedDict([('id', 'attE3gJZRoLQpO3nR'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fzbUdu1FWQZkXamlZfuoKw/asK4EC7mliD4nvk_LxFK4QVvnn9ecGtjAuRu4mfJeex7wE1UXlnuZgqYjnlBfgR50m71B2Wgqwq4b17SRUyyoAIiF34L4jl7s69Nu1Bg2y8/pDd_EDBzf_NBaAo2l2kmWhaUJRSk9plMIIZWnPGygrE'), ('filename', '8135_PM100USB_SGL.jpg'), ('size', 136075), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YJDeKFDI48fLthB7yqs5GQ/TCgredn6ZGNGkRBAqaLgcKtgIhUPMCLBoZHDYQSYDHhCmfcBotqHWSk1hwQKKRkGH3iB98jhAYTgepb1VWu_ag/BGH3fyh2BPHk6NdB7ES9x3EOle5ETp8g8oZpNE2xRGs'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PepEOYChcl2SUhHqwUE_Cg/EIFMQIHwuQ33yHJcspjbf2SGWLbKry7M2M1Me8mK377g0eUvWBEv_-fTyJi0FCsNnuJ11pKfn_B8WkrseAFKhA/6LJhDc3P7JK2CTaTRx2iJXD2WV5fRGeYrUigh-U4fu4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BQcqGPnd2tGugoh2OHh9dQ/T1DVJ1z43wHOicMIhsH6MtUMWjHgSCvTl6jdaDdve7mm73eqVbMQUqzFzCQSONHNHeeG-as9PpC6fMuspvU79Q/rdl4m1ZAZPOj30Nqdg6zWlPaKec0PSOpguoRdQ-42BM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037&pn=PM100USB,['Power Meters'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,USA,550.0,These interfaces provide communication between an attached sensor and a PC or other external control unit. They are designed to be controlled via an external device or operated autonomously using the analog output; there are no controls or display screens.,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037,Write a Python script that uses Instrumentkit to connect to a PM100USB Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782423/Instruments/Power%20Meters/PM100USB/PM100USB.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,487.99,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
3,384.0,Newport,Picomotorcontroller 8742,Instrumentkit,"The model 8742 is a 4-axis open-loop intelligent motion controller/driver that provides a compact and low cost solution for driving New Focus open-loop Picomotors products. It is a single-box solution that can be computer controlled via USB and Ethernet communication interfaces using Newport Motion Control Language (NMCL) command set. Both interfaces are well supported via Windows DLL, sample LabVIEW™VIs, and intuitive graphical user interface (GUI) Windows application with device auto-discovery feature. Each model 8742 controller/driver can control one of four 4-pin RJ-22 single output ports for use with any single-channel Picomotor actuator at any given time. The model 8725 multi-axis adapter can be used to connect the 4-pin RJ-22 output ports on the drivers to New Focus™ Picomotor products with 6-pin RJ-11 connectors. Note: Power Supply not included",https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#picomotorcontroller8742,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newport_pmc8742.py,Picomotorcontroller 8742,"[OrderedDict([('id', 'attloDMGvxGciAsjA'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RfO26RDoGuPJlpTp6P1Vhg/tGNpbi6qv7r91MDS-CI2Mhq2lP9YpblT1x0d2-Mt2pF0Kx5xtOx-xTAMjk4yysM3nVc1Z0vA-ddFn20-5xmENZ_Bvbxm_XgDu7mSTE4QRvs/FUPCIOCCNwmHcKU84Oswk05L_yK2tK-Gjsh4Tyo8_7Y'), ('filename', '8742_with_RS485_400w.jpg'), ('size', 22135), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kyIrjnoil1W3BqVOU3ZJeQ/oEzuLIwNDO1196IvpoF3T4KXBZ2IYcOGNDyfXpkQpE3NT4UGHIMqezyAWkJW0iqNFJuI1-LXZuOmeN3Lw9B-0Q/qLDSWnOXyWDyCAK7ycyZ6GHRFWzUjDttQT_4RbXhtPA'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OwquxQdQK_8uIoO5Y4fbpg/ldwzU5xGS1Wfp-b63Ugjmq1sLiFQrcad5McyHfgtu7a8JIgnoqCnJwgX3eT1QeFuc4cSgnymo_9gPwQ8k01SjA/ZOy_9--JvJy07WVLE0HB0RucOobyzkvdU-h1e91AZ-o'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Z7EoNQO-89kRANd18Iw7-A/GvONTQEoAY9KPdQDScJ_OawMHj3IIT7zTao2qs4-kJyblFHHC6dz6GjvwPnM2fnVHZOZ0-irexwLxbGlXhVvhw/yBO_5nozOsfhDVl9zE7AzzanC3g_lthxv6FpxU9DTG0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/p/8742,['Positional Controller'],"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FEWzl_hzGTfl7OvJgJBdBw/tPUDo5GPB1KUxhEyyOyobsP-KEoiK2Ih0xVZaUfiHiCt8r8W4khZe5VI19-bfsWgJr3xTYo2OiKTwJWjUJomWLKyq_9tO2Hmp27pDpqzx-g/VaW543YV-j-evaaGXiVtfJJ5PPutORCTokI0LUABPIc'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vzEo1yHydkYTKcvHU805lg/CN-Pa1g8KwDGrdj8avQ4kKAmq7GFLPkZWa2UP04inCOeRMltWULhATvOM4IlAHcgVsXm1VdKVfkKjfQ-doZuMQ/mAI8eljB2LprW6B5NUwrGo3_Uqhn4syCcDAEHs1345k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZWcs6GDcJ0WTbiq0cPGZg/77XjGUVRHP1QY9Et0AK2dUapnZ3BKA0ZFBF02a0GHvgloiyQAx_1bhBRMiUHP1mBT85PJwHOVvWgte2i91UMyg/c1h_II4v-sB65q3OPWiLcoZAYpxxo71GcwvmsgmcK90'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q5473MlvnA3X6gpdkxtp3Q/btNVEPK-gcX1En1uum6OoqnGCibk8YOVbpyUjAX1wT5sVyYQ5RwHd0sED4XLD64CkxE8G1C54Q9cRyxHz-DddA/T5IaJdzzqvtdLXEa73S1td6HEBjTZuUGAi2Itohi9Dw'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,https://www.newport.com/medias/sys_master/images/images/h8e/hfa/8797030088734/8742-Datasheet.pdf,"Irvine, California, United States",3500.0,"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782424/Instruments/Positional%20Controller/Picomotorcontroller-8742/Picomotorcontroller-8742.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116708/Instruments/Vendor%20Logos/Newport.png,1260.0,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
18,386.0,Newport,Newportesp 301,Instrumentkit,"The ESP301-3N 3 Axis Motion Controller and Driver is the successor of the popular ESP300 motion controller. The ESP301 provides the same functionality as the ESP300 with a standard USB interface and extended front panel functions. For maximum backward compatibility, the ESP301 features the same motion commands and control algorithms and the same casing as the ESP300. The ESP301-3N drives and controls up to three axes of motion using any combination of DC or 2-phase stepper motors up to 3A per axis. This capability enables driving a large selection of Newport stages and actuators. Featuring an integrated manual front panel interface and Newport's unique ESP stage auto-detection and auto-configuration, the ESP301 provides most easy operation and excellent functionality at an affordable price.",https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newportesp301-motor-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newportesp301.py,Newportesp 301,"[OrderedDict([('id', 'attIAGKtQzOcnhr4i'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ubnc0w7W9qjq0Yen5WK_1A/fcl-rI0QUhR3z1o9wmsre4R1ngTMTSSmXcyN__jvizRQ8o4SKVpC2BnrxXbsqoVjJnNfhcVEZua3dykPe8v_ffrr9Ns5CpXuy-0KjMNxCGqf-Nh14-nXrHcqn7u0DY1v/GmF6vz5y1J3OmXRyO4ADsAleFLmsJI7x_uLsPa6kli4'), ('filename', 'MC-ESP301_06_Position_400w.jpg'), ('size', 11025), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/A9MfahadWvTLcuDe2Ro-wQ/l8nyK5M3jz_N30ku4ZZvxX8yXUc0GnQi5x1GuHNEtKeY5fwFPGKOhalivq3zzPRym1m0WE6p66Df2hPHATGA4w/FNwB7tkkkfUU5bQ_9w8XTMTTUFD_SS6YU59JO-m0K50'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-tTebjAOgux65PXUrofR4Q/gBVlZVY9r-UzntH25ptLVKMGhjvRvr_79efoscw5ZagAf3rqEP24ioP607H1Vvw7MVNZ38n-57RuNSf40AKq8Q/jHA1sapVQc-13_yOECis2ccnIFZuWPVe602-uR2zTmQ'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YqAZLJTIsA8FcZQO2aW2eg/gYcaXyWf9m8WZ7gq0MHBmoiOfYYkXavIkEqgfvTNHWjUTj32Dg_CZ7kvBkUpY0iX-Uv85Cn2yvXXn3l2khIB-w/-mGHYa6UMJsOVwju-B5Ww0omZ16ot6xjAVLK5tcLKkE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/p/ESP301-3N,['Positional Controller'],"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FEWzl_hzGTfl7OvJgJBdBw/tPUDo5GPB1KUxhEyyOyobsP-KEoiK2Ih0xVZaUfiHiCt8r8W4khZe5VI19-bfsWgJr3xTYo2OiKTwJWjUJomWLKyq_9tO2Hmp27pDpqzx-g/VaW543YV-j-evaaGXiVtfJJ5PPutORCTokI0LUABPIc'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vzEo1yHydkYTKcvHU805lg/CN-Pa1g8KwDGrdj8avQ4kKAmq7GFLPkZWa2UP04inCOeRMltWULhATvOM4IlAHcgVsXm1VdKVfkKjfQ-doZuMQ/mAI8eljB2LprW6B5NUwrGo3_Uqhn4syCcDAEHs1345k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZWcs6GDcJ0WTbiq0cPGZg/77XjGUVRHP1QY9Et0AK2dUapnZ3BKA0ZFBF02a0GHvgloiyQAx_1bhBRMiUHP1mBT85PJwHOVvWgte2i91UMyg/c1h_II4v-sB65q3OPWiLcoZAYpxxo71GcwvmsgmcK90'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q5473MlvnA3X6gpdkxtp3Q/btNVEPK-gcX1En1uum6OoqnGCibk8YOVbpyUjAX1wT5sVyYQ5RwHd0sED4XLD64CkxE8G1C54Q9cRyxHz-DddA/T5IaJdzzqvtdLXEa73S1td6HEBjTZuUGAi2Itohi9Dw'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,https://www.newport.com/medias/sys_master/images/images/hda/h3e/9117547069470/ESP301-User-s-Manual.pdf,"Irvine, California, United States",3500.0,"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782436/Instruments/Positional%20Controller/Newportesp-301/Newportesp-301.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116708/Instruments/Vendor%20Logos/Newport.png,,,True,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
20,547.0,Tektronix,Tektds 224,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/intro.html,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tektds224.html,TDS224,"[OrderedDict([('id', 'att89SCom6OfiH4jE'), ('width', 1157), ('height', 687), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/AHZgonxmm8XClfISFB4WoA/CHwexJy6R-b40YUNxeUF84YhJVXkcov5J2pvjaH9wM0yRFX1fpee9L5hiet-kGJvjpqZJn_Uu_Q6x0j7tbVWvVSdw5NktwRyf3RGQDYynCE/mEHguhDH6glSYy4FgRowkCKEAOUfw_wlI0RL25_NnJI'), ('filename', 'TDS224.jpeg'), ('size', 134607), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/K31tchtIcvWzk3JVb45z3w/EUL7sBcLEQj56o4UE_xAVs_KireKoJsTncQuyFwGgnzYTiTHwnfZJTiSU1eLGGZsZyBD3ZsMFpnAZPzzM2pJMg/Zp5VCF_ebQBdN5cuSJa_EGoqxbrZjO4PtZSGKNTTh8Q'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9R0JZdjIHhJIu8ZQ5mm-EA/ggllzfffrtqXHZrO3YAe0DD9s_evFvqniEwZy4QeY8MsnSg3ajEXWZVzLb-QqM4xb_pxgoX5beGovJJgN7AoYw/p3IJLWqlv1VUXSPOCZi7Sd8BmJ3QUfaNulcZZySdlNQ'), ('width', 862), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/S4Ky1MtBpSwdUNj2IWGxaw/UvcQAgwGtK4ovBBtvpyFJdoYg18MLC2rqMSY131M-MNkvKVv-9VngwYGRQLhgk1x_jTbCRjLY_-6kV9tCEB7vg/KiQ2FcLMD3sv4GOqrHSDJufOedvvsLesMhDUxRE-8tc'), ('width', 3000), ('height', 3000)]))]))])]",,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS224 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782513/Instruments/Oscilloscopes/TDS224/TDS224.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,,,
25,237.0,Keithley,Keithley 485,Instrumentkit,"The Keithley 485 Autoranging Picoammeter provides 100fA sensitivity with 4 1/2-digit resolution in a low-cost, highly sensitive, easy-to-use instrument. The 485 measures DC current on seven ranges covering 10 decades from 100fA to 2mA. The input can withstand overloads as high as 1000V (with 100kΩ limiting resistor) for flexibility in a wide range of applications in test, research, and student labs. An analog output linearly converts the incoming current to voltage for hard copy output or control loop applications.
",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley485-picoammeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley485.py,Keithley 485,"[OrderedDict([('id', 'attvUEoTPINWnGzN5'), ('width', 600), ('height', 318), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qwSUKIpGTfBRSnaKmTPOtw/0CliUuv063nD-ObkUMFXt0obuURwA86tIHp_3F3QM8PrVsCUC2GwaqwR98egd0LwFdYAdL2_szOQ0_1ePPlz9lfaQT5jrKFtFHVzGwuKPks/JT2mCvRE3z8mzmc9WccxTDO3l30KQrtxdMwVvpVo2Fo'), ('filename', 'Keithley_485_View5.jpg'), ('size', 71051), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/elU9HAKsup-VMDnmr8pcUw/nSfm_FBP_iG0VkuG1XVCl3p0-gYbZkFjj436DnY_rywYncxkoF2yGpktWqncV1BvKDJpWRq7yP9CTtEeUyTKYQ/r5cTuCpntwyrtOIL9UC1Z_Ix9J3q-zDZ3JAfCmCwJfA'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/btCgjyUY5lYjfHD7bBip_A/S7y4KaJBH9x_h3QZy3cz5AJQz5mM4QoncRCyzRg0Q6syO_cucRFAdu3yXJ_O46gbfcl-lUFj63AWABCChQ5LZw/GIFdeVWcG9mvxvTzS0XsuATflqNTDAsR23CwFVA40X4'), ('width', 600), ('height', 318)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/r6L47YRhUF6GAeCbzyrKUw/gCD3JsxCjnhWkybUHeKW46iLTjd5wS2jgyAOtUgoPDZAXJI4KnOMS34RAF9Uio4G4c_-xeD6Z7z7ftpJLr49wg/4G5h2FktQHTlS5dbxtrC3j8Z2xI6gs7N-kgHFRBIcR8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/67358-1/Keithley-485-Autoranging-Picoammeter,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/KEITHLEY-485-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.",https://en.wikipedia.org/wiki/Electricity_meter,Write a Python script that uses Instrumentkit to connect to a Keithley 485 Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782442/Instruments/Power%20Meters/Keithley-485/Keithley-485.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
35,250.0,Keithley,Keithley 2182,Instrumentkit,"The two-channel Model 2182A Nanovoltmeter is optimized for making stable, low noise voltage measurements and for characterizing low resistance materials and devices reliably and repeatably. It provides higher measurement speed and significantly better noise performance than alternative low voltage measurement solutions. It offers a simplified delta mode for making resistance measurements in combination with a reversing current source, such as the Model 6220 or 6221.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley2182-nano-voltmeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley2182.py,Keithley 2182,"[OrderedDict([('id', 'attKCSe2wix9ghzw6'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/76we3H6EVOLZy4u7CQfRgw/syXKeiCH_8Ps_Bxm6fAjXj_A6TPoFcf4XK_FDdnmqrSb-RwfJE_rcvH43BDW7V1H8jplGU67m69aON55IfAHqw/mhSudpRDHMc4Qs68atrfBhE-LHoxyte9LPJhCAoKyn8'), ('filename', '2182.jpg'), ('size', 23819), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ubi_X0r1Kh_F55j513TcIw/OovBCbjIL60_HLswIfRchN8Mn9lYD37pXbKh0ZTQV0AaWECdE6rKG9kdgXhq1xiDLxl-bfPpGUCQ4daMCqtijQ/d9QTg0F1YSoIr5DEhWac3FFKjCAU5Z2GzT_Rz8m_VyM'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Lepo2PBGF1XFmY1P6Z2qLg/NxMnvPH9QMxau2F_fJ3GFjkoatWRZwTBL1id3q946F6JWFo_T2LglzxOjMamXhQVePs0zU4LbKyE5yJdyK7Y3g/A62oVKDKP8zuLnbGbROgTf5JjyJlVZnzCwB3JS7c5WQ'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kEYHOAMMZWTzBrkaL9JlWg/Poz9ZEzM48wszG5WrccUOglzhJQNFDraZYtXKnJbozGCd9_Tc9XtIvNMjVSI_55TndNi4a2nizRbPR1MB-nXCA/V3XSEYzr7WuEBshLrdUE65FquTM__jcweTrsndAUlxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/nanovoltmeter-model-2182a,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://download.tek.com/datasheet/2182A-15912.pdf,"Cleveland, Ohio, United States",110.6,A voltmeter is an instrument used for measuring electric potential difference between two points in an electric circuit. It is connected in parallel. It usually has a high resistance so that it takes negligible current from the circuit.,https://en.wikipedia.org/wiki/Voltmeter,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782450/Instruments/Power%20Meters/Keithley-2182/Keithley-2182.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,7500.0,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
42,432.0,Qubitekk,CC1,Instrumentkit,Qubitekk’s 2-channel Coincidence Counter provides researchers with a low-cost solution for nanosecond resolution coincidence counting. A third gating channel makes the counter suitable for use with pulsed sources.,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#cc1-coincidence-counter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/cc1.py,CC1,"[OrderedDict([('id', 'attW3pZ1U5zs32JXd'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GtNYEFEOWiMvgLv3mMMt1w/gxqT4vhWHcm17Rbjpj_I9lmAnrLDYrERzbQgqgqHTb8HBIlT6ksj5MvMoUJE8JseQ4zFzJpmcF0l64J49sC0-j8kPIHakRZz3-dmZlUb_9gRg4oxCAOBn-sZ_vBY3NlJ/y0r4LycvY406qgOAmL6qTxkHjy-NW3Pmb-P1jjmX_UM'), ('filename', 'QBTK006_Handheld_Coincidence_Counter.jpg'), ('size', 43231), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CpdAWk-3uejlvTHznKzQxQ/G_uGnE_SvxHbc1HU71pzKRcY-QOW35aTaeNWtYjM4-aKFoIeJPYlSSxJGUDHPY31HWXFJQAlMWKDl9ZUU5zvng/YiGFCizgrGbW3v_JTPGf9gVzXk_o64Oq8pdCzUsIsBo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/U1aGAXrn11eoZMedaFD6tw/ubci8G3QYEWEgtwqF_TbkAP5BuSjlowlKctRj3pyT4eZirYFaJM3bhSIB7bpchpUADJxgMszLsqKAmFgFYmcmw/lYOOKs09FAYrqxcnwYUMfp7ANjR7xtCywv00E7DDZC8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kKwNYVzTcYLrlKrDPx6IVw/JnpJc5jLmlXfhZmr_xeWA5jTyk_tTTk2R9WM5RgdktxbEvQTbo8YTQQKse5WrUfGEU4mfTyqGUnagRJ4NDTnvg/PSA32a_i0W9GMuJPlPDKrPCNBC7WJs3hyzJ4N8mhyb0'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/products/coincidence-counter/,['Coincidence Counter'],"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4ijrLHLMvOyqle0SY059yQ/CXZr3NpK0Z0IgC0x8X1iruyvfSYSVt-7Ilztem3QxSLNBh__JyUxJrMYbeqH9H2XWNpcy_x1ixFOKNnYyDv180FNXAx60eG3uZuWCFXjwwqZO-xV3fEJDO8hVw1VbB8g/IqG-AigygKQH5u1vt2i5NasYa15GxrADK82y_zCoaLs'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BkGFFHsZQ62QuxK6IyCdrA/jsddFBYN5dDdb11iizAizNjUzpKhCpO0qjFkzd-kXRdhbyrO2iY3v-x6usmx2Dj7tRjnnEp_fCJlDNS2L1U9Xg/oZNUPNwjwSIqztq7O377L_DqMCls6AJlE60n1_7aoPs'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KO1pHcrqfsjUAro1j_pATg/l2AzsU_gW7cWzeLOB_EM1dA51yOdlwRIk1wwbirqDAbvRCnRTyPQ9h7NRijrig0u-eJ7eJs2sNsjddK-t51VcQ/OYj2Xr3s7-cP7Lx9LDSLv0BqgimXXcL5icKcIeXEFJM'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tGdHvx5craZwVcERJ6Z8kQ/HVaw5Q8XDvDOTNzEH6vDfyEecq9dI9jUgEt5myKoAyahdN0UEKJGcHO374HTlt3m_3IKUT6f1KE0oiADC8NbMg/j-gQQw3F7Wwt8xkWWEgDR1H7Huu3-Z7HHaJjxxl0d10'), ('width', 3000), ('height', 3000)]))]))])]","Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",https://qubitekk.com/,,"Vista, California, United States",5.0,"In quantum physics, coincidence counting is used in experiments testing particle non-locality and quantum entanglement. In these experiments two or more particles are created from the same initial packet of energy, inexorably linking/entangling their physical properties. Separate particle detectors measure the quantum states of each particle and send the resulting signal to a coincidence counter. In any experiment studying entanglement, the entangled particles are vastly outnumbered by non-entangled particles which are also detected; patternless noise that drowns out the entangled signal. In a two detector system, a coincidence counter alleviates this problem by only recording detection signals that strike both detectors simultaneously (or more accurately, recording only signals that arrive at both detectors and correlate to the same emission time). This ensures that the data represents only entangled particles.",https://en.wikipedia.org/wiki/Coincidence_counting_(physics),Write a Python script that uses Instrumentkit to connect to a {Device name} Coincidence Counter,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782456/Instruments/Coincidence%20Counter/CC1/CC1.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116712/Instruments/Vendor%20Logos/Qubitekk.png,,,,,"

Source code for instruments.qubitekk.cc1
#!/usr/bin/env python
""""""
Provides support for the Qubitekk CC1 Coincidence Counter instrument.

CC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi.scpi_instrument import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units, split_unit_str

# CLASSES #####################################################################


class CC1(SCPIInstrument):

    """"""
    The CC1 is a hand-held coincidence counter.

    It has two setting values, the dwell time and the coincidence window. The
    coincidence window determines the amount of time (in ns) that the two
    detections may be from each other and still be considered a coincidence.
    The dwell time is the amount of time that passes before the counter will
    send the clear signal.

    More information can be found at :
    http://www.qubitekk.com
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\n""
        self._channel_count = 3
        self._firmware = None
        self._ack_on = False
        self.sendcmd("":ACKN OF"")
        # a readline is required because if the firmware is prior to 2.2,
        # the cc1 will respond with 'Unknown Command'. After
        # 2.2, it will either respond by acknowledging the command (turning
        # acknowledgements off does not take place until after the current
        # exchange has been completed), or not acknowledging it (if the
        # acknowledgements are off). The try/except block is required to
        # handle the case in which acknowledgements are off.
        try:
            self.read(-1)
        except OSError:
            pass
        _ = self.firmware  # prime the firmware

        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            self._bool = (""ON"", ""OFF"")
            self._set_fmt = "":{}:{}""
            self.TriggerMode = self._TriggerModeNew

        else:
            self._bool = (""1"", ""0"")
            self._set_fmt = "":{} {}""
            self.TriggerMode = self._TriggerModeOld

    def _ack_expected(self, msg=""""):
        return (
            msg
            if self._ack_on and self.firmware[0] >= 2 and self.firmware[1] > 1
            else None
        )

    # ENUMS #

    class _TriggerModeNew(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""MODE CONT""
        start_stop = ""MODE STOP""

    class _TriggerModeOld(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""0""
        start_stop = ""1""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a channel on the Qubitekk CC1.
        """"""

        __CHANNEL_NAMES = {1: ""C1"", 2: ""C2"", 3: ""CO""}

        def __init__(self, cc1, idx):
            self._cc1 = cc1
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        # PROPERTIES #

        @property
        def count(self):
            """"""
            Gets the counts of this channel.

            :rtype: `int`
            """"""
            count = self._cc1.query(f""COUN:{self._chan}?"")
            tries = 5
            try:
                count = int(count)
            except ValueError:
                count = None
                while count is None and tries > 0:
                    # try to read again
                    try:
                        count = int(self._cc1.read(-1))
                    except ValueError:
                        count = None
                        tries -= 1

            if tries == 0:
                raise OSError(f""Could not read the count of channel "" f""{self._chan}."")

            self._count = count
            return self._count

    # PROPERTIES #

    @property
    def acknowledge(self):
        """"""
        Gets/sets the acknowledge message state. If True, the CC1 will echo
        back every command sent, then print the response (either Unable to
        comply, Unknown command or the response to a query). If False,
        the CC1 will only print the response.

        :units: None
        :type: boolean
        """"""
        return self._ack_on

    @acknowledge.setter
    def acknowledge(self, new_val):
        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            if self._ack_on and not new_val:
                self.sendcmd("":ACKN OF"")
                self._ack_on = False
            elif not self._ack_on and new_val:
                self.sendcmd("":ACKN ON"")
                self._ack_on = True
        else:
            raise NotImplementedError(
                ""Acknowledge message not implemented in "" ""this version.""
            )

    @property
    def gate(self):
        """"""
        Gets/sets the gate enable status

        :type: `bool`
        """"""
        return self.query(""GATE?"").strip() == self._bool[0]

    @gate.setter
    def gate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""GATE"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def subtract(self):
        """"""
        Gets/sets the subtract enable status

        :type: `bool`
        """"""
        return self.query(""SUBT?"").strip() == self._bool[0]

    @subtract.setter
    def subtract(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""SUBT"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode setting for the CC1. This can be set to
        ``continuous`` or ``start/stop`` modes.

        :type: `CC1.TriggerMode`
        """"""
        return self.TriggerMode(self.query(""TRIG?"").strip())

    @trigger_mode.setter
    def trigger_mode(self, newval):
        try:  # First assume newval is Enum.value
            newval = self.TriggerMode[newval]
        except KeyError:  # Check if newval is Enum.name instead
            try:
                newval = self.TriggerMode(newval)
            except ValueError:
                raise ValueError(""Enum property new value not in enum."")
        self.sendcmd(self._set_fmt.format(""TRIG"", self.TriggerMode(newval).value))

    @property
    def window(self):
        """"""
        Gets/sets the length of the coincidence window between the two signals.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units nanoseconds.
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(*split_unit_str(self.query(""WIND?""), ""ns""))

    @window.setter
    def window(self, new_val):
        new_val_mag = int(assume_units(new_val, u.ns).to(u.ns).magnitude)
        if new_val_mag < 0 or new_val_mag > 7:
            raise ValueError(""Window is out of range."")
        # window must be an integer!
        self.sendcmd(f"":WIND {new_val_mag}"")

    @property
    def delay(self):
        """"""
        Get/sets the delay value (in nanoseconds) on Channel 1.

        When setting, ``N`` may be ``0, 2, 4, 6, 8, 10, 12, or 14ns``.

        :rtype: `~pint.Quantity`
        :return: the delay value
        """"""
        return u.Quantity(*split_unit_str(self.query(""DELA?""), ""ns""))

    @delay.setter
    def delay(self, new_val):
        new_val = assume_units(new_val, u.ns).to(u.ns)
        if new_val < 0 * u.ns or new_val > 14 * u.ns:
            raise ValueError(""New delay value is out of bounds."")
        if new_val.magnitude % 2 != 0:
            raise ValueError(""New magnitude must be an even number"")
        self.sendcmd("":DELA "" + str(int(new_val.magnitude)))

    @property
    def dwell_time(self):
        """"""
        Gets/sets the length of time before a clear signal is sent to the
        counters.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units seconds.
        :type: `~pint.Quantity`
        """"""
        # the older versions of the firmware erroneously report the units of the
        # dwell time as being seconds rather than ms
        dwell_time = u.Quantity(*split_unit_str(self.query(""DWEL?""), ""s""))
        if self.firmware[0] <= 2 and self.firmware[1] <= 1:
            return dwell_time / 1000.0

        return dwell_time

    @dwell_time.setter
    def dwell_time(self, new_val):
        new_val_mag = assume_units(new_val, u.s).to(u.s).magnitude
        if new_val_mag < 0:
            raise ValueError(""Dwell time cannot be negative."")
        self.sendcmd(f"":DWEL {new_val_mag}"")

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                if self._firmware.find(""Unknown"") >= 0:
                    self._firmware = None
                else:
                    value = self._firmware.replace(""Firmware v"", """").split(""."")
                    if len(value) < 3:
                        for _ in range(3 - len(value)):
                            value.append(0)
                    value = tuple(map(int, value))
                    self._firmware = value
        return self._firmware

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> cc = ik.qubitekk.CC1.open_serial('COM8', 19200, timeout=1)
        >>> print(cc.channel[0].count)

        :rtype: `CC1.Channel`
        """"""
        return ProxyList(self, CC1.Channel, range(self._channel_count))

    # METHODS #

    def clear_counts(self):
        """"""
        Clears the current total counts on the counters.
        """"""
        self.sendcmd(""CLEA"")


"
44,169.0,Holzworth,"Holzworth HS 9000 
",Instrumentkit,"HS9008B - 8 Channel, 1U RF Synthesizer - Phase Coherent",https://instrumentkit.readthedocs.io/en/latest/apiref/holzworth.html#hs9000-multichannel-frequency-synthesizer,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/holzworth/holzworth_hs9000.py,HS 9008B,"[OrderedDict([('id', 'att9iBW4LwVyUukeF'), ('width', 1808), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JYn0Gq5B4wgWhe_KeXSS0Q/0pHsZu9PxhUMzXpwZ89WbfGrfBJXejZP1FVJd3kj_1HeGTnkARSAlFEVRbkcKvRNR8L-TPV-e56_KSauG38k-qiFm2nR9eVSsO_2_nIySLM/gcYC3Je4DwVbOg8KLJWsk7t5M8OCyyPP1053J_FjGX4'), ('filename', 'hs9008b-right-face.jpg'), ('size', 110410), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G01jyb9wP06VYQEuTiK6sw/xLzH9ufIyvuHp9yrQ-ToT6Dn70hLPEzxIm87gj_I4iVkxJXxOO5cE72ejhVw0rqkyVMWqAkngVsMOKIL4nNrQw/NuSkJ5tEOMxr0v4NHzhnvKt3EHe_-UJHljZ06amsMJA'), ('width', 88), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/D_nUm2w04_KFFRDcw0swAA/S5xfZlPfNloGLqRnpt4sANiWpBoTBH_DSUzPbKlvu6ZPnIWCVMYZdJCsFGCztrLMxJpJ9RqofTT3gpR9O3g1Ow/WM-BFUJQddNxwHDmPbYDMnzqt0_qhLMh6DL_WjW4UF4'), ('width', 1249), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i939sATlCKd6cMW5bc01rA/C-FZ3KUVnwt5SweaKfQ3xmbtWse1fIo35GOYvoX2uuXBNvfLoLeJRdSbfm8whaIcH-FNu4MbfDIP-0ClCeULeg/vuzHW3nFL5z87BcxQGLADgjLo2M6bn1Gw1qTANXg4x8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.testforce.com/products/additional-products/accessories/hs9008b.html,['Frequency synthesizer'],"[OrderedDict([('id', 'attbKqwLCO8edU9zL'), ('width', 410), ('height', 116), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/s_QLHUEqrwPHj4-YsC3UmQ/dW9cBpDjcIKiIMLDKzwJigTbh0ihiIL0DFLDDGoNyUAxTlUAyhfZilYlQLmDXaqI8egq24dcbfP3uTsqmpoh-Snh-p3TMFvToa8yRNxJuJs/cAuP8gFZ28CwyMHa522TouLj9BGhSIXdxtbbRFHxH20'), ('filename', 'logo-Holzworth.jpg'), ('size', 8728), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rVfOonEWNBWOR0EH4QgQTg/MlZo4G5QWxkuV_UwGtyFvMdV0xUNgfajFNP92vAwtJ0vub-HczKaNxt5iFaLZ265mOvE1Q4-tH1hpN1ON62f3g/bjMhUXiM8baB2D12CWqFnOmXYC4_bhd9Wdu_9mLGS6w'), ('width', 127), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WI0Nk51h0hCgs1G2XlpgDg/T3_YQ5ZYJ-OLQVxrsVyP641BUV1yqSqqG_pV7vLWHLzdiEOPsCbfr_KtkHFqH5X4qaETVDno1SXnddKj5SFpfw/a6M3kTvvngLzbITPcJIk8kbqaqrDQgTfzTQJWf4rBuY'), ('width', 410), ('height', 116)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/inF4Y4z0dUPwAi3Icyt77Q/KCyJYpmid0dKof1OQ36w0RwQafSDOaDp61iFfDowDU9F0jOKQPQrKFf9KjcIA4y4kmxod5Hh85ufX8A8Zb7mww/CMulkfTg0pgWdHap7XHWAbng--qx2UuvV2UWGjtF_lw'), ('width', 3000), ('height', 3000)]))]))])]","**Holzworth** Instrumentation is a leader in high-performance phase noise analyzers and RF/microwave synthesizers optimized for ultra-low phase noise
",https://holzworth.com,https://holzworth.com/Portals/0/datasheets/hs9000-series_datasheet.pdf,USA,3.0,A frequency synthesizer is an electronic circuit that generates a range of frequencies from a single reference frequency.,https://en.wikipedia.org/wiki/Frequency_synthesizer,Write a Python script that uses Instrumentkit to connect to a HS 9008B Frequency synthesizer,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782458/Instruments/Frequency%20synthesizer/HS-9008B/HS-9008B.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116710/Instruments/Vendor%20Logos/Holzworth.png,6700.0,,,,"

Source code for instruments.holzworth.holzworth_hs9000
#!/usr/bin/env python
""""""
Provides support for the Holzworth HS9000
""""""

# IMPORTS #####################################################################


from instruments.units import ureg as u

from instruments.abstract_instruments.signal_generator import SignalGenerator, SGChannel
from instruments.util_fns import (
    ProxyList,
    split_unit_str,
    bounded_unitful_property,
    bool_property,
)

# CLASSES #####################################################################


class HS9000(SignalGenerator):

    """"""
    Communicates with a `Holzworth HS-9000 series`_ multi-channel frequency
    synthesizer.

    .. _Holzworth HS-9000 series: http://www.holzworth.com/synthesizers-multi.htm
    """"""

    # INNER CLASSES #

    class Channel(SGChannel):
        """"""
        Class representing a physical channel on the Holzworth HS9000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `HS9000` class.
        """"""

        def __init__(self, hs, idx_chan):
            self._hs = hs
            self._idx = idx_chan

            # We unpacked the channel index from the string of the form ""CH1"",
            # in order to make the API more Pythonic, but now we need to put
            # it back.
            # Some channel names, like ""REF"", are special and are preserved
            # as strs.
            self._ch_name = (
                idx_chan if isinstance(idx_chan, str) else f""CH{idx_chan + 1}""
            )

        # PRIVATE METHODS #

        def sendcmd(self, cmd):
            """"""
            Function used to send a command to the instrument while wrapping
            the command with the neccessary identifier for the channel.

            :param str cmd: Command that will be sent to the instrument after
                being prefixed with the channel identifier
            """"""
            self._hs.sendcmd(f"":{self._ch_name}:{cmd}"")

        def query(self, cmd):
            """"""
            Function used to send a command to the instrument while wrapping
            the command with the neccessary identifier for the channel.

            :param str cmd: Command that will be sent to the instrument after
                being prefixed with the channel identifier
            :return: The result from the query
            :rtype: `str`
            """"""
            return self._hs.query(f"":{self._ch_name}:{cmd}"")

        # STATE METHODS #

        def reset(self):
            """"""
            Resets the setting of the specified channel

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].reset()
            """"""
            self.sendcmd(""*RST"")

        def recall_state(self):
            """"""
            Recalls the state of the specified channel from memory.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].recall_state()
            """"""
            self.sendcmd(""*RCL"")

        def save_state(self):
            """"""
            Saves the current state of the specified channel.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].save_state()
            """"""
            self.sendcmd(""*SAV"")

        # PROPERTIES #

        @property
        def temperature(self):
            """"""
            Gets the current temperature of the specified channel.

            :units: As specified by the instrument.
            :rtype: `~pint.Quantity`
            """"""
            val, units = split_unit_str(self.query(""TEMP?""))
            units = f""deg{units}""
            return u.Quantity(val, units)

        frequency, frequency_min, frequency_max = bounded_unitful_property(
            ""FREQ"",
            units=u.GHz,
            doc=""""""
            Gets/sets the frequency of the specified channel. When setting,
            values are bounded between what is returned by `frequency_min`
            and `frequency_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].frequency)
            >>> print(hs.channel[0].frequency_min)
            >>> print(hs.channel[0].frequency_max)

            :type: `~pint.Quantity`
            :units: As specified or assumed to be of units GHz
            """""",
        )
        power, power_min, power_max = bounded_unitful_property(
            ""PWR"",
            units=u.dBm,
            doc=""""""
            Gets/sets the output power of the specified channel. When setting,
            values are bounded between what is returned by `power_min`
            and `power_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].power)
            >>> print(hs.channel[0].power_min)
            >>> print(hs.channel[0].power_max)

            :type: `~pint.Quantity`
            :units: `instruments.units.dBm`
            """""",
        )
        phase, phase_min, phase_max = bounded_unitful_property(
            ""PHASE"",
            units=u.degree,
            doc=""""""
            Gets/sets the output phase of the specified channel. When setting,
            values are bounded between what is returned by `phase_min`
            and `phase_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].phase)
            >>> print(hs.channel[0].phase_min)
            >>> print(hs.channel[0].phase_max)

            :type: `~pint.Quantity`
            :units: As specified or assumed to be of units degrees
            """""",
        )

        output = bool_property(
            ""PWR:RF"",
            inst_true=""ON"",
            inst_false=""OFF"",
            set_fmt=""{}:{}"",
            doc=""""""
            Gets/sets the output status of the channel. Setting to `True` will
            turn the channel's output stage on, while a value of `False` will
            turn it off.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].output)
            >>> hs.channel[0].output = True

            :type: `bool`
            """""",
        )

    # PROXY LIST ##

    def _channel_idxs(self):
        """"""
        Internal function used to get the list of valid channel names
        to be used by `HS9000.channel`

        :return: A list of valid channel indicies
        :rtype: `list` of `int` and `str`
        """"""
        # The command :ATTACH? returns a string of the form "":CH1:CH2"" to
        # indicate what channels are attached to the internal USB bus.
        # We convert what channel names we can to integers, and leave the
        # rest as strings.
        return [
            (
                int(ch_name.replace(""CH"", """")) - 1
                if ch_name.startswith(""CH"")
                else ch_name.strip()
            )
            for ch_name in self.query("":ATTACH?"").split("":"")
            if ch_name
        ]

    @property
    def channel(self):
        """"""
        Gets a specific channel on the HS9000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
        >>> print(hs.channel[0].frequency)

        :return: A channel object for the HS9000
        :rtype: `~HS9000.Channel`
        """"""
        return ProxyList(self, self.Channel, self._channel_idxs())

    # OTHER PROPERTIES #

    @property
    def name(self):
        """"""
        Gets identification string of the HS9000

        :return: The string as usually returned by ``*IDN?`` on SCPI instruments
        :rtype: `str`
        """"""
        # This is a weird one; the HS-9000 associates the :IDN? command
        # with each individual channel, though we want it to be a synthesizer-
        # wide property. To solve this, we assume that CH1 is always a channel
        # and ask its name.
        return self.channel[0].query(""IDN?"")

    @property
    def ready(self):
        """"""
        Gets the ready status of the HS9000.

        :return: If the instrument is ready for operation
        :rtype: `bool`
        """"""
        return ""Ready"" in self.query("":COMM:READY?"")


"
45,382.0,Newport,Newporterror,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newporterror,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/errors.py,Newporterror,,,,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FEWzl_hzGTfl7OvJgJBdBw/tPUDo5GPB1KUxhEyyOyobsP-KEoiK2Ih0xVZaUfiHiCt8r8W4khZe5VI19-bfsWgJr3xTYo2OiKTwJWjUJomWLKyq_9tO2Hmp27pDpqzx-g/VaW543YV-j-evaaGXiVtfJJ5PPutORCTokI0LUABPIc'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vzEo1yHydkYTKcvHU805lg/CN-Pa1g8KwDGrdj8avQ4kKAmq7GFLPkZWa2UP04inCOeRMltWULhATvOM4IlAHcgVsXm1VdKVfkKjfQ-doZuMQ/mAI8eljB2LprW6B5NUwrGo3_Uqhn4syCcDAEHs1345k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZWcs6GDcJ0WTbiq0cPGZg/77XjGUVRHP1QY9Et0AK2dUapnZ3BKA0ZFBF02a0GHvgloiyQAx_1bhBRMiUHP1mBT85PJwHOVvWgte2i91UMyg/c1h_II4v-sB65q3OPWiLcoZAYpxxo71GcwvmsgmcK90'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q5473MlvnA3X6gpdkxtp3Q/btNVEPK-gcX1En1uum6OoqnGCibk8YOVbpyUjAX1wT5sVyYQ5RwHd0sED4XLD64CkxE8G1C54Q9cRyxHz-DddA/T5IaJdzzqvtdLXEa73S1td6HEBjTZuUGAi2Itohi9Dw'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,,"Irvine, California, United States",3500.0,,,Write a Python script that uses Instrumentkit to connect to a {Device name} ,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116708/Instruments/Vendor%20Logos/Newport.png,,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
55,640.0,Yokogawa,Yokogawa 7651,Instrumentkit,"The 7651 is a general-purpose DC source developed on YOKOGAWA's state-of-the-art DC standard technology. The dual multiplying D/A converter has enabled the compatibility of high-speed response and high resolution. The 7651 also provides high accuracy and stability. In addition to the source function (current supply), the sink function (current absorption) is also available, so the 7651 can be used as not only DC voltage/current source but also high-precision electronic load. Further, a series of powerful functions to meet the system use such as the programming function up to 50 steps, the IC memory card capable of storing 7 patterns of programs, and GP-IB interface are provided as standard. This 7651 can be used for a wide range of fields from R & D to production line, service and maintenance.",https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa7651,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa7651.py,Yokogawa 7651,"[OrderedDict([('id', 'attI6RnDjug8zxuhg'), ('width', 800), ('height', 502), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/11Gy1xZ2WtEgsmu69hC_LQ/ZzO1xPBEYEucBzfY27w33BMZ9Lmq271kYs-goDZ2nrbSebqcGc4f58kkoz3TaM1pzU6VR46hUy3TGV7zMeGiiZWxG2xg71kGWMZZXIpV9wc/jSn-xWGuyKjeRq-500e4o4NXqVgtxzRs_N3W9w3wyKs'), ('filename', '7651_lg.jpg'), ('size', 302628), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5jZ9Pwu4HEOrR8oMTgELJA/pM7l-IgYt7m_HZZsfOYgvd88VTu98Kmzonnu90QhFBpdlq3cr8qRd_4ePrnsH_9ST8oWNXPgeLnHaX3qLJ0YQQ/Wr4-7esJG0xKkP8C2Sf0FlCBWFekM2mLyKaq4oSPZl4'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KInYKfFDFUihKpgnjSxvWg/L2jphx-OYjFqdboKbE2a8O8KoE40t6f3i-4bAaxj5vtnroctWily_DnaBz6iF1u_kfK6h0v-znTTTo08P9ceUA/UifWZbT_T-4PufSejoAcQwPGeruXAeUjuD8c9015L84'), ('width', 800), ('height', 502)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DPeCOQW4T7o3SpMPiF9N8w/BjAsaFZ-2Zbtg1FNWc2FCWgc6CedhA7hPTT-t8xh-8j2mTlOQKFbCxXQZV3kLh8ct1ze5b3j_6hrJpoiLGFusA/fplw-moi-N1p24hYZhiJLC7Dn3u3PM1IP4RGwi2YAXE'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/discontinued/7651-programmable-dc-source/,['Power Supplies'],"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f7hYK50L2LFSnoG6b-tr_Q/PIUr0ysKwfdPoGdRfXB0_h09W8CmAgZMdtnCJA8oACp2MTavzvWTParMzhyBaXLJiz5MWCSGHrK48yk0-3bfUkIGkwJpKTgMFJl-ly-KdSs/005CXDzn6XFLXK7WJHb0bIHDl5oO0DB1Psmc7FeI52s'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hGhnjgmxNSTXxR7kAim1ww/RDzNoEC6FTtC3vztLVJZ89BVEbySAgthi0nJMoDuXoiPA7aSQ1BwyVF4KxdRVyBagIIEuVsDsLXMiBu6r3Uh1Q/cJfrr6UDIT1btUz5czUhSi9oYrVD5uY6Ds17A8WQ26I'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MWH_Mu8dBgIkoDhCCGXp8g/wBAiqUxh-OrvnTMRuOSgOj2_ZB8bIIvBTNIvkqZAlPLE919LoJ2grzsuGm-glI7KS2DdxaXXNwauPeW6l0ME-w/4iMOXEUzxB7fe914JbqzSV_4ze3fhXn_p7DcHRV8Ov0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9hlyfn9bpaqywUXQIW4RCg/yrzzUFNxV8JpxT7PmwgzAOC8hLbvYZaHUSWDHq2M1BJllptYkuzR1ZdKPdT7GAvsoFmjAKbF3YDr-rjYlPL8Dg/22UwYEpKEOninguLEKbx0zEgLRmTyLKraj9xhGrJifw'), ('width', 3000), ('height', 3000)]))]))])]","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://www.yokogawa.com/,https://cdn.tmi.yokogawa.com/IM7651-01E.is.pdf,Japan,318.0,"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ",https://en.wikipedia.org/wiki/Power_supply,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Supplies,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782436/Instruments/Power%20Supplies/Yokogawa-7651/Yokogawa-7651.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116709/Instruments/Vendor%20Logos/Yokogawa.png,,,True,,"

Source code for instruments.yokogawa.yokogawa6370
#!/usr/bin/env python
""""""
Provides support for the Yokogawa 6370 optical spectrum analyzer.
""""""

# IMPORTS #####################################################################


from enum import IntEnum, Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import OpticalSpectrumAnalyzer
from instruments.abstract_instruments.comm import SocketCommunicator
from instruments.util_fns import (
    enum_property,
    unitful_property,
    unitless_property,
    bounded_unitful_property,
    ProxyList,
    string_property,
)


# CLASSES #####################################################################


class Yokogawa6370(OpticalSpectrumAnalyzer):

    """"""
    The Yokogawa 6370 is a optical spectrum analyzer.
    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa6370.open_visa('TCPIP0:192.168.0.35')
    >>> inst.start_wl = 1030e-9 * u.m
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if isinstance(self._file, SocketCommunicator):
            self.terminator = ""\r\n""  # TCP IP connection terminator

        # Set data Format to binary
        self.sendcmd("":FORMat:DATA REAL,64"")  # TODO: Find out where we want this

    # INNER CLASSES #

    class Channel(OpticalSpectrumAnalyzer.Channel):

        """"""
        Class representing the channels on the Yokogawa 6370.
        This class inherits from `OpticalSpectrumAnalyzer.Channel`.
        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa6370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._name = idx

        # METHODS #

        def _data(self, axis, limits=None, bin_format=True):
            """"""Get data of `axis`.

            :param axis: Axis to get the data of, ""X"" or ""Y""
            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            if limits is None:
                cmd = f"":TRAC:{axis}? {self._name}""
            elif isinstance(limits, (tuple, list)) and len(limits) == 2:
                cmd = f"":TRAC:{axis}? {self._name},{limits[0]+1},{limits[1]+1}""
            else:
                raise ValueError(""limits has to be a list or tuple with two members"")
            self._parent.sendcmd(cmd)
            data = self._parent.binblockread(data_width=8, fmt=""<d"")
            self._parent._file.read_raw(1)  # pylint: disable=protected-access
            return data

        def data(self, limits=None, bin_format=True):
            """"""
            Return the trace's level data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""Y"", limits=limits, bin_format=bin_format)

        def wavelength(self, limits=None, bin_format=True):
            """"""
            Return the trace's wavelength data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""X"", limits=limits, bin_format=bin_format)

    # ENUMS #

    class SweepModes(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 6370
        """"""

        SINGLE = 1
        REPEAT = 2
        AUTO = 3

    class Traces(Enum):
        """"""
        Enum containing valid Traces for the Yokogawa 6370
        """"""

        A = ""TRA""
        B = ""TRB""
        C = ""TRC""
        D = ""TRD""
        E = ""TRE""
        F = ""TRF""
        G = ""TRG""

    # PROPERTIES #

    # General

    id = string_property(
        ""*IDN"",
        doc=""""""
            Get the identification of the device.
            Output: 'Manufacturer,Product,SerialNumber,FirmwareVersion'
            Sample: 'YOKOGAWA,AQ6370D,90Y403996,02.08'
            """""",
        readonly=True,
    )

    status = unitless_property(
        ""*STB"",
        doc=""""""The status byte of the device.
        Bit 7: Summary bit of operation status
        Bit 5: Summary bit of standard event status register
        Bit 4: “1” if the output buffer contains data
        Bit 3: Summary bit of questionable status
        """""",
        readonly=True,
    )

    operation_event = unitless_property(
        "":status:operation:event"",
        doc=""""""
            All changes after the last readout. Readout clears the operation_event
            Bit 4: Autosweep
            Bit 3: Calibration/Alignment
            Bit 2: Copy/File
            Bit 1: Program
            Bit 0: Sweep finished.
        """""",
        readonly=True,
    )

    @property
    def channel(self):
        """"""
        Gets the specific channel object.
        This channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> osa = ik.yokogawa.Yokogawa6370.open_gpibusb('/dev/ttyUSB0')
        >>> dat = osa.channel[""A""].data # Gets the data of channel 0

        :rtype: `list`[`~Yokogawa6370.Channel`]
        """"""
        return ProxyList(self, Yokogawa6370.Channel, Yokogawa6370.Traces)

    # Sweep

    start_wl, start_wl_min, start_wl_max = bounded_unitful_property(
        "":SENS:WAV:STAR"",
        u.meter,
        doc=""""""
        The start wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    stop_wl, stop_wl_min, stop_wl_max = bounded_unitful_property(
        "":SENS:WAV:STOP"",
        u.meter,
        doc=""""""
        The stop wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    bandwidth = unitful_property(
        "":SENS:BAND:RES"",
        u.meter,
        doc=""""""
        The bandwidth in m.
        """""",
    )

    span = unitful_property(
        "":SENS:WAV:SPAN"",
        u.meter,
        doc=""""""
        A floating point property that controls the wavelength span in m.
        """""",
    )

    center_wl = unitful_property(
        "":SENS:WAV:CENT"",
        u.meter,
        doc=""""""
         A floating point property that controls the center wavelength m.
        """""",
    )

    points = unitless_property(
        "":SENS:SWE:POIN"",
        doc=""""""
        An integer property that controls the number of points in a trace.
        """""",
    )

    sweep_mode = enum_property(
        "":INIT:SMOD"",
        SweepModes,
        input_decoration=int,
        doc=""""""
        A property to control the Sweep Mode as one of Yokogawa6370.SweepMode.
        Effective only after a self.start_sweep()."""""",
    )

    # Analysis

    # Traces

    active_trace = enum_property(
        "":TRAC:ACTIVE"",
        Traces,
        doc=""""""
        The active trace of the OSA of enum Yokogawa6370.Traces. Determines the
        result of Yokogawa6370.data() and Yokogawa6370.wavelength()."""""",
    )

    # METHODS #

    def data(self, limits=None):
        """"""
        Function to query the active Trace data of the OSA.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].data(limits=limits)

    def wavelength(self, limits=None):
        """"""
        Query the wavelength axis of the active trace.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].wavelength(limits=limits)

    def analysis(self):
        """"""Get the analysis data.""""""
        return [float(x) for x in self.query("":CALC:DATA?"").split("","")]

    def start_sweep(self):
        """"""
        Triggering function for the Yokogawa 6370.
        After changing the sweep mode, the device needs to be triggered before
        it will update.
        """"""
        self.sendcmd(""*CLS;:init"")

    def abort(self):
        """"""Abort a running sweep or calibration etc.""""""
        self.sendcmd("":ABORT"")

    def clear(self):
        """"""Clear status registers.""""""
        self.sendcmd(""*CLS"")


"
69,234.0,Keithley,Keithley 580,Instrumentkit,"The Keithley 580 Micro-ohmmeter combines high accuracy, resolution, and sensitivity with three special capabilities that make micro-ohm measurements easier and more versatile than ever. When measuring contact and connector resistances, it is important not to puncture oxides and films that may have formed. The Model 580 ensures this dry-circuit condition by clamping the open-circuit test voltage to 20mV on the 200m, 2, and 20 ranges when the 20mV MAX button is pressed.

The Keithley 580 can test more devices by enabling both test current polarity and waveform (DC or pulsed) to be selected. When using pulsed test current, the Model 580 automatically compensates for thermoelectric EMFs. Tests on inductive devices are best performed using DC test current, as this avoids the effects of time constants on pulsed current resistance measurements. For temperature-sensitive components, a single trigger mode of operation minimizes power delivered to the device.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley580-microohm-meter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley580.py,Keithley 580,"[OrderedDict([('id', 'attqllbRtWoi3InUL'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zI9Q3fUWZhNMQ6lplEb40g/aFdFF5i3jUl6CFdU8Xswv9tpK_giwhkxKraBiHFJGgC6FS9URFU3gdwrmBftWmsUzgk5zOIFtOL_e7oafSpCmw/nQAeQ34LRWl6PNGP-KJxDOoc9rz9By9pq2U1_LKNoXY'), ('filename', '580.jpg'), ('size', 8047), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fS9itANqi7UO2BEr8z61bQ/rzpfGm5jeVT6XMulCByZAiYGd8rgjJSBPzCFBq320TBFFMDFaxQkN41x8MhoOgkKxahrztS6pAw41I4tT_bA2A/ifDi-hCw8aiUXmDhTlYnmMU0V7p5H5BqZ2mevPo_C-o'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nTMjJrss1lmP4SO9CicCfQ/DxHOy7tN_L52VRlx7Anv_c4tmuLNd7iwjix-zxce_ywLICmEFoGk4HJJCQGDO1lmU3jfJhaRrvZ0fR8ftiagew/IYZxfd9flDw6QV4WmXDDNMrqjV5TeqUl-h4EqAB5a-A'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/A30uiTMhPByg1uGy1ShK1A/0AfZvuJErt4Fon0G6Mg3-rWzpb1qulkvkgkM3EuRYfvoQviHer3M4Vy4eoLprMYeBC27489bYUYAWX8saOwSEQ/as7jZP2BJufKhgB363tiZX4AfvGSdZPXQt8lzE3cETY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.valuetronics.com/product/580-keithley-micro-ohmmeter-used,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/KEITHLEY-580-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law.,https://en.wikipedia.org/wiki/Ohmmeter,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782479/Instruments/Power%20Meters/Keithley-580/Keithley-580.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,3295.0,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
71,555.0,Tektronix,Tekawg 2000,Instrumentkit,"The AWG2005 offers 20 MS/s and 64 k deep memory. As with the entire AWG2000 Series, the graphical user interface allows on-screen viewing of waveform editing, simplifying ""what if"" test scenarios by allowing the easy creation of composite signals. The standard AWG2005 configuration provides two independent 10 V outputs or a third and fourth 10 V output (Option 02) each with 12-Bits vertical resolution. Option 04 adds TTL digital levels with (2) 12-Bit, 100 MS/s ports and combines with the marker outputs to provide a total of 28-Bits wide. The built-in sweep generator (Option 05) provides even more flexibility by offering linear and logarithmic swept frequencies, but even more significantly the AWG2005 has user definable sweep capability. This allows creation of digitally modulated signals at IF frequencies. The built-in frequency domain (FFT) editor (Option 09) is a perfect addition for customers performing proprietary or standard I & Q modulation simulations, filter design or in circuit testing of physical layer. Real time waveform sequencing extends the effective record length output to over a billion points! The AWG2005 easily simulates signals where moderate point definition and long records are required for simulating complex waveform conditions. Direct waveform transfer capability makes the AWG2005 the perfect complement to selected Tektronix oscilloscopes.",https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekawg2000-arbitrary-wave-generator,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekawg2000.py,AWG2005,"[OrderedDict([('id', 'attqkHYzPkKkFIskn'), ('width', 800), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wN5veP-eLMGM1DF5k2l5eA/RfEpKxXXYVrQdrRevvlWH0Ns97RZOA06u1568pkVPtfcw0kxX04z4voJ2u_FebOYWbGu33g2w0cD_RBMDhtZrcL-l55i4xBSs2Po4ejhSV7d03RxwX_opIwfaiPHo3Hv/M-sHgjsomhzVap2ybd6nUFSUaWGXUBesq0gdRai2iOo'), ('filename', 'Alltest-Tektronix-AWG2005-23811.jpg'), ('size', 84919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uOgvw_Y8XgBTwFqy2Gq3KA/Bgszk9A81QXbdvuZ2IKpyP5nR0H9pHNDs1R0VM4uI4MxgiANQBLzgtVG2Apgi_Zc56gG6QMqellrGMB0f_tRKA/fxEaKQO19fdsCnajGqIOfNjXND767Wq-nkp872VFnQk'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ac7VIquNcrMqStS4tavKqQ/A2nryMSbhtx5EpxN-mkPdm2BXcnDk81I8pDPeIHK6CDbNPVozgJQ4fu4PenU2d4NruJV2vMg3LUdZziq0JQuUw/6pJVgPEE0-hFOvyokOXTKHJb590Q2slAdV1oA-U9QTQ'), ('width', 800), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xNxz9Y014r-tHjOG5VCYWQ/UyiCETccKnHW4lEMSFOHhPYChLCexTKf6-mDEneSEd_20bxV85eC2p-XNuMg1MEtHjIUgXWoh7IJcN7ybnnPjw/A2U62HMEUO4pp8pgd2ZybNy7aYW5DjlzFso3Kr9hV8I'), ('width', 3000), ('height', 3000)]))]))])]",https://alltest.net/categories/products/AWG2005-Tektronix,['RF Signal Generator'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://download.tek.com/datasheet/76W_10020_2_1.pdf,USA,5800.0,"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",https://en.wikipedia.org/wiki/Signal_generator,Write a Python script that uses Instrumentkit to connect to a AWG2005 RF Signal Generator,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782481/Instruments/RF%20Signal%20Generator/AWG2005/AWG2005.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,495.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
87,626.0,Toptica,Topmode,Instrumentkit,"TOPTICA’s TopMode lasers operate as easily as a HeNe, but also offer higher power and the choice of wavelength. The TopMode series sets records in terms of power, coherence and wavelength stability. The proprietary CoHerence-Advanced Regulation Method (CHARM) provides an active stabilization of the lasers’ coherence and ensures continuous single-frequency operation. TopMode and CHARM means nothing less than reliable 24/7 operation.",https://instrumentkit.readthedocs.io/en/latest/apiref/toptica.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/toptica/topmode.py,TopMode,"[OrderedDict([('id', 'attySc0bj6E4RhJ6k'), ('width', 1200), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MBETGI6yJw_PW6MOOXEOtg/SN7vj7Rz8dVJdIFytoj3v9d6hTexMr6kQXnhifTP7akBD6ABumRw0_qqWjB3UFlwCEX7Lju7aK0tQB2K286p2Kz6bGVISa5RUp-Nd3F7V5PRdh5oIzhe4TLK6XzG0tke/JmOB-uedXehCwTq0WgWGFurSZMkO1JfEVxFGyyEi5aw'), ('filename', 'toptica_topmode_3x_1200x350_w.jpg'), ('size', 83757), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NSR85ft7dGEl_lIax2qAww/VSg6b7YZ_le1lJC_y6AcX9Oop46LHsZ7zktBRNedmmkGYidLdxhxNI-swX5x0w84KuojTEYcG8S43ZbQQBlfKg/aVkrNxa1vuJ5YphhoOAox-AkDYBbykZVyE8y6F2twCI'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qH86CJ8eNOXEa9Lo2oql9Q/VCwh_0_jWpPoi0NIePEkiA450OWWcpSMXWkQcREQPK7yMyktLtWtSyrSB-W25ekKQjsmISXI5ehg9LkBWQePgA/Og_ucnjU1NX2NxVm2VVbc_Kjnxl80V1mXC19hGlNjSo'), ('width', 1200), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/luyMHE_Xdx3tBs6Y_18_TA/6qx8-s5r7zNLx_Wy8SlmfBQTO5GaY2m7El9PQTzQioKO32TQiBzHRIROEk8DZSM8VMh3u_SQPKoYN9WA23xdoA/3G8D5NDc7qyys6_V6bSafVjh4LhiiZQrO_Wuy8_dD3Y'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/products/single-frequency-lasers/topmode,['Lasers'],"[OrderedDict([('id', 'attdPu3r6YQ3XuoNe'), ('width', 469), ('height', 107), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WIp56Lq0hW9Rcch8LMMASw/d3cs5bu5G5boLlTaSqMGKBdUhm7Xp2BmnLlKCtXDVRHsk10WtuSndX4oaPK9g2CPrqzu_CUSAtzCzBfm0um56l8_PtSkjtdCl_ENeKgO0II/YyutUm36GHGznKKOynu73dbIZkObgMdF_yARW5SME60'), ('filename', 'download.png'), ('size', 4105), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0G3uf8ncbaop_rGwHSxBJg/SIgj7V1CI4AmGgDdZodg8fKXCnKGogP5GUig-y-rABHWZEllmY-n7VR9VblYhquLXDq_wChQwp3w1LIR-K36rw/wlaWVKXLxhdWS_a-z65TMOUFhJKTSwHr-M_pAlT-C0g'), ('width', 158), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3riJc9TapjxX6TEZlnPAxw/T2_qbUHUuUhw--lnC4rFGuLqdOJZ2_QVPOoUQct7gD5YsNrmA5xCctLmTcTcASgol-Gu_kS8VgxRBXtz15BMig/PNhyTQFA5zwMJDj2xFlGgXJZ5AkZTWyv5PsVvvl7aWI'), ('width', 469), ('height', 107)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w3rInYENHL9Yq6S06aarNA/Atp0PvDJ2HfO_jbmn3ajpAJNJoQUjKAs1O_Z9tq4u3YR1s1nwlMI-7RWbkRrk_xGy0xNoC0apLNvyIgyzxY5Jg/UOYz9TjQy_BYY1r0Vfx-MFOmREAvjey5DnbZvOIjMwo'), ('width', 3000), ('height', 3000)]))]))])]","TOPTICA Photonics is a manufacturer of [lasers](https://en.wikipedia.org/wiki/Laser) for quantum technologies, biophotonics and material inspection
",https://www.toptica.com/,https://www.toptica.com/fileadmin/Editors_English/11_brochures_datasheets/01_brochures/toptica_BR_TopMode.pdf,Germany,75.0,"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction",https://en.wikipedia.org/wiki/Laser_diode,Write a Python script that uses Instrumentkit to connect to a TopMode Lasers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782495/Instruments/Lasers/TopMode/TopMode.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116693/Instruments/Vendor%20Logos/Toptica.png,,,,,"

Source code for instruments.toptica.topmode
#!/usr/bin/env python
""""""
Provides the support for the Toptica Topmode diode laser.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.toptica.toptica_utils import convert_toptica_boolean as ctbool
from instruments.toptica.toptica_utils import convert_toptica_datetime as ctdate
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TopMode(Instrument):

    """"""
    Communicates with a `Toptica Topmode`_ instrument.

    The TopMode is a diode laser with active stabilization, produced by Toptica.

    Example usage:

    >>> import instruments as ik
    >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
    >>> print(tm.laser[0].wavelength)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.prompt = ""> ""
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if ""reboot"" in msg:
            return [msg, ""reboot process started.""]
        elif ""start-correction"" in msg:
            return [msg, ""()""]

        return msg

    # ENUMS #

    class CharmStatus(IntEnum):

        """"""
        Enum containing valid charm statuses for the lasers
        """"""

        un_initialized = 0
        in_progress = 1
        success = 2
        failure = 3

    # INNER CLASSES #

    class Laser:

        """"""
        Class representing a laser on the Toptica Topmode.

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `Topmode` class.
        """"""

        def __init__(self, parent, idx):
            self.parent = parent
            self.name = f""laser{idx + 1}""

        # PROPERTIES #

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the laser

            :return: The serial number of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":serial-number"")

        @property
        def model(self):
            """"""
            Gets the model type of the laser

            :return: The model of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":model"")

        @property
        def wavelength(self):
            """"""
            Gets the wavelength of the laser

            :return: The wavelength of the specified laser
            :units: Nanometers (nm)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":wavelength"")) * u.nm

        @property
        def production_date(self):
            """"""
            Gets the production date of the laser

            :return: The production date of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":production-date"")

        @property
        def enable(self):
            """"""
            Gets/sets the enable/disable status of the laser. Value of `True`
            is for enabled, and `False` for disabled.

            :return: Enable status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":emission""))

        @enable.setter
        def enable(self, newval):
            if not isinstance(newval, bool):
                raise TypeError(
                    ""Emission status must be a boolean, got: "" ""{}"".format(type(newval))
                )
            if not self.is_connected:
                raise RuntimeError(
                    ""Laser was not recognized by charm "" ""controller. Is it plugged in?""
                )
            self.parent.set(self.name + "":enable-emission"", newval)

        @property
        def is_connected(self):
            """"""
            Check whether a laser is connected.

            :return: Whether the controller successfully connected to a laser
            :type: `bool`
            """"""
            if self.serial_number == ""unknown"":
                return False
            return True

        @property
        def on_time(self):
            """"""
            Gets the 'on time' value for the laser

            :return: The 'on time' value for the specified laser
            :units: Seconds (s)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":ontime"")) * u.s

        @property
        def charm_status(self):
            """"""
            Gets the 'charm status' of the laser

            :return: The 'charm status' of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 7) % 2 == 1

        @property
        def temperature_control_status(self):
            """"""
            Gets the temperature control status of the laser

            :return: The temperature control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 5) % 2 == 1

        @property
        def current_control_status(self):
            """"""
            Gets the current control status of the laser

            :return: The current control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 6) % 2 == 1

        @property
        def tec_status(self):
            """"""
            Gets the TEC status of the laser

            :return: The TEC status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":tec:ready""))

        @property
        def intensity(self):
            """"""
            Gets the intensity of the laser. This property is unitless.

            :return: the intensity of the specified laser
            :units: Unitless
            :type: `float`
            """"""
            return float(self.parent.reference(self.name + "":intensity""))

        @property
        def mode_hop(self):
            """"""
            Gets whether the laser has mode-hopped

            :return: Mode-hop status of the specified laser
            :type: `bool`
            """"""
            response = self.parent.reference(self.name + "":charm:reg:mh-occurred"")
            return ctbool(response)

        @property
        def lock_start(self):
            """"""
            Gets the date and time of the start of mode-locking

            :return: The datetime of start of mode-locking for specified laser
            :type: `datetime`
            """"""
            # if mode locking has not started yet, the device will respond with
            # an empty date string. This causes a problem with ctdate.
            _corr_stat = self.correction_status
            if (
                _corr_stat == TopMode.CharmStatus.un_initialized
                or _corr_stat == TopMode.CharmStatus.failure
            ):
                raise RuntimeError(""Laser has not yet successfully locked"")

            response = self.parent.reference(self.name + "":charm:reg:started"")
            return ctdate(response)

        @property
        def first_mode_hop_time(self):
            """"""
            Gets the date and time of the first mode hop

            :return: The datetime of the first mode hop for the specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:first-mh"")

            return ctdate(response)

        @property
        def latest_mode_hop_time(self):
            """"""
            Gets the date and time of the latest mode hop

            :return: The datetime of the latest mode hop for the
                specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:latest-mh"")
            return ctdate(response)

        @property
        def correction_status(self):
            """"""
            Gets the correction status of the laser

            :return: The correction status of the specified laser
            :type: `~TopMode.CharmStatus`
            """"""
            value = self.parent.reference(self.name + "":charm:correction-status"")
            return TopMode.CharmStatus(int(value))

        # METHODS #

        def correction(self):
            """"""
            Run the correction against the specified laser
            """"""
            if self.correction_status == TopMode.CharmStatus.un_initialized:
                self.parent.execute(self.name + "":charm:start-correction-initial"")
            else:
                self.parent.execute(self.name + "":charm:start-correction"")

    # TOPMODE CONTROL LANGUAGE #

    def execute(self, command):
        """"""
        Sends an execute command to the Topmode. This is used to automatically
        append (exec ' + command + ) to your command.

        :param str command: The command to be executed.
        """"""
        self.sendcmd(""(exec '"" + command + "")"")

    def set(self, param, value):
        """"""
        Sends a param-set command to the Topmode. This is used to automatically
        handle appending ""param-set!"" and the rest of the param-set message
        structure to your message.

        :param str param: Parameter that will be set
        :param value: Value that the parameter will be set to
        :type value: `str`, `tuple`, `list`, or `bool`
        """"""

        if isinstance(value, str):
            self.query(f'(param-set! \'{param} ""{value}"")')
        elif isinstance(value, (tuple, list)):
            self.query(""(param-set! '{} '({}))"".format(param, "" "".join(value)))
        elif isinstance(value, bool):
            value = ""t"" if value else ""f""
            self.query(f""(param-set! '{param} #{value})"")

    def reference(self, param):
        """"""
        Sends a reference commands to the Topmode. This is effectively a query
        request. It will append the required (param-ref ' + param + ).

        :param str param: Parameter that should be queried
        :return: Response to the reference request
        :rtype: `str`
        """"""
        response = self.query(f""(param-ref '{param})"").replace('""', """")
        return response

    def display(self, param):
        """"""
        Sends a display command to the Topmode.

        :param str param: Parameter that will be sent with a display request
        :return: Response to the display request
        """"""
        return self.query(f""(param-disp '{param})"")

    # PROPERTIES #

    @property
    def laser(self):
        """"""
        Gets a specific Topmode laser object. The desired laser is
        specified like one would access a list.

        For example, the following would print the wavelength from laser 1:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
        >>> print(tm.laser[0].wavelength)

        :rtype: `~TopMode.Laser`
        """"""
        return ProxyList(self, self.Laser, range(2))

    @property
    def enable(self):
        """"""
        is the laser lasing?
        :return:
        """"""
        return ctbool(self.reference(""emission""))

    @enable.setter
    def enable(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(
                ""Emission status must be a boolean, "" ""got: {}"".format(type(newval))
            )
        self.set(""enable-emission"", newval)

    @property
    def locked(self):
        """"""
        Gets the key switch lock status

        :return: `True` if key switch is locked, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""front-key-locked""))

    @property
    def interlock(self):
        """"""
        Gets the interlock switch open state

        :return: `True` if interlock switch is open, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""interlock-open""))

    @property
    def firmware(self):
        """"""
        Gets the firmware version of the charm controller

        :return: The firmware version of the charm controller
        :type: `tuple`
        """"""
        firmware = tuple(map(int, self.reference(""fw-ver"").split(""."")))
        return firmware

    @property
    def fpga_status(self):
        """"""
        Gets the FPGA health status

        :return: `False` if there has been a failure for the FPGA,
            `True` otherwise
        :type: `bool`
        """"""
        response = self.reference(""system-health"")
        if response.find(""#f"") >= 0:
            return False
        response = int(response)
        return False if response % 2 else True

    @property
    def serial_number(self):
        """"""
        Gets the serial number of the charm controller

        :return: The serial number of the charm controller
        :type: `str`
        """"""
        return self.reference(""serial-number"")

    @property
    def temperature_status(self):
        """"""
        Gets the temperature controller board health status

        :return: `False` if there has been a failure for the temperature
            controller board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 1) % 2 else True

    @property
    def current_status(self):
        """"""
        Gets the current controller board health status

        :return: `False` if there has been a failure for the current controller
            board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 2) % 2 else True

    # METHODS #

    def reboot(self):
        """"""
        Reboots the system (note that the serial connect might have to be
        re-opened after this)
        """"""
        self.execute(""reboot-system"")


"
92,551.0,Tektronix,Tektds 5 XX,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,TDS520/TDS540,"[OrderedDict([('id', 'attBqUxbkbvswUSvd'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/X-dhLUjPwwlQh6zHFDJFpA/LDCqYfpl9jxT0Sbxa4DgGZ-X_6eRBE8kFU5AScqYKJqt2o8wu9BK9rZAQGtNRoos649sHdj3orQbBPN74pJMqiPy_ze_XbhiUEGazw4eI5Y/yQagADGZdYXi0ggQpSHGEi3KBcMoiYFT-mCT_r7-LM4'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CN2yo5Br6dtl-cELXmJKZw/y1fDx0OqiRFf4mut_hXB3sx-wAvF_c2YZ52voDqRTOvM27PY-P9SITqUYaS8WEc4J-8EF_uoQRHlOlKNa11tDA/JKMubMWSyZbswLSrlkHSyucUE68qHpS4NXt63vbwSNE'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lXDsjBJx9c9T5olET0SBww/d6gwZo1bGo0eBExIclnYudubhjzZU8uHqxDXEtLwetUpaROe0q2ad8IK9N81pdlb6xQFGuKl63Z8a9teccX7rA/Lxwa4-icBtLfbYjKmCrUTpspXc8ePGXFPHtDxlhWb60'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FZtRLUXT8HN3CknIm0hJSQ/MSxsPSFsKbdk5UfPWZ2Av_K9fhV_3nFTtoOhYWVT8eauHEQwcvbmwKtJDne_c_mDFa5vN2mMDbWygBrCM5oaLg/NOfxy4O1SV8uMz2nn0ejnBSM_GKSFoSqwZwCSQX2Wzk'), ('width', 3000), ('height', 3000)]))]))])]",,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://xdevs.com/doc/Tektronix/TDS520/TEKTRONIX_Company_Ad_TDS520_w_Datasheet.pdf,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS520/TDS540 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782499/Instruments/Oscilloscopes/TDS520-TDS540/TDS520-TDS540.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,450.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
94,548.0,Tektronix,Tekdpo 70000,Instrumentkit,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo70000-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo70000.py,DPO70000,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WsOWv-JV7GKaFSUmikElnA/FcE2F5kwbC0dzqe-VO-xxGIQCJmlulIzNnfzZypOHdnVxEl66Z9Iweqjumb81naKEWasCEM4NGZwyj0JDXI0g0v-xXmYW68-kFebXGLsa63OCBrZHqjw4gf7HwcYfPwEpTaatH0fva7J3tNudx5fsg/hG87vOaqGIL9d6DRm9Uyv_9s4a6YxEGPzRL6eUPJcxc'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G3Xe1UXf174GIRLewzm6BQ/FuPBbb4fUhU1fLrJOR9j1Odv-iOmwveeAbhSfK9kdqjePdinC9gdOfOrwPk-4wTiLoxtvJMYk8CB5sgjkZJq6q9y95O9FOp4OZiO7GTf15o/L9COYzFW4Cq3OOmUhSdLg3Nt32vpNzAewgCllwRUv_k'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IDWJqZT2JqdkvKYnCqljLg/h3HDNdNTlG7iymZ0SwPVXgKO0dyu5UyfioiXD1cxdN-XVzBW-qo1pA5i09ljVODVZO0Ba6kOz8EPus_YBn0d1Mpp-lokwwUFKU0laO1ciHM/Ry0cQ8w_ZnwfuKzQuGu3rt_q1WoGDaYTg_H5Z8Ez5aE'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PxxO2zEVzSVGNSsb0WoVzg/os-KcM5U58Vxh5oHKo6M_LujGceSAVD4hLgINBBluDlRZ16Z54YK_pHadcTJTE8dh3msKZCO7866ZWm-TP4Dxan-YDm288-vvPFPCPZ-55I/vxCUn8Gvs_cR2czq6DM4VFZRUReLTiHb-l-QcV-haS8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://download.tek.com/document/55W-22447-9.pdf,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a DPO70000 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782501/Instruments/Oscilloscopes/DPO70000/DPO70000.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
95,347.0,Lakeshore,Lakeshore 370,Instrumentkit,"The Model 370 AC resistance bridge is designed for precise, accurate, low noise, low excitation power AC resistance measurements. Its primary application is the measurement of resistive materials in cryogenic environments from 20 mK to 1 K. Fully integrated, the Model 370 includes features to reduce and control noise at every step of the resistance measurement process. A unique, patented, matched impedance current source and active common mode reduction circuitry minimize noise and self-heating errors. With up to 16 channels, IEEE-488 and serial interfaces, and closed loop temperature control, the Model 370 offers seamless integration with existing cryogenic systems and is the most complete package on the market today. Used with Lake Shore calibrated subkelvin resistance temperature sensors, it not only measures and displays, but also controls temperature for dilution refrigerators and other cryogenic systems.",https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore370-ac-resistance-bridge,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore370.py,Lakeshore 370,"[OrderedDict([('id', 'atto87LIsOZVAKm9z'), ('width', 505), ('height', 157), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/E0kMcDfJjUFBwOW0uErmSQ/rP9ay4RsenmthyNMrjhY67_VzF5KhVl8G_cgNA-Z27HqeNy1nORhdGkZ08UclGSZtLhgTUs7LVLDnt0rC-ZceA/pyJwQJl207tcGDF1ijp7Ym2JXsfr-Bxi_-VOS2vGOPQ'), ('filename', '370.png'), ('size', 99490), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gWhG7yd1S5re8AvCJ1CE9g/Y_EHVi9NU9ZlQc6oOm5ulgmae9YRA7x4tfYppBaHnV4zSXi5oga-iehf1vunrq78d0mEvXEUKgKI6n_Lgib7wQ/IHYsWu7ALztTsOlgnhE5lwhqD2HxggNQnHQy1eSTa6M'), ('width', 116), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pbAe_TPAv8f_ocA6ZboxVg/TUzNsX1xPwqcuNaYfHAan32ic4nbqQK7P67B6Vx9iIYrRefc0BEdHSQQGpSNFnfmhVZOcyvUVFFMdZw1yytVLw/G3JfCm9KmETSKWbAVtgCftYGBU3Ptikm2jLpszGumoA'), ('width', 505), ('height', 157)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cyNMBXTebhBdzUuA36DRsQ/eDVaZUgZ2HgcnQGOALjodOHlDofCkfRANZOVqm57J3H9W4tNDD1wZw2E3DpNV7eHS466RKoGjWxGV5JHFVmwqA/REVF6o-sgPkeXrFMUqYH_me9rHCpnyUULh-KiHR57ww'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-370-ac-resistance-bridge-,['Power Meters'],"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://www.lakeshore.com/home,http://www.cryotrade.ru/uploads/documents/temperature/LakeShore370.pdf,"Westerville, Ohio, USA",21.4,An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law,https://en.wikipedia.org/wiki/Ohmmeter,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782502/Instruments/Power%20Meters/Lakeshore-370/Lakeshore-370.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,,,True,,"

Source code for instruments.lakeshore.lakeshore340
#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))


"
105,584.0,Teledyne,Maui,Instrumentkit,"WaveRunner 9000 oscilloscopes have the industry's widest and deepest collection of tools, making it unbelievably powerful and MAUI with OneTouch makes measurement setup insanely easy, providing faster time to insight.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveRunner 9000,"[OrderedDict([('id', 'attO8NgzXv6EBjVdD'), ('width', 1000), ('height', 929), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3SFpW_-LtO4mWsycS3SmtA/NSIfndieM7cXzDpz6waLWg32IiyuPBRBoh_jeehYqoIwMhZx0t8MMWiTER32pgAKQTCjtvXoEYjV8JcaNfSryfm-B_4BacEsXJGztbHmPfk/Mjbqh1x_EXwR5Gm8C3llSpyS982mtzJ9wY5V3mYqg6s'), ('filename', 'wr9000-hero.webp'), ('size', 138832), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dgKPPd3i5J1SwcKrR-f6Rw/3WXeRaZAeXFtsCh3XYttJK0Re5tE01vTPG8izeWako1-lGo5L5aocrlbDXsotVz8umqZA3zYEhM-JSJsjLz5w2eVx3SMS6-Eo_O7exg6fj8/PKRBGoPOZ69eFvRizuvvalJHfRa0hbPCgg507Wf5Chc'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7Diyn3LUju8lacyE-T_xKA/UKcXDCgmGEJN-lwE1zyHOQTVFTHkbsEI3FnSRH_o7-OxLV_a6DiBJ0BePUPHQjOD-bG8g_VKxO755ese4DZCIR0WpiQpy9RAGbjfWr78N9o/r0vRgI0NMpvIB3NFbxm-Kwv3Gh2fGaB5bjsMlY-kIWY'), ('width', 551), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jT2Hb8IHTTFXeRBda5Gm2A/U5ZmLfIJ0D1ACtTkmT0fqQ8vCiUS9479yBQMWrcIurw7c0KHTM6z8Keto6PYrn5Nul0ccKqAeSaZoPa4Z4ZFBNzun-l22g9_fljgysxW9jI/v0bO5RlPs0OK_aPRYvPA7T4K4x6GYkG2VeYDS0GPimU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/waverunner-9000-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveRunner 9000 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782511/Instruments/Oscilloscopes/WaveRunner-9000/WaveRunner-9000.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,16800.0,,,price from here: https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
107,552.0,Tektronix,Tektds 224,Instrumentkit,The Tektronix TDS224 is a portable four-channel digital scope with 1 GS/s sampling rate and 100 MHz bandwidth.,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds224-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds224.py,TDS224,"[OrderedDict([('id', 'attogh5LFg8s7lsw4'), ('width', 798), ('height', 566), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CpHvWozb6-x9peRCaiqy5w/2QZWHDLgOgRBeUjkIBZS5flKQC5crYhx___xAWEwYZI2GYvSgEm-tsj5lhfq2s45SQT_jE0Eh8RK6AipP-pNqQJwrWPO_2NlrodGVFU2YCI/H_-uFv1PUx6KjCmZSOEheuKqdbByMjaMDk7rxcXRR3A'), ('filename', 'TDS224.jpg'), ('size', 323986), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_vZbLrYA53AgN8lkf8LtsQ/0w6H5FVnRE9xT-NDdwjwFFBvrt-vghZ9dE-fk71dZMhBmM7Mq00QXPjTxOJwkMDO_FdHBMJAV4Ph8RdLeklBAg/CBIq6S10pRtv2nnDHw5R0LUcYNeXlE4MNO1svcp1KAE'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pw_HepD9WjeAE5dNjm_4FA/bGw9wNYDr5rixIjwjL9AIwimgeyOENaNTcwFbXNOD35R2LwjWCppQATEUI2r3w-Ixb9vrBvatBO9mByrE4K2tQ/Z9tt20W1fb3_-FdLKbAKlatMeVCnh6cNOsLQUs8OD3g'), ('width', 722), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WvM3h2wmnzopSVnyA3Ymgw/w9af7gsj7KhQSfPTDnmDEllTDYo2_L2e6skOlOhrf3DoAe-yAaiKH2H_HE_uoIDtHQwur3w0STgEMPkRVx_xXg/UAW12PJiXCdgCwYoonY6itu87qlqCLqMcx0t4zVpamo'), ('width', 3000), ('height', 3000)]))]))])]",https://w140.com/tekwiki/wiki/TDS224,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/TEKTRONIX-TDS224-Datasheet.pdf,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS224 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782513/Instruments/Oscilloscopes/TDS224/TDS224.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,650.0,,True,price from the following: https://bmisurplus.com/product/tektronix-tds-224-100-mhz-4-channel-oscilloscope/,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
126,390.0,Newport,Agilis,Instrumentkit,Agilis™ Piezo Motion Controllers provide convenient and compact fine positioning control of the Agilis family of piezo motion stages and mounts.,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#agilis-piezo-motor-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/agilis.py,Agilis,"[OrderedDict([('id', 'attwW1zLjGpXPjApa'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Tt0azGSJN293UgNYxbAlnA/D94j7mfIdTQkzAMGFsMPLJHqWnFlGg4ueqYPqjazo5F_DMQsgC2SBKGlD4Z7kG6IC9gsabD8nTsyAtLZyowWblm_X66butgI4T9CNERGxpM/cg2VN5_HhQvT2xd8rxwVb7FU9Q5SFhb1VcOTCYLtFiI'), ('filename', 'AG-UC8_400w (1).jpg'), ('size', 15942), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qT5r-BG5ckQzscGCqDhTXA/AO-L4s0MNJqL3of3nMqGM0LgMVZMFegRgQWetzZhf1tgL76JJ2zJ6jmODbmjH-P1g_EquatZ2khnamHd35m_4g/nDDS6Lgy4ZsY5B_RPe5xJmMkkFvJvMNTfzPRpktWPrI'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9w1hXfyQxyLpJ-lK_8wADA/b3fqYNFbKflkA-COpjiRyi3KB4n027Qd7VfPDwn_2Z57IUVboStlDEcb9ROnhJrLunr802wuNik8p27QO1mu_A/nlrxWaGZNe5Qiq8nPpV_gcdrLTtW1Xh8xZy5YIS6YiI'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Xp2bIWrXw3MdDMxaxv9fkQ/xTHhAIkJGmsRV9xwLYaxsYo0HGGQyKCn7E7l1z9P2JbsgTp_UiH_tx6NtAQhKU1arUlYelbAk1wGdXp_MQDymw/SNrjh1uttzCsa4tnAdS9CE_WQj-Qe571wl3TKTkvDWE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/f/agilis-piezo-motion-controllers,['Positional Controller'],"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FEWzl_hzGTfl7OvJgJBdBw/tPUDo5GPB1KUxhEyyOyobsP-KEoiK2Ih0xVZaUfiHiCt8r8W4khZe5VI19-bfsWgJr3xTYo2OiKTwJWjUJomWLKyq_9tO2Hmp27pDpqzx-g/VaW543YV-j-evaaGXiVtfJJ5PPutORCTokI0LUABPIc'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vzEo1yHydkYTKcvHU805lg/CN-Pa1g8KwDGrdj8avQ4kKAmq7GFLPkZWa2UP04inCOeRMltWULhATvOM4IlAHcgVsXm1VdKVfkKjfQ-doZuMQ/mAI8eljB2LprW6B5NUwrGo3_Uqhn4syCcDAEHs1345k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZWcs6GDcJ0WTbiq0cPGZg/77XjGUVRHP1QY9Et0AK2dUapnZ3BKA0ZFBF02a0GHvgloiyQAx_1bhBRMiUHP1mBT85PJwHOVvWgte2i91UMyg/c1h_II4v-sB65q3OPWiLcoZAYpxxo71GcwvmsgmcK90'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q5473MlvnA3X6gpdkxtp3Q/btNVEPK-gcX1En1uum6OoqnGCibk8YOVbpyUjAX1wT5sVyYQ5RwHd0sED4XLD64CkxE8G1C54Q9cRyxHz-DddA/T5IaJdzzqvtdLXEa73S1td6HEBjTZuUGAi2Itohi9Dw'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,https://www.newport.com/mam/celum/celum_assets/np/resources/Agilis_Piezo_Motor_Driven_Components_User_Manual.pdf?1,"Irvine, California, United States",3500.0,"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782528/Instruments/Positional%20Controller/Agilis/Agilis.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116708/Instruments/Vendor%20Logos/Newport.png,1022.0,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
137,584.0,Teledyne,Maui,Instrumentkit,"Providing 12 bits all the time, a bigger display, smaller footprint, and more capability, the HDO6000B captures every detail.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,HDO6000B,"[OrderedDict([('id', 'attj3CSnSBkmM2yoT'), ('width', 800), ('height', 552), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1FA19IRZuUekhnUtF48UpA/hWmBcdiEk8w33sF0KO7Y9lbtQlPk80I_vS0ju4-GxYReABnQr4h8FjrcvWhgMjD55Ets6gF0B9-6QT6ZXT-rhM0qsZwZfkh4zVRuzf2kyXw/efxVhHelSPFgCqGls-xrgCXXJ2z1u47GcORxXuIIVGA'), ('filename', 'hdo6000b09.webp'), ('size', 69476), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6iiiWrm7vUtxFoj3_2bzIw/NwJp4vNv7H395MQ4PZHhbUTu2lj6ZfDtMW6AOFc-73C8KZN9WvAnN5rGuK2pzJahC7CzE2ejsU5nxyTnPIV_0UCtoaYBlVAAHfBQ07P4lhU/H42arCrt0KSND5c_r5Wzu-pwdC4FrZIBMn4WPO4ZpOM'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aMzP91d6qnRND2eBUy8Hqw/0Jc7bvlzzZ7B_324nxY4GZVCxd75JatEzd3iD4R36ls80efKHiJaua_qHogGak3xqm-XhZG3NeoeuTjH2FLIQ2l0DvrDWTIOBJ48YwNkv5g/xtLwIocvRMG2Zat8ZzNVHOOSdNtW-BuTwcqyzMX9mmU'), ('width', 742), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eTMnfiQ0Tw1oEU1Ogx_4Tg/xJcXM40hBEU1QZfPL5o4JgcahtdByVKrnXa6_QWQ6haz2GwuHHOBq3kqzyVxeuh5Ja8vEEUjN-9pbPgQ4ytNclsIl9EBlqaPnndktRCaWPU/hQ2v2FyVCAnKEEt-DuPY6sX_qH_xTpxaW-_mWOeYrj0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/hdo6000b-high-definition-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/hdo6000b-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a HDO6000B Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782540/Instruments/Oscilloscopes/HDO6000B/HDO6000B.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,16990.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
139,584.0,Teledyne,Maui,Instrumentkit,"Providing 12 bits all the time, more channels than any other oscilloscope, and long memory without tradeoffs – the WaveRunner 8000HD 8 channel oscilloscope captures every detail.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveRunner 8000HD,"[OrderedDict([('id', 'att2AevkrfFPeXyJ8'), ('width', 648), ('height', 475), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iyHpGevxT-ZBVvf2KbZusQ/y-UjTxXLP9mHXtGfkHmEM10uYbVKbSkIGEPpRoUuOmvfQGz_o4eso1IGryy1CptYMq2_WFCJZE3cqdaF9oSIRR72__gEaZqddHT5vymLT_4/gfpjWwbd2sdSjVfHTqDl0lz4bFrBzvezyw9a-GGo6vM'), ('filename', 'wr8000-1.webp'), ('size', 62720), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eA3hXfba5qOew-M83dbzmw/oTXIMsmTVzM8lycXgrIffFVRQzYKEHz8k6Z0q9A6Pt0DxtKVVreRCl6HxUjpCBACCKNbo7YnS8qBq41GmPQC4WpZOneqFduWGUlB43_uChc/5f5p34OdzeTs9h8C2LMN5hdUCGUI_inAva15SgPONZA'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zcXQYbTKw46rhIYSbtngqg/CbavZdcHsJpyVF9hzOMLhO0LsPujbzj3rQMgJH11lCV0KdQF14fFm5pUz2m6fogEx0NSszqO7LcRT_3gA0xRihjbJjgxVAsvfSfwsCW1DlA/wQM-1JsourqsH3jKqUCbV-Dhrat2zKf-9KBlHbJ7_AE'), ('width', 648), ('height', 475)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wi1EkMfihllrxkzJClT3Kw/NvZDnwSFJxOED2-bEAoPCp0CnAyCPoRppBzVb_GRq4crJcNaJxyzTHdh7aE5PpPm5Qb3jmeev9868KSd9bKG0NpW879RtchKVjjbAZDNMks/VsY941fFyPfjziKTNru4Hg1NGzT_-q8Xg94Rp6z3Asg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/waverunner-8000hd-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/waverunner-8000hd-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveRunner 8000HD Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782542/Instruments/Oscilloscopes/WaveRunner-8000HD/WaveRunner-8000HD.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,28625.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
151,551.0,Tektronix,Tektds 5 XX,Instrumentkit,"The TDS510A Digital Oscilloscope is a full-featured, cost-effective, versatile oscilloscope which meets the measurement requirements for general-purpose research and design. Its industry-preferred graphical user interface makes it easy to learn and efficient to use. The TDS510A advanced trigger capability allows the user to trigger and view signals in a wide variety of simple as well as complex design and analysis settings. With four channels, 50 K points per channel record length, and powerful waveform acquisition modes, the TDS510A can satisfy most complex design, debug, and analysis requirements.",https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,TDS510A,"[OrderedDict([('id', 'attxkUJsDPlUzetik'), ('width', 944), ('height', 708), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cNsRSE_vAk0Y6qs993kQ9A/TNqaZraWkAY5utcYhnksahE3cdSHcwn0_TGWQ7YG6GJ21EJ5Bh7_EIGdTlCsA8l2JN2z2nNNlYlMSj6ecGBq34cxiL9PIKcXqi3qjOU3J9I/SCGFhAyEYRX2lmC2Xch8p0Y8gdZUM0lYduDhFZAedA4'), ('filename', 'TDS510A.jpeg.webp'), ('size', 31982), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aN_4r6TaWjszFpCFIqpNIA/5HlSKf4dbHweTa8meWyK72lUv3wgyM639hDpULB439n95xt84OBSLy1EJb7OiEpNuZtfCUmp26KOkjKSL3NgY-3Rv1I-sKzzBYUU1sdhHMI/fSS5yd4mAsZVwB0CiRXLTIEPdfGcrigSlKcw5I6-gqs'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LVmg6QVAxz9dZ4cCs3JD0Q/sgHgZV15ywLgEnPt0vY-tUK4s0BahNavlumk71nmRfg4Evtoe5a28NQTUdSsvGpSFAAV3w4O8lI320gkxgoZVidvP6pZOy54d3xeyzIf4kM/I6bqzxCyBYRdck7ci5QGjdQXdwXYOOMsAstfpR54IQo'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WS7P_QrSsjoDuGaPKOhxQw/zpyMswdOGv-cqPQSQrZ5xV-R_hBv1IqLOELjyr5zz5QDI3tWsGboa558l7lQtQ3z9bBYCPJpWBL4yxpjdkECKF3JhmQrr18ESQlGo_Fcd0k/unK9M8QMOcKejUh1SAXOG_nxdvDGeX1-DmCFiRsoirg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/tds510a,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://www.instrumex.de/datasheet/TDS510A.pdf,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS510A Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782554/Instruments/Oscilloscopes/TDS510A/TDS510A.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,1030.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
159,233.0,Keithley,Keithley 6220,Instrumentkit,"The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High DC power supply sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.py,Keithley 6220,"[OrderedDict([('id', 'attGUuYhDgUI2msSE'), ('width', 799), ('height', 416), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/buEYZMZdVcV-aVd8BQ7FTQ/Wst1SmvUhfiygXfBfFSJXDCgQR2kLF9xWdmD5S5seWYKYb09kBFmRF49ujf6q_TU6JkRCH_ok8F2EoTd7yCzrlK9zsjV2SV38CKdTi5A_9Q/vwj9WVFgEHd6AyUcTMV-s_uYC6McHA0AZm0X9vYeaXY'), ('filename', 'Keithley_6220.jpg'), ('size', 79670), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WqhMMs6dkAZW4FuyRYtMQQ/NQ5YeuU7yArE9ofrRQbeXqToEramyjkL9DJ3ZPG2U-6B-hurqjVpt9fG0lsymwj39gu6hphmw75qNrhAhbKrOA/HAMs5gN09mvXSCPYvpE0q_4UDhK6GUqDK8Om_8pbt8E'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OkLbpeoBd7Dubr23e2eDRg/wllbB1DT77NSm83KrUI6yhAz5KNsCIe995sFgL79KQG2Yobnc8VVAO6ut5TKgnKy3ov01064hItbzcqD807buw/pKbnuUqaZFg1Odht_oqaGLA6OVk7FjFvrDUuHEhTxNM'), ('width', 799), ('height', 416)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/j42tVh3o514kyMJ7Sygx-A/s5IpHKgsh4V4HRYFf17v_tpp5F05cm_eK6C6GHPC2IhqdFAEgK3QPFfZ1I30kv4guAdQIVh3gh1JG3ORTfuwTQ/f5Z5jSr0d0h4jtlfAv1867BB1516FGemfXkKZiaN4BE'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/6220/source-meter-dc-current-11w/dp/43K0016,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.",https://en.wikipedia.org/wiki/Electricity_meter,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782562/Instruments/Power%20Meters/Keithley-6220/Keithley-6220.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,8631.9,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
164,584.0,Teledyne,Maui,Instrumentkit,"WavePro HD High-Definition oscilloscopes employ unique Teledyne LeCroy HD4096 technology to achieve 12-bit resolution at up to 8 GHz bandwidth, for the lowest noise and unmatched signal fidelity. Up to 5 Gpt of highly responsive acquisition memory gives more visibility into system behavior, and the exceptional analysis toolbox enables deep insight.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WavePro HD,"[OrderedDict([('id', 'att4IDQeQoh37ZEzt'), ('width', 940), ('height', 627), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xftECY-XwPwvpu4Nx6_ZBQ/ZtrMGILeGb-E5WWQRwvFfGSUWiDz9SxyF2XAxFHRheQ4SU12_ulf4I-dcPWJhpUMLa_2--6p9iMHBWck3lvCpwQZaifNQqQqX-PDZnJKfyY/XEAkoV35jN9w1xKK831HMoXsiTIUktMzY7SG0VcsTFo'), ('filename', 'wphd-04.png'), ('size', 406177), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qbnfjhX1I3jlClpPo00zNg/kYktTwy0nDFHvMEt2bXjynSkdcyXnlG3J-7JQvsPO8cQ696aM2z1L9k6ZVAI6qgQLxDJFWcc3KkmoonScVwylQ/EWcVfrEf3mDG40fokCHIl1zmwJhHjFd0YxLqUcZycSE'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zbgebGKfadp_wjuqmtuptg/VShKP6q7QRTPEQqYEVxhyl7SE_qW6JOzqY9egqgbLcwBUSyKOXlWwS7RHkOWq7zDPPVKmjd9ka8QUTNIHVeYpA/PPZP7xHH8W_h_WU49Q9flYCi3YHMyeWjK0XKrGBueRI'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CwmQFMwhbqxzokkkIxSzRQ/h9UaRWxfsNcqSlyHj29YUcFrsEKw1t-kwtcRkulpg_xrbEvbdmsrGH9Ti0eAeq3G6ZakMVmavy5iEBpUrBiIrw/AwOArAZ0pWPrkeg_mxcZ_qlveM1RVWMYBTh0olhx-Kc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavepro-hd-oscilloscope,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/waveprohd-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WavePro HD Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782567/Instruments/Oscilloscopes/WavePro-HD/WavePro-HD.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,31000.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
166,156.0,HP,HPE 3631 A,Instrumentkit,"E3631A 80W Triple Output Power Supply, 6V, 5A & ±25V, 1A",https://instrumentkit.readthedocs.io/en/latest/apiref/hp.html#hpe3631a-power-supply,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hp/hpe3631a.py,Keysight E3631A,"[OrderedDict([('id', 'attSpS8B1W8Re8bpU'), ('width', 582), ('height', 431), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Bk_-qSbmu6lvK4hDilVr1Q/WTwjXa_veSTqh5gJm2ktOwpO_p10yuZTBCucTiyWtuS0xaVB6A9-SmsyZsOQ3xau_ov0ZzT58RemyrPdzDbpVLp4qegr6mGqUP4xpKCaoEk/xT91Qv1bCfwo2PLTYHk3Yh2BDaQqmNkzE_3lB8t0--k'), ('filename', 'E3631.png'), ('size', 222345), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Mqmx8CHkl2y4HA0oGZS75g/GXO5wra-05c0N8USbU0FSEyvOMCmuzaxVbw2xQkApcZSFT7cV9zk34BxmlECEHIsArOCJaksAxSqZQ62JQdW2Q/JegzucnWoc3H0sD27b0Cd6xY8T9qE6741WSce062GQw'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VndOpT86vyHSljL71JLmKg/FM8JzX2yAf7w6ibKT_AZQ2FV2P-MyAKVSoMKKUDGKGWO-9r-wRRHDszhgJyITm8aaAOYROeicrf7nGsRTOzspw/ATJ4ldeNBrJsmk_IgPN_nZ4XGkEZGBXWLOHlVzCjcrA'), ('width', 582), ('height', 431)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/21bkcZiVtXstFcZgSqJbYg/CWT0JKarRwFdcaPx_6KqdLsJ1N3WyHVXuyZHJiwwvAexS_V1sBj0sO6bvzE3HPrvA5OB_x94oHRTjfcNwxgN7Q/jolLbQsavdgBdDIz6zfqIfKnoDo-oN3ymOpLagZPcJU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E3631A/80w-triple-output-power-supply-6v-5a--25v-1a.html,['Power Supplies'],"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KLdW4e0aCMvuXtiF41lm5Q/tsULR905frVMXXpSBwX--GGG9pd67YfJfVqUbiphB7yi1YiZaesAKIc0H5OSMeujmzTnzL_TYJFKsYOLX2M-HuYgDDy464YMgOwWmAd540U/CQIhv7AHEyD7_1uuRrDXD-cM5HYvTXSunU9vcixsAug'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hlmdofa38jYloahcVSLpNw/3p9k2-zlW4PdZXOINyi5WevKuox8MEkgKxpfU8qhRNpuf6uCOaEc-SiDI8AOTUAw7YWp8NRCdU2dgc1P7EdU6HAyjmQbiEO3Hp3vcYlrIOY/Q6c584Zg-Ge5NIW7DvdQ-5bvCuyqJrmDmg6PDWARSL4'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dR-u6vcQ_qWkh_hzfJEdxQ/CqsqK2EnfYs5VLISQZ0OFYxQu_f9UQE_4pV_CakymtxZEGedpRn5KZvpsUnaybslmwwnrzvwiTZYPMP4emI5NC_nZxdGIx1ebsyYeKzRvnI/_oVf9TubhrO_RGOizCZPQfUHwNRQejxeIB_SREKXPHo'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SUaU78ZSlXE2XNRXeJAbJA/6bdGaHs7U5UbkXguW0uCC_jxHbNmi66L6y9XdaPyQYZhXOjcQsnb5Vx_VObVUE-pJ0UAWtZ88P0_zZN1TD3orExVUQe-wN3ukqEB7ShXXFw/tZAWl3xpv2JxN3HZABBPT7KYR938lcxPG87n9cnzOC0'), ('width', 3000), ('height', 3000)]))]))])]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://www.keysight.com/us/en/home.html,https://www.keysight.com/us/en/assets/7018-06785/data-sheets/5968-9726.pdf,USA,5420.0,A power supply is an electrical device that supplies electric power to an electrical load.,https://en.wikipedia.org/wiki/Power_supply,Write a Python script that uses Instrumentkit to connect to a Keysight E3631A Power Supplies,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782569/Instruments/Power%20Supplies/Keysight-E3631A/Keysight-E3631A.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116715/Instruments/Vendor%20Logos/HP.png,2300.0,,,,"

Source code for instruments.hp.hp3456a
#!/usr/bin/env python
#
# hp3456a.py: Driver for the HP3456a Digital Voltmeter.
#
# © 2014 Willem Dijkstra (wpd@xs4all.nl).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the HP3456a Digital Voltmeter

Originally contributed and copyright held by Willem Dijkstra (wpd@xs4all.nl)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

import time
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u
from instruments.util_fns import assume_units, bool_property, enum_property

# CLASSES #####################################################################


class HP3456a(Multimeter):

    """"""The `HP3456a` is a 6 1/2 digit bench multimeter.

    It supports DCV, ACV, ACV + DCV, 2 wire Ohms, 4 wire Ohms, DCV/DCV Ratio,
    ACV/DCV Ratio, Offset compensated 2 wire Ohms and Offset compensated 4 wire
    Ohms measurements.

    Measurements can be further extended using a system math mode that allows
    for pass/fail, statistics, dB/dBm, null, scale and percentage readings.

    `HP3456a` is a HPIB / pre-448.2 instrument.
    """"""

    def __init__(self, filelike):
        """"""
        Initialise the instrument, and set the required eos, eoi needed for
        communication.
        """"""
        super().__init__(filelike)
        self.timeout = 15 * u.second
        self.terminator = ""\r""
        self.sendcmd(""HO0T4SO1"")
        self._null = False

    # ENUMS ##

    class MathMode(IntEnum):

        """"""
        Enum with the supported math modes
        """"""

        off = 0
        pass_fail = 1
        statistic = 2
        null = 3
        dbm = 4
        thermistor_f = 5
        thermistor_c = 6
        scale = 7
        percent = 8
        db = 9

    class Mode(Enum):

        """"""
        Enum containing the supported mode codes
        """"""

        #: DC voltage
        dcv = ""S0F1""
        #: AC voltage
        acv = ""S0F2""
        #: RMS of DC + AC voltage
        acvdcv = ""S0F3""
        #: 2 wire resistance
        resistance_2wire = ""S0F4""
        #: 4 wire resistance
        resistance_4wire = ""S0F5""
        #: ratio DC / DC voltage
        ratio_dcv_dcv = ""S1F1""
        #: ratio AC / DC voltage
        ratio_acv_dcv = ""S1F2""
        #: ratio (AC + DC) / DC voltage
        ratio_acvdcv_dcv = ""S1F3""
        #: offset compensated 2 wire resistance
        oc_resistence_2wire = ""S1F4""
        #: offset compensated 4 wire resistance
        oc_resistence_4wire = ""S1F5""

    class Register(Enum):

        """"""
        Enum with the register names for all `HP3456a` internal registers.
        """"""

        number_of_readings = ""N""
        number_of_digits = ""G""
        nplc = ""I""
        delay = ""D""
        mean = ""M""
        variance = ""V""
        count = ""C""
        lower = ""L""
        r = ""R""
        upper = ""U""
        y = ""Y""
        z = ""Z""

    class TriggerMode(IntEnum):

        """"""
        Enum with valid trigger modes.
        """"""

        internal = 1
        external = 2
        single = 3
        hold = 4

    class ValidRange(Enum):

        """"""
        Enum with the valid ranges for voltage, resistance, and number of
        powerline cycles to integrate over.

        """"""

        voltage = (1e-1, 1e0, 1e1, 1e2, 1e3)
        resistance = (1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9)
        nplc = (1e-1, 1e0, 1e1, 1e2)

    # PROPERTIES ##

    mode = enum_property(
        """",
        Mode,
        doc=""""""Set the measurement mode.

        :type: `HP3456a.Mode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    autozero = bool_property(
        ""Z"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the autozero mode.

        This is used to compensate for offsets in the dc
        input amplifier circuit of the multimeter. If set, the amplifier""s input
        circuit is shorted to ground prior to actual measurement in order to
        take an offset reading. This offset is then used to compensate for
        drift in the next measurement. When disabled, one offset reading
        is taken immediately and stored into memory to be used for all
        successive measurements onwards. Disabling autozero increases the
        `HP3456a`""s measurement speed, and also makes the instrument more
        suitable for high impendance measurements since no input switching is
        done."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    filter = bool_property(
        ""FL"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the analog filter mode.

        The `HP3456a` has a 3 pole active filter with
        greater than 60dB attenuation at frequencies of 50Hz and higher. The
        filter is applied between the input terminals and input amplifier. When
        in ACV or ACV+DCV functions the filter is applied to the output of the
        ac converter and input amplifier. In these modes select the filter for
        measurements below 400Hz."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    math_mode = enum_property(
        ""M"",
        MathMode,
        doc=""""""Set the math mode.

        The `HP3456a` has a number of different math modes that
        can change measurement output, or can provide additional
        statistics. Interaction with these modes is done via the
        `HP3456a.Register`.

        :type: `HP3456a.MathMode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    trigger_mode = enum_property(
        ""T"",
        TriggerMode,
        doc=""""""Set the trigger mode.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`.

        :type: `HP3456a.TriggerMode`

        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    @property
    def number_of_readings(self):
        """"""Get/set the number of readings done per trigger/measurement cycle
        using `HP3456a.Register.number_of_readings`.

        :type: `float`
        :rtype: `float`

        """"""
        return self._register_read(HP3456a.Register.number_of_readings)

    @number_of_readings.setter
    def number_of_readings(self, value):
        self._register_write(HP3456a.Register.number_of_readings, value)

    @property
    def number_of_digits(self):
        """"""Get/set the number of digits used in measurements using
        `HP3456a.Register.number_of_digits`.

        Set to higher values to increase accuracy at the cost of measurement
        speed.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.number_of_digits))

    @number_of_digits.setter
    def number_of_digits(self, newval):
        newval = int(newval)
        if newval not in range(3, 7):
            raise ValueError(
                ""Valid number_of_digits are: "" ""{}"".format(list(range(3, 7)))
            )

        self._register_write(HP3456a.Register.number_of_digits, newval)

    @property
    def nplc(self):
        """"""Get/set the number of powerline cycles to integrate per measurement
        using `HP3456a.Register.nplc`.

        Setting higher values increases accuracy at the cost of a longer
        measurement time. The implicit assumption is that the input reading is
        stable over the number of powerline cycles to integrate.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.nplc))

    @nplc.setter
    def nplc(self, newval):
        newval = int(newval)
        valid = HP3456a.ValidRange[""nplc""].value
        if newval in valid:
            self._register_write(HP3456a.Register.nplc, newval)
        else:
            raise ValueError(""Valid nplc settings are: "" ""{}"".format(valid))

    @property
    def delay(self):
        """"""Get/set the delay that is waited after a trigger for the input to
        settle using `HP3456a.Register.delay`.

        :type: As specified, assumed to be `~quantaties.Quantity.s` otherwise
        :rtype: `~quantaties.Quantity.s`

        """"""
        return self._register_read(HP3456a.Register.delay) * u.s

    @delay.setter
    def delay(self, value):
        delay = assume_units(value, u.s).to(u.s).magnitude
        self._register_write(HP3456a.Register.delay, delay)

    @property
    def mean(self):
        """"""
        Get the mean over `HP3456a.Register.count` measurements from
        `HP3456a.Register.mean` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.mean)

    @property
    def variance(self):
        """"""
        Get the variance over `HP3456a.Register.count` measurements from
        `HP3456a.Register.variance` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.variance)

    @property
    def count(self):
        """"""
        Get the number of measurements taken from `HP3456a.Register.count` when
        in `HP3456a.MathMode.statistic`.

        :rtype: `int`
        """"""
        return int(self._register_read(HP3456a.Register.count))

    @property
    def lower(self):
        """"""
        Get/set the value in `HP3456a.Register.lower`, which indicates the
        lowest value measurement made while in `HP3456a.MathMode.statistic`, or
        the lowest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        """"""
        return self._register_read(HP3456a.Register.lower)

    @lower.setter
    def lower(self, value):
        self._register_write(HP3456a.Register.lower, value)

    @property
    def upper(self):
        """"""
        Get/set the value in `HP3456a.Register.upper`, which indicates the
        highest value measurement made while in `HP3456a.MathMode.statistic`,
        or the highest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.upper)

    @upper.setter
    def upper(self, value):
        return self._register_write(HP3456a.Register.upper, value)

    @property
    def r(self):
        """"""
        Get/set the value in `HP3456a.Register.r`, which indicates the resistor
        value used while in `HP3456a.MathMode.dbm` or the number of recalled
        readings in reading storage mode.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.r)

    @r.setter
    def r(self, value):
        self._register_write(HP3456a.Register.r, value)

    @property
    def y(self):
        """"""
        Get/set the value in `HP3456a.Register.y` to be used in calculations
        when in `HP3456a.MathMode.scale` or `HP3456a.MathMode.percent`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.y)

    @y.setter
    def y(self, value):
        self._register_write(HP3456a.Register.y, value)

    @property
    def z(self):
        """"""
        Get/set the value in `HP3456a.Register.z` to be used in calculations
        when in `HP3456a.MathMode.scale` or the first reading when in
        `HP3456a.MathMode.statistic`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.z)

    @z.setter
    def z(self, value):
        self._register_write(HP3456a.Register.z, value)

    @property
    def input_range(self):
        """"""Set the input range to be used.

        The `HP3456a` has separate ranges for `ohm` and for
        `volt`. The range value sent to the instrument depends on
        the unit set on the input range value. `auto` selects auto ranging.

        :type: `~pint.Quantity`
        """"""
        raise NotImplementedError

    @input_range.setter
    def input_range(self, value):
        if isinstance(value, str):
            if value.lower() == ""auto"":
                self.sendcmd(""R1W"")
            else:
                raise ValueError(
                    ""Only 'auto' is acceptable when specifying ""
                    ""the input range as a string.""
                )

        elif isinstance(value, u.Quantity):
            if value.units == u.volt:
                valid = HP3456a.ValidRange.voltage.value
                value = value.to(u.volt)
            elif value.units == u.ohm:
                valid = HP3456a.ValidRange.resistance.value
                value = value.to(u.ohm)
            else:
                raise ValueError(
                    ""Value {} not quantity.volt or quantity.ohm"" """".format(value)
                )

            value = float(value.magnitude)
            if value not in valid:
                raise ValueError(
                    ""Value {} outside valid ranges "" ""{}"".format(value, valid)
                )
            value = valid.index(value) + 2
            self.sendcmd(f""R{value}W"")
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                ""or the string 'auto', got {}"".format(type(value))
            )

    @property
    def relative(self):
        """"""
        Enable or disable `HP3456a.MathMode.Null` on the instrument.

        :type: `bool`
        """"""
        return self._null

    @relative.setter
    def relative(self, value):
        if value is True:
            self._null = True
            self.sendcmd(f""M{HP3456a.MathMode.null.value}"")
        elif value is False:
            self._null = False
            self.sendcmd(f""M{HP3456a.MathMode.off.value}"")
        else:
            raise TypeError(
                ""Relative setting must be specified as a bool, ""
                ""got {}"".format(type(value))
            )

    # METHODS ##

    def auto_range(self):
        """"""
        Set input range to auto. The `HP3456a` should upscale when a reading
        is at 120% and downscale when it below 11% full scale. Note that auto
        ranging can increase the measurement time.
        """"""
        self.input_range = ""auto""

    def fetch(self, mode=None):
        """"""Retrieve n measurements after the HP3456a has been instructed to
        perform a series of similar measurements. Typically the mode, range,
        nplc, analog filter, autozero is set along with the number of
        measurements to take. The series is then started at the trigger
        command.

        Example usage:

        >>> dmm.number_of_digits = 6
        >>> dmm.auto_range()
        >>> dmm.nplc = 1
        >>> dmm.mode = dmm.Mode.resistance_2wire
        >>> n = 100
        >>> dmm.number_of_readings = n
        >>> dmm.trigger()
        >>> time.sleep(n * 0.04)
        >>> v = dmm.fetch(dmm.Mode.resistance_2wire)
        >>> print len(v)
        10

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be returned.

        :type mode: `HP3456a.Mode`

        :return: A series of measurements from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            units = UNITS[mode]
        else:
            units = 1

        value = self.query("""", size=-1)
        values = [float(x) * units for x in value.split("","")]
        return values

    def measure(self, mode=None):
        """"""Instruct the HP3456a to perform a one time measurement. The
        measurement will use the current set registers for the measurement
        (number_of_readings, number_of_digits, nplc, delay, mean, lower, upper,
        y and z) and will immediately take place.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`

        Example usage:

        >>> dmm = ik.hp.HP3456a.open_gpibusb(""/dev/ttyUSB0"", 22)
        >>> dmm.number_of_digits = 6
        >>> dmm.nplc = 1
        >>> print dmm.measure(dmm.Mode.resistance_2wire)

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be
            returned.

        :type mode: `HP3456a.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`

        """"""
        if mode is not None:
            modevalue = mode.value
            units = UNITS[mode]
        else:
            modevalue = """"
            units = 1

        self.sendcmd(f""{modevalue}W1STNT3"")

        value = self.query("""", size=-1)
        return float(value) * units

    def _register_read(self, name):
        """"""
        Read a register on the HP3456a.

        :param name: The name of the register to read from
        :type name: `HP3456a.Register`
        :rtype: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        self.sendcmd(f""RE{name.value}"")
        time.sleep(0.1)
        return float(self.query("""", size=-1))

    def _register_write(self, name, value):
        """"""
        Write a register on the HP3456a.

        :param name: The name of the register to write to
        :type name: `HP3456a.Register`
        :type value: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        if name in [
            HP3456a.Register.mean,
            HP3456a.Register.variance,
            HP3456a.Register.count,
        ]:
            raise ValueError(f""register {name} is read only"")
        self.sendcmd(f""W{value}ST{name.value}"")
        time.sleep(0.1)

    def trigger(self):
        """"""
        Signal a single manual trigger event to the `HP3456a`.
        """"""
        self.sendcmd(""T3"")


# UNITS #######################################################################

UNITS = {
    None: 1,
    HP3456a.Mode.dcv: u.volt,
    HP3456a.Mode.acv: u.volt,
    HP3456a.Mode.acvdcv: u.volt,
    HP3456a.Mode.resistance_2wire: u.ohm,
    HP3456a.Mode.resistance_4wire: u.ohm,
    HP3456a.Mode.ratio_dcv_dcv: 1,
    HP3456a.Mode.ratio_acv_dcv: 1,
    HP3456a.Mode.ratio_acvdcv_dcv: 1,
    HP3456a.Mode.oc_resistence_2wire: u.ohm,
    HP3456a.Mode.oc_resistence_4wire: u.ohm,
}


"
169,584.0,Teledyne,Maui,Instrumentkit,"The WaveSurfer 510 combines the MAUI with OneTouch user interface with powerful waveform processing, in addition to advanced math, measurement, and debug tools, to quickly analyze and find the root cause of problems. The 12.1” touch-screen display of the WaveSurfer 510 is the largest in its class and makes viewing waveform abnormalities fast and easy.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveSurfer 510,"[OrderedDict([('id', 'attoBSvdaeYOq105z'), ('width', 1024), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/94aTbLs4PfOQR8XdHKFATQ/8-wTxB2QLEZQ3XomsiyTkv6cnSCSqrZCSn6rea5b6YftAvxPR3EP2P8x_k3WVl_euEA-3AfVVHmuAn0c0LOZqqHRnMEFv9nfsJHlZDSLnD8qNRahKId2qIR4dJdRPArh/4ctxebU0Pk_B6SLKOKv71YZ4GCjPbeyzL7vLzJyMx8I'), ('filename', 'LeCroy_WaveSurfer-510_img2.jpg'), ('size', 73189), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mYKItQF3FsIh_qAA4yz2dQ/3gUODbUdMAH9NPHgH-K77ZVwPWXXyedGtgnoHasedh2SqcTw8TL6SLZMniNoGc-0pqgvrAksqWb2ISgjQelcPg/XGXaMhx7nhfFV53TzVXka9hmXsM3VGj846RbR7dFnKY'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WlSK87tip0jVW1sKh-6NcA/aPukIZPTm8yD0traHZYp9lnElI2LUb_4WI_YCi1-7Jk5QTiL8Tm7xyk40uHfJaasNHDKQlAftln5NFNm29hAwg/Ppi058zs6SR_B2kxaWL1Xw6BWYeOjzjgU-iiksCyGHk'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/17NpssqS_P6xcoZr2kiGoA/7NKvPc2ZRWutu36OwS4kydl6dusSboEMfs3ynKxgXeK3YSfhtSbceN7MHNASwSpWVT1DsyEevcWHDWiP_V9aGQ/1yl8byIEZYCz6g2xpZ6MeTVs2rdXgAW0vYqyEcOTDQ8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tequipment.net/LeCroy/WaveSurfer-510/Digital-Oscilloscopes/,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,"https://res.cloudinary.com/iwh/image/upload/q_auto,g_center/assets/1/26/wavesurfer510-ds-24mar17-prelim.pdf",USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 510 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782572/Instruments/Oscilloscopes/WaveSurfer-510/WaveSurfer-510.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,13553.0,,True,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
171,607.0,Thorlabs,LCC 25,Instrumentkit,"The LCC25 is a liquid crystal controller compatible with all Thorlabs LC Variable
Retarders. The LCC25 will drive most nematic liquid crystal devices. The liquid crystal
device is connected to the BNC voltage output port. The amplitude of the output voltage,
adjusted by the front panel knob, and external signal, and a computer via a USB interface,
controls the retardance of the LC device.",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#lcc25-liquid-crystal-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/lcc25.py,LCC25,"[OrderedDict([('id', 'attHPq5FREiy9RqsJ'), ('width', 1200), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HfC1WywpshMmiXJq6nxWaQ/JjrftlmSHMQVtCQ44ei-dqtptdP0HFyxOw6zd0SdM9uR647LOIA0WbD6EzTU6QV9vwsC1ELv5j9BnLUqfL2aLilSia3jw1DZHNcIx477HdU/9GgYYooUfcYg6t7Zj4Z4iRRAFb-ViZoYachau1h2oDA'), ('filename', 'LCC25.jpg'), ('size', 110410), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8U2dSgpABDG17gNHUAYvcA/cF7fv0Ux-IpiTZuA-533reBQzjZb_oFcHWkSILHRT7f4imwEEiwWXnlWcyj1PkMrkjevdtrGkaB6O6FoPsC81w/-5oPDjgEQ0NbmfE2P6gC_l0pfXVUnjWTsDkM9xXERCQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/edx2vTnhMkPzSZThpKp88Q/i6dxKH2jjK4_fXDfJcNk91AbSOkyEE7BmjzZX_KALEuRG6sTdEtOV8SjoI-d0mPAg8U53HG5sVwp8SZ4fzisdA/74s9oMta8AtsMK865zzu5UdVf2405Ij9HSxEcStSGe8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yvriHwHiniF4SeSIwyZGHA/-IEKU7tXm8Ob7zga39DmSTufLNjsjYfr3Ry01sSzCfQYYSVegDmCgOdyKbOSHEWlBFmpgfqNpKr8kw1VvJmyOw/FoTCRzW0yNT-Mg-Ktci-HU_zCMjszPMKrv98z9NijSA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,['Power Supplies'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,USA,550.0,"A part of Thorlabs' growing line of high-end, compact controllers and is designed to drive many of Thorlabs' liquid crystal variable retarders, polarization rotators, and cells",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=14074,Write a Python script that uses Instrumentkit to connect to a LCC25 Power Supplies,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782574/Instruments/Power%20Supplies/LCC25/LCC25.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,1512.85,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
172,433.0,Qubitekk,MC1,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#mc1-motor-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/mc1.py,MC1,,,['Positional Controller'],"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4ijrLHLMvOyqle0SY059yQ/CXZr3NpK0Z0IgC0x8X1iruyvfSYSVt-7Ilztem3QxSLNBh__JyUxJrMYbeqH9H2XWNpcy_x1ixFOKNnYyDv180FNXAx60eG3uZuWCFXjwwqZO-xV3fEJDO8hVw1VbB8g/IqG-AigygKQH5u1vt2i5NasYa15GxrADK82y_zCoaLs'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BkGFFHsZQ62QuxK6IyCdrA/jsddFBYN5dDdb11iizAizNjUzpKhCpO0qjFkzd-kXRdhbyrO2iY3v-x6usmx2Dj7tRjnnEp_fCJlDNS2L1U9Xg/oZNUPNwjwSIqztq7O377L_DqMCls6AJlE60n1_7aoPs'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KO1pHcrqfsjUAro1j_pATg/l2AzsU_gW7cWzeLOB_EM1dA51yOdlwRIk1wwbirqDAbvRCnRTyPQ9h7NRijrig0u-eJ7eJs2sNsjddK-t51VcQ/OYj2Xr3s7-cP7Lx9LDSLv0BqgimXXcL5icKcIeXEFJM'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tGdHvx5craZwVcERJ6Z8kQ/HVaw5Q8XDvDOTNzEH6vDfyEecq9dI9jUgEt5myKoAyahdN0UEKJGcHO374HTlt3m_3IKUT6f1KE0oiADC8NbMg/j-gQQw3F7Wwt8xkWWEgDR1H7Huu3-Z7HHaJjxxl0d10'), ('width', 3000), ('height', 3000)]))]))])]","Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",https://qubitekk.com/,,"Vista, California, United States",5.0,"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116712/Instruments/Vendor%20Logos/Qubitekk.png,,,,,"

Source code for instruments.qubitekk.cc1
#!/usr/bin/env python
""""""
Provides support for the Qubitekk CC1 Coincidence Counter instrument.

CC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi.scpi_instrument import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units, split_unit_str

# CLASSES #####################################################################


class CC1(SCPIInstrument):

    """"""
    The CC1 is a hand-held coincidence counter.

    It has two setting values, the dwell time and the coincidence window. The
    coincidence window determines the amount of time (in ns) that the two
    detections may be from each other and still be considered a coincidence.
    The dwell time is the amount of time that passes before the counter will
    send the clear signal.

    More information can be found at :
    http://www.qubitekk.com
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\n""
        self._channel_count = 3
        self._firmware = None
        self._ack_on = False
        self.sendcmd("":ACKN OF"")
        # a readline is required because if the firmware is prior to 2.2,
        # the cc1 will respond with 'Unknown Command'. After
        # 2.2, it will either respond by acknowledging the command (turning
        # acknowledgements off does not take place until after the current
        # exchange has been completed), or not acknowledging it (if the
        # acknowledgements are off). The try/except block is required to
        # handle the case in which acknowledgements are off.
        try:
            self.read(-1)
        except OSError:
            pass
        _ = self.firmware  # prime the firmware

        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            self._bool = (""ON"", ""OFF"")
            self._set_fmt = "":{}:{}""
            self.TriggerMode = self._TriggerModeNew

        else:
            self._bool = (""1"", ""0"")
            self._set_fmt = "":{} {}""
            self.TriggerMode = self._TriggerModeOld

    def _ack_expected(self, msg=""""):
        return (
            msg
            if self._ack_on and self.firmware[0] >= 2 and self.firmware[1] > 1
            else None
        )

    # ENUMS #

    class _TriggerModeNew(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""MODE CONT""
        start_stop = ""MODE STOP""

    class _TriggerModeOld(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""0""
        start_stop = ""1""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a channel on the Qubitekk CC1.
        """"""

        __CHANNEL_NAMES = {1: ""C1"", 2: ""C2"", 3: ""CO""}

        def __init__(self, cc1, idx):
            self._cc1 = cc1
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        # PROPERTIES #

        @property
        def count(self):
            """"""
            Gets the counts of this channel.

            :rtype: `int`
            """"""
            count = self._cc1.query(f""COUN:{self._chan}?"")
            tries = 5
            try:
                count = int(count)
            except ValueError:
                count = None
                while count is None and tries > 0:
                    # try to read again
                    try:
                        count = int(self._cc1.read(-1))
                    except ValueError:
                        count = None
                        tries -= 1

            if tries == 0:
                raise OSError(f""Could not read the count of channel "" f""{self._chan}."")

            self._count = count
            return self._count

    # PROPERTIES #

    @property
    def acknowledge(self):
        """"""
        Gets/sets the acknowledge message state. If True, the CC1 will echo
        back every command sent, then print the response (either Unable to
        comply, Unknown command or the response to a query). If False,
        the CC1 will only print the response.

        :units: None
        :type: boolean
        """"""
        return self._ack_on

    @acknowledge.setter
    def acknowledge(self, new_val):
        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            if self._ack_on and not new_val:
                self.sendcmd("":ACKN OF"")
                self._ack_on = False
            elif not self._ack_on and new_val:
                self.sendcmd("":ACKN ON"")
                self._ack_on = True
        else:
            raise NotImplementedError(
                ""Acknowledge message not implemented in "" ""this version.""
            )

    @property
    def gate(self):
        """"""
        Gets/sets the gate enable status

        :type: `bool`
        """"""
        return self.query(""GATE?"").strip() == self._bool[0]

    @gate.setter
    def gate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""GATE"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def subtract(self):
        """"""
        Gets/sets the subtract enable status

        :type: `bool`
        """"""
        return self.query(""SUBT?"").strip() == self._bool[0]

    @subtract.setter
    def subtract(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""SUBT"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode setting for the CC1. This can be set to
        ``continuous`` or ``start/stop`` modes.

        :type: `CC1.TriggerMode`
        """"""
        return self.TriggerMode(self.query(""TRIG?"").strip())

    @trigger_mode.setter
    def trigger_mode(self, newval):
        try:  # First assume newval is Enum.value
            newval = self.TriggerMode[newval]
        except KeyError:  # Check if newval is Enum.name instead
            try:
                newval = self.TriggerMode(newval)
            except ValueError:
                raise ValueError(""Enum property new value not in enum."")
        self.sendcmd(self._set_fmt.format(""TRIG"", self.TriggerMode(newval).value))

    @property
    def window(self):
        """"""
        Gets/sets the length of the coincidence window between the two signals.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units nanoseconds.
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(*split_unit_str(self.query(""WIND?""), ""ns""))

    @window.setter
    def window(self, new_val):
        new_val_mag = int(assume_units(new_val, u.ns).to(u.ns).magnitude)
        if new_val_mag < 0 or new_val_mag > 7:
            raise ValueError(""Window is out of range."")
        # window must be an integer!
        self.sendcmd(f"":WIND {new_val_mag}"")

    @property
    def delay(self):
        """"""
        Get/sets the delay value (in nanoseconds) on Channel 1.

        When setting, ``N`` may be ``0, 2, 4, 6, 8, 10, 12, or 14ns``.

        :rtype: `~pint.Quantity`
        :return: the delay value
        """"""
        return u.Quantity(*split_unit_str(self.query(""DELA?""), ""ns""))

    @delay.setter
    def delay(self, new_val):
        new_val = assume_units(new_val, u.ns).to(u.ns)
        if new_val < 0 * u.ns or new_val > 14 * u.ns:
            raise ValueError(""New delay value is out of bounds."")
        if new_val.magnitude % 2 != 0:
            raise ValueError(""New magnitude must be an even number"")
        self.sendcmd("":DELA "" + str(int(new_val.magnitude)))

    @property
    def dwell_time(self):
        """"""
        Gets/sets the length of time before a clear signal is sent to the
        counters.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units seconds.
        :type: `~pint.Quantity`
        """"""
        # the older versions of the firmware erroneously report the units of the
        # dwell time as being seconds rather than ms
        dwell_time = u.Quantity(*split_unit_str(self.query(""DWEL?""), ""s""))
        if self.firmware[0] <= 2 and self.firmware[1] <= 1:
            return dwell_time / 1000.0

        return dwell_time

    @dwell_time.setter
    def dwell_time(self, new_val):
        new_val_mag = assume_units(new_val, u.s).to(u.s).magnitude
        if new_val_mag < 0:
            raise ValueError(""Dwell time cannot be negative."")
        self.sendcmd(f"":DWEL {new_val_mag}"")

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                if self._firmware.find(""Unknown"") >= 0:
                    self._firmware = None
                else:
                    value = self._firmware.replace(""Firmware v"", """").split(""."")
                    if len(value) < 3:
                        for _ in range(3 - len(value)):
                            value.append(0)
                    value = tuple(map(int, value))
                    self._firmware = value
        return self._firmware

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> cc = ik.qubitekk.CC1.open_serial('COM8', 19200, timeout=1)
        >>> print(cc.channel[0].count)

        :rtype: `CC1.Channel`
        """"""
        return ProxyList(self, CC1.Channel, range(self._channel_count))

    # METHODS #

    def clear_counts(self):
        """"""
        Clears the current total counts on the counters.
        """"""
        self.sendcmd(""CLEA"")


"
176,210.0,Keithley,Keithley 195,Instrumentkit,"The Keithley 195A Digital Multimeter is a fully programmable instrument with a 5.5 digit resolution. In standard configuration, the Model 195A is capable of DC voltage measurements between 100nV and 1000V on six ranges, 2-terminal and 4-terminal resistance measurements between 100µO and 20MO on seven ranges. The instrument is designed to work with platinum RTD probes, a factor which contributes to high accuracy.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley195-digital-multimeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley195.py,Keithley 195,"[OrderedDict([('id', 'attY6gK1wdeglTdjY'), ('width', 600), ('height', 373), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_0foOXu8qK2-Mtxmna-L8g/RXLJoY9or9rRiSA48DYp168wChAJbfkL3xJhNEfsA9Hs7fXS5ZulTalvTreAVOP99kYBCINSAyN_rbxNRbwsNA/-z_1fMgaUQCOj4Hhp9UIsP-PvocZtoWiwVVswWBOARM'), ('filename', '195.jpg'), ('size', 28452), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Mq_QoeiQ2GfUIRN-k5z0xQ/Sggzy9Kwcf5Vt9AKEXUyj-57O-Q0Za-6Zap6A7q283z3206Hw5AH_3f3nkGSJ07MJ-rgRR_CDqZsfpAbHeGRBg/RH1IDHPhls5AuekzVa0nSYa8YxeX78x5C6U5bO1Ivc8'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/InBx03c5mFHz_i9WV8oloQ/iQzvIw7gnDDmYJ1MZsdwIwgJbjaaeEiStcwoKaZ5ykIb2wk0wkbs0dWWlB4st6E7LXM_T9N-Zxs2DlQqf0uR-A/Mo6INnRNuyXVa14J97pAi9INGgGIv-N6dvn1GnNPjhQ'), ('width', 600), ('height', 373)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ld6XTNt9OK6phEI785vHYg/TdnsspxP8GwqwhjPBOH1zKiIBu7XQ-KTFpx26HxIlT9ax5rVdAlzsRGzUqEAmjxSim7dmiPponu20DxUAOQ2pg/wUoo3wImQerHjQNADSnj_J8_lJgGyS2V_nz7CfTQftQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/78005-3/Keithley-195A-Digital-Multimeter,['Multimeters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,http://chrisgrossman.com/manuals/keithley/KEITHLEY-195A-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",https://en.wikipedia.org/wiki/Multimeter,Write a Python script that uses Instrumentkit to connect to a {Device name} Multimeters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782580/Instruments/Multimeters/Keithley-195/Keithley-195.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
177,597.0,Thorlabs,APTPiezoInertiaActuator,Instrumentkit,"This four-channel controller features four SMC outputs to drive piezo inertia devices. The channels can be controlled independently or simultaneously in pairs using the dual-axis joystick on the controller's top panel. The controller can be configured to operate up to four PD series piezo inertia stages, up to four PIA series piezo inertia actuators, or up to two PIM series piezo inertia optic mounts; one KIM101 can only concurrently drive devices that use the same ""Select Stage"" configuration in the controller's menu options",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,KIM101,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbsvzZjoAEczQzfhk8a8OQ/Bi8Jy3DKpej5eIPyk6zdjzMI1UJbZeG4-atj6dM3i-WObDjqqhbvmNOwXKsV3jssJ7rbFqhCriXvi7aDsytzZ6N--UCbAjif4fPJXZ7UIu8/couTzDEDqzeSKnqC6v3OeHteD9sk4tUdzOneHVO4pwQ'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uXrOd3j--NAa6Xe3ucz9iA/6ulcj5KiUvxKN5pKPHh0MhtOtKxg3wUD-JzDdapPpvn7UpOLLjj_NsUu_3fcb6Ou0tm69V8qgdIC_PrRavHuwA/y_MSsN6VkrTIz5L86b0_J8pefc_9fCaFFkmzqdtsZy8'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rU9TobmYxVc8X8OGs6W6lg/b1-3JmEt9umAwIPy0ZMMeDe6m1BGGIbb3Gbag1M8DAueHIyU207HJ8RrwISwI_S2LD3z1yQSGKJqmCYWNZOAMg/8FkDd-NTtnrc98f6tPWI-_vmxkujodROsjGhO6vMH8E'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QOQvpP9UDoToi3NZueQE-w/vM2NoWOJjRG8r0e3OeZgkX25bpv80zSfeGD2Oj9DaF2OQldNEMOtiJBGPfezwTrS3zvJwg_jkVFnQeSSMx963A/78bR-pBpX_8KHy12bPjV9ieYTc6yV4KY-nYhV4Y-fT4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,['Positional Controller'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ETN040053-D02.pdf&partNumber=KIM101,USA,550.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a KIM101 Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782580/Instruments/Positional%20Controller/KIM101/KIM101.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,1183.98,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
187,400.0,Oxford Instruments,Oxford itc 503,Instrumentkit,"Oxford Intelligent Temperature Controller ITC 502. Oxford Instruments ITC502 Intelligent Temperature Controller (Model 611-968) is a three term controller. It has the capability of monitoring up to three thermometers at the same time, and supplying heat to control the temperature of one part of the cryostat. The sensor interface can be configured to suit a wide range of thermometers (typically within the temperature range of 0.25 to 500 K).",https://instrumentkit.readthedocs.io/en/latest/apiref/oxford.html#oxforditc503-temperature-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/oxford/oxforditc503.py,ITC 503,"[OrderedDict([('id', 'attrty3FFFzJUtuMr'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uVV4PIb2VUtcSJ-TLP_D3w/R5kacMP4tN9UHGcTr4TZjpJYTFypnhdKMqRIwvBAkqTTI47dN6NpF_T8OWOUCs6zpO61N76nKSkkVrmugYFkdmuXttCXLH5wtmtsoS6USAc/lq0VAbSpcSPihk1OZQIUiozvJv5LbExo6zvAQTyYpyQ'), ('filename', 's-l1600.jpg'), ('size', 266225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6z_OQIXpIMTL9HEk-BvdLg/cnAoXGHcCcu5ZnqfuH93cCKZL_ZHj95XtyiuVfVKO2r-aaRAXt6_mCAxf0oA0Owwep8vwADkdTHgtmLEebhO2A/EyzYiCyID60OJo2xdMJBQp0jSoja4KLQNKK64frMq00'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VJB8QknpEMjXdPnjwxPo4w/EwGQbnpsCThwFqp9jq3bFAMhbeoD_mcAdo9ogKJhGR7MzqLjjeoZqaMuJy35Ar8EtirWawKHVv_UHlW6wCH5Bw/keyJBgy2KauUNkNTyjADyqNvLLCb0PfZCdBorzJ_TnU'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/o0d-bFaL2kPgZpLeOxCOLw/zkz-S7s33CWskalaROdwhhNCsXqsjvciNL6GWvwkRRdjexzxKLSol3SGBM71R2JbdYr0Ssceq98Ef6Q5BOef7w/06BwLTespIiP_NlZUUMXz0f_2mbXWdSuhkIAuzSskC0'), ('width', 3000), ('height', 3000)]))]))])]",https://picclick.com/Oxford-Intelligent-Temperature-Controller-ITC-502-132299188022.html,['Temperature Controllers'],"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ge6UBa_PxVIRzTWaSDRhWw/z1nIIHpByPxcMFrxqz4wGua6L37TPuzjwuecyLHCFzr-uz84QG2przENPF1hXhY8XoqufraDY0oOQ6SMKew6m8dr0TjAnZhETraeiUtpcEI/9z2Sye-RWq0CT52RGvMeiR8CoeXPWB3yYto48j5ieq8'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/huAYtj4AqjzWQwtFbrocBw/ObKFsL5lrDEKZIzYosPMMAHykYqLRJhZzGmq81EktzRrWlN1S0qoVcGN10kXdT_Lcl-YwpqbQ2uXXTE58cUAzQ/sS56sfdd-S0WOj9HXdamH5KqMh4t3BlzRGkZDN_4h8I'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3otB5nYeU1qyF_laf_uciQ/En9x8ndMr6huc_UqR3iTmKE7EyJOmI-pqJKGxD_1iQvmC27k0lNw207b0eeZSFnZxVvJgXyx4wB4_l_J2ViTZw/kpdiY6dHLy4RY1bNMbPeMG-6iXXcT4BwYVW_BNY0ze0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bAQ9fOdp4fpHrIZL81i94w/dMc4vF9YSwqzuMc-sTB3iNls2t10Mo2tTfN1WMu9NQVaU_lvrq0ZLAhHh3WITeRd-flcjLvDijuR9i3SR8DqpA/GATYdc8TgmKLFz9DOI7DBZrtskXNPyb33IysjQXKBrg'), ('width', 3000), ('height', 3000)]))]))])]","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://www.oxinst.com/,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ITC503.pdf,"Abingdon, United Kingdom",367.3,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Instrumentkit to connect to a ITC 503 Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782452/Instruments/Temperature%20Controllers/ITC-503/ITC-503.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116704/Instruments/Vendor%20Logos/Oxford_Instruments.png,2150.0,,,,"

Source code for instruments.oxford.oxforditc503
#!/usr/bin/env python
""""""
Provides support for the Oxford ITC 503 temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class OxfordITC503(Instrument):

    """"""
    The Oxford ITC503 is a multi-sensor temperature controller.

    Example usage::

    >>> import instruments as ik
    >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(itc.sensor[0].temperature)
    >>> print(itc.sensor[1].temperature)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.sendcmd(""C3"")  # Enable remote commands

    # INNER CLASSES #

    class Sensor:

        """"""
        Class representing a probe sensor on the Oxford ITC 503.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `OxfordITC503` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES #

        @property
        def temperature(self):
            """"""
            Read the temperature of the attached probe to the specified channel.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = float(self._parent.query(f""R{self._idx}"")[1:])
            return u.Quantity(value, u.kelvin)

    # PROPERTIES #

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
        >>> print(itc.sensor[0].temperature)

        :type: `OxfordITC503.Sensor`
        """"""
        return ProxyList(self, OxfordITC503.Sensor, range(3))


"
193,146.0,HCP,TC-038D,Instrumentkit,"Temperature controller, TC-038D, goes along with different ovens (OV-30D, OV-50D, WG OVENs) with extreme temperature tunability up to 200 deg
",https://instrumentkit.readthedocs.io/en/latest/apiref/hcp.html#tc038d-crystal-oven-dc,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hcp/tc038d.py,TC-038D,"[OrderedDict([('id', 'attrSHmyzn2qlEPy2'), ('width', 1200), ('height', 564), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7kroC5hIMbpiWCkkB6yBkQ/LaGU24Cn9ISWBVxH0zRv8WvQUAAQH30GQlaRJ98S3_kvOIfqx0j9mdmSSFydnvKqL35fMie_dULJP-yzJ2YNxl-q3kSL5Qq1Zw32rMolWxA/kVsCA5xFlkzC-6YxT9xdwRvw5sll3Qaz5Ngx0ktrt2c'), ('filename', 'TC038D.webp'), ('size', 40894), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z4odikVOKQMcVAdC49fZng/AHMdZdSyZbw4pduKabc2RybnjctvaexAyH4siMYS6rY5kCJ6mIfVBLGoIyudL4AdehM6YkAqQZWibwGanAh6qY1eYGeAnWVVGC-UIo3RSEw/aATm-JGn-HhmeFsLAJb18AXIA2x0VK2oO8qUcW4gBak'), ('width', 77), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N1zgOkN209Fx4SU4Sj_xJA/-Mii_PE_JZKR2R-E56B16kjqC5lDVRLu7K5NnPrgU2D_pr8xWIh5pTD5djptjt7vKKeTu34W4F3jwm4XzPlEfUSnwj2xiIsOMlqbjx345wc/7Jru2rhXLUBpbNb_B5dFuiU3ZW_pQrCvf670DuffS4g'), ('width', 1089), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9cs7-Xp9yMVv_PkjpfthUQ/Vi4QAM-fr1uE5OclvtO1p-SZ5acxyOdjO5YEj0EGe0RxW-vASMQUigdLNK5k-7nJXFN-nUQk1-EMlxh5OZbyWBqRjT_7CqmGBUw5QM3ZkEU/Tl46rwARWgORQtQZX1JnqyCH3Ehj2CK3t9pybtQ8wm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.hcphotonics.com/accessories,['Temperature Controllers'],"[OrderedDict([('id', 'att0HIJANIUaKbEnj'), ('width', 969), ('height', 327), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pVdHzKHVST3cA-5uIhkuhg/v4lcqa4XSE6y95zQyTekMun8Ko8-Xgcgz2-8YIZTWTxAqkF2dwZa_WLGc26__ELc0fCemoLxWbAfZlPAJZFyuO3OjbHBudM-hjvCQiC9A9NtSW4gdyadfhdLxcm6g8cG/mwJsx1H6ssur5REM9lZo7M2vopCU2efCS4_7KsW-GXI'), ('filename', '88959ca5c0458434_HCP Logo_web 1.jpg'), ('size', 71666), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DIPFVo2rsac3u8544BO3Tg/rUODiDHlKhvsnId6q1i6ntlebFtKyGCo8MX-CMvvjJUKY5qO9LUQ2MJdSaLR0UJ-9b47gN10AV0Pwn-p9RcRAQ/T5Qm2CmSCFv3-2UjaNQr23Aj9ryzYxATyazdsnyUfyw'), ('width', 107), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FB5QQ6euedWEWaP0CfmfJQ/4lqFRiHWnfCO6nlwAiEuiPozTa4BNd-R5aHxYcb7LskfF_7dijLmDBoyF-ft5tDvZFfh_k3na7x25Jr7lZSN0w/-h_aHSExGhYt2n4L6ncwtfhI2ILOsKW_ZGMxuN68THA'), ('width', 969), ('height', 327)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/AF1Z7_p58fnBGnrN4-iP5A/WKt6a6ej7A4Rn2blQC0N-gqKCpLjyLxdTZIuj1vIag5CTOfzBmpu80HsFNi8CRSpJCDh9FQz9gCcNFJ6pgXK7Q/zHfp-8PyKyeSEsFQJLFDqMHBhXT_1BCuLFy5VkVsMB8'), ('width', 3000), ('height', 3000)]))]))])]","**HC Photonics** (HCP) provides crystal ovens and controllers to well manage the temperature of nonlinear crystals, especially PPLN and PPLT. 
",https://www.hcphotonics.com,https://drive.google.com/file/d/1dvlmTTycCDXEis8rC74uM3bgh-szW-_n/view?usp=sharing,Taiwan,7.0,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Instrumentkit to connect to a TC-038D Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782598/Instruments/Temperature%20Controllers/TC-038D/TC-038D.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116723/Instruments/Vendor%20Logos/HCP.png,,,,Nothing on Github Yet,"

Source code for instruments.hcp.tc038
#!/usr/bin/env python
""""""
Provides support for the TC038 AC crystal oven by HC Photonics.
""""""


# IMPORTS #####################################################################


from instruments.units import ureg as u

from instruments.abstract_instruments.instrument import Instrument
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class TC038(Instrument):
    """"""
    Communication with the HCP TC038 oven.

    This is the older version with an AC power supply and AC heater.

    It has parity or framing errors from time to time. Handle them in your
    application.
    """"""

    _registers = {
        ""temperature"": ""D0002"",
        ""setpoint"": ""D0120"",
    }

    def __init__(self, *args, **kwargs):
        """"""
        Initialize the TC038 is a crystal oven.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.hcp.TC038.open_serial('COM10')
        >>> inst.setpoint = 45.3
        >>> print(inst.temperature)
        """"""
        super().__init__(*args, **kwargs)
        self.terminator = ""\r""
        self.addr = 1
        self._monitored_quantity = None
        self._file.parity = ""E""  # serial.PARITY_EVEN

    def sendcmd(self, command):
        """"""
        Send ""command"" to the oven with ""commandData"".

        Parameters
        ----------
        command : string, optional
            Command to be sent. Three chars indicating the type, and data for
            the command, if necessary.
        """"""
        # 010 is CPU (01) and time to wait (0), which are fix
        super().sendcmd(chr(2) + f""{self.addr:02}"" + ""010"" + command + chr(3))

    def query(self, command):
        """"""
        Send a command to the oven and read its response.

        Parameters
        ----------
        command : string, optional
            Command to be sent. Three chars indicating the type, and data for
            the command, if necessary.

        Returns
        -------
        string
            response of the system.
        """"""
        return super().query(chr(2) + f""{self.addr:02}"" + ""010"" + command + chr(3))

    @property
    def monitored_quantity(self):
        """"""The monitored quantity.""""""
        return self._monitored_quantity

    @monitored_quantity.setter
    def monitored_quantity(self, quantity=""temperature""):
        """"""
        Configure the oven to monitor a certain `quantity`.

        `quantity` may be any key of `_registers`. Default is the current
        temperature in °C.
        """"""
        assert quantity in self._registers.keys(), f""Quantity {quantity} is unknown.""
        # WRS in order to setup to monitor a word
        # monitor 1 to 16 words
        # monitor the word in the given register
        # Additional registers are added with a separating space or comma.
        self.query(command=""WRS"" + ""01"" + self._registers[quantity])
        self._monitored_quantity = quantity

    @property
    def setpoint(self):
        """"""Read and return the current setpoint in °C.""""""
        got = self.query(command=""WRD"" + ""D0120"" + "",01"")
        # WRD: read words
        # start with register D0003
        # read a single word, separated by space or comma
        return self._data_to_temp(got)

    @setpoint.setter
    def setpoint(self, value):
        """"""Set the setpoint to a temperature in °C.""""""
        number = assume_units(value, u.degC).to(u.degC).magnitude
        commandData = f""D0120,01,{int(round(number * 10)):04X}""
        # Temperature without decimal sign in hex representation
        got = self.query(command=""WWR"" + commandData)
        assert got[5:7] == ""OK"", ""A communication error occurred.""

    @property
    def temperature(self):
        """"""Read and return the current temperature in °C.""""""
        got = self.query(command=""WRD"" + ""D0002"" + "",01"")
        return self._data_to_temp(got)

    @property
    def monitored_value(self):
        """"""
        Read and return the monitored value.

        Per default it's the current temperature in °C.
        """"""
        # returns the monitored words
        got = self.query(command=""WRM"")
        return self._data_to_temp(got)

    @property
    def information(self):
        """"""Read the device information.""""""
        return self.query(""INF6"")[7:-1]

    @staticmethod
    def _data_to_temp(data):
        """"""Convert the returned hex value ""data"" to a temperature in °C.""""""
        return u.Quantity(int(data[7:11], 16) / 10, u.degC)
        # get the hex number, convert to int and shift the decimal sign


"
196,546.0,Tektronix,Tektds 5 XX,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/intro.html,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tektds5xx.html,TDS5XX,"[OrderedDict([('id', 'attH1B9TOst5XXL94'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6opn0xMqFKh6j081GFgTxQ/Z5qSvwLi-VR9IXlr3u3xC-kHzHJObzASeNpUNIq22_75UaZjUe08M5ienRjpHR3iS6UVc0YuFwJg_GKcZ1siNRNRixLQf1_O5AcX4fEe8j4/wfhhlQJEmDF1UBEWh5SaGI42ZU6SqB0R7XsbZO5exOg'), ('filename', 'tds500.jpeg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8PxoQyzZAJIOYy0ESXGv7Q/YycBQGao2y88_Wh4WmkKNCetRmvkNeBIfrcLgh0i1kuGfsHtZ7_doX80fOKdISwmm6DN4YQN-Nrc5zupXOh1rw/VcDfX1mLe2_6CiJeIqK5Y5SwTTMLiG_SKio81-TF7J4'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/v6bJCuF-ljHM9xCp91QwZw/XsBBYhRiqY1YcILdD2hkMQmepvxuW9a8peaw4laQh-BZKi_f6-gw9RHFq0rpn-OqpxGHFTtGFyFc9Zy023kz3w/_ZjMY02cmXgHWPXTAP9qHGZ6UK2wEUF7xZsPJUyt6G8'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YSY3FkGYcF-PThUf6Cf_-A/wInTwSHYZLf1vTgw8mDKX_i91WEVhK-7tk6lNEgMwvA7jzTpDudX-6Kz3YT9neVXEdT3AfIwTIja3Sn1V57zrA/n5CICqMpcoB_LbmB8_FWoK9_vbbA5BaW9HpGFilvlus'), ('width', 3000), ('height', 3000)]))]))])]",,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS5XX Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782600/Instruments/Oscilloscopes/TDS5XX/TDS5XX.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,,,
197,584.0,Teledyne,Maui,Instrumentkit,"The WaveSurfer 3000z has a 10.1"" capacitive touch display, the longest memory, and the deepest toolbox – all at an affordable price.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveSurfer 3000z,"[OrderedDict([('id', 'attVTXwZRFz6jxMyZ'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6zXcsgTC0WjQSIX7BIrMKg/gFIShv1ncGSHB75h8Eza9sBq3rjMZtv3lTO60wSENoCcM4m6JJDHkaOxhgiH6AU1LLKFrQ2U0KdE8Ij5JeC8IcMQqiiLyVlTAzb6-kU-e-E/shT5lT-5GeD0yVY41TI4LCYvgDOcwhHal_m0jBgd4s0'), ('filename', 'WAVESURFER-3014Z_DSL.jpg'), ('size', 31613), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-B7DsCNpCJJTkZ2_3qK2pg/0HcMFgm58YHVto9WU5liIk5QNvLc82ONJasNpQHC83fyw02CwLF2b81fHSKsvkn-N-_RWTs6e9Bas_aMcOQoXA/z-P2ozuD-vuppCA66TDPIK1wF92JLglpD8NW4hlsl1g'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9bRLn8ULxDXUqzwEJ0Ecw/pYDrlWJSfVQG19jMaLHVyQArUPK616bxp7sr-1Ip_l2IoRQvbNB0BnYnWopyHwyemt7pdR8HxDV8tWKFEiZiqw/BvBj7v3uFiJha77OfepgrcpvAWCc7BIW15ADOI-_gWE'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-0OjJpHVuYRZf3w6HMQP9Q/H1gY48XTzuJQDOgfYR92WPVXIgc2lGTG4RXCcZL9jKislau7H_7nD7qybnA0cMqVJqHr3rp9_QLnfZqUhOUCXw/VJeHgIZT6qAI6ldhMHVYVQ7QSoRfmKDPZVtlmMycxPQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavesurfer-3000z-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-3000z-oscilloscope-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 3000z Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782601/Instruments/Oscilloscopes/WaveSurfer-3000z/WaveSurfer-3000z.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,5780.0,,,Price from this website: https://www.globaltestsupply.com/online/teledyne-lecroy-wavesurfer-3000z-oscilloscopes,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
201,584.0,Teledyne,Maui,Instrumentkit,"WaveSurfer 4000HD extends Teledyne LeCroy’s leadership in High Definition Oscilloscopes with a bright, 12.1” touch screen display, performance without compromise, and price points that fit your budget.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveSurfer 4000HD,"[OrderedDict([('id', 'attSL7iJBGpDPbEEX'), ('width', 740), ('height', 667), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OFi6ozAeyJDR1As1JePn9w/I_8ldQSzmMhLw73RXWTPQv6qDrhvyt_Dw-f6yTNmYRC0dBqondUJ3S2YcXGlGe8SC2li-he_K0W9sSK8ef-0rmVebPp_Fi4LNxSqK2SdxFg/nlp6RdIGWC1gzM22nd1jK9qv2vK9TbrOqiT7fNT9kck'), ('filename', 'ws4000hd-img-1.2.webp'), ('size', 68826), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uDK_pkCGcYuHMfsX9l9CeA/NHJ35TBF15v8wJ4mszl-NNZCFsZ6Ii3hmV0sJ_e17GBCHuIl2Y8-dAgXq3cSHEOnu2nieXB4XeHGd8XgvuCEaHoOVT1TpLk9RQy8oabOClc/2_qCiKKwZ3DrPL6LoWcl_njVAuSYWQ1JGzHNRRduUGg'), ('width', 40), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hwINCZSBWRPznEQjmhjGyA/_pfJEDgLUHc-XcwBJTY7HGWR9QrYlNDmxFANyeeuRgSXz9pF2uDg81wK0JEdYoKVC_tmRNcKxrZADCalh-qLfV3KszfZoUQ7wi4kcZ-pNeI/u_njvLkqkZnkEL1Yx9Vo5WJHLpyTZxthGIb6dzDddyQ'), ('width', 568), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UsRJ9p2uk1Bcr8-8UkdXkg/TkjwprVsQfxqmNt7x-PE-TJJ5RyTXloR9Pwlbs0-Cb1ICB8IelddRLuFGdYH06CF_Qgz0-cmiuH483wYlO53_qVO8cDYzUt44Fks5F8pMY8/CTIaVS5ZVHc2u-P6OQQrGB04B_J7or2QMv4VZe1qWKs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavesurfer-4000hd-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-4000hd-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 4000HD Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782604/Instruments/Oscilloscopes/WaveSurfer-4000HD/WaveSurfer-4000HD.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,8850.0,,,price from here: https://www.globaltestsupply.com/,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
224,141.0,Glassman,"XP GlassMan FJ

",Instrumentkit,FJ Series - 120W regulated high voltage AC-DC power supplies with outputs from 0 - 1kVDC to 0 - 60kVDC,https://instrumentkit.readthedocs.io/en/latest/apiref/glassman.html#glassmanfr-single-output-power-supply,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/glassman/glassmanfr.py,FJ Series,"[OrderedDict([('id', 'attkmac7fxPBBo0P7'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dCIGsN5yEBm5W--7LFVlAA/7iBfFH217IkqI1LOO2fOAyBkq4Wd-C2_yydI_UrLqIltQ_iNsji-OTIoxBWb3SKLFovn9OzTWSeyGF3MXcQmxX67Rqo3bzngjqw4GCq8EoQ/hophSgLNX69myUF8hL4XdacdVHfAFBvMHdGQ8HXoOkA'), ('filename', 'FJ_prod_lrg.webp'), ('size', 34698), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gfiCrKvhzqHbQuPi37EI6w/BhT0kCHNruKRttXE_UhP37fsbX_yA1sba4ImtOieYjD0JPE_N4KeaB-yJbTUHjqRmzj6W8FiVk7fU7-lfLy-ScoOoggOugKQZTZK7uzMKKE/BMB-P-PgZoYaDiNhOM98ckKQzPfGcuvCLNW2eDgMLhU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZKMhFjs4x9LNdtgc8q403w/DQrqSZdA1XuQE-18eaB2inxOQVj6fVsY0S-HFvnC-T7uIzPqBv4OoIZOWc3jENFoZBf9aMnH884O0jxhebCFIroIVLLtnScapwgLea1OVCs/KJPvRvmvvvo6jLx3Oo0W9-g8CQcmJq0dmAR90Rkq-rk'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZcWPewF-v7tVCy205VlEWA/GY18F1QGpInpC7PNr_7MXGRB-SXFhddbdIsa7i4YZMxAfAv-lL-dwpjITRTw7ynxGNY7FDNaXjINFda55QLBnIEYA8VcbogjdplqRFHPmsc/Jg07FQw6JU2iQCpKxCgkNJf-jfx-RphiGBbJFvtB6Uo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.xppower.com/product/FJ-Series,['Power Supplies'],"[OrderedDict([('id', 'attQ9jak9WrU3JbmU'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/trfSzDWbesu8Cz_Ya97YrQ/W8bpBbW6EDqGDpggGmISjZIQKY33x01IqxXj7Wpg1fSavvuqcnVW_PNoOPzpmhL2Lz9pJ8zOrGLqvmai1hN6AHTJm2ZHW-3ckYKiWS6Amw4/L1_X_LoUAZKubeYfS8S0G05-X7sHoSDMlA8nJxCbF9s'), ('filename', 'XP_Power.png'), ('size', 5633), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VA5nZ3fuQDWofXGBKBAwMg/wO183QzYJa7Ke2Og4yR1K-1gahD5SrayRsVnKCeRvf-7baYD5_Kerp20eC1PGnyhLksjqvZWstMtSIUE4dqrMQ/9DdxCPxYFip2JcNDliNEmxI3NZOPQ-X3saaDvJJ4tP0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XNV_Z3aJg4a0bB93JVDTGA/zlA34odnUWPBIEwHW93xe9vEZ8HLZjUO5wzA0bKdfx9jRg1xWobbBgFvyBO9-dQVVFKFAgAvytJ39y7C1SAbhA/1STyHittGGgC6aO4CiD_J7QpaPqro0u2sezSudsSPnE'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Eiuoi8_w6Fi-QpLSWENJYg/48IcjFwzrDHdFavFhGoIZDRkc5K4MjGtohA8yfNu4FY7-Tb7Vedl-EQx4-IdnO_ZHYqNfuai-BbnDk1OpeJs0A/wH0GF4JCX5uFtpcnrOfXbPiOgYXkvWASQyNAz52eRA0'), ('width', 3000), ('height', 3000)]))]))])]","Looking for the leading manufacturer of AC-DC **power** supplies, DC-DC converters, high voltage, RF & custom **power** products? Discover our extensive range.

",https://www.xppower.com,https://www.xppower.com/portals/0/pdfs/SF_FJ.pdf,Singapore,295.0,A power supply is an electrical device that supplies electric power to an electrical load.,https://en.wikipedia.org/wiki/Power_supply,Write a Python script that uses Instrumentkit to connect to a FJ Series Power Supplies,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782626/Instruments/Power%20Supplies/FJ-Series/FJ-Series.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116713/Instruments/Vendor%20Logos/Glassman.png,,,,Python Package for a Series of Products,"

Source code for instruments.glassman.glassmanfr
#!/usr/bin/env python
#
# hpe3631a.py: Driver for the Glassman FR Series Power Supplies
#
# © 2019 Francois Drielsma (francois.drielsma@gmail.com).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the Glassman FR Series Power Supplies

Originally contributed and copyright held by Francois Drielsma
(francois.drielsma@gmail.com)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""
# IMPORTS #####################################################################

from struct import unpack
from enum import Enum

from instruments.abstract_instruments import PowerSupply
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class GlassmanFR(PowerSupply, PowerSupply.Channel):

    """"""
    The GlassmanFR is a single output power supply.

    Because it is a single channel output, this object inherits from both
    PowerSupply and PowerSupply.Channel.

    This class should work for any of the Glassman FR Series power supplies
    and is also likely to work for the EJ, ET, EY and FJ Series which seem
    to share their communication protocols. The code has only been tested
    by the author with an Glassman FR50R6 power supply.

    Before this power supply can be remotely operated, remote communication
    must be enabled and the HV must be on. Please refer to the manual.

    Example usage:

    >>> import instruments as ik
    >>> psu = ik.glassman.GlassmanFR.open_serial('/dev/ttyUSB0', 9600)
    >>> psu.voltage = 100 # Sets output voltage to 100V.
    >>> psu.voltage
    array(100.0) * V
    >>> psu.output = True # Turns on the power supply
    >>> psu.voltage_sense < 200 * u.volt
    True

    This code uses default values of `voltage_max`, `current_max` and
    `polarity` that are only valid of the FR50R6 in its positive setting.
    If your power supply differs, reset those values by calling:

    >>> import instruments.units as u
    >>> psu.voltage_max = 40.0 * u.kilovolt
    >>> psu.current_max = 7.5 * u.milliamp
    >>> psu.polarity = -1
    """"""

    def __init__(self, filelike):
        """"""
        Initialize the instrument, and set the properties needed for communication.
        """"""
        super().__init__(filelike)
        self.terminator = ""\r""
        self.voltage_max = 50.0 * u.kilovolt
        self.current_max = 6.0 * u.milliamp
        self.polarity = +1
        self._device_timeout = False
        self._voltage = 0.0 * u.volt
        self._current = 0.0 * u.amp

    # ENUMS ##

    class Mode(Enum):
        """"""
        Enum containing the possible modes of operations of the instrument
        """"""

        #: Constant voltage mode
        voltage = ""0""
        #: Constant current mode
        current = ""1""

    class ResponseCode(Enum):
        """"""
        Enum containing the possible reponse codes returned by the instrument.
        """"""

        #: A set command expects an acknowledge response (`A`)
        S = ""A""
        #: A query command expects a response packet (`R`)
        Q = ""R""
        #: A version query expects a different response packet (`B`)
        V = ""B""
        #: A configure command expects an acknowledge response (`A`)
        C = ""A""

    class ErrorCode(Enum):
        """"""
        Enum containing the possible error codes returned by the instrument.
        """"""

        #: Undefined command received (not S, Q, V or C)
        undefined_command = ""1""
        #: The checksum calculated by the instrument does not correspond to the one received
        checksum_error = ""2""
        #: The command was longer than expected
        extra_bytes = ""3""
        #: The digital control byte set was not one of HV On, HV Off or Power supply Reset
        illegal_control = ""4""
        #: A send command was sent without a reset byte while the power supply is faulted
        illegal_while_fault = ""5""
        #: Command valid, error while executing it
        processing_error = ""6""

    # PROPERTIES ##

    @property
    def channel(self):
        """"""
        Return the channel (which in this case is the entire instrument, since
        there is only 1 channel on the GlassmanFR.)

        :rtype: 'tuple' of length 1 containing a reference back to the parent
            GlassmanFR object.
        """"""
        return [self]

    @property
    def voltage(self):
        """"""
        Gets/sets the output voltage setting.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        return self.polarity * self._voltage

    @voltage.setter
    def voltage(self, newval):
        self.set_status(voltage=assume_units(newval, u.volt))

    @property
    def current(self):
        """"""
        Gets/sets the output current setting.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        return self.polarity * self._current

    @current.setter
    def current(self, newval):
        self.set_status(current=assume_units(newval, u.amp))

    @property
    def voltage_sense(self):
        """"""
        Gets the output voltage as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `~pint.Quantity`
        """"""
        return self.get_status()[""voltage""]

    @property
    def current_sense(self):
        """"""
        Gets/sets the output current as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `~pint.Quantity`
        """"""
        return self.get_status()[""current""]

    @property
    def mode(self):
        """"""
        Gets/sets the mode for the specified channel.

        The constant-voltage/constant-current modes of the power supply
        are selected automatically depending on the load (resistance)
        connected to the power supply. If the load greater than the set
        V/I is connected, a voltage V is applied and the current flowing
        is lower than I. If the load is smaller than V/I, the set current
        I acts as a current limiter and the voltage is lower than V.

        :type: `GlassmanFR.Mode`
        """"""
        return self.get_status()[""mode""]

    @property
    def output(self):
        """"""
        Gets/sets the output status.

        This is a toggle setting. True will turn on the instrument output
        while False will turn it off.

        :type: `bool`
        """"""
        return self.get_status()[""output""]

    @output.setter
    def output(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Output status mode must be a boolean."")
        self.set_status(output=newval)

    @property
    def fault(self):
        """"""
        Gets the output status.

        Returns True if the instrument has a fault.

        :type: `bool`
        """"""
        return self.get_status()[""fault""]

    @property
    def version(self):
        """"""
        The software revision level of the power supply's
        data intereface via the `V` command

        :rtype: `str`
        """"""
        return self.query(""V"")

    @property
    def device_timeout(self):
        """"""
        Gets/sets the timeout instrument side.

        This is a toggle setting. ON will set the timeout to 1.5
        seconds while OFF will disable it.

        :type: `bool`
        """"""
        return self._device_timeout

    @device_timeout.setter
    def device_timeout(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Device timeout mode must be a boolean."")
        self.query(f""C{int(not newval)}"")  # Device acknowledges
        self._device_timeout = newval

    # METHODS ##

    def sendcmd(self, cmd):
        """"""
        Overrides the default `setcmd` by padding the front of each
        command sent to the instrument with an SOH character and the
        back of it with a checksum.

        :param str cmd: The command message to send to the instrument
        """"""
        checksum = self._get_checksum(cmd)
        self._file.sendcmd(""\x01"" + cmd + checksum)  # Add SOH and checksum

    def query(self, cmd, size=-1):
        """"""
        Overrides the default `query` by padding the front of each
        command sent to the instrument with an SOH character and the
        back of it with a checksum.

        This implementation also automatically check that the checksum
        returned by the instrument is consistent with the message. If
        the message returned is an error, it parses it and raises.

        :param str cmd: The query message to send to the instrument
        :param int size: The number of bytes to read back from the instrument
            response.
        :return: The instrument response to the query
        :rtype: `str`
        """"""
        self.sendcmd(cmd)
        result = self._file.read(size)
        if result[0] != getattr(self.ResponseCode, cmd[0]).value and result[0] != ""E"":
            raise ValueError(f""Invalid response code: {result}"")
        if result[0] == ""A"":
            return ""Acknowledged""
        if not self._verify_checksum(result):
            raise ValueError(f""Invalid checksum: {result}"")
        if result[0] == ""E"":
            error_name = self.ErrorCode(result[1]).name
            raise ValueError(f""Instrument responded with error: {error_name}"")

        return result[1:-2]  # Remove SOH and checksum

    def reset(self):
        """"""
        Reset device to default status (HV Off, V=0.0, A=0.0)
        """"""
        self.set_status(reset=True)

    def set_status(self, voltage=None, current=None, output=None, reset=False):
        """"""
        Sets the requested variables on the instrument.

        This instrument can only set all of its variables simultaneously,
        if some of them are omitted in this function, they will simply be
        kept as what they were set to previously.
        """"""
        if reset:
            self._voltage = 0.0 * u.volt
            self._current = 0.0 * u.amp
            cmd = format(4, ""013d"")
        else:
            # The maximum value is encoded as the maximum of three hex characters (4095)
            cmd = """"
            value_max = int(0xFFF)

            # If the voltage is not specified, keep it as is
            voltage = (
                assume_units(voltage, u.volt) if voltage is not None else self.voltage
            )
            ratio = float(voltage.to(u.volt) / self.voltage_max.to(u.volt))
            voltage_int = int(round(value_max * ratio))
            self._voltage = self.voltage_max * float(voltage_int) / value_max
            assert 0.0 * u.volt <= self._voltage <= self.voltage_max
            cmd += format(voltage_int, ""03X"")

            # If the current is not specified, keep it as is
            current = (
                assume_units(current, u.amp) if current is not None else self.current
            )
            ratio = float(current.to(u.amp) / self.current_max.to(u.amp))
            current_int = int(round(value_max * ratio))
            self._current = self.current_max * float(current_int) / value_max
            assert 0.0 * u.amp <= self._current <= self.current_max
            cmd += format(current_int, ""03X"")

            # If the output status is not specified, keep it as is
            output = output if output is not None else self.output
            control = f""00{int(output)}{int(not output)}""
            cmd += format(int(control, 2), ""07X"")

        self.query(""S"" + cmd)  # Device acknowledges

    def get_status(self):
        """"""
        Gets and parses the response packet.

        Returns a `dict` with the following keys:
        ``{voltage,current,mode,fault,output}``

        :rtype: `dict`
        """"""
        return self._parse_response(self.query(""Q""))

    def _parse_response(self, response):
        """"""
        Parse the response packet returned by the power supply.

        Returns a `dict` with the following keys:
        ``{voltage,current,mode,fault,output}``

        :param response: Byte string to be unpacked and parsed
        :type: `str`

        :rtype: `dict`
        """"""
        (voltage, current, monitors) = unpack(""@3s3s3x1c2x"", bytes(response, ""utf-8""))

        try:
            voltage = self._parse_voltage(voltage)
            current = self._parse_current(current)
            mode, fault, output = self._parse_monitors(monitors)
        except:
            raise RuntimeError(""Cannot parse response "" ""packet: {}"".format(response))

        return {
            ""voltage"": voltage,
            ""current"": current,
            ""mode"": mode,
            ""fault"": fault,
            ""output"": output,
        }

    def _parse_voltage(self, word):
        """"""
        Converts the three-bytes voltage word returned in the
        response packet to a single voltage quantity.

        :param word: Byte string to be parsed
        :type: `bytes`

        :rtype: `~pint.Quantity`
        """"""
        value = int(word.decode(""utf-8""), 16)
        value_max = int(0x3FF)
        return self.polarity * self.voltage_max * float(value) / value_max

    def _parse_current(self, word):
        """"""
        Converts the three-bytes current word returned in the
        response packet to a single current quantity.

        :param word: Byte string to be parsed
        :type: `bytes`

        :rtype: `~pint.Quantity`
        """"""
        value = int(word.decode(""utf-8""), 16)
        value_max = int(0x3FF)
        return self.polarity * self.current_max * float(value) / value_max

    def _parse_monitors(self, word):
        """"""
        Converts the monitors byte returned in the response packet
        to a mode, a fault boolean and an output boolean.

        :param word: Byte to be parsed
        :type: `byte`

        :rtype: `str, bool, bool`
        """"""
        bits = format(int(word, 16), ""04b"")
        mode = self.Mode(bits[-1])
        fault = bits[-2] == ""1""
        output = bits[-3] == ""1""
        return mode, fault, output

    def _verify_checksum(self, word):
        """"""
        Calculates the modulo 256 checksum of a string of characters
        and compares it to the one returned by the instrument.

        Returns True if they agree, False otherwise.

        :param word: Byte string to be checked
        :type: `str`

        :rtype: `bool`
        """"""
        data = word[1:-2]
        inst_checksum = word[-2:]
        calc_checksum = self._get_checksum(data)
        return inst_checksum == calc_checksum

    @staticmethod
    def _get_checksum(data):
        """"""
        Calculates the modulo 256 checksum of a string of characters.
        This checksum, expressed in hexadecimal, is used in every
        communication of this instrument, as a sanity check.

        Returns a string corresponding to the hexademical value
        of the checksum, without the `0x` prefix.

        :param data: Byte string to be checksummed
        :type: `str`

        :rtype: `str`
        """"""
        chrs = list(data)
        total = 0
        for c in chrs:
            total += ord(c)

        return format(total % 256, ""02X"")


"
225,370.0,Minghe,MHS 5200 A,Instrumentkit,"MHS-5200A series instruments using large scale integrated circuits andhigh-speed FPGA MCU microprocessor, the internal circuit to take surface mounttechnology has greatly enhanced the instrument's noise immunity and service life.Display interface using LC1602 LCD display is divided into two lines, the top lineshows the current frequency, the following line displays additional parameters orfunction variable and flexible use of flip key setting, greatly enhances the operability.",https://instrumentkit.readthedocs.io/en/latest/apiref/minghe.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/minghe/mhs5200a.py,MHS 5200 A,"[OrderedDict([('id', 'atthHXPfbt5sZJn0O'), ('width', 560), ('height', 560), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ONGAdakSN7XVgaBj8TitMw/dNSi8naY1_4faKVRGU-HMQcQc8SzkbM37xb4AAaNq3FyCVG0Q_YxYrlcIO-cCuADXfWtMFdv1xxzzt1jKw1fwA/buRdZB46xClhZV1mtvINtNigihRl_nURMMZEzQ51YaU'), ('filename', 'raw.jpg'), ('size', 92012), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mySvpHp-vdr3J21ms2DQUA/21gjqU-aAodDMFr2jsbJs5cu80Ki5KHhOimuWYiIJ64_xLwyYSnIuU4wnLskPbyzTFk9ZGiCYMvQ5R7Rup3kRw/AQkyOr6qhlpoh37r6EiPFx7pml-keTexM_HyP31nlv4'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/W4cWsDO1uHVSwxBEKnp2qg/gF7Ja0sC37A2MTUGBcrUdQYdWPTBi54TxCkNaActBEpv18eGDH2tlMJdVba5twmguLGkIGfTqRTAvsJeT2TePw/HeykvnHi12qUJD6hcwscG9lrYngVM4n5hLYYhDCg368'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UlSSSlL5YLu9r4FrG8mT3g/wFJGinSyIrVcyMZ5e6ybO1uhR3KtgdOZa9zfnlcFEJrkBg4fgoVS_V8VQR38wJn756TgG3X4xuLejPxgO92cCg/E6s9-SxnJ3uYA1IXK5i-XisVf1pS5l-CpHsEXo0AofA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.manualslib.com/manual/1302069/Minghe-Instruments-Mhs-5200a-Series.html?page=3#manual,['Function Generators'],"[OrderedDict([('id', 'attJoEjL7HtaAtqwT'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cUe70I2qDhv4JpVAgQAQ_A/i5MqTmZ2U2Ul48_lwlIyFavJ9ZyKhU0GEXVJjYh07gsb1cRLQdr_q4xTY_SPAqltbLWEvDNu6AN22H83ThEh17dzKwZFbu0Dgsp_eQ5Wiss/v3ZRjMF9ptL7KBapOcMd7uIx76--lkPqfdswV9W3Rac'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pcPueLLSyUT8wL_7w6lkYQ/qbF6aKbS-p84_wsLQ2AWd_eauNUOA3nf2RpCPzMXUy-zqarzofryMgsrSsILAwxCkCltDtIXg3UA32NvEWfOZQ/KpW-F3BEjZj77bJ5LcUEmlOMmOPcDX-uNznSHvPGr-c'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2Qn7ZSDyQSiFdu5NjGVPEA/CU0HVOQJJMK_2-iI9E4KkKSEGuAM6amd10UbeqC1rvf3I95-zzay3AXk4-KPGgc6sd163mm9JW83xlwSSCaYXQ/2rMBiIN5nLVtvyOsrY7PVxW2jCfQXfNsrhFCVkNXxUY'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PiLF8T4zJWBSEzezSJ1Kqg/FPlfDUgHg-y1am-enIaP5LIxzlcPmWTI1cMbwCLqYqIV-BZan7AbeofTSeQZ0XlDhsJBUmSAlU3xftlSfL0KuA/OOM9HFrKHe7nCB8hH-Uw84RooMQS9UcC4a2nUOcXqxw'), ('width', 3000), ('height', 3000)]))]))])]","Could not find

",https://sigrok.org/wiki/MHINSTEK_MHS-5200A,,,,"A function generator is electronic test equipment that generates standard waveforms, such as sine, square, ramp, or sawtooth waves, to a device under test (DUT).",https://en.wikipedia.org/wiki/Function_generator#Function_generator,Write a Python script that uses Instrumentkit to connect to a {Device name} Function Generators,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782627/Instruments/Function%20Generators/MHS-5200-A/MHS-5200-A.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116714/Instruments/Vendor%20Logos/NoLogo.png,,,True,,"

Source code for instruments.minghe.mhs5200a
#!/usr/bin/env python
""""""
Provides the support for the MingHe low-cost function generator.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import FunctionGenerator
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units

# CLASSES #####################################################################


class MHS5200(FunctionGenerator):
    """"""
    The MHS5200 is a low-cost, 2 channel function generator.

    There is no user manual, but Al Williams has reverse-engineered the
    communications protocol:
    https://github.com/wd5gnr/mhs5200a/blob/master/MHS5200AProtocol.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._channel_count = 2
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if msg.find("":r"") == 0:
            return None
        # most commands res
        return ""ok""

    # INNER CLASSES #

    class Channel(FunctionGenerator.Channel):
        """"""
        Class representing a channel on the MHS52000.
        """"""

        # pylint: disable=protected-access

        __CHANNEL_NAMES = {1: ""1"", 2: ""2""}

        def __init__(self, mhs, idx):
            self._mhs = mhs
            super().__init__(parent=mhs, name=idx)
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        def _get_amplitude_(self):
            query = f"":r{self._chan}a""
            response = self._mhs.query(query)
            return float(response.replace(query, """")) / 100.0, self._mhs.VoltageMode.rms

        def _set_amplitude_(self, magnitude, units):
            if (
                units == self._mhs.VoltageMode.peak_to_peak
                or units == self._mhs.VoltageMode.rms
            ):
                magnitude = assume_units(magnitude, ""V"").to(u.V).magnitude
            elif units == self._mhs.VoltageMode.dBm:
                raise NotImplementedError(""Decibel units are not supported."")
            magnitude *= 100
            query = f"":s{self._chan}a{int(magnitude)}""
            self._mhs.sendcmd(query)

        @property
        def duty_cycle(self):
            """"""
            Gets/Sets the duty cycle of this channel.

            :units: A fraction
            :type: `float`
            """"""
            query = f"":r{self._chan}d""
            response = self._mhs.query(query)
            duty = float(response.replace(query, """")) / 10.0
            return duty

        @duty_cycle.setter
        def duty_cycle(self, new_val):
            query = f"":s{self._chan}d{int(100.0 * new_val)}""
            self._mhs.sendcmd(query)

        @property
        def enable(self):
            """"""
            Gets/Sets the enable state of this channel.

            :type: `bool`
            """"""
            query = f"":r{self._chan}b""
            return int(self._mhs.query(query).replace(query, """").replace(""\r"", """"))

        @enable.setter
        def enable(self, newval):
            query = f"":s{self._chan}b{int(newval)}""
            self._mhs.sendcmd(query)

        @property
        def frequency(self):
            """"""
            Gets/Sets the frequency of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units hertz.
            :type: `~pint.Quantity`
            """"""
            query = f"":r{self._chan}f""
            response = self._mhs.query(query)
            freq = float(response.replace(query, """")) * u.Hz
            return freq / 100.0

        @frequency.setter
        def frequency(self, new_val):
            new_val = assume_units(new_val, u.Hz).to(u.Hz).magnitude * 100.0
            query = f"":s{self._chan}f{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def offset(self):
            """"""
            Gets/Sets the offset of this channel.

            The fraction of the duty cycle to offset the function by.

            :type: `float`
            """"""
            # need to convert
            query = f"":r{self._chan}o""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) / 100.0 - 1.20

        @offset.setter
        def offset(self, new_val):
            new_val = int(new_val * 100) + 120
            query = f"":s{self._chan}o{new_val}""
            self._mhs.sendcmd(query)

        @property
        def phase(self):
            """"""
            Gets/Sets the phase of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of degrees.
            :type: `~pint.Quantity`
            """"""
            # need to convert
            query = f"":r{self._chan}p""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) * u.deg

        @phase.setter
        def phase(self, new_val):
            new_val = assume_units(new_val, u.deg).to(""deg"").magnitude
            query = f"":s{self._chan}p{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def function(self):
            """"""
            Gets/Sets the wave type of this channel.

            :type: `MHS5200.Function`
            """"""
            query = f"":r{self._chan}w""
            response = self._mhs.query(query).replace(query, """")
            return self._mhs.Function(int(response))

        @function.setter
        def function(self, new_val):
            query = f"":s{self._chan}w{self._mhs.Function(new_val).value}""
            self._mhs.sendcmd(query)

    class Function(Enum):
        """"""
        Enum containing valid wave modes for
        """"""

        sine = 0
        square = 1
        triangular = 2
        sawtooth_up = 3
        sawtooth_down = 4

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> import instruments as ik
        >>> mhs = ik.minghe.MHS5200.open_serial(vid=1027, pid=24577,
        baud=19200, timeout=1)
        >>> print(mhs.channel[0].frequency)

        :rtype: `list`[`MHS5200.Channel`]
        """"""
        return ProxyList(self, MHS5200.Channel, range(self._channel_count))

    @property
    def serial_number(self):
        """"""
        Get the serial number, as an int

        :rtype: int
        """"""
        query = "":r0c""
        response = self.query(query)
        response = response.replace(query, """").replace(""\r"", """")
        return response

    def _get_amplitude_(self):
        raise NotImplementedError()

    def _set_amplitude_(self, magnitude, units):
        raise NotImplementedError()


"
229,350.0,Lakeshore,Lakeshore 340,Instrumentkit,"The Model 340 cryogenic temperature controller is our most advanced temperature controller and offers unsurpassed resolution, accuracy, and stability for temperature measurement and control applications to as low as 100 mK. Operating with diodes, platinum RTDs, and negative temperature coefficient (NTC) resistor sensors, the Model 340 is expandable to ten sensor inputs or to operate with thermocouple or capacitance sensors. It has two control loops, with the first loop powered to 100 W.",https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore340-cryogenic-temperature-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore340.py,Lakeshore 340,"[OrderedDict([('id', 'atthNL1cSca5MCqeq'), ('width', 505), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/98GIFrDrb5SvmFrUr-GaeQ/1BWR0DD8F0He2VMF2F-Gq-NPT8y4gkwMuH6fXw5bGxXf1jwm_kOOE4uaSCltzkXGN0zxpDv9QENIppFpqXqBXg/2fGrd4vsXT66mfzj2KIT26qcOa62rB-16shh842a-V0'), ('filename', '340.png'), ('size', 89525), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gmnATaBN_kq2nlILaHmCxg/HwQdt-fmbD47TOvvT8PRORAxeMFbNOvCPscJABO_lwdGwsRozUc5qHsNtTcIuLjAN4d27eOtcelWkPeTJ4-kdw/QhBBNnENYZOd8_9egv4ZnpPu9nh-hEc5fuRcg1w2tzo'), ('width', 114), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bjw8bTz3befXDSwuuNdp0w/gLREWmnrvwZ8bp1kAlfUO0lwkyKxwM_yqatSnq1IRNOGuE0M1441NXpt1dTvkn7pUXOjr0VUk9C9oK3vQ4cL3Q/NH8NOa3-p_AHXavjKVnkUuhDa3dkuaFz-E2LE3V2qAU'), ('width', 505), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wS7x9aJcfpGEdoa4ks5wkQ/Kvl4aQikbhuittRH-P0Hxn6w-J0slZm9PYUSGcYvOWozdXsYHzIMKSSbfpMFg3K8ofbAzOMgxyL43pouBuLeyg/iJEAXSd9LWN-o1Ene7bmYT-2OS8ZAf9yaKpTwn8F858'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-340-cryogenic-temperature-controller,['Temperature Controllers'],"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://www.lakeshore.com/home,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_340_l.pdf?sfvrsn=ad773cdf_1,"Westerville, Ohio, USA",21.4,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Instrumentkit to connect to a {Device name} Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782630/Instruments/Temperature%20Controllers/Lakeshore-340/Lakeshore-340.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,,,True,,"

Source code for instruments.lakeshore.lakeshore340
#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))


"
230,584.0,Teledyne,Maui,Instrumentkit,"The Motor Drive Analyzer is built on an 8 channel, 12-bit resolution oscilloscope platform. It acquires any signal and performs three-phase electrical and mechanical power calculations. It provides complete power section and embedded control test coverage.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,MDA8000HD,"[OrderedDict([('id', 'att8urLApvEdo7Bqk'), ('width', 260), ('height', 263), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ijcs7e2bUvF7CI9UV40niw/A-H_yxTGnqvySKQfsgUncgtJnp0dWLAwsDucHeR0ZgxWejdr7C3O4s6FRtlGXGC04XUD2OBMG7HeNsNr3fWt9vs7y8PV36_91MDxZqg_ooc/7pIfy6hR_k_PDbpVP3CTL7sr9aE--wlL4OlcDitsO2w'), ('filename', 'mda8000hd-title.webp'), ('size', 25102), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8j_vKSuId-STLMm_0QWFKw/y6_vw7XMBuX_KHA-uz2KNWK0RlklQTjISutiY0z2Od5IDHWpSi1eus_iPjMQq5D3bqk-t_R5wIc6bH22E1mc9JesYfD4dXbF0sujhTr_pf4/6NPl1X856_t6DqdAkAyh9wb_3zWkz7N2fLk818qTlTE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/b2dfveMMrbGtufEftVvW8Q/HIc-sJAhf0YJhAM1Fw7m6OFfycbRL2oqedByDisD8QXoXeb3hrgv-BwxyaHqX4Wf3zGRjwBHKQ079fjuSt7-TMUomAfaVZx-ZJdZkUnuiYA/D4dvkNLv_UJqrp2LHtcbvr52zUbzlGc8KWuKVVwOeYE'), ('width', 260), ('height', 263)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2cMVnNws0LTxSKs-A_TZDg/9PLYuXSKz_MnMW2dWy54z-555DiKtYRo1xhpYZq470jHQfz1DM6VSqm-qSnXvFZDwxCcKHr_eK-EI2gv_pc8pacG5AysH7EZFg3ldAKqeb8/pIndwQfAETExr1Pam-p8736venALkZlYUGIOjtqQ8yI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/mda-8000hd-motor-drive-analyzers,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/mda8000hd-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a MDA8000HD Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782631/Instruments/Oscilloscopes/MDA8000HD/MDA8000HD.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
239,634.0,Yokogawa,Yokogawa 6370,Instrumentkit,The AQ6370 is Yokogawa's high speed and high performance Optical Spectrum Analyzer for characterization of optical communications system and optical components. Thirteen built-in optical viewer analysis functions and seven trace calculations for popular applications can be utilized with a simple function key. ,https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa6370,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa6370.py,AQ6370,"[OrderedDict([('id', 'atttq1VLeer6131dE'), ('width', 800), ('height', 467), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rUC8xqDYZX9N9zAnNul6iw/IyJ-68krt09zNA0uOICvznE4RhkPV6YnDSiKkHmUZAV8xGc2bsqtRxj4eF03GtR3qvSCQY1vDc5zugr1EjgOtRoMJJMcoEIMiHcH0blMX3s/yhebQgPRzlrtz0-2AFEbdQu-HdGoUYwOWXU7ga707Zo'), ('filename', 'AQ6370_Front_lg.jpg'), ('size', 262250), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HFcZCzSjgYeqTevkVEBMuw/bISkYQjZT5eqDutV1FiLuDX5IswZ_OmUNIhctrNlVC3YsU3Pa5D3TLyA0R20m5sUZg7UTw_KhfXVC5qZZM8DtA/iOsMQjSzLKn4Z-3E07oCswmFUPk_oJtERHMpSBCLCGo'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gMIbocQuKx1_2FYfwgOP4A/4PqkeW1SDkMhC4Yxf4QBNqFOm0ZuMpBp0_FawPGmF1hPFZ5bnh3AhUbNtDI1-hityeHLzLMOkJhEt9pkFrtWjQ/DwK_uf6lauDevGYe5nBqiss_oK1h7nD0YMm6weCkk8g'), ('width', 800), ('height', 467)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BsWIU2d2DzbMrm9RFI6IGw/50ATUCciluFAUFtoliIvL5kt4n1JTkX4pE60WjpjDVfVQ770oK9uzDAJ18wfUuDUc1AQsSQCkPW4UUtdBgF3qg/13Wg5MIQMqYPPqmKeE5CyPOywf5aDFrmR-ROoh9EBYM'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/discontinued/aq6370-optical-spectrum-analyzer/,['Spectrum Analyzers'],"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f7hYK50L2LFSnoG6b-tr_Q/PIUr0ysKwfdPoGdRfXB0_h09W8CmAgZMdtnCJA8oACp2MTavzvWTParMzhyBaXLJiz5MWCSGHrK48yk0-3bfUkIGkwJpKTgMFJl-ly-KdSs/005CXDzn6XFLXK7WJHb0bIHDl5oO0DB1Psmc7FeI52s'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hGhnjgmxNSTXxR7kAim1ww/RDzNoEC6FTtC3vztLVJZ89BVEbySAgthi0nJMoDuXoiPA7aSQ1BwyVF4KxdRVyBagIIEuVsDsLXMiBu6r3Uh1Q/cJfrr6UDIT1btUz5czUhSi9oYrVD5uY6Ds17A8WQ26I'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MWH_Mu8dBgIkoDhCCGXp8g/wBAiqUxh-OrvnTMRuOSgOj2_ZB8bIIvBTNIvkqZAlPLE919LoJ2grzsuGm-glI7KS2DdxaXXNwauPeW6l0ME-w/4iMOXEUzxB7fe914JbqzSV_4ze3fhXn_p7DcHRV8Ov0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9hlyfn9bpaqywUXQIW4RCg/yrzzUFNxV8JpxT7PmwgzAOC8hLbvYZaHUSWDHq2M1BJllptYkuzR1ZdKPdT7GAvsoFmjAKbF3YDr-rjYlPL8Dg/22UwYEpKEOninguLEKbx0zEgLRmTyLKraj9xhGrJifw'), ('width', 3000), ('height', 3000)]))]))])]","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://www.yokogawa.com/,https://cdn.tmi.yokogawa.com/IM735301-01E.pdf,Japan,318.0,A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals.,https://en.wikipedia.org/wiki/Spectrum_analyzer,Write a Python script that uses Instrumentkit to connect to a AQ6370 Spectrum Analyzers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782639/Instruments/Spectrum%20Analyzers/AQ6370/AQ6370.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116709/Instruments/Vendor%20Logos/Yokogawa.png,,,True,,"

Source code for instruments.yokogawa.yokogawa6370
#!/usr/bin/env python
""""""
Provides support for the Yokogawa 6370 optical spectrum analyzer.
""""""

# IMPORTS #####################################################################


from enum import IntEnum, Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import OpticalSpectrumAnalyzer
from instruments.abstract_instruments.comm import SocketCommunicator
from instruments.util_fns import (
    enum_property,
    unitful_property,
    unitless_property,
    bounded_unitful_property,
    ProxyList,
    string_property,
)


# CLASSES #####################################################################


class Yokogawa6370(OpticalSpectrumAnalyzer):

    """"""
    The Yokogawa 6370 is a optical spectrum analyzer.
    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa6370.open_visa('TCPIP0:192.168.0.35')
    >>> inst.start_wl = 1030e-9 * u.m
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if isinstance(self._file, SocketCommunicator):
            self.terminator = ""\r\n""  # TCP IP connection terminator

        # Set data Format to binary
        self.sendcmd("":FORMat:DATA REAL,64"")  # TODO: Find out where we want this

    # INNER CLASSES #

    class Channel(OpticalSpectrumAnalyzer.Channel):

        """"""
        Class representing the channels on the Yokogawa 6370.
        This class inherits from `OpticalSpectrumAnalyzer.Channel`.
        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa6370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._name = idx

        # METHODS #

        def _data(self, axis, limits=None, bin_format=True):
            """"""Get data of `axis`.

            :param axis: Axis to get the data of, ""X"" or ""Y""
            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            if limits is None:
                cmd = f"":TRAC:{axis}? {self._name}""
            elif isinstance(limits, (tuple, list)) and len(limits) == 2:
                cmd = f"":TRAC:{axis}? {self._name},{limits[0]+1},{limits[1]+1}""
            else:
                raise ValueError(""limits has to be a list or tuple with two members"")
            self._parent.sendcmd(cmd)
            data = self._parent.binblockread(data_width=8, fmt=""<d"")
            self._parent._file.read_raw(1)  # pylint: disable=protected-access
            return data

        def data(self, limits=None, bin_format=True):
            """"""
            Return the trace's level data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""Y"", limits=limits, bin_format=bin_format)

        def wavelength(self, limits=None, bin_format=True):
            """"""
            Return the trace's wavelength data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""X"", limits=limits, bin_format=bin_format)

    # ENUMS #

    class SweepModes(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 6370
        """"""

        SINGLE = 1
        REPEAT = 2
        AUTO = 3

    class Traces(Enum):
        """"""
        Enum containing valid Traces for the Yokogawa 6370
        """"""

        A = ""TRA""
        B = ""TRB""
        C = ""TRC""
        D = ""TRD""
        E = ""TRE""
        F = ""TRF""
        G = ""TRG""

    # PROPERTIES #

    # General

    id = string_property(
        ""*IDN"",
        doc=""""""
            Get the identification of the device.
            Output: 'Manufacturer,Product,SerialNumber,FirmwareVersion'
            Sample: 'YOKOGAWA,AQ6370D,90Y403996,02.08'
            """""",
        readonly=True,
    )

    status = unitless_property(
        ""*STB"",
        doc=""""""The status byte of the device.
        Bit 7: Summary bit of operation status
        Bit 5: Summary bit of standard event status register
        Bit 4: “1” if the output buffer contains data
        Bit 3: Summary bit of questionable status
        """""",
        readonly=True,
    )

    operation_event = unitless_property(
        "":status:operation:event"",
        doc=""""""
            All changes after the last readout. Readout clears the operation_event
            Bit 4: Autosweep
            Bit 3: Calibration/Alignment
            Bit 2: Copy/File
            Bit 1: Program
            Bit 0: Sweep finished.
        """""",
        readonly=True,
    )

    @property
    def channel(self):
        """"""
        Gets the specific channel object.
        This channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> osa = ik.yokogawa.Yokogawa6370.open_gpibusb('/dev/ttyUSB0')
        >>> dat = osa.channel[""A""].data # Gets the data of channel 0

        :rtype: `list`[`~Yokogawa6370.Channel`]
        """"""
        return ProxyList(self, Yokogawa6370.Channel, Yokogawa6370.Traces)

    # Sweep

    start_wl, start_wl_min, start_wl_max = bounded_unitful_property(
        "":SENS:WAV:STAR"",
        u.meter,
        doc=""""""
        The start wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    stop_wl, stop_wl_min, stop_wl_max = bounded_unitful_property(
        "":SENS:WAV:STOP"",
        u.meter,
        doc=""""""
        The stop wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    bandwidth = unitful_property(
        "":SENS:BAND:RES"",
        u.meter,
        doc=""""""
        The bandwidth in m.
        """""",
    )

    span = unitful_property(
        "":SENS:WAV:SPAN"",
        u.meter,
        doc=""""""
        A floating point property that controls the wavelength span in m.
        """""",
    )

    center_wl = unitful_property(
        "":SENS:WAV:CENT"",
        u.meter,
        doc=""""""
         A floating point property that controls the center wavelength m.
        """""",
    )

    points = unitless_property(
        "":SENS:SWE:POIN"",
        doc=""""""
        An integer property that controls the number of points in a trace.
        """""",
    )

    sweep_mode = enum_property(
        "":INIT:SMOD"",
        SweepModes,
        input_decoration=int,
        doc=""""""
        A property to control the Sweep Mode as one of Yokogawa6370.SweepMode.
        Effective only after a self.start_sweep()."""""",
    )

    # Analysis

    # Traces

    active_trace = enum_property(
        "":TRAC:ACTIVE"",
        Traces,
        doc=""""""
        The active trace of the OSA of enum Yokogawa6370.Traces. Determines the
        result of Yokogawa6370.data() and Yokogawa6370.wavelength()."""""",
    )

    # METHODS #

    def data(self, limits=None):
        """"""
        Function to query the active Trace data of the OSA.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].data(limits=limits)

    def wavelength(self, limits=None):
        """"""
        Query the wavelength axis of the active trace.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].wavelength(limits=limits)

    def analysis(self):
        """"""Get the analysis data.""""""
        return [float(x) for x in self.query("":CALC:DATA?"").split("","")]

    def start_sweep(self):
        """"""
        Triggering function for the Yokogawa 6370.
        After changing the sweep mode, the device needs to be triggered before
        it will update.
        """"""
        self.sendcmd(""*CLS;:init"")

    def abort(self):
        """"""Abort a running sweep or calibration etc.""""""
        self.sendcmd("":ABORT"")

    def clear(self):
        """"""Clear status registers.""""""
        self.sendcmd(""*CLS"")


"
245,493.0,SRS,SRS 345,Instrumentkit,"The DS345 Function Generator is a full-featured 30 MHz synthesized function generator that uses an innovative Direct Digital Synthesis (DDS) architecture. It generates many standard waveforms with excellent frequency resolution (1 µHz), and has versatile modulation capabilities including AM, FM, Burst, PM and frequency sweeps. It also generates arbitrary waveforms with a fast 40 Msample/s update rate.",https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs345-function-generator,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs345.py,DS345,"[OrderedDict([('id', 'attdOv77MX1TYKshq'), ('width', 2688), ('height', 1517), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Zv6WfufRXxSSVwK7oBfLDA/ohZXzeqIMtVMIdgKEqpQEFfXjJPcxf-G2D9lI1UhF4mUOjAyFu97WP1NPVOfwOvlKGSkpRVKLKeoAhsenqd59c0UFgAZbgoX9j-iT4mZOGA/kkBxGOR51iyCgr2uvedXfUL2h45AasA2-o2tlB-paQM'), ('filename', 'DS345_Main2.jpg'), ('size', 572471), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kLjhLDTg7wiTn3OEF5Lo-g/xYzpbEFlC49nQ1ZqnhYfbW4mxvcsJtrMwexVP4W--79bbMphtuhTSbOBDJJWafkr2qy2qdtzM9qbpL8ftTiwCQ/1ewVdSoIdb3vHzjv7GucchhHsyKdb943K-BixiB2nes'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-A5_wUMUxDIHk_bQ103-yg/5epmGvmsvYHN3sxPCLmIBwvk6jdjqyDbHgPmFAUTPSCk_HF1zgOLmzUI0C7os7z1R-eWaDx7N8Nlxhg18EQx6A/sRfYjiZ7hoJ9IYtBgok4kKDCdQtSJgnwDCkIJY_NKLI'), ('width', 907), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lHM7MvjTO_uAKVeqKAJovw/SNQG0PGaG_M6nn083LESVIcWajzV_NsABaZTi2Ik9dSX8VREF5rIUqmf4eW_JlQ41KMMAtRpzRw9vxb8an_7Aw/FrwAc90M8yq5kV4-bof56k7VQ81VmVCCsy-ciasLSHY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/DS345.htm,['Function Generators'],"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GEdN_BmXtwosiOLFEHJAgw/PannVp8q7hX-OINFNDMu04EiCrGfkEyf_a7am51WUxStJWJi6HBGfO5RdARQLDysZaCfCkkKXkVdnbBukXGTQxbMCK3zp-sXBXczPXScTp0/_OM_giJ55r-yDN3fv-xuCU3fuzytXkA-VelTj5P3j7o'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ktg3MJbM5fVSVdt3fMZrOQ/LnTb8WIGKn6y_2rylP2WzkQ5L3ZhqlQEjFezXnTPhyjYOl55KR733DJxZu8jSIOSHKhRwYfN1eTa4-Zpgi2KuQ/XMNQhs49wJC3pMlfni4bL2RzeB3pN0Wk_qmWOTM4Vok'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1GQ22ccu1nNLIdB_kUsgfA/S6JBQA_uRz1xktSChfAXHi9LBJkX2rNur5kgkZys5yQodnemo8ASB4BXFtvZ4ohvR7kt3ldfdyMU2Wxll8bkkQ/FAkTJm-bqxYi8JWUJUJLpHFt8sToHJTlydzPVyl4Kbg'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ecfa4InLTffUJ3uIvbLfSg/ku6PGtHKgjADwD6exgPngQF-R0vvCpdp2D6CYiddskBPk5658MnGv4KWNfiGmFd05lfyJB7xff2-qaCoMeLxFg/cjsWt7n5d1Mo-_pS1qdQpSz4ZodrswGC4enbHZNGmXw'), ('width', 3000), ('height', 3000)]))]))])]","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://www.thinksrs.com/index.html,https://www.thinksrs.com/downloads/pdfs/catalog/DS345c.pdf,"Sunnyvale, California",24.9,"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.",https://en.wikipedia.org/wiki/Function_generator,Write a Python script that uses Instrumentkit to connect to a DS345 Function Generators,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782645/Instruments/Function%20Generators/DS345/DS345.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,1595.0,,,,"

Source code for instruments.srs.srs345
#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )


"
248,584.0,Teledyne,Maui,Instrumentkit,"The LabMaster 10 Zi is the world's highest-performance modular oscilloscope - it breaks channel count barriers and provides more ""bandwidth density"". The modular design provides the simplest upgrade path in bandwidth and channel count, with one acquisition module providing four channels at 36 GHz or two channels at 65 GHz, with capability for up to 20 acquisition modules",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,LabMaster 10 Zi-A,"[OrderedDict([('id', 'attreLJUz1eRfLnKT'), ('width', 392), ('height', 301), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/85dZw8eo_smbthGn2Ty7EA/gVk-EOOJWUISLatA2jX5CJwoKBZleLUkhZIhDNUEXrcEb2qN1RyRfhJ7iKHWSbfMJPzB_Y6_LtuSmtF6Et1SQzdeefZmqzDDXYrPLzZrhQs/Cin2s1H8Qcjyl-trsdJ_RG176BceNzqZqpNbf3qpluk'), ('filename', 'cross-sync-p3.webp'), ('size', 19634), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FSCgqfsoz2AfC9j26X7KAA/5hcUe3jrzJTdwVOSviUJwp9ocdu8Zz_ah4CTki-SPTKRFjQIdB8EM_BgCJI0jtev4sNjSAexPlmynssr1fWOh7xRuXsBDIEVsj_usdUJ9mE/L03avVWh9yBc1DX1Xyck7STzBjGOGjY8unF5VwnTHS8'), ('width', 47), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VbbApwd-w0eiWfujsCli_A/2vfLuR1CMHt7HbhMYjjsoF1APZVj7eZKQk__fE4p2BIhoXpv1OWeF03tmJlbm9q6FjL7Ph9bo1S7aBdnqtv43fiJPe7lwS8bw1KUeWEjFzk/owXvf2EX7poaSZRWYsyCSQv4sQI2Zw0m3J3Ht7EYnGU'), ('width', 392), ('height', 301)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GJYqGviQE0DYgImGoao2_Q/gSZaL6ycO340pl_t9nAoVKlwSEY6zSoFaTO1FAkRw9E82dRCiRXzPm5stBcczyDNXLToyn6T84m-bA3gP9949Ff4FGKmAvRN7VOTYJSaqTo/TDl9LtGXv35zmGYCRKk7Oxo6YM4ePLMiRV3IqiB1UR8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/labmaster-10-zi-a-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/labmaster-10zi-a-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a LabMaster 10 Zi-A Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782647/Instruments/Oscilloscopes/LabMaster-10-Zi-A/LabMaster-10-Zi-A.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
258,598.0,Thorlabs,APTPiezoInertiaActuator,Instrumentkit,This single-channel piezo inertia controller provides a voltage output for a single piezo inertia stage or actuator. The top panel features a spring-loaded scroll wheel for driving the stage or actuator as well as selecting menu options.,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,KIM001,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbsvzZjoAEczQzfhk8a8OQ/Bi8Jy3DKpej5eIPyk6zdjzMI1UJbZeG4-atj6dM3i-WObDjqqhbvmNOwXKsV3jssJ7rbFqhCriXvi7aDsytzZ6N--UCbAjif4fPJXZ7UIu8/couTzDEDqzeSKnqC6v3OeHteD9sk4tUdzOneHVO4pwQ'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uXrOd3j--NAa6Xe3ucz9iA/6ulcj5KiUvxKN5pKPHh0MhtOtKxg3wUD-JzDdapPpvn7UpOLLjj_NsUu_3fcb6Ou0tm69V8qgdIC_PrRavHuwA/y_MSsN6VkrTIz5L86b0_J8pefc_9fCaFFkmzqdtsZy8'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rU9TobmYxVc8X8OGs6W6lg/b1-3JmEt9umAwIPy0ZMMeDe6m1BGGIbb3Gbag1M8DAueHIyU207HJ8RrwISwI_S2LD3z1yQSGKJqmCYWNZOAMg/8FkDd-NTtnrc98f6tPWI-_vmxkujodROsjGhO6vMH8E'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QOQvpP9UDoToi3NZueQE-w/vM2NoWOJjRG8r0e3OeZgkX25bpv80zSfeGD2Oj9DaF2OQldNEMOtiJBGPfezwTrS3zvJwg_jkVFnQeSSMx963A/78bR-pBpX_8KHy12bPjV9ieYTc6yV4KY-nYhV4Y-fT4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,['Positional Controller'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ETN051885-D02.pdf&partNumber=KIM001,USA,550.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a KIM001 Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782656/Instruments/Positional%20Controller/KIM001/KIM001.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,835.34,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
260,598.0,Thorlabs,TC 200,Instrumentkit,"The TC200 Temperature Controller is a bench top controller intended for use with resistive heating elements
rated up to 18 Watts. This general purpose instrument can drive various types of heaters, including foil and
resistive coil types. It accepts feedback from either positive or negative temperature coefficient thermistors, has
programmable P, I, and D gains, and will display the temperature in °C, °F, or K. In addition, it can be
programmed for up to five sequential temperature settings along with associated ramp and hold times for each
level. A user-programmable maximum temperature limit provides protection to the device being heated, and a
user-programmable power limit protects the heating element from being over driven. ",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#tc200-temperature-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/tc200.py,TC200,"[OrderedDict([('id', 'attcuzwqvuj6cXzvc'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZBOUgmgPho5RHv0fVZmfeA/Ts1FvUWp688bMyryeCo48gkQucdPcmmzkHpouRhQbGGks-OREY6KHzrwGN9r7H4d-dn3RZ6M3rn3ml8ebvT_LqRg3TNheYiYRZRFac_P0j8/DTPK9Jjnz3xfbrYtCF7RyjpLtvZWBeEbrKvKs1A4NpQ'), ('filename', '12597-xl.jpg'), ('size', 35659), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7b3Tfs8PlvH7AQGFvFq-aA/BDwvP63DZ8EXYrOmZNOjYy-CWG88YdKNT4h89ArZQxJwzjk4LoaZCy8Le7XCBmz4-aaNBykVw9RH3hYAyj223A/0Xvcb_fG6joG5QgCA-Qcj5Xcc6_6oRPbqE815Ww1Ypo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gVYKOqVJsr2JPRWNbdO8sQ/2ebTCj-PapP_U8GrWBY94mPHySANWHhmCcEo5bHxR3fUxN5bqOmhdsKldduCDdQSHhBzr_6iPthDJbKUF5cr4A/DPN1aZXiqc1uHw9un2gGlQfynjH3gECxL6y02MyEKwk'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2LdOR1fzXI2R7AZwGaF87w/-Y-Js0gwB_m5fnCI4zEalJ3Ky5LKUZhhkfqGJjKXP2oer7ECPPdqbb1m36HYIZRzqgxfjNdeEB7hvqKQYuVuRA/DI0-REsdPFcEodajVbh7aZzzkcau06LdafHWANuXt_w'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/thorproduct.cfm?partnumber=TC200,['Temperature Controllers'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=12597-D02.pdf&partNumber=TC200,USA,550.0,"As the name implies, a temperature controller is an instrument used to control temperatures, mainly without extensive operator involvement. A controller in a temperature control system will accept a temperature sensor such as a thermocouple or RTD as input and compare the actual temperature to the desired control temperature, or setpoint. It will then provide an output to a control element.

Digital temperature controllers are used in a variety of applications, ranging from industrial processes to consumer products. For example, industrial applications such as HVAC systems, food processing, and chemical processing often require precise temperature control in order to ensure quality and safety. On the other hand, consumer products such as refrigerators, air conditioners, and water heaters also rely on temperature controllers to maintain a comfortable environment.",https://www.omega.ca/en/resources/temperature-controllers,Write a Python script that uses Instrumentkit to connect to a TC200 Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782658/Instruments/Temperature%20Controllers/TC200/TC200.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,,,True,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
263,584.0,Teledyne,Maui,Instrumentkit,"HDO4000A oscilloscopes have 4 analog input channels, 12-bit resolution using Teledyne LeCroy’s HD4096 high definition technology, up to 1 GHz of bandwidth and a compact form factor with a large 12.1” multi-touch display. They are ideal for debug and troubleshooting of power electronics designs, digital power management or power integrity analysis, automotive electronics systems, and deeply embedded or mechatronic designs.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,HDO4000A,"[OrderedDict([('id', 'attFW6vjF1JLHmN7h'), ('width', 260), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9q5t7iiymEoIlz0J6_hm2g/0KVKHMlpiaN-JcN1QuNPHeCgb4yqe5hHJeG_6RK32VjxsHm97JnoT9HDwuRIrXLkaZ6MbW0UsBG68LgHukEFP3wtP0bsc-pooXi_UufURdw/U7ntYvDoBT6oXtwfnB4sovOY2Y4kQlkPUjlVKOHp1Io'), ('filename', 'hdo4000a-00.webp'), ('size', 18318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4NT8UWwPE1Nx-CsRi2L5eg/lZcjrSR7hWa0BSA-w_6HwKJED3EsfhKcaohOJbt8CPGzmnSyovxUgaPetioRwhzdbnKaagDIu6l0fVxwpTNcObcTQTmER5-s2_JbwXxuvs8/yx-6W6U5t_7X7EpKW8IGRQFzQqZknT1M_PV_fn-VOiw'), ('width', 37), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rQDk8wql5r4mmdK7_VoN1Q/097gAdWVB9jTXmidoekZGQzz0wMApGDj7kPt459wja_9Kn0fbCPUOtaR26ap3xkkiSuQI-PsWShhiFI9z0M09cVHSTIHUcS2ndSIhHp-5Pg/7gH64j6oRrhxtJn3etbaFMTzsR-ndMBFsvi-S11RK7Q'), ('width', 260), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/a-CVKdd5_odBttgq6M8W1A/51iy0NjltULfqmUbyJHJqczDERgS878ppvUdtI2Eu4qPNfDSAGwvMDN0LMO_P0ydwuqSTugszplGKsnxnp7OzbBT67098n3Kz-aYFw9QjyY/XUT8h4KzcV_MzeBV29iblMkr1zdVdkuQBLKEHt5wbz0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/hdo4000a-high-definition-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/hdo4000a-oscilloscopes-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a HDO4000A Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782661/Instruments/Oscilloscopes/HDO4000A/HDO4000A.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
266,380.0,Newport,Aguc 2,Instrumentkit,"The AG-UC2 Agilis™ Controller provides USB computer control for two Agilis axes. The AG-UC2 controller features two sets of push buttons for each Agilis axis; one set for step size settings, and the other set for precise low speed adjustments and fast coarse motion. Power is supplied through the USB port and if not available, the USB-CH power supply can independently power the Agilis controller. USB hubs may also be used for power and communication, but must provide the required 5 V supply, e.g. must feature an external power supply.",https://github.com/instrumentkit/InstrumentKit/blob/main/doc/source/apiref/newport.rst,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html,AG-UC2,"[OrderedDict([('id', 'attQbpWUn3oumhgod'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kmN3yq6s5MjFKhKtG-kKLA/xU9bq-PrFk9dh4TMdXTBOuz8pzw_nNDZgfUkwvIkdYdooseOJPa2CPFXosmTreDjPkfHSJdhMhK_vunNv6N4aOFK0pgz5rECj3oVx3whZL8/7mjfRxc9orD7rA6uZU8bTxBFgTlcvrmnqKjKp7F7dJg'), ('filename', 'AG-UC2.jpeg'), ('size', 87230), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4qR8fKXaEP4TGSebw7zZaw/sBjtcblvSdtLuDN6dq9YsJaoqEz5qV7-BoNYkkvsw7Q7OGnxB6mAyo97_nw57Wygzjyj7yyXUyaknIYkVtBmLg/c8u6zbtp8Yb952mi1r6sx6HAPi8tf0Vn0ZaKLA_gDEw'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yo-LetfhuZEpLVVuDecz5g/7GE9s5_AqPYCEeWdcPKKCn0riQQnGMZs00N6LrukH2hGvivFbaGnjXscNHOp2_Bn3Xlq9dC0zTV3UkHwwS0pTw/SQoSWxnyeTeIsqPzFvaqX9SqywGYUg5_zj8QmaYacVQ'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MD9aHlLKftUHOsKbxJAyLQ/Wg0Pj0P7i3XqQQVie0daGR4lFeUOFYqLKdjmjkfG9lly6v7Rs7xARdg5eupYaPb0XU5pqaC4f-_KDMgSo0-h-A/pQVbkpYyofOIb9_9aCwAFJ3WW6rHbdvuHvtWw4kVRAE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/p/AG-UC2,['Motor Controller'],"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FEWzl_hzGTfl7OvJgJBdBw/tPUDo5GPB1KUxhEyyOyobsP-KEoiK2Ih0xVZaUfiHiCt8r8W4khZe5VI19-bfsWgJr3xTYo2OiKTwJWjUJomWLKyq_9tO2Hmp27pDpqzx-g/VaW543YV-j-evaaGXiVtfJJ5PPutORCTokI0LUABPIc'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vzEo1yHydkYTKcvHU805lg/CN-Pa1g8KwDGrdj8avQ4kKAmq7GFLPkZWa2UP04inCOeRMltWULhATvOM4IlAHcgVsXm1VdKVfkKjfQ-doZuMQ/mAI8eljB2LprW6B5NUwrGo3_Uqhn4syCcDAEHs1345k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZWcs6GDcJ0WTbiq0cPGZg/77XjGUVRHP1QY9Et0AK2dUapnZ3BKA0ZFBF02a0GHvgloiyQAx_1bhBRMiUHP1mBT85PJwHOVvWgte2i91UMyg/c1h_II4v-sB65q3OPWiLcoZAYpxxo71GcwvmsgmcK90'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q5473MlvnA3X6gpdkxtp3Q/btNVEPK-gcX1En1uum6OoqnGCibk8YOVbpyUjAX1wT5sVyYQ5RwHd0sED4XLD64CkxE8G1C54Q9cRyxHz-DddA/T5IaJdzzqvtdLXEa73S1td6HEBjTZuUGAi2Itohi9Dw'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,,"Irvine, California, United States",3500.0,"Motor controllers are devices which regulate the operation of an electric motor. In artificial lift applications, motor controllers generally refer to those devices used in conjunction with switchboards or VFDs to control the operation of the prime mover.","https://www.sciencedirect.com/topics/engineering/motor-controller#:~:text=Motor%20controllers-,Motor%20controllers%20are%20devices%20which%20regulate%20the%20operation%20of%20an,operation%20of%20the%20prime%20mover.",Write a Python script that uses Instrumentkit to connect to a AG-UC2 Motor Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782662/Instruments/Motor%20Controller/AG-UC2/AG-UC2.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116708/Instruments/Vendor%20Logos/Newport.png,,,,,
272,368.0,Mettler Toledo,Mtsics,Instrumentkit,"Instrument class to communicate with Mettler Toledo balances using the MT-SICS Standared Interface Command Set.

",https://instrumentkit.readthedocs.io/en/latest/apiref/mettler_toledo.html?highlight=mettler%20toeldo#instruments.mettler_toledo.MTSICS,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/mettler_toledo/mt_sics.py,MT Standard Interface Communication Software,,https://www.mt.com/ca/en/home/library/user-manuals/laboratory-weighing/RM-MT-SICS-MS-ML-ME.html,,"[OrderedDict([('id', 'att9xokawODTifrvQ'), ('width', 610), ('height', 343), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/elCy7dWOmmcP7v1hrjkhPg/C6jkKVgGNBFYqbON7tGXg3YTYSjVDY6ERMjhaTNQZluh2jNK7m4k4NnHkW43fmbzGl4PTsS4lmxMuMjWwwvaMMNt-4HAipXN24M6l5OTy_faVp3NrdrmZPBlz8kOdC-WvOnb9XH34RW0BmtvH0P_NA/fxdnTaTP57MSKyZoYQeVYen_FZcW3yYAV54CJ8w6-Bc'), ('filename', 'Mettler-Toledo-AG-SIC-Pharma-2010-2014.jpg'), ('size', 13614), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1zmHPA3jYjPTMVdEhziiaw/1ZrZlJC16nwRsTHpWOWrzDvuWWQxsVxsd6lzUFLeWbfOR4cBL6MUHlCNTeCUNqPgPKl62JTK3gkmG_FL0dYOCw/Md05PTs3RjMx31pZp3YE6BRB37vHHkvoksvuKnai2Es'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9hR7fKTPS7XZME0jb8LZMA/Ds7lzUCnkIdReBYbUMMp8g1SN0d_lFOjrIwt9k7ZPRdo98XjGugdDx5Kv2Gcoq9PNbXDRX_HK8XiDXRi52pDDA/I3_9mICIx7mGmA1NdRKHj1i2QBACb31Hv5OwfxaDUOE'), ('width', 610), ('height', 343)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iVSK6FzTyfdanGRfVGl8qw/8CyFWwoVbvc2tVzIX1P7_BNsJH9d1oQqT6tzeFu1K-3bEL44_ffreobBPz0Szqepbr2NVk_5glEtRWAefYdi8Q/ZTkyHjlA2bf609HMkuVZkhYxTO-nVp4l3CoXvZMRCLM'), ('width', 3000), ('height', 3000)]))]))])]","Mettler Toledo (NYSE: MTD) is a multinational manufacturer of scales and analytical instruments. It is the largest provider of weighing instruments for use in laboratory, industrial, and food retailing applications. The company also provides various analytical instruments, process analytics instruments, and end-of-line inspection systems. The company operates worldwide with 70% of net sales, derived in equal parts, from Europe and from the Americas. Asian business is included in the remaining 30%.[2] Mettler Toledo is headquartered in Switzerland and incorporated in the United States.[4]
",https://www.mt.com/ca/en/home.html,,"Columbus, Ohio, USA",2819.0,,,Write a Python script that uses Instrumentkit to connect to a MT Standard Interface Communication Software ,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Mettler_Toledo.png,,,,,"

Source code for instruments.mettler_toledo.mt_sics
#!/usr/bin/env python
""""""
Provides support for the Mettler Toledo balances via Standard Interface Command Set.
""""""

from enum import Enum
import warnings

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units


class MTSICS(Instrument):
    """"""
    Instrument class to communicate with Mettler Toledo balances using the MT-SICS
    Standared Interface Command Set.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
    >>> inst.weight
    <Quantity(120.2, 'gram')>
    """"""

    class WeightMode(Enum):
        """"""
        Enum class to select the weight mode.
        """"""

        stable = False
        immediately = True

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r\n""
        self._weight_mode = MTSICS.WeightMode.stable

    def clear_tare(self):
        """"""
        Clear the tare value.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.clear_tare()
        """"""
        _ = self.query(""TAC"")

    def reset(self):
        """"""
        Reset the balance.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.reset()
        """"""
        _ = self.query(""@"")

    def tare(self, immediately=None):
        """"""
        Tare the balance.

        The mode is dependent on the weight mode, however, can be overwritten with
        the keyword `immediately`.

        :param bool immediately: Tare immediately if True, otherwise wait for stable
            weight.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.tare()
        """"""
        if immediately is None:
            immediately = self.weight_mode.value
        msg = ""TI"" if immediately else ""T""
        _ = self.query(msg)

    def zero(self, immediately=None):
        """"""
        Zero the balance after stable weight is obtained.

        Terminates processes such as zero, tare, calibration and testing etc.
        If the device is in standby mode, it is turned on. This function sets the
        currently read and the tare value to zero.

        The mode is dependent on the weight mode, however, can be overwritten with
        the keyword `immediately`.

        :param bool immediately: Zero immediately if True, otherwise wait for stable
            weight.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.zero()
        """"""
        if immediately is None:
            immediately = self.weight_mode.value
        msg = ""ZI"" if immediately else ""Z""
        _ = self.query(msg)

    def query(self, cmd, size=-1):
        """"""
        Query the instrument for a response.

        Error checking is performed on the response.

        :param str cmd: The command to send to the instrument.
        :param int size: Number of bytes to read from the instrument.

        :return: The response from the instrument.
        :rtype: str

        :raises: UserWarning if the balance is in dynamic mode.
        """"""
        self.sendcmd(cmd)

        rval = self.read(size)
        rval = rval.split()

        # error checking
        self._general_error_checking(rval[0])
        self._cmd_error_checking(rval[1])

        # raise warning if balance in dynamic mode
        if rval[1] == ""D"":
            warnings.warn(""Balance in dynamic mode."", UserWarning)

        return rval[2:]

    def _cmd_error_checking(self, value):
        """"""
        Check for errors in the query response.

        :param value: Command specific error code.
        :return: None

        :raises: OSError if an error in the command occurred.
        """"""
        if value == ""I"":
            raise OSError(""Internal error (e.g. balance not ready yet)."")
        elif value == ""L"":
            raise OSError(""Logical error (e.g. parameter not allowed)."")
        elif value == ""+"":
            raise OSError(
                ""Weigh module or balance is in overload range""
                ""(weighing range exceeded).""
            )
        elif value == ""-"":
            raise OSError(
                ""Weigh module or balance is in underload range""
                ""(e.g. weighing pan is not in place).""
            )

    def _general_error_checking(self, value):
        """"""
        Check for general errors in the query response.

        :param value:  General error code.

        :return: None

        :raises: OSError if a general error occurred.
        """"""
        if value == ""ES"":
            raise OSError(""Syntax Error."")
        elif value == ""ET"":
            raise OSError(""Transmission Error."")
        elif value == ""EL"":
            raise OSError(""Logical Error."")

    @property
    def mt_sics(self):
        """"""
        Get MT-SICS level and MT-SICS versions.

        :return: Level, Version Level 0, Version Level 1, Version Level 2,
            Version Level 3

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.mt_sics
        ['1', '1.0', '1.0', '1.0']
        """"""
        retval = [it.replace('""', """") for it in self.query(""I1"")]
        return retval

    @property
    def mt_sics_commands(self):
        """"""
        Get MT-SICS commands.

        Please refer to manual for information on the commands. Not all of these
        commands are currently implemented in this class!

        :return: List of all implemented MT-SICS levels and commands
        :rtype: list

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> in inst.mt_sics_commands
        [[""0"", ""I0""], [""1"", ""D""]]
        """"""
        timeout = self.timeout
        self.timeout = u.Quantity(0.1, u.s)

        retlist = []
        self.sendcmd(""I0"")
        while True:
            try:
                lst = self.read().split()
                if lst == []:  # data stream was empty
                    break
                retlist.append(lst)
            except OSError:  # communication timed out
                break
        self.timeout = timeout
        av_cmds = [[it[2], it[3].replace('""', """")] for it in retlist]
        return av_cmds

    @property
    def name(self):
        """"""Get / Set balance name.

        A maximum of 20 characters can be entered.

        :raises ValueError: If name is longer than 20 characters.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.name = ""My Balance""
        >>> inst.name
        'My Balance'
        """"""
        retval = "" "".join(self.query(""I10""))
        return retval.replace('""', """")

    @name.setter
    def name(self, value):
        if len(value) > 20:
            raise ValueError(""Name must be 20 characters or less."")
        _ = self.query(f'I10 ""{value}""')

    @property
    def serial_number(self):
        """"""
        Get the serial number of the balance.

        :return: The serial number of the balance.
        :rtype: str

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.serial_number
        '123456789'
        """"""
        return self.query(""I4"")[0].replace('""', """")

    @property
    def tare_value(self):
        """"""Get / set the tare value.

        If no unit is given, grams are assumed.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.tare_value = 1.0
        >>> inst.tare_value
        <Quantity(1.0, 'gram')>
        """"""
        retval = self.query(""TA"")
        return u.Quantity(float(retval[0]), retval[1])

    @tare_value.setter
    def tare_value(self, value):
        value = assume_units(value, u.gram)
        value = value.to(u.gram)
        _ = self.query(f""TA {value.magnitude} g"")

    @property
    def weight(self):
        """"""
        Get the weight.

        If you want to get the immediate (maybe unstable) weight, plese set the
        weight mode accordingly.

        :return: Weight
        :rtype: u.Quantity

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.weight
        <Quantity(1.0, 'gram')>
        """"""
        msg = ""SI"" if self.weight_mode.value else ""S""
        retval = self.query(msg)
        return u.Quantity(float(retval[0]), retval[1])

    @property
    def weight_mode(self):
        """"""Get/set the weight mode.

        By default, it starts in ``MTSICS.WeightMode.stable``.

        :return: Weight mode
        :rtype: MTSICS.WeightMode

        :raises TypeError: Weight mode is not of type ``MTSICS.WeightMode``

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.weight_mode = inst.WeightMode.immediately
        >>> inst.weight_mode
        <Weight.immediately>
        """"""
        return self._weight_mode

    @weight_mode.setter
    def weight_mode(self, value):
        if not isinstance(value, MTSICS.WeightMode):
            raise TypeError(""Weight mode must be of type `MTSICS.WeightMode"")
        self._weight_mode = value


"
273,348.0,Lakeshore,Lakeshore 475,Instrumentkit,"Lake Shore combined the technical advantages of digital signal processing with over a decade of experience in precision magnetic field measurements to produce the first commercial digital signal processor (DSP) based Hall effect gaussmeter, the Model 475. DSP technology creates a solid foundation for accurate, stable, and repeatable field measurement while simultaneously enabling the gaussmeter to offer an unequaled set of useful measurement features. The Model 475 is intended for the most demanding DC and AC applications. In many cases, it provides the functionality of two or more instruments in a field measurement system.",https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore475-gaussmeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore475.py,Lakeshore 475,"[OrderedDict([('id', 'attN0SqMNqnS9oS5O'), ('width', 500), ('height', 271), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DyOJmNFZ_jU3_KDvYXS7CQ/0jWdy8Fkum6dDv_7k9eSjYBQu5WHg5oQDkmh5kNosVq4RAVwOZDUD48GjmyiQG53Ok18JUIumO7b9cMGAGFAqQ/ljg2pGdrx3saZZv5ccG_aW-TWud4dqDKOViCJfwASNk'), ('filename', '475.png'), ('size', 146533), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/E8XnXnnI7Q8kFvsCVSY8TQ/9bIFi2I16F1QQk9GrwP3Bc0q3BQFhfsW8cuRE1rTN4fWRq9DXfkOGGUKhUUmiO9EMs4UPG07LfsqcXPnipxNWg/xzRLE2NMmBDFsGQLmb6TV_6sFcEOztio9d2wJ6keAjY'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bbhcYELlmITgcE47SlZ7Nw/ImbwUCk2irR5YmHzxdL3PVbZWtpSb6cpUWC513wfLrvuwm9l6IouPcgnp5hw8ojvMuf6-EZcStwNeo5324VX8g/V6oPi6xUw98hd68BXUguCcPcNt7QRn7R3i8e_OnF5gA'), ('width', 500), ('height', 271)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wJN6eYH7qhi46L8hN0CZMQ/jrEaRzLNP2rK9AFy-fpzKBNRi614R-QOllkXJBWZbkfNjxv9bbRlFOF6-o5ONPl-D8ZXFsroEOd-HVKSofpdTw/LygW6pndQOLX4VaP3LHgO9geNp8YuVmAmm6JoSq2XkA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-475-dsp-gaussmeter,['Power Meters'],"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://www.lakeshore.com/home,https://www.optixs.cz/data/ke-stazeni/475_dsp_gaussmeter-d879.pdf,"Westerville, Ohio, USA",21.4,"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.",https://en.wikipedia.org/wiki/Magnetometer,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782669/Instruments/Power%20Meters/Lakeshore-475/Lakeshore-475.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,4454.0,,,,"

Source code for instruments.lakeshore.lakeshore340
#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))


"
282,240.0,Keithley,Keithley 6220,Instrumentkit,"The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.pyli,Keithley 6220,"[OrderedDict([('id', 'att31UsbWkgLLw6lz'), ('width', 799), ('height', 416), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2N0r9UCVBXcwAFCoFgCpQg/DXTyTe3IG9r50Db2Xr1cdzoO7_aHKZlq-slf2lTu1xA9BGTap_09laWpPuum_JE2-n8Ez7ZiThUAqQq7dQl9mzvuKyDrlUPD1xNG1SiPfTY/gi73lH4Yi_r38vHQzXbOFIU0wHWTwCseOq9RGtxmJpo'), ('filename', 'Keithley_6220.jpg'), ('size', 79670), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JJYtjOW1oGLQiI1icYy1Ww/qTExdAKqeM3auwhVEtIqO_sPE2uR8ZeS2uZ3Z9QyYok2T5EpZeA6p799wJQ3BM_1zJqZERDPOnGMDJnmpCe1jQ/6JPcTxyspV5QLtUKMpg-UfRLadVSe7isw2lgXuihmVU'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oxQlk5mtCRzsgwb7z2BKgQ/W5uoXCxp8lSC1b0sUefDp2baeMEqkVGD9LYnVXjP95VagFPlfXwOunleK9RO2tq39EDJVcud6H-RbI33OnAusg/mlBurf9mTyd3YamNcm99sKrCWf4hgCKktBFGhHi-ZvE'), ('width', 799), ('height', 416)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vUkmDV4G31FXKkeyGC48Pg/toZvLGO1NIESMmTZZJhSxUD9Z6Ztwzb0xJBqp5w6qpO-BKKVGm1B3xwsA4ZB1EiXkXbOmdJjhWsXesIeuS-bJw/jEC-qN-HzlxZbQ1JxY4MGh5ZbytzkrakhGyYpEVc2xk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/series-6200,['Power Supplies'],"[OrderedDict([('id', 'attqJ7B2tvK8wDFSb'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CeND0HX3_87yXn80NieY2Q/IhAZZfSfODAFKXNyRqyB857EaahEjp2lZrmX8vSuDTEscXZAcz0AkKNlC0S_15rcUzMLyWKvrt1-3XhNLxv2bnOi-PqxHJL6Ww56ZFEVoDGCbYG_oWVgOrnHIxISFsyR6bBytBAgyNgq6gnQHXUmJg/0IrZMcPFZojeMt4IWDr9TgFKJXk7nJxCozRUcyQAo80'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YmJkPx_h6TfZW16IBrCbzA/XqYT-DXfaFwsVlOOrz52sJKSCsc2aEmxuVbcK4mxurPZQ2DlNlq-pa4VyuEtxcRvVrBPPK4JcNLjm7Rrldz4Rg/Bj2ZoE6EProztPAPcNWtbK-EiAsENfqlCgFnRuloQ8U'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pwc46WNDEn3--c2XLZoHMQ/ecAURNuLcM5r82kKNj7sy6fAoZlxtC-IC-O4T9k2v7CzAWkW8A2MAsNu2ad_wcIeuKi8zMj-N_nHowNbClpsYw/sjcAtSF9wBJ1fxvG7H2HfecmwbOOPdOD7CIYzz9ZBqw'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kXPrH7wPcLxNJno9AAPw3g/toXIxooklz_EXlU8QzrFr--wHEnrftlHzFhjnebe7M-mtOWWCKdH2Bv_iJeJjLZFtAet7eMdQqOknb6Qa402mQ/VW9PiU_E_8pVZCjIN422-nci8Z7ukaXmYaZa2v0EBco'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,"A current source is an electronic circuit that delivers or absorbs an electric current which is independent of the voltage across it.

A current source is the dual of a voltage source. The term current sink is sometimes used for sources fed from a negative voltage supply. Figure 1 shows the schematic symbol for an ideal current source driving a resistive load. There are two types. An independent current source (or sink) delivers a constant current. A dependent current source delivers a current which is proportional to some other voltage or current in the circuit.",https://en.wikipedia.org/wiki/Current_source,Write a Python script that uses Instrumentkit to connect to a Keithley 6220 Power Supplies,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782676/Instruments/Power%20Supplies/Keithley-6220/Keithley-6220.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,6210.0,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
284,135.0,Generic SCPI,SCPI multimeter,Instrumentkit,"All SCPI Multimeters
",https://instrumentkit.readthedocs.io/en/latest/apiref/generic_scpi.html#scpimultimeter-generic-multimeter-using-scpi-commands,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/generic_scpi/scpi_multimeter.py,SCPI multimeter,"[OrderedDict([('id', 'attJFtaQgK65Azlmu'), ('width', 800), ('height', 945), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HROgW7yNRAPVGL2m6AsTXg/n__yUb35a55kErAOW6qn9tGUIwIIUx72LbgyTK9kYMQ8rrG91-or87YwvkfeNrQJx0EafGwt8P1IrKLknF4HcxXYyA3lw4mr-z9l9NyVQJ4/HSq8MSvua_FwGhpNOaFWC3H12Hl7CRMON1ZoYP_8UGs'), ('filename', 'image.png'), ('size', 845732), ('type', 'image/png')])]",https://supereyes.ru/img/instructions/OWON_HDS_SCPI_manual.pdf,['Multimeters'],"[OrderedDict([('id', 'attpFOvtzuWOJVOYv'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z4c60R16FPMT5ywW741wMA/ZK3oqj-6oG3VPZOO3pLlbEWHrqs71hdGCGmsWGraxU6M9iMuwddeO-StLFV0OKBllEYR7W9Y21epMKPr0DILwLRwSwy6ltVHXoGCq37R_1M/4Imlak4UYaNRiQndgVsxed0tH3GqM_HKHZNbG2S52h4'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-vy9eNJi7jKQTaYfJuwu4w/vZ3L0Rh_G6XRhVcQXBq5rSsyiJnp-j6ezRT4Mkry6QH51wt3K-3SCon3e9N5Dr5Th6Qr0luQZKLHYLX2kfWJFw/8B6zdz6DmqxFYMODHygmIuU6kynqrfj_wDNPRSuz3MA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fzyiRnglphLbA3fusr2WxQ/a-xX_hqvS86LJzTYM-x3DwnLVhBN8E53j7bYcoAGhFL5P8NWG3LyAjjA_rFYiWbUUK6JgVu0xx8SLeJ1NswkqA/d4nqWYO2JumruSUglzuod7tJiEaTHS0Jy01K8AVSO3A'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UA82RFn1BzC2cDqJCyzRcg/X-WT_FfY-d2GY3q_PqwlAdbqrzaa9K4LQEPHulSF0Va6xixGUWf-zBrRdyy-mmpPaQ-LVDFRV-fMvrTGpoUnWg/pznk72tvRkiqY3pCF4vrEalrr_ehGtEpkGfcOFyOGSE'), ('width', 3000), ('height', 3000)]))]))])]","
",https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,,,,SCPI Multimeter,https://en.wikipedia.org/wiki/Multimeter,Write a Python script that uses Instrumentkit to connect to a SCPI multimeter Multimeters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782678/Instruments/Multimeters/SCPI-multimeter/SCPI-multimeter.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116714/Instruments/Vendor%20Logos/NoLogo.png,,,,"Many Devices and Vendors SCPI Multimeters, And Github Project seems Coded in C++","

Source code for instruments.generic_scpi.scpi_instrument
#!/usr/bin/env python
""""""
Provides support for SCPI compliant instruments
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class SCPIInstrument(Instrument):
    r""""""
    Base class for all SCPI-compliant instruments. Inherits from
    from `~instruments.Instrument`.

    This class does not implement any instrument-specific communication
    commands. What it does add is several of the generic SCPI star commands.
    This includes commands such as ``*IDN?``, ``*OPC?``, and ``*RST``.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.generic_scpi.SCPIInstrument.open_tcpip('192.168.0.2', 8888)
    >>> print(inst.name)
    """"""

    # PROPERTIES #

    @property
    def name(self):
        """"""
        The name of the connected instrument, as reported by the
        standard SCPI command ``*IDN?``.

        :rtype: `str`
        """"""
        return self.query(""*IDN?"")

    @property
    def scpi_version(self):
        """"""
        Returns the version of the SCPI protocol supported by this instrument,
        as specified by the ``SYST:VERS?`` command described in section 21.21
        of the SCPI 1999 standard.
        """"""
        return self.query(""SYST:VERS?"")

    @property
    def op_complete(self):
        """"""
        Check if all operations sent to the instrument have been completed.

        :rtype: `bool`
        """"""
        result = self.query(""*OPC?"")
        return bool(int(result))

    @property
    def power_on_status(self):
        """"""
        Gets/sets the power on status for the instrument.

        :type: `bool`
        """"""
        result = self.query(""*PSC?"")
        return bool(int(result))

    @power_on_status.setter
    def power_on_status(self, newval):
        on = [""on"", ""1"", 1, True]
        off = [""off"", ""0"", 0, False]
        if isinstance(newval, str):
            newval = newval.lower()
        if newval in on:
            self.sendcmd(""*PSC 1"")
        elif newval in off:
            self.sendcmd(""*PSC 0"")
        else:
            raise ValueError

    @property
    def self_test_ok(self):
        """"""
        Gets the results of the instrument's self test. This lets you check
        if the self test was sucessful or not.

        :rtype: `bool`
        """"""
        result = self.query(""*TST?"")
        try:
            result = int(result)
            return result == 0
        except ValueError:
            return False

    # BASIC SCPI COMMANDS ##

    def reset(self):
        """"""
        Reset instrument. On many instruments this is a factory reset and will
        revert all settings to default.
        """"""
        self.sendcmd(""*RST"")

    def clear(self):
        """"""
        Clear instrument. Consult manual for specifics related to that
        instrument.
        """"""
        self.sendcmd(""*CLS"")

    def trigger(self):
        """"""
        Send a software trigger event to the instrument. On most instruments
        this will cause some sort of hardware event to start. For example, a
        multimeter might take a measurement.

        This software trigger usually performs the same action as a hardware
        trigger to your instrument.
        """"""
        self.sendcmd(""*TRG"")

    def wait_to_continue(self):
        """"""
        Instruct the instrument to wait until it has completed all received
        commands before continuing.
        """"""
        self.sendcmd(""*WAI"")

    # SYSTEM COMMANDS ##

    @property
    def line_frequency(self):
        """"""
        Gets/sets the power line frequency setting for the instrument.

        :return: The power line frequency
        :units: Hertz
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(float(self.query(""SYST:LFR?"")), ""Hz"")

    @line_frequency.setter
    def line_frequency(self, newval):
        self.sendcmd(
            ""SYST:LFR {}"".format(assume_units(newval, ""Hz"").to(""Hz"").magnitude)
        )

    # ERROR QUEUE HANDLING ##
    # NOTE: This functionality is still quite incomplete, and could be fleshed
    #       out significantly still. One good thing would be to add handling
    #       for SCPI-defined error codes.
    #
    #       Another good use of this functionality would be to allow users to
    #       automatically check errors after each command or query.
    class ErrorCodes(IntEnum):

        """"""
        Enumeration describing error codes as defined by SCPI 1999.0.
        Error codes that are equal to 0 mod 100 are defined to be *generic*.
        """"""

        # NOTE: this class may be overriden by subclasses, since the only access
        #       to this enumeration from within SCPIInstrument is by ""self,""
        #       not by explicit name. Thus, if an instrument supports additional
        #       error codes from the SCPI base, they can be added in a natural
        #       way.
        no_error = 0

        # -100 BLOCK: COMMAND ERRORS ##
        command_error = -100
        invalid_character = -101
        syntax_error = -102
        invalid_separator = -103
        data_type_error = -104
        get_not_allowed = -105
        # -106 and -107 not specified.
        parameter_not_allowed = -108
        missing_parameter = -109
        command_header_error = -110
        header_separator_error = -111
        program_mnemonic_too_long = -112
        undefined_header = -113
        header_suffix_out_of_range = -114
        unexpected_number_of_parameters = -115
        numeric_data_error = -120
        invalid_character_in_number = -121
        exponent_too_large = -123
        too_many_digits = -124
        numeric_data_not_allowed = -128
        suffix_error = -130
        invalid_suffix = -131
        suffix_too_long = -134
        suffix_not_allowed = -138
        character_data_error = -140
        invalid_character_data = -141
        character_data_too_long = -144
        character_data_not_allowed = -148
        string_data_error = -150
        invalid_string_data = -151
        string_data_not_allowed = -158
        block_data_error = -160
        invalid_block_data = -161
        block_data_not_allowed = -168
        expression_error = -170
        invalid_expression = -171
        expression_not_allowed = -178
        macro_error = -180
        invalid_outside_macro_definition = -181
        invalid_inside_macro_definition = -183
        macro_parameter_error = -184

        # pylint: disable=fixme
        # TODO: copy over other blocks.
        # -200 BLOCK: EXECUTION ERRORS ##
        # -300 BLOCK: DEVICE-SPECIFIC ERRORS ##
        # Note that device-specific errors also include all positive numbers.
        # -400 BLOCK: QUERY ERRORS ##

        # OTHER ERRORS ##

        #: Raised when the instrument detects that it has been turned from
        #: off to on.
        power_on = -500  # Yes, SCPI 1999 defines the instrument turning on as
        # an error. Yes, this makes my brain hurt.
        user_request_event = -600
        request_control_event = -700
        operation_complete = -800

    def check_error_queue(self):
        """"""
        Checks and clears the error queue for this device, returning a list of
        :class:`SCPIInstrument.ErrorCodes` or `int` elements for each error
        reported by the connected instrument.
        """"""
        # pylint: disable=fixme
        # TODO: use SYST:ERR:ALL instead of SYST:ERR:CODE:ALL to get
        #       messages as well. Should be just a bit more parsing, but the
        #       SCPI standard isn't clear on how the pairs are represented,
        #       so it'd be helpful to have an example first.
        err_list = map(int, self.query(""SYST:ERR:CODE:ALL?"").split("",""))
        return [
            self.ErrorCodes[err] if isinstance(err, self.ErrorCodes) else err
            for err in err_list
            if err != self.ErrorCodes.no_error
        ]

    # DISPLAY COMMANDS ##

    @property
    def display_brightness(self):
        """"""
        Brightness of the display on the connected instrument, represented as
        a float ranging from 0 (dark) to 1 (full brightness).

        :type: `float`
        """"""
        return float(self.query(""DISP:BRIG?""))

    @display_brightness.setter
    def display_brightness(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display brightness must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:BRIG {newval}"")

    @property
    def display_contrast(self):
        """"""
        Contrast of the display on the connected instrument, represented as
        a float ranging from 0 (no contrast) to 1 (full contrast).

        :type: `float`
        """"""
        return float(self.query(""DISP:CONT?""))

    @display_contrast.setter
    def display_contrast(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display contrast must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:CONT {newval}"")


"
289,444.0,Rigol,Rigolds 1000 Series,Instrumentkit,"The 1000 Series from RIGOL include the B, D, and E series oscilloscopes. The E Series are the value leader with 50-100 MHz models that include 2 channels and 1 Million points of memory. The D Series add low speed digital capture enabling basic mixed signal analysis in a economic package. The B Series provide more speed and power including our economic 4 channel, 200 MHz DS1204B model which provides 2 GSa/sec sampling. With features including FFTs, record and replay, roll mode, alternate trigger mode, and adjustable trigger sensitivity the 1000 Series is a great entry for value oscilloscope requirements.",https://instrumentkit.readthedocs.io/en/latest/apiref/rigol.html#rigolds1000series-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/rigol/rigolds1000.py,Rigol DS1000-Series,"[OrderedDict([('id', 'att8CeLFiqOpXnfXX'), ('width', 500), ('height', 313), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aLnnNd3EdVRX-vy-OvMMXg/0u0Ok54KS0oiEDLA-RT-aQe7czAovGzZJ_LrPtc_DYUs8qbSvl7Povz1H_I7rDdI3ylu31fXeNdBRPhRq9edSkt-O3Sc-7cOMhx3CAvMgT0/9Uxhe9kCazEMei7i54cErSNRtNpRgD10LEFEZ0-a6BQ'), ('filename', '1000Z.png'), ('size', 220984), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/u2pcS2m1RkvNIUsSRVmELg/2k4j_fiPasg1pvhojXMPHI_gkc2e1QKFHl1Du9OI_0mj2znTozyIa69C1lZJKG-0Ld221J0OmBCp14UKuTVkYw/py_6SNK-DUzb8DZjieA9XmAeEW6ZxH3DcjS1iqLM_Og'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/btuY_1Kp2q8WMaZcOS_wRw/PXEH-5-lSzrPvjR-oSPPkdPVVo3iz2fpmFL2QrccJvJU0vUFk_7Kjt5KiWubHStDb20QAu2wBvQN0lVRIsTyTg/hdEEaEeW0ic5IYLLU95fJbEuhlXhmEgiHri71j2SC-M'), ('width', 500), ('height', 313)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/K27swPuRXRFNIcfMJrSmaQ/MaAx6QY35KoGTgKig3SJpnZY-J1khts1drIOLc2JE9TlWdu2LrYn-goYiZaC1_xgnY977S0IKuHpcbIGHGozag/_rVg9mDyiIvxWf5D9Fd1BhTQLgD3yBrmIRDXnsVK8vk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigolna.com/products/digital-oscilloscopes/1000/,['Oscilloscopes'],"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://www.rigol.com/,,"Beijing, China",23.0,An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a Rigol DS1000-Series Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782681/Instruments/Oscilloscopes/Rigol-DS1000-Series/Rigol-DS1000-Series.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,,,,,"

Source code for instruments.rigol.rigolds1000
#!/usr/bin/env python
""""""
Provides support for Rigol DS-1000 series oscilloscopes.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import ProxyList, bool_property, enum_property

# CLASSES #####################################################################


class RigolDS1000Series(SCPIInstrument, Oscilloscope):

    """"""
    The Rigol DS1000-series is a popular budget oriented oscilloscope
    that has featured wide adoption across hobbyist circles.

    .. warning:: This instrument is not complete, and probably not even
        functional!
    """"""

    # ENUMS #

    class AcquisitionType(Enum):
        """"""
        Enum containing valid acquisition types for the Rigol DS1000
        """"""

        normal = ""NORM""
        average = ""AVER""
        peak_detect = ""PEAK""

    # INNER CLASSES #

    class DataSource(Oscilloscope.DataSource):
        """"""
        Class representing a data source (channel, math, or ref) on the
        Rigol DS1000

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `RigolDS1000Series` class.
        """"""

        @property
        def name(self):
            return self._name

        def read_waveform(self, bin_format=True):
            # TODO: add DIG, FFT.
            if self.name not in [""CHAN1"", ""CHAN2"", ""DIG"", ""MATH"", ""FFT""]:
                raise NotImplementedError(
                    ""Rigol DS1000 series does not ""
                    ""supportreading waveforms from ""
                    ""{}."".format(self.name)
                )
            self._parent.sendcmd(f"":WAV:DATA? {self.name}"")
            data = self._parent.binblockread(2)  # TODO: check width
            return data

    class Channel(DataSource, Oscilloscope.Channel):
        """"""
        Class representing a channel on the Rigol DS1000.

        This class inherits from `~RigolDS1000Series.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `RigolDS1000Series` class.
        """"""

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the Rigol DS1000
            """"""

            ac = ""AC""
            dc = ""DC""
            ground = ""GND""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # Rigols are 1-based.

            # Initialize as a data source with name CHAN{}.
            super().__init__(self._parent, f""CHAN{self._idx}"")

        def sendcmd(self, cmd):
            """"""
            Passes a command from the `Channel` class to the parent
            `RigolDS1000Series`, appending the required channel identification.

            :param str cmd: The command string to send to the instrument
            """"""
            self._parent.sendcmd(f"":CHAN{self._idx}:{cmd}"")

        def query(self, cmd):
            """"""
            Passes a command from the `Channel` class to the parent
            `RigolDS1000Series`, appending the required channel identification.

            :param str cmd: The command string to send to the instrument
            :return: The result as returned by the instrument
            :rtype: `str`
            """"""
            return self._parent.query(f"":CHAN{self._idx}:{cmd}"")

        coupling = enum_property(""COUP"", Coupling)

        bw_limit = bool_property(""BWL"", inst_true=""ON"", inst_false=""OFF"")
        display = bool_property(""DISP"", inst_true=""ON"", inst_false=""OFF"")
        invert = bool_property(""INV"", inst_true=""ON"", inst_false=""OFF"")

        # TODO: :CHAN<n>:OFFset
        # TODO: :CHAN<n>:PROBe
        # TODO: :CHAN<n>:SCALe

        filter = bool_property(""FILT"", inst_true=""ON"", inst_false=""OFF"")

        # TODO: :CHAN<n>:MEMoryDepth

        vernier = bool_property(""VERN"", inst_true=""ON"", inst_false=""OFF"")

    # PROPERTIES #

    @property
    def channel(self):
        # Rigol DS1000 series oscilloscopes all have two channels,
        # according to the documentation.
        return ProxyList(self, self.Channel, range(2))

    @property
    def math(self):
        return self.DataSource(parent=self, name=""MATH"")

    @property
    def ref(self):
        return self.DataSource(parent=self, name=""REF"")

    acquire_type = enum_property("":ACQ:TYPE"", AcquisitionType)
    # TODO: implement :ACQ:MODE. This is confusing in the documentation,
    # though.

    @property
    def acquire_averages(self):
        """"""
        Gets/sets the number of averages the oscilloscope should take per
        acquisition.

        :type: `int`
        """"""
        return int(self.query("":ACQ:AVER?""))

    @acquire_averages.setter
    def acquire_averages(self, newval):
        if newval not in [2**i for i in range(1, 9)]:
            raise ValueError(
                ""Number of averages {} not supported by instrument; ""
                ""must be a power of 2 from 2 to 256."".format(newval)
            )
        self.sendcmd(f"":ACQ:AVER {newval}"")

    # TODO: implement :ACQ:SAMP in a meaningful way. This should probably be
    #       under Channel, and needs to be unitful.
    # TODO: I don't understand :ACQ:MEMD yet.

    # METHODS ##

    def force_trigger(self):
        self.sendcmd("":FORC"")

    # TODO: consider moving the next few methods to Oscilloscope.
    def run(self):
        """"""
        Starts running the oscilloscope trigger.
        """"""
        self.sendcmd("":RUN"")

    def stop(self):
        """"""
        Stops running the oscilloscope trigger.
        """"""
        self.sendcmd("":STOP"")

    # TODO: unitful timebase!

    # FRONT-PANEL KEY EMULATION METHODS ##
    # These methods correspond one-to-one with physical keys on the front
    # (local) control panel, except for release_panel, which enables the local
    # panel and disables any remote lockouts, and for panel_locked.
    #
    # Many of the :KEY: commands are not yet implemented as methods.

    panel_locked = bool_property("":KEY:LOCK"", inst_true=""ENAB"", inst_false=""DIS"")

    def release_panel(self):
        # TODO: better name?
        # NOTE: method may be redundant with the panel_locked property.
        """"""
        Releases any lockout of the local control panel.
        """"""
        self.sendcmd("":KEY:FORC"")


"
301,134.0,Generic SCPI,Scpi Instrument,Instrumentkit,All SCPI Instrument,https://instrumentkit.readthedocs.io/en/latest/apiref/generic_scpi.html#scpiinstrument-base-class-for-instruments-using-the-scpi-protocol,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/generic_scpi/scpi_instrument.py,SCPI Instrument,"[OrderedDict([('id', 'attJFtaQgK65Azlmu'), ('width', 800), ('height', 945), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HROgW7yNRAPVGL2m6AsTXg/n__yUb35a55kErAOW6qn9tGUIwIIUx72LbgyTK9kYMQ8rrG91-or87YwvkfeNrQJx0EafGwt8P1IrKLknF4HcxXYyA3lw4mr-z9l9NyVQJ4/HSq8MSvua_FwGhpNOaFWC3H12Hl7CRMON1ZoYP_8UGs'), ('filename', 'image.png'), ('size', 845732), ('type', 'image/png')])]",,,"[OrderedDict([('id', 'attpFOvtzuWOJVOYv'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z4c60R16FPMT5ywW741wMA/ZK3oqj-6oG3VPZOO3pLlbEWHrqs71hdGCGmsWGraxU6M9iMuwddeO-StLFV0OKBllEYR7W9Y21epMKPr0DILwLRwSwy6ltVHXoGCq37R_1M/4Imlak4UYaNRiQndgVsxed0tH3GqM_HKHZNbG2S52h4'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-vy9eNJi7jKQTaYfJuwu4w/vZ3L0Rh_G6XRhVcQXBq5rSsyiJnp-j6ezRT4Mkry6QH51wt3K-3SCon3e9N5Dr5Th6Qr0luQZKLHYLX2kfWJFw/8B6zdz6DmqxFYMODHygmIuU6kynqrfj_wDNPRSuz3MA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fzyiRnglphLbA3fusr2WxQ/a-xX_hqvS86LJzTYM-x3DwnLVhBN8E53j7bYcoAGhFL5P8NWG3LyAjjA_rFYiWbUUK6JgVu0xx8SLeJ1NswkqA/d4nqWYO2JumruSUglzuod7tJiEaTHS0Jy01K8AVSO3A'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UA82RFn1BzC2cDqJCyzRcg/X-WT_FfY-d2GY3q_PqwlAdbqrzaa9K4LQEPHulSF0Va6xixGUWf-zBrRdyy-mmpPaQ-LVDFRV-fMvrTGpoUnWg/pznk72tvRkiqY3pCF4vrEalrr_ehGtEpkGfcOFyOGSE'), ('width', 3000), ('height', 3000)]))]))])]","
",https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,,,,SCPI Instrument,https://fr.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,Write a Python script that uses Instrumentkit to connect to a SCPI Instrument ,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116714/Instruments/Vendor%20Logos/NoLogo.png,,,,Generic Python Library for communication with SCPI Instruments,"

Source code for instruments.generic_scpi.scpi_instrument
#!/usr/bin/env python
""""""
Provides support for SCPI compliant instruments
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class SCPIInstrument(Instrument):
    r""""""
    Base class for all SCPI-compliant instruments. Inherits from
    from `~instruments.Instrument`.

    This class does not implement any instrument-specific communication
    commands. What it does add is several of the generic SCPI star commands.
    This includes commands such as ``*IDN?``, ``*OPC?``, and ``*RST``.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.generic_scpi.SCPIInstrument.open_tcpip('192.168.0.2', 8888)
    >>> print(inst.name)
    """"""

    # PROPERTIES #

    @property
    def name(self):
        """"""
        The name of the connected instrument, as reported by the
        standard SCPI command ``*IDN?``.

        :rtype: `str`
        """"""
        return self.query(""*IDN?"")

    @property
    def scpi_version(self):
        """"""
        Returns the version of the SCPI protocol supported by this instrument,
        as specified by the ``SYST:VERS?`` command described in section 21.21
        of the SCPI 1999 standard.
        """"""
        return self.query(""SYST:VERS?"")

    @property
    def op_complete(self):
        """"""
        Check if all operations sent to the instrument have been completed.

        :rtype: `bool`
        """"""
        result = self.query(""*OPC?"")
        return bool(int(result))

    @property
    def power_on_status(self):
        """"""
        Gets/sets the power on status for the instrument.

        :type: `bool`
        """"""
        result = self.query(""*PSC?"")
        return bool(int(result))

    @power_on_status.setter
    def power_on_status(self, newval):
        on = [""on"", ""1"", 1, True]
        off = [""off"", ""0"", 0, False]
        if isinstance(newval, str):
            newval = newval.lower()
        if newval in on:
            self.sendcmd(""*PSC 1"")
        elif newval in off:
            self.sendcmd(""*PSC 0"")
        else:
            raise ValueError

    @property
    def self_test_ok(self):
        """"""
        Gets the results of the instrument's self test. This lets you check
        if the self test was sucessful or not.

        :rtype: `bool`
        """"""
        result = self.query(""*TST?"")
        try:
            result = int(result)
            return result == 0
        except ValueError:
            return False

    # BASIC SCPI COMMANDS ##

    def reset(self):
        """"""
        Reset instrument. On many instruments this is a factory reset and will
        revert all settings to default.
        """"""
        self.sendcmd(""*RST"")

    def clear(self):
        """"""
        Clear instrument. Consult manual for specifics related to that
        instrument.
        """"""
        self.sendcmd(""*CLS"")

    def trigger(self):
        """"""
        Send a software trigger event to the instrument. On most instruments
        this will cause some sort of hardware event to start. For example, a
        multimeter might take a measurement.

        This software trigger usually performs the same action as a hardware
        trigger to your instrument.
        """"""
        self.sendcmd(""*TRG"")

    def wait_to_continue(self):
        """"""
        Instruct the instrument to wait until it has completed all received
        commands before continuing.
        """"""
        self.sendcmd(""*WAI"")

    # SYSTEM COMMANDS ##

    @property
    def line_frequency(self):
        """"""
        Gets/sets the power line frequency setting for the instrument.

        :return: The power line frequency
        :units: Hertz
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(float(self.query(""SYST:LFR?"")), ""Hz"")

    @line_frequency.setter
    def line_frequency(self, newval):
        self.sendcmd(
            ""SYST:LFR {}"".format(assume_units(newval, ""Hz"").to(""Hz"").magnitude)
        )

    # ERROR QUEUE HANDLING ##
    # NOTE: This functionality is still quite incomplete, and could be fleshed
    #       out significantly still. One good thing would be to add handling
    #       for SCPI-defined error codes.
    #
    #       Another good use of this functionality would be to allow users to
    #       automatically check errors after each command or query.
    class ErrorCodes(IntEnum):

        """"""
        Enumeration describing error codes as defined by SCPI 1999.0.
        Error codes that are equal to 0 mod 100 are defined to be *generic*.
        """"""

        # NOTE: this class may be overriden by subclasses, since the only access
        #       to this enumeration from within SCPIInstrument is by ""self,""
        #       not by explicit name. Thus, if an instrument supports additional
        #       error codes from the SCPI base, they can be added in a natural
        #       way.
        no_error = 0

        # -100 BLOCK: COMMAND ERRORS ##
        command_error = -100
        invalid_character = -101
        syntax_error = -102
        invalid_separator = -103
        data_type_error = -104
        get_not_allowed = -105
        # -106 and -107 not specified.
        parameter_not_allowed = -108
        missing_parameter = -109
        command_header_error = -110
        header_separator_error = -111
        program_mnemonic_too_long = -112
        undefined_header = -113
        header_suffix_out_of_range = -114
        unexpected_number_of_parameters = -115
        numeric_data_error = -120
        invalid_character_in_number = -121
        exponent_too_large = -123
        too_many_digits = -124
        numeric_data_not_allowed = -128
        suffix_error = -130
        invalid_suffix = -131
        suffix_too_long = -134
        suffix_not_allowed = -138
        character_data_error = -140
        invalid_character_data = -141
        character_data_too_long = -144
        character_data_not_allowed = -148
        string_data_error = -150
        invalid_string_data = -151
        string_data_not_allowed = -158
        block_data_error = -160
        invalid_block_data = -161
        block_data_not_allowed = -168
        expression_error = -170
        invalid_expression = -171
        expression_not_allowed = -178
        macro_error = -180
        invalid_outside_macro_definition = -181
        invalid_inside_macro_definition = -183
        macro_parameter_error = -184

        # pylint: disable=fixme
        # TODO: copy over other blocks.
        # -200 BLOCK: EXECUTION ERRORS ##
        # -300 BLOCK: DEVICE-SPECIFIC ERRORS ##
        # Note that device-specific errors also include all positive numbers.
        # -400 BLOCK: QUERY ERRORS ##

        # OTHER ERRORS ##

        #: Raised when the instrument detects that it has been turned from
        #: off to on.
        power_on = -500  # Yes, SCPI 1999 defines the instrument turning on as
        # an error. Yes, this makes my brain hurt.
        user_request_event = -600
        request_control_event = -700
        operation_complete = -800

    def check_error_queue(self):
        """"""
        Checks and clears the error queue for this device, returning a list of
        :class:`SCPIInstrument.ErrorCodes` or `int` elements for each error
        reported by the connected instrument.
        """"""
        # pylint: disable=fixme
        # TODO: use SYST:ERR:ALL instead of SYST:ERR:CODE:ALL to get
        #       messages as well. Should be just a bit more parsing, but the
        #       SCPI standard isn't clear on how the pairs are represented,
        #       so it'd be helpful to have an example first.
        err_list = map(int, self.query(""SYST:ERR:CODE:ALL?"").split("",""))
        return [
            self.ErrorCodes[err] if isinstance(err, self.ErrorCodes) else err
            for err in err_list
            if err != self.ErrorCodes.no_error
        ]

    # DISPLAY COMMANDS ##

    @property
    def display_brightness(self):
        """"""
        Brightness of the display on the connected instrument, represented as
        a float ranging from 0 (dark) to 1 (full brightness).

        :type: `float`
        """"""
        return float(self.query(""DISP:BRIG?""))

    @display_brightness.setter
    def display_brightness(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display brightness must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:BRIG {newval}"")

    @property
    def display_contrast(self):
        """"""
        Contrast of the display on the connected instrument, represented as
        a float ranging from 0 (no contrast) to 1 (full contrast).

        :type: `float`
        """"""
        return float(self.query(""DISP:CONT?""))

    @display_contrast.setter
    def display_contrast(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display contrast must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:CONT {newval}"")


"
309,41.0,Agilent,Agilent 33220 A,Instrumentkit,The Keysight 33220A is a 20 MHz synthesized function generator with built-in arbitrary waveform and pulse capabilities. Itscombination of bench-top and system features makes this function generator a versatile solution for your testing requirements now and in the future.,https://instrumentkit.readthedocs.io/en/latest/apiref/agilent.html#agilent33220a-function-generator,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/agilent/agilent33220a.html#Agilent33220a,Keysight 33220A,"[OrderedDict([('id', 'att9Bw70ALrjUCUhO'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vngcz2JwlizCeP-0fie6hg/g_t51gLnjdT7AemAnyUOffboOZb_usPEFdIs8Ut4QOmvTeD4ggS-wQXcDDhn8HID2TniBmFIuajdTg8t5kIkacnNNWn2gqTd-yaaHdTQ32M/RZY35AGrf-qyKEt3Mu_5dGy966dHIZl4n45dMa8XZAc'), ('filename', 'PROD-127539-01.webp'), ('size', 12382), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZerLq5HCs-d9oqP1Y1ceWg/5ULi5welY5AKeb2UIGy7RZ2Me9m4V94ZdtXdSh45qFm2ka-bEyFcuXZNMDrQnxmE4_DkG00HJYKfMxmIGRjbnqDIFCdOPBCxkOC4g9a2nDQ/fUwxUaGm8f_yONqlIonO3yi8hQ3twz1oZMzFrQvvgWc'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uEjw1VxincAniaOm_nDmJg/Xphjj98WPtlbSrG1iHByV_IS7ivOKorLIuf5kIfFmu3WQEdRSuiVKfoTYmiAkziZ_ZP2hNMbRB0qo6dbiOGpEkOYnXkMKajDWPzDvjI1zLo/DZTHxvNZRZIgd4rk6G_IfHb3_iPj-SDxPqQZmBMzXJY'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RmttI3V5xoyf7hwkvXgnJA/Zz6tH26_MLof5EsrkOKcKJCyI7GEUlZRRCCQEq-8OquXuRidoxYwRsg7mXIHvyKjySnp9AC0NDWiblUfnqDe8gAsZZMpd3cKs0kNCEj26fk/Xbr9-dmwVJ4tTc_xk9iGSvZECxQctiR3raQ-YpnxBeI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/support/33220A/function--arbitrary-waveform-generator-20-mhz.html,['RF Signal Generator'],"[OrderedDict([('id', 'attXkc513oAf08kfb'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8pQofJgPHQb2LpL32lUViQ/HpkGFcMVw1pBTpp8fxU2dwEi1T-7jjnH3bR-DnJfg-tDD0iuQo1mnzaQ3lHdj5W8QbVyHvinvjzcuWGm2kLErUnOGr0OtwO3fCvCo1DxUFI/dxMtfE985JSu0jqgiGD6Rzh3OnxfbnEKPCSr_Ii3TA0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-9hjUC7iWseAAXViPKZ6GQ/hRDA26BH_J7d3j8NC9glrpAyEDPCc7CUtcjRNZQ2ENHqATKtXwVm0vyiyFnT4vAuE_g5NFtAxubS2Bkpxh5TjBWZfWwLgwkcVpPH_NpzerE/J8ysv5Eh9-YeyT-TZnySRQ9xT2BzuEHspZpsu3CZD7U'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pqloDSsSxT-wVkiOi1g2Xg/TxdxGI9E-JJbuwnpMuWWmhAzOI57qufgL8P3oNAQ70m5Go1TEiz08_i2kr3kLRuiasm4lLWakpo5bIEWPEzJD1biEOaGc0-3EQ5kRpcphbg/ESxCyhJC-x2DUe-1kF5o_dBX0ZK76fb73gXmaPZ3FO0'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/l6uU9LfKUwFxhrc__ZfB-w/aBP2fg7I5la7UI8GqCZ6iumqioys1CnuwizWVvRzc4770_WWZhH8jv2AaB3O_TevY7xJXz2ON9XujG6SY_asFN3e9MNeIavLsb9fRIsw294/k-LcgJDq6o75Z1tB5xzlIq4yq3QsFM3D0ebQSc3ITgQ'), ('width', 3000), ('height', 3000)]))]))])]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://www.keysight.com/us/en/home.html,https://www.keysight.com/us/en/assets/7018-01144/data-sheets/5988-8544.pdf,USA,5420.0,"Function / Arbitrary Waveform Generator, 20 MHz",https://www.keysight.com/us/en/products/waveform-and-function-generators.html,Write a Python script that uses Instrumentkit to connect to a Keysight 33220A RF Signal Generator,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782698/Instruments/RF%20Signal%20Generator/Keysight-33220A/Keysight-33220A.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,,"
",True,,"

Source code for instruments.agilent.agilent33220a
#!/usr/bin/env python
""""""
Provides support for the Agilent 33220a function generator.
""""""

# IMPORTS #####################################################################

from enum import Enum


from instruments.generic_scpi import SCPIFunctionGenerator
from instruments.units import ureg as u
from instruments.util_fns import (
    enum_property,
    int_property,
    bool_property,
    assume_units,
)


# CLASSES #####################################################################


class Agilent33220a(SCPIFunctionGenerator):

    """"""
    The `Agilent/Keysight 33220a`_ is a 20MHz function/arbitrary waveform
    generator. This model has been replaced by the Keysight 33500 series
    waveform generators. This class may or may not work with these newer
    models.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.agilent.Agilent33220a.open_gpibusb('/dev/ttyUSB0', 1)
    >>> inst.function = inst.Function.sinusoid
    >>> inst.frequency = 1 * u.kHz
    >>> inst.output = True

    .. _Agilent/Keysight 33220a: http://www.keysight.com/en/pd-127539-pn-33220A

    """"""

    # ENUMS #

    class Function(Enum):

        """"""
        Enum containing valid functions for the Agilent/Keysight 33220a
        """"""

        sinusoid = ""SIN""
        square = ""SQU""
        ramp = ""RAMP""
        pulse = ""PULS""
        noise = ""NOIS""
        dc = ""DC""
        user = ""USER""

    class LoadResistance(Enum):

        """"""
        Enum containing valid load resistance for the Agilent/Keysight 33220a
        """"""

        minimum = ""MIN""
        maximum = ""MAX""
        high_impedance = ""INF""

    class OutputPolarity(Enum):

        """"""
        Enum containg valid output polarity modes for the
        Agilent/Keysight 33220a
        """"""

        normal = ""NORM""
        inverted = ""INV""

    # PROPERTIES #

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        doc=""""""
        Gets/sets the output function of the function generator

        :type: `Agilent33220a.Function`
        """""",
        set_fmt=""{}:{}"",
    )

    duty_cycle = int_property(
        command=""FUNC:SQU:DCYC"",
        doc=""""""
        Gets/sets the duty cycle of a square wave.

        Duty cycle represents the amount of time that the square wave is at a
        high level.

        :type: `int`
        """""",
        valid_set=range(101),
    )

    ramp_symmetry = int_property(
        command=""FUNC:RAMP:SYMM"",
        doc=""""""
        Gets/sets the ramp symmetry for ramp waves.

        Symmetry represents the amount of time per cycle that the ramp wave is
        rising (unless polarity is inverted).

        :type: `int`
        """""",
        valid_set=range(101),
    )

    output = bool_property(
        command=""OUTP"",
        inst_true=""ON"",
        inst_false=""OFF"",
        doc=""""""
        Gets/sets the output enable status of the front panel output connector.

        The value `True` corresponds to the output being on, while `False` is
        the output being off.

        :type: `bool`
        """""",
    )

    output_sync = bool_property(
        command=""OUTP:SYNC"",
        inst_true=""ON"",
        inst_false=""OFF"",
        doc=""""""
        Gets/sets the enabled status of the front panel sync connector.

        :type: `bool`
        """""",
    )

    output_polarity = enum_property(
        command=""OUTP:POL"",
        enum=OutputPolarity,
        doc=""""""
        Gets/sets the polarity of the waveform relative to the offset voltage.

        :type: `~Agilent33220a.OutputPolarity`
        """""",
    )

    @property
    def load_resistance(self):
        """"""
        Gets/sets the desired output termination load (ie, the impedance of the
        load attached to the front panel output connector).

        The instrument has a fixed series output impedance of 50ohms. This
        function allows the instrument to compensate of the voltage divider
        and accurately report the voltage across the attached load.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units :math:`\\Omega` (ohm).
        :type: `~pint.Quantity` or `Agilent33220a.LoadResistance`
        """"""
        value = self.query(""OUTP:LOAD?"")
        try:
            return int(value) * u.ohm
        except ValueError:
            return self.LoadResistance(value.strip())

    @load_resistance.setter
    def load_resistance(self, newval):
        if isinstance(newval, self.LoadResistance):
            newval = newval.value
        else:
            newval = assume_units(newval, u.ohm).to(u.ohm).magnitude
            if (newval < 0) or (newval > 10000):
                raise ValueError(""Load resistance must be between 0 and 10,000"")
        self.sendcmd(f""OUTP:LOAD {newval}"")

    @property
    def phase(self):
        raise NotImplementedError

    @phase.setter
    def phase(self, newval):
        raise NotImplementedError


"
332,218.0,Keithley,Keithley 6514,Instrumentkit,"6514 electrometer combines flexible interfacing capabilities with current sensitivity, charge measurement capabilities, resolution, and speed that are equal or superior to our earlier electrometers. The Model 6514’s built-in IEEE-488, RS-232, and digital I/O interfaces make it simple to configure fully automated, high speed systems for low-level testing. The 5½-digit Model 6514 is designed for applications that demand fast, yet precise measurements of low currents, voltages from high resistance sources, charges, or high resistances. The Model 6514’s exceptional measurement performance comes at an affordable price. While its cost is comparable with that of many high end DMMs, the Model 6514 offers far greater current sensitivity and significantly lower voltage burden (as low as 20μV) than other instruments can provide.",https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6514-electrometer,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6514.py,Keithley 6514,"[OrderedDict([('id', 'att30haLadU97rFh4'), ('width', 320), ('height', 161), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_zTB4TuGzIYRnPcVwRjVDQ/UPpZeVW-T_yXt0MhrxMvkw5V2xIvEf7ooutY6Pm4BzZkBKfypSmcC6FVnGwAS21CycMU96MgdaicxT2be12XRW4WgMOssCSwYXbJqMKZSao/wS9l9Gyjt8-ieyeYyruXYFrEqT3iSBtCE1OF4f34Rec'), ('filename', '6514.webp'), ('size', 4232), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YA0Wi8qtwV3-GAVKiK_ELA/k1UEdQ7zsUJfuSnydxD32yhOhSjpVPxre6qSCHnSWoXEEk4H0Z3BCA4FA_l0nILJrNeDQ6FUNDQmS4VofA1zUtc87U0SKRh1qqyDBDcVq04/pkZn75CSSVqHwXIjvaP8qb3HtLDYEMmSKQruJCsGBjM'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sicf1yHnEuI3kL6EnOtgpw/-8VhMdkK3QZL_hKMrbLMi60x_PKbvrEGzLMeWtMO4xotWor_s8pKNR07Yt37Nfo291sB9GF3ER505s5pPoXwnfoqCDjchOfKfK1AGUGX0lg/T8bPxJwxgoJp65X3Ig2NVnu_v82i5f02OzcYxH8bGiQ'), ('width', 320), ('height', 161)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3gKRoqbyWL55pchVs-YXTQ/Tb7yQfKzzawESHBv3azMkRlRRS3_OGJWjtShYhUfklOIcA54RRVYrEtLusPCjlIIeriC6a95AYKatiAaT3YmosMVMq-rz3oAWtZbYGkrUmA/wlMIW4BMzGsIlDqhNz1gkrWpphMonDRA4G3xoLEyjgw'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/6514/electrometer-20pa-to-20ma-2v-to/dp/59K0092,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.farnell.com/datasheets/1484270.pdf,"Cleveland, Ohio, United States",110.6,"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.",https://en.wikipedia.org/wiki/Electrometer,Write a Python script that uses Instrumentkit to connect to a Keithley 6514 Power Meters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782717/Instruments/Power%20Meters/Keithley-6514/Keithley-6514.webp,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,11161.7,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
334,604.0,Thorlabs,Aptmotorcontroller,Instrumentkit,"The APT™ MST602 module is a dual-channel, high-resolution, rack-mounted stepper motor driver designed for use with the APT MMR601 Motion Control 19"" Modular Rack System. It has been designed to drive 2-phase bi-polar stepper motors up to 50 W, with or without encoder feedback, and is compatible with the full range of stepper-motor-equipped nanopositioning actuators and stages offered by Thorlabs. Alternatively, it is also compatible with any generic two-phase bi-polar motor of varying powers and varying cardinal step sizes. ",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,APT Stepper Motor Control Module,"[OrderedDict([('id', 'attYtJhsEvZTymA09'), ('width', 780), ('height', 508), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/b46BcPCKqj0zcLcb1OZ6Tw/Rex-0ZdmFeTuwAV43miqGv5AY35Q2CUEMSBVT-iO7faeOuTsk2atX9fOYN7CwQJP4pvrPAOEhyH6hLyWO3Q39qAGmJDUzv02jNTTdIr_iVo/bvp5746EmgdRQeyiDGW-42fJRzFuJpQJmCKDIPY1Avw'), ('filename', 'ETN012478-xl.jpg'), ('size', 49930), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_9LXnHXyejLTmezGt8sfWA/iknGat_p8HnJeobjfZ_LfcsbnRxHFW5yHZXbb0Lvh2FIw-SUwk_NFdI_SH8eVQ43QRyo-sjold9r86rKnujk7Q/Jmh-lffHdlxa-AFA_6f9YlPhVwk_sQPmJ7TOORnjvYc'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1A3_teW5JbtBaQCpuljXOg/4qLtkvtprn1i3NykFqa9L_BK5iWqzqnYSieGlPidAVZPOhw3V3STcLzq2yj4jjDYdl64HHY0z-S1y2ET4AHuZQ/jWXhmi-8Mz6BDnn5msiz3U_mD3DOFTIgLQqg8K_B9j8'), ('width', 780), ('height', 508)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_xZOf-Jh66Hp5tkT8o1wRg/SPZjr51Qs92iAer4UIoMK7P3_OOsNTgkVvqK3TOfzr9skDLIPINmZF87ZitDvNzDl8XFVNN4vCH6pH_ae54MzA/dv0q64u-3FFiOAskEOBlQMMUsK0ht-1ZBoMYEFZR2iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=1186,['Positional Controller'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ETN012478-D02.pdf&partNumber=MST602,USA,550.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a APT Stepper Motor Control Module Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782719/Instruments/Positional%20Controller/APT-Stepper-Motor-Control-Module/APT-Stepper-Motor-Control-Module.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,1523.17,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
337,543.0,Tektronix,Tekdpo 7000,Instrumentkit,"The MSO/DPO70000DX is one of the most advanced oscilloscopes in its class—enabling today's engineer to see signals better with minimal noise, debug signal anomalies faster and utilize measurement and analysis tools for automated compliance testing and other verifications",https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tekdpo70000.html,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tekdpo70000.html,DPO7000,"[OrderedDict([('id', 'attu9I3LtvUIcgvyq'), ('width', 540), ('height', 351), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2ZTc2fQ_q9pz-1fmpRKGsA/tina4soxCvaY2JOPCKrs-r-98_K1wj6dvDwV244VujXMC5oyS0SbpqOnnJ7ahLYBoBfEdQVxMFnFlU7CcrF-ffVvAHC92v9waNIkEfUguTE/CS-55HaeoHeeLhUR_rvlzYX1VYSE28tds--JHyjApgA'), ('filename', 'Tek-dpo73304.jpeg'), ('size', 55700), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bR5LvPKuwlIBcMoiwomzdw/KgNtnIOlQAoNBHelG2gF9Lg_Uk0EHlzalQCKEWKeWg9pVJuPmxzFpNcU3i0nfe2yvvnmDjaL3DOOA8bXmmjdhw/TOqXah1OQnBnpQrHjRWtzAzN_vRttp_wBeRiMnJjqs0'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zsTxYulgePIV7aEruqHslA/_R0AzDvNewrMCV2IKIb0mnna0kcC2LyCKyVDdw-8YNouwvCPDCna64QgJmOttdg02ZlyS-G6oIP6HWB1xSqGgA/9iewqR-lhHlJ2HvfUM6BaDn0MH82O2xnHOgUVQEAYGI'), ('width', 540), ('height', 351)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_jM1QA48-uIdvaz-bBQa-Q/nk1sHQvfHWdTQdgr4ykjUscOtG8pZVlkp6Sq7JimjCB-TcNY1rlLqMNYMHfPnb3tZOo78IFaqfbrL7SrJlPvmw/6KmnSg63WKlsJGZQ-Pf6BYjLtXNlmbSYcbGCQh2Q4LM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/oscilloscopes/dpo70000-mso70000?utm_source=Google&utm_medium=ppc&utm_term=&utm_content=Colts-and-Titans&utm_campaign=Evergreen-Tektronix-Mainstream-Scopes&_bt=623794827723&_bk=&_bm=&_bn=g&_bg=140123783248&gclid=Cj0KCQjw8NilBhDOARIsAHzpbLCFoQf1R6EyTEO3Cq_CaxeAyy1od8kPILEYzOvwRWPPA3R2dif-PQ4aAid7EALw_wcB,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a DPO7000 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782722/Instruments/Oscilloscopes/DPO7000/DPO7000.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,,,
341,599.0,Thorlabs,SC 10,Instrumentkit,"The easy-to-read LCD front panel provides access to the same commands as the included LabVIEW and LabWindows software packages. In addition to simply opening or closing the shutter, a repeating sequence of open and close events with exposure times as low as 10 ms can be set up and initiated either by a front panel button, a TTL pulse (+5 V), or a computer command via RS-232. Alternatively, the shutter can be synchronized to follow the rising and falling edges of an external voltage supplied over BNC.

",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/sc10.py,SC10,"[OrderedDict([('id', 'attuCdx2mUAVBjH8G'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5vVWqm1z69_lPGQqUS_oog/Pu4rDdCpihBWBZUtu--W0BjiRVMZ5QTSFKzSIbB14vhXGzl3dS3nHURtSWQ6NXvSbFd98MjSHFEnt9y4y3nUPS-2Rv2v277D3GbXZfdLvrQ/spYc8QJAawXcAEzYwvyWq9OjfDJls1OiP3GQVadeWck'), ('filename', '2698_SC10_SGL.jpg'), ('size', 29251), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8-s-6L5BC69X0ArSmhY-oQ/Cn6B0e5ZKQ8e8_VF1RP4ooFdbE5iaN4sUKqk3oKiQLk1ZPlicXwxmc2MbTJ3Np_KNq9r3o-RkhCZ5oinxxkeDg/2_xatoTsp-8_cZEBsUT1-4QDnEg67Bt2ul5igpS-okI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/63wBsEv4s9P5K22Eer-eQg/Orlm0_I7YUdg2CtTcxKMETGuxqk3Xcf5Fhgysx6DvccZuk9QQ6-WR5Gt6fljYM-7H77bHljE6L28bES3haLHRw/9jobnXyHe1uTRpFxT5FiDPpQolTAZ3E4Tha7pYjwsd0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SrkWSm4aabHkLAIFaw6hQw/r6HsQlJ8Qwhj1gXpf_0WdGDVK8aA0zMoVNJh-MZ5iCPiOc0DfrliEwu_l4UFp2Wzg7kGxig5WvmcXLFVN3CuBg/OytdJK7Y8sWx8qZmRGRJEtrjyZWq1OCtOWBvjd2QCpc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927&pn=SC10,['Shutter Controller'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=8654-D02.pdf&partNumber=SC10,USA,550.0,"Optical Shutters utilize a rotary, electro-mechanical actuator to provide millisecond shutter operation. During operation, these shutters remain in a closed position and then open when a pulse control signal is applied by an external controller. As long as the control voltage to the optical shutter remains high, the shutter stays open, but as soon as the voltage goes low, the shutter closes, providing inherent ""fail-safe"" operation. The frequency at which the device is opened and closed can be controlled. An optical sensor, which detects the shutter blade position in the housing, provides information that confirms the state of the optical shutter position. This makes it ideal in applications where a laser safety lockout is required.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927,Write a Python script that uses Instrumentkit to connect to a SC10 Shutter Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782726/Instruments/Shutter%20Controller/SC10/SC10.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,844.36,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
344,495.0,SRS,Srs ctc 100,Instrumentkit,"CTC100 Cryogenic Temperature Controller—a high performance instrument that can monitor and control temperatures with millikelvin resolution.

The CTC100 Cryogenic Temperature Controller is configured to suit a wide range of research and industrial applications. The system consists of four sensor inputs, two powered and four analog voltage outputs, and up to six feedback control loops.",https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsctc100-cryogenic-temperature-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsctc100.py,CTC100,"[OrderedDict([('id', 'attWJtT5pqwcUvIF4'), ('width', 3996), ('height', 2704), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/S3zd4uIisvCYy3EF3dzNAg/qyEcOfYFbJqUP6YdZq-lvNPMZTZAOZxFze03Yxtq4jnkbk4mDVnYwF8hDBaeNuh6w1CTOwEnp6NgT6iuRgyauMyATl8UCoWakVjbcrrH8X4/9EnqDbMDEEBKxH11IuvUBoJRtPYDmSdBLNziO1G1m0s'), ('filename', 'CTC100_Main2.jpg'), ('size', 2127759), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8jRFi3p2uxb_fRaT7AtqPw/QbWAI-6foWQIEVln8vN9XepszjZM8PPgRl_r1cxJJaPLtFjIbezOysZ4dNCNRCWkr-9WV5pPkICzcxd0gA2Z_g/VoahyI1btWRnVAfjsWxtpNxg1BES_0O3d9yVSbTcaG8'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y7CYTTPL-JUBwGioNCh56A/qN1XCyOEAyjoFL_QVolWBlbgN2bQj_2uWZyUHX2yUfAE-gTALXkuDgjVKXl71GypkohPfDpYgBVsZolwWUREJg/fPWW436tbvTfmDZbAMNlxSS0RJ67L4pH4u6CSqimRHI'), ('width', 757), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/K2ptCft8EdQfqwrbvMm3KQ/o5sIHS8mQOAQITS2u6NKhtI_SKDF0Sy7I3A6OsrHewO52nWkZb1y4FCOQOokdXYy6IYE_aNzz03JSzyAGRtDBw/ch4828b8H0ShVV2wkwI-QFwuYrvS68adWa6Gjb0yIDk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/ctc100.html,['Temperature Controllers'],"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GEdN_BmXtwosiOLFEHJAgw/PannVp8q7hX-OINFNDMu04EiCrGfkEyf_a7am51WUxStJWJi6HBGfO5RdARQLDysZaCfCkkKXkVdnbBukXGTQxbMCK3zp-sXBXczPXScTp0/_OM_giJ55r-yDN3fv-xuCU3fuzytXkA-VelTj5P3j7o'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ktg3MJbM5fVSVdt3fMZrOQ/LnTb8WIGKn6y_2rylP2WzkQ5L3ZhqlQEjFezXnTPhyjYOl55KR733DJxZu8jSIOSHKhRwYfN1eTa4-Zpgi2KuQ/XMNQhs49wJC3pMlfni4bL2RzeB3pN0Wk_qmWOTM4Vok'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1GQ22ccu1nNLIdB_kUsgfA/S6JBQA_uRz1xktSChfAXHi9LBJkX2rNur5kgkZys5yQodnemo8ASB4BXFtvZ4ohvR7kt3ldfdyMU2Wxll8bkkQ/FAkTJm-bqxYi8JWUJUJLpHFt8sToHJTlydzPVyl4Kbg'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ecfa4InLTffUJ3uIvbLfSg/ku6PGtHKgjADwD6exgPngQF-R0vvCpdp2D6CYiddskBPk5658MnGv4KWNfiGmFd05lfyJB7xff2-qaCoMeLxFg/cjsWt7n5d1Mo-_pS1qdQpSz4ZodrswGC4enbHZNGmXw'), ('width', 3000), ('height', 3000)]))]))])]","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://www.thinksrs.com/index.html,https://www.thinksrs.com/downloads/pdfs/catalog/CTC100c.pdf,"Sunnyvale, California",24.9,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Instrumentkit to connect to a CTC100 Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782728/Instruments/Temperature%20Controllers/CTC100/CTC100.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,3495.0,,,,"

Source code for instruments.srs.srs345
#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )


"
347,419.0,Picowatt,Picowattavs 47,Instrumentkit,The Picowatt AVS 47 is a resistance bridge used to measure the resistance of low-temperature sensors.,https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/picowatt/picowattavs47.py,AVS 47,"[OrderedDict([('id', 'attLoXHvdB7eWnmFg'), ('width', 2935), ('height', 1593), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/abP_VOlsp5QfVd2YAOn6vw/x0J08MavuZO3goCB7-kX6QwS4GlANmykRAdN-T-l3EP6FK160h9HQJiY0OnXUlSNsnp--82feUsAPs3Y2pDuOMScdEFgPLikMP7GfFCY5Zyj6qIlOSSa18YYztO4IBr4/TmMGP5DE9ZzCuB1Y2cw01MC-z_58CJEqhHxsbEDkeok'), ('filename', 'avs48si_physical_front_panel.jpg'), ('size', 188257), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kYW3X4nvfpbr9jnt8zAJiA/up4oP9FH0uAU1phCxFCVa_JhZOczi5g2S3-Bky7IndfS_KX5u3vhfB2blRN4PBVSiP35y-1884l3kcx1P1WDfQ/Oxt3O65ZkN4sNmYMxpsrtXyEYbN80uE_I1L2r_itZDo'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oeF78jpQCRtif2nRGXOS6Q/-luYEa5TpRmglkMS5cW7IclnQF3H1u-hk4OiD9fLp1128yothtsbWE85FlyC70DrNnIEn0zPJn6-6m_HLOT5ew/os_L4UsCI4awhVRntVrAHAeSr8rcE6mI1gWGY8c6F80'), ('width', 943), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pNzf8B3qPv8UgQHTdPWZGg/SWHVYrSJv3-fI-jJ8YFUJ6nPXAzYlYt3EKuoRzEHLpq_2OLHXZFi3W6-keYuhSrhYjFq4HS1wwjxcl-4OkrkuQ/rQvu3l96c0yAIYrcHzra3kLzKWARi3D8vornQWu6UvA'), ('width', 3000), ('height', 3000)]))]))])]",https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,['Temperature Controllers'],"[OrderedDict([('id', 'attgTI15cND1GBG9f'), ('width', 150), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZOsdjZI8YXZO1g-LGiRBMQ/tIV5OdeZ9f4ANbAPsPe8dAwOFR7yeI5Z_LrepynWK1hk1CViY2hBstv2afb7HoNBPhCDkT12JApaOwCYAH6nHUM_ynMdPexkCdHNEmvPYHw/S-oqP65cztGL0SoRm5EBsV5fQTf8hjAa7STysyNpq-U'), ('filename', 'logotext.gif'), ('size', 543), ('type', 'image/gif'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iN__NLlzMTreeW-ACwi8Qw/9Zh9nXkzSxyqAWXjVX2viFDutwcsVTEM2HtesLSIg17p-jJoKFrGRypeZ5-hxMcvZdA7OzsZ_tZqKDkn78V2vg/mYi2nSqwObQOz4VsYLN4bRfHTxgA02qMFIgeU1W5gPM'), ('width', 108), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tRGLXF9qtPHrls4VzhKKnw/AlVQu_tmEl2TzRAG7TzWialmjr-v4vwJ6r1WYXBlEfAxD8xmIfIq6i_JP3wg6mBaEwsagqUDUExE5RuTTdyBjg/qfhFQQBQgprSh1Av9KPjhM2SzlKgtyrBORZSN0U7uO4'), ('width', 150), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CBlm6q2PBj-RG3elaMxq_w/uAcL7NF5sY5SZ59AEGrWsyce-mP03h8n7Iv42LvSSWL1NKzkpeJGBYK3Q_PeM9bYlaxysoEi_1k05iwbbK8l2w/BmjHv0O6jL7H06p-SG67_tY4KTzAEjgrr-rodEI5ZDs'), ('width', 3000), ('height', 3000)]))]))])]","RV-Elektroniikka Oy PICOWATT is specialized in manufacturing instruments for thermometry at ultralow temperatures. Founded in February 1978, we have gathered 45 years of experience in designing and manufacturing low-noise precision
",https://www.picowatt.fi/index1.html,https://www.picowatt.fi/interfacing/avs47_serial_usb/avs47_serial_usb_w_userguide.pdf,Finland,5.0,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Instrumentkit to connect to a AVS 47 Temperature Controllers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782731/Instruments/Temperature%20Controllers/AVS-47/AVS-47.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116673/Instruments/Vendor%20Logos/Picowatt.png,,,True,,"

Source code for instruments.picowatt.picowattavs47
#!/usr/bin/env python
""""""
Provides support for the Picowatt AVS 47 resistance bridge
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import enum_property, bool_property, int_property, ProxyList

# CLASSES #####################################################################


class PicowattAVS47(SCPIInstrument):

    """"""
    The Picowatt AVS 47 is a resistance bridge used to measure the resistance
    of low-temperature sensors.

    Example usage:

    >>> import instruments as ik
    >>> bridge = ik.picowatt.PicowattAVS47.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print bridge.sensor[0].resistance
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""HDR 0"")  # Disables response headers from replies

    # INNER CLASSES #

    class Sensor:

        """"""
        Class representing a sensor on the PicowattAVS47

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `PicowattAVS47` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx  # The AVS47 is actually zero-based indexing! Wow!

        @property
        def resistance(self):
            """"""
            Gets the resistance. It first ensures that the next measurement
            reading is up to date by first sending the ""ADC"" command.

            :units: :math:`\\Omega` (ohms)
            :rtype: `~pint.Quantity`
            """"""
            # First make sure the mux is on the correct channel
            if self._parent.mux_channel != self._idx:
                self._parent.input_source = self._parent.InputSource.ground
                self._parent.mux_channel = self._idx
                self._parent.input_source = self._parent.InputSource.actual
            # Next, prep a measurement with the ADC command
            self._parent.sendcmd(""ADC"")
            return float(self._parent.query(""RES?"")) * u.ohm

    # ENUMS #

    class InputSource(IntEnum):
        """"""
        Enum containing valid input source modes for the AVS 47
        """"""

        ground = 0
        actual = 1
        reference = 2

    # PROPERTIES #

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        :rtype: `~PicowattAVS47.Sensor`

        .. seealso::
            `PicowattAVS47` for an example using this property.
        """"""
        return ProxyList(self, PicowattAVS47.Sensor, range(8))

    remote = bool_property(
        command=""REM"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""
        Gets/sets the remote mode state.

        Enabling the remote mode allows all settings to be changed by computer
        interface and locks-out the front panel.

        :type: `bool`
        """""",
    )

    input_source = enum_property(
        command=""INP"",
        enum=InputSource,
        input_decoration=int,
        doc=""""""
        Gets/sets the input source.

        :type: `PicowattAVS47.InputSource`
        """""",
    )

    mux_channel = int_property(
        command=""MUX"",
        doc=""""""
        Gets/sets the multiplexer sensor number.
        It is recommended that you ground the input before switching the
        multiplexer channel.

        Valid mux channel values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )

    excitation = int_property(
        command=""EXC"",
        doc=""""""
        Gets/sets the excitation sensor number.

        Valid excitation sensor values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )

    display = int_property(
        command=""DIS"",
        doc=""""""
        Gets/sets the sensor that is displayed on the front panel.

        Valid display sensor values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )


"
348,602.0,Thorlabs,Aptpiezostage,Instrumentkit,"The LPS710E(/M) Amplified Piezo Stage provides long range, fine focus Z-axis travel for a microscope slide while maintaining a compact, low-profile footprint. It features submicron repeatability, nanometer positioning resolution, low angular error, and fast millisecond response and settling times. When used with the LPSA1(/M) microscope slide holder, the stage is ideal for imaging modalities requiring sensitive sample positioning and sectioning, such as confocal laser scanning microscopy. This stage is not compatible with trans-illumination.",https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,LPS710E/M,"[OrderedDict([('id', 'attM8R0YwBzGU5Fsz'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QNsIGrjDFcP1N_K1GcnAQg/GPswfa6RMaFrbWqCUJQdr-QOFdzFYvwUk5QS6230Tkz5W-vn7_Cn8m0C04KbXEC7-Vzbb4sZuwnioGIRW9yWcYFNPjOj2L_MgCLydthODA0/SybB-nbtv5XlzumTmrtTUgjEXew5ag1c8D6GHlROSn8'), ('filename', 'ETN035405-xl.jpg'), ('size', 40288), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nkDRYiiDtLTp4F82n7WTfQ/AYy3tXyfSrncwo8L6rlFqDDElxxWLJkTBEiT7sN2wQKcq3JtOXjLDkna1W1wtrCSH2h_ct5sgl1kwdR_rOxn2A/Z3YcNZgjv6v7Ai_L_zWkOvKMwjn3ElaGbMMe-hGEG48'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PeQuyA_KY_qNLVJ4aibJGg/GCZKSH9HpAgutHToI7euGpCeoPDikFifcWcXGSOgz4Be65rav50LrlxTEeJWcgOU0uXokWPsj4fsHLuCj0VKOg/Hab2DAfapFxT3YWyvR1Bgzz3_qLFRVJpN6jhZeZEr9M'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-Ky6e1iDq2MjLBzHIn7E9w/08Gchfg1PV3Jf-HRoqtidJEDagdRB0PvM7sHygXw_jbcEmNPJGWKsOgq5-vIElFaI-gncXcrQlM-s8Ok6r32wQ/jeCzE0337TIiJsn8Eq_NSEW01XhWsocklHwWnYGTs7Y'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=11303,['Positional Controller'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xGJR34R9-fm008VXahWvMA/HKf2MdugH1FbTlfMoqUrSx7RKRRELsiW8roGFIRpNrgchtmi54kCZ6piWp1xfxGPhpw0PQVT8cSmn7cJM5MjaUPWrYKq6te9D1nLJUfiYY4/o-ei6zIG3ifeOBuqo1HmEiSGUl_OxG4OnB8dwnM4PUQ'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h8Fywnn9onEETXMBTC47jw/hCDvJB6IOqNLJWr8Vj8enQrXbLxm75QoUb6FqLeWM20Fp3SmBBza0DVYGK1_SwO4O5gLpbhDvaaVB7KYh4UtzQ/CsfYocBqC9AO5cc0I5WW6sx2q6Oj46otiX7SdX-d3uM'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eK8II0SgsB7vFRqGAQl-GA/BP9D35lsbjjMs7wnkyudsWUjAi_H0-z28xPHID2D0bkR4z6ShdMH1x588dDR--J-4Mz3gaRtIWVKls2eG1XWpw/NJCW-6MsKADIPwUt9yMbTqWc0DwbJAULTORlwaYC5To'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gbQwdX2o6LbdWhxeeHvw-w/8Xs43YS7oUkIHJr23Nq0g6t7EkonU7X-6HNLtRt6M4eryJ79Y3l-ehFhKUCJ0EmqZkMhC9OIc0FNg6zJJ3qWyw/CqE4okkZVKx8gpxZwPLM49AXd_BTTFMIKwi6E5NZVbQ'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ETN035405-D02.pdf&partNumber=LPS710E,USA,550.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumentkit to connect to a LPS710E/M Positional Controller,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782731/Instruments/Positional%20Controller/LPS710E-M/LPS710E-M.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116721/Instruments/Vendor%20Logos/Thorlabs.png,5309.35,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
357,497.0,SRS,SRS 830,Instrumentkit,SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs830-lock-in-amplifier,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs830.py,SRS 830,"[OrderedDict([('id', 'attNaj1PW0Au0Ue7A'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/664ElZ0KRFvr9bGwBistew/GAXbFm4AgOb0i6pYkNEO8lGSkPfF357m7JM2VlTcx6HDqhw_7rR37dpB4vxdNqBCJy_-cTJ0xnP_OxJX72pibF_Le4Eff_zxb2VM6eZv0Kw/nyPamAz3O3zcAxMiIpIQGdmpSNy2wOIt8oFfA7QkhiA'), ('filename', 'SR830_FP_Wide1.jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Kv0rz_wVccTV5eN5QD-qIA/i2EshlXPq_E4oEoYvXGKbEhsIjaOeLvEut98AdvRtpM7Q4D3s9VovwDGhMyYw86I7p3r-UJfqq5XrA-OHcrMZw/nmgpe5Uyqw1DRjGp8cIESx7q55qZp8BmsaUMXmc3-Ak'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FXAzk7kf4lFInvl39fr1_g/_svnrCH3OkS-7idMmdCwMiwGJpvxzOTejApy-0W4gu7MIv09gD9qED5EmRGeKLqUbeNXb_vODmvqWGyVvOXn4A/HWpgfFfeFvfqF96x7EbVrmPjn9xdEEUXO1XmJIDU8Ts'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Yq8w25GfCKyFbuGrXq5AYA/ZAWsz55bAvm4V1Ll48Q5q_TuOdBqAxmXcpKLyCANFALWsoiraeADITLJlkZ8GpPae6wbaTdIKZEBi5_x6jTxvw/8LSB3UyKHrKMlY7LRFNBaauV0DUuy7w1DeFH9XE0I-s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr810830.htm,['Lockin Amplifiers'],"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GEdN_BmXtwosiOLFEHJAgw/PannVp8q7hX-OINFNDMu04EiCrGfkEyf_a7am51WUxStJWJi6HBGfO5RdARQLDysZaCfCkkKXkVdnbBukXGTQxbMCK3zp-sXBXczPXScTp0/_OM_giJ55r-yDN3fv-xuCU3fuzytXkA-VelTj5P3j7o'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ktg3MJbM5fVSVdt3fMZrOQ/LnTb8WIGKn6y_2rylP2WzkQ5L3ZhqlQEjFezXnTPhyjYOl55KR733DJxZu8jSIOSHKhRwYfN1eTa4-Zpgi2KuQ/XMNQhs49wJC3pMlfni4bL2RzeB3pN0Wk_qmWOTM4Vok'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1GQ22ccu1nNLIdB_kUsgfA/S6JBQA_uRz1xktSChfAXHi9LBJkX2rNur5kgkZys5yQodnemo8ASB4BXFtvZ4ohvR7kt3ldfdyMU2Wxll8bkkQ/FAkTJm-bqxYi8JWUJUJLpHFt8sToHJTlydzPVyl4Kbg'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ecfa4InLTffUJ3uIvbLfSg/ku6PGtHKgjADwD6exgPngQF-R0vvCpdp2D6CYiddskBPk5658MnGv4KWNfiGmFd05lfyJB7xff2-qaCoMeLxFg/cjsWt7n5d1Mo-_pS1qdQpSz4ZodrswGC4enbHZNGmXw'), ('width', 3000), ('height', 3000)]))]))])]","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://www.thinksrs.com/index.html,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,"Sunnyvale, California",24.9,"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,Write a Python script that uses Instrumentkit to connect to a {Device name} Lockin Amplifiers,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782548/Instruments/Lockin%20Amplifiers/SR-830/SR-830.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,4250.0,,,,"

Source code for instruments.srs.srs345
#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )


"
358,496.0,SRS,Srs dg645,Instrumentkit,"The DG645 is a versatile digital delay/pulse generator that provides precisely defined pulses at repetition rates up to 10 MHz. The instrument offers several improvements over older designs—lower jitter, higher accuracy, faster trigger rates, and more outputs. The DG645 also has Ethernet, GPIB and RS-232 interfaces for computer or network control of the instrument.",https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsdg645-digital-delay-generator,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsdg645.py,DG645,"[OrderedDict([('id', 'attQqnPuoAadlGes3'), ('width', 2000), ('height', 1435), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1Ua4-ByYk_YlIVRofP80Fg/cpASpBQqDZw8HCaEhyzfRpx9kJmbTRKfiRWWvXF1y-mPgbpsO9T7Cg8MvOl-vZFLd5yMZlhnXRJld3CiqFVUzcH8ezHUDDxA_6eC8mtsKK4/MWr8lxStjycwTSBivCiSCkmSvJty3c4Tx9WR886URy0'), ('filename', 'DG645_Wide_Reflect.jpg'), ('size', 472623), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kFeS1_eaxuh47DFbRqdHUw/ZBBZ3R3zjpoAIAYBwy2aWcObRNU5C3vOeIZGBVYb8SN4LWh0HlmQ874vQrnNI-rzlei4GJczuH7268ivO39u7A/sqF2Rv4t24MTL5uqPrqv6RVjxPAKZC6_lanwRlT9YLc'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VdaIYLj13eQXAF2C2gxKpQ/qFcVMRThGHBNmEu-BHLu1YGv7HG6tLFQOCmjw7hi9ISJqoxkAApfXAie7771ttuXckyy-eAR3Uow4qP2r4pECQ/0Z9qMBMTZywACCb_slKnqdS7mqUbN9rvS5dstQdECbw'), ('width', 714), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/21ifb3i9JbYeuzDdi_5Uug/qXxLa-KWbo12aGkjQRY4lRQVW2H3nhpsYaMkZKgm6c5Cj5oI8oM3h0XufdVqrNXNF_EdGTUAGUtyDSUxgiqQjA/5MeY3LozsyV0QHIypJesinJwQMUlG4-W3Nyd2UseDsM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/dg645.html,['Pulse Generator'],"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GEdN_BmXtwosiOLFEHJAgw/PannVp8q7hX-OINFNDMu04EiCrGfkEyf_a7am51WUxStJWJi6HBGfO5RdARQLDysZaCfCkkKXkVdnbBukXGTQxbMCK3zp-sXBXczPXScTp0/_OM_giJ55r-yDN3fv-xuCU3fuzytXkA-VelTj5P3j7o'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ktg3MJbM5fVSVdt3fMZrOQ/LnTb8WIGKn6y_2rylP2WzkQ5L3ZhqlQEjFezXnTPhyjYOl55KR733DJxZu8jSIOSHKhRwYfN1eTa4-Zpgi2KuQ/XMNQhs49wJC3pMlfni4bL2RzeB3pN0Wk_qmWOTM4Vok'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1GQ22ccu1nNLIdB_kUsgfA/S6JBQA_uRz1xktSChfAXHi9LBJkX2rNur5kgkZys5yQodnemo8ASB4BXFtvZ4ohvR7kt3ldfdyMU2Wxll8bkkQ/FAkTJm-bqxYi8JWUJUJLpHFt8sToHJTlydzPVyl4Kbg'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ecfa4InLTffUJ3uIvbLfSg/ku6PGtHKgjADwD6exgPngQF-R0vvCpdp2D6CYiddskBPk5658MnGv4KWNfiGmFd05lfyJB7xff2-qaCoMeLxFg/cjsWt7n5d1Mo-_pS1qdQpSz4ZodrswGC4enbHZNGmXw'), ('width', 3000), ('height', 3000)]))]))])]","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://www.thinksrs.com/index.html,https://www.thinksrs.com/downloads/pdfs/catalog/DG645c.pdf,"Sunnyvale, California",24.9,A pulse generator is either an electronic circuit or a piece of electronic test equipment used to generate rectangular pulses. Pulse generators are used primarily for working with digital circuits; related function generators are used primarily for analog circuits.,https://en.wikipedia.org/wiki/Pulse_generator,Write a Python script that uses Instrumentkit to connect to a DG645 Pulse Generator,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782433/Instruments/Pulse%20Generator/DG-645/DG-645.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,4695.0,,,,"

Source code for instruments.srs.srs345
#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )


"
369,584.0,Teledyne,Maui,Instrumentkit,"The WaveMaster 8 Zi-B combines the performance, signal fidelity and feature set needed for today’s high-speed measurements with the ease of use of a standard benchtop oscilloscope. Featuring the highest-speed serial data triggers, the only complete multi-lane serial data analysis and eye diagram solution, and the most comprehensive set of compliance packages, the WaveMaster 8 Zi-B simplifies the most complex testing.",https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,WaveMaster / SDA /DDA 8 Zi-B,"[OrderedDict([('id', 'att9dZv0ctFtBQxTK'), ('width', 665), ('height', 705), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KWXqU6iGWiKK7a8t6axKmw/RNbzuBaE_79_h4mMj2O3qvtGjadjbFL-jszTbpxGuHSlmuc1VUnSH0puYzvfiTR1mrPqgXnE75CBsv2Nk-NsGWemAfnO3oNZn8vBaznuBhk/YvXlSXTJc6ZQvBzuj9fipF_gT8BaM1GFDXQs0wQ3BoU'), ('filename', 'wavemaster8zi-b-02.png'), ('size', 436672), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5P3PKuyu3Vu-t4tpc_EjsA/WBVwxx_L6Px-nV4WaceD3fPVjnICXGSLPfpKElS3DRSrxlIl2oqaJ4VGIRWQcYhIs7U6qJ-3wy2C8kw08snAlA/HopgSYEgyZdlbKQiWyT6GE0ycZBLpKsz-40aUtbZbFM'), ('width', 34), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/R68zSU4YM17K9zMi2G7htQ/wwvz4qJq8rhm1NNCTqchT0wov9fYuVdWDzRxbL00MTnvl9KdJC38d8usg5c0BgvksOSwaY1UyEnDphrROwmh4w/U4E6s8APGMC2xh0U7-wauSYhB8mJfQVGjawYCt2-vcQ'), ('width', 512), ('height', 543)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mzZEEMZNCcP0Nl9k2OVUig/05NtZwbx4-WckR73Z50CoDLPMy-sZ3vPnq2QUYGQ6kB1hCx8_JANWN_anFIBmey6RX0zeFAztY1N0PHQvd_WsA/2SHdiMQRmBJdWPHOFUl9fAULreJe0wiCvMU9sU0wYts'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavemaster-sda-dda-8-zi-b-oscilloscopes,['Oscilloscopes'],"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iB-Dze0FOgUudS4JhfTLPg/WDExKBInbADn0xDZEeQOmvJJ7oIKxqq-tkgptm2stU2jMbzjlzINAuCr8TpbnTY83UGWA1LLinoqZkOT98qVlYVbcXtPF9-TVTcrwxBjwoI/bhVubL3Ms24LbmBLzebglm9Hxe7-ayrf4MEaOfVaiBY'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Sj7BXHh-GQRN5zmqO0366g/vOubzy7kXmytep8itlfKZ_smL1Cwa82U0lXFY5YZCDYGxisaQ0T_iYtLUHYs5_O18rofG_nip4C18YxTtoJF8w/hkrUT2G1YqEC3w6PBRmOSzLE6AZckheOkCf68F3AX-U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epbQ8kZyKl8hHgVjLsAOwg/1vP9SWVL2ofS0Qe2oiUdWu_S-J0Y-0nFVm6j2ijpbv6JPUq5v2q5L4ZrwahDvHZs9JoVGlsi7dNw5emPrqvaMg/fjSFH6NuaQiUrJNO20RL6bRnVkfPe_DehFEVu4cBfS8'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6gr5jK8jwZcO1T1qLtZF7Q/lGLdeki0zm9HfmNkksT1hXsqQ5bA3ePWRHNiZ6V2crLaGHLhqG1J637uvDEWvfzwZyPvlRgrSJJXKwNDh6KsNw/YqzRiPFGjNPx3GV3OuBDTp7rFxe00nUGA7SDtT1P-9g'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://www.teledynelecroy.com/,https://cdn.teledynelecroy.com/files/pdf/wavemaster-8zi-b-datasheet.pdf,USA,5458.6,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a WaveMaster / SDA /DDA 8 Zi-B Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782751/Instruments/Oscilloscopes/WaveMaster---SDA--DDA-8-Zi-B/WaveMaster---SDA--DDA-8-Zi-B.png,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116678/Instruments/Vendor%20Logos/Teledyne_logo.png,,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
377,551.0,Tektronix,Tektds 5 XX,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,TDS500 Series,"[OrderedDict([('id', 'attyKXRy1zDMMnNf2'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OiuoGc9LWMZdPKWpoe1mVg/XkjVLwrBJZLmF2fSh3yK7mB5n-X8MAADorAtG4EuapMYLr0aWMe1-y_NTrY36azsFxNXBXkw2vuHRNl66AZFo4g6orsiqkF6LnnV6TRJiMM/-pXhUACGE9rH4oarzspLyF-hnTY3lt6r-HmrWWFixF4'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XXoAg1inhpla8y9OH4-5wQ/9t4ndyhoYSaUuJvaI1gU_ndzhJQiPvXUpqec44Jjq-PkuJUsDhZV6TTl2GcKwt0cBzqFOyg6Bt13UmNw-GndxQ/MC-fhrpiJVexT--41Lkf1nbedklX6xm-MRBhi2x-Buo'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZErkrwML7EkCWOnjHRXJXw/jgFWX8hTF-wKqhUiu9OOq-TENwr1YEkOy7035scuDD-1ggCbFURR6oChdbbGKGScQHDBzdtBaUqC6SnWhH7f2A/rpN9U04faRehXI9GS89l5n7nqlGMEjklgJ-2nZu_fGc'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bbDkFodELBIUpSZEqFn48A/Obz5CoDxZXHLMSViS8NauRUXId7ZzDtyjl659pfsccxi0J6VffwefH3A4B51kXLwInnOuG_CieYYv6J7KD8QaA/dk25_Y4jaAgyDsoARid8lgaTRScPIaIlw_VGhR8QHuI'), ('width', 3000), ('height', 3000)]))]))])]",,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782757/Instruments/Oscilloscopes/TDS500-Series/TDS500-Series.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
383,149.0,HP,HP 3456 A,Instrumentkit,3456A 6 1/2 Digit Digital Multimeter,https://instrumentkit.readthedocs.io/en/latest/apiref/hp.html#hp3456a-digital-voltmeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hp/hp3456a.py,Keysight 3456A,"[OrderedDict([('id', 'att0ooJCGULf7i5fN'), ('width', 900), ('height', 288), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-ulpNzXF9AFb3zEQRifk5Q/sanIQ1fJ2FPflU3qJ5tejlHRzOFNKuaTYrn09-ib5QRaN8xAf5BZPTxLHKrka2zoJTO-OzjQMgkZdv1bvIj0igheTWb7DIE2UU0RtD9StSk/bAx_pUL36B1Kn0Wy0bnSu-WeZsXhsGhyT_8EdFfIRD4'), ('filename', 'face_1.jpg'), ('size', 64705), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ew0T6XH2OhijRiaUos1sSw/-nvjhyLwjczYgJWGT93Rq4ffwNe1xSi_T7MjUWePxKaufhVvqAIOS7fo4vdCD_k4jLds05yjfpYGRCx62NyduA/0R11IXCwGds-cs9fgz6oE8Gv4N1LIrz1jUB9gqEXWVI'), ('width', 113), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wndebn9cSQYwy3cwmFr2lQ/LpdgYNc5xjP35QPEKNaCReuYz7epFBUGev-_oWtten0kOVQ3rZOM8nzIm2qk8CwcjxvbHqbzqiRm38TMr50ZjQ/DJ9sM9TUTuzlsyvSFf53dpvYhRKWJ-IQ6Uw14jrV9mM'), ('width', 900), ('height', 288)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YmV0q5BUsvsOTMZdKRrtpw/Xk5-SSiZYJE4VOnBCrioKQRiwNqf9LdxHeQb5IEew6tJaYX_xLNsYhVeIIYVYASztqtfWa_-LCTose2-XKoz0g/EuDhyssgrgK3Dpcmg97QcTXbgsGXDV2w3XE_-_8-35I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/3456A/6-12-digit-digital-multimeter.html,['Multimeters'],"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KLdW4e0aCMvuXtiF41lm5Q/tsULR905frVMXXpSBwX--GGG9pd67YfJfVqUbiphB7yi1YiZaesAKIc0H5OSMeujmzTnzL_TYJFKsYOLX2M-HuYgDDy464YMgOwWmAd540U/CQIhv7AHEyD7_1uuRrDXD-cM5HYvTXSunU9vcixsAug'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hlmdofa38jYloahcVSLpNw/3p9k2-zlW4PdZXOINyi5WevKuox8MEkgKxpfU8qhRNpuf6uCOaEc-SiDI8AOTUAw7YWp8NRCdU2dgc1P7EdU6HAyjmQbiEO3Hp3vcYlrIOY/Q6c584Zg-Ge5NIW7DvdQ-5bvCuyqJrmDmg6PDWARSL4'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dR-u6vcQ_qWkh_hzfJEdxQ/CqsqK2EnfYs5VLISQZ0OFYxQu_f9UQE_4pV_CakymtxZEGedpRn5KZvpsUnaybslmwwnrzvwiTZYPMP4emI5NC_nZxdGIx1ebsyYeKzRvnI/_oVf9TubhrO_RGOizCZPQfUHwNRQejxeIB_SREKXPHo'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SUaU78ZSlXE2XNRXeJAbJA/6bdGaHs7U5UbkXguW0uCC_jxHbNmi66L6y9XdaPyQYZhXOjcQsnb5Vx_VObVUE-pJ0UAWtZ88P0_zZN1TD3orExVUQe-wN3ukqEB7ShXXFw/tZAWl3xpv2JxN3HZABBPT7KYR938lcxPG87n9cnzOC0'), ('width', 3000), ('height', 3000)]))]))])]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://www.keysight.com/us/en/home.html,Not Available,USA,5420.0,"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",https://en.wikipedia.org/wiki/Multimeter,Write a Python script that uses Instrumentkit to connect to a Keysight 3456A Multimeters,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782761/Instruments/Multimeters/Keysight-3456A/Keysight-3456A.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116715/Instruments/Vendor%20Logos/HP.png,,,True,,"

Source code for instruments.hp.hp3456a
#!/usr/bin/env python
#
# hp3456a.py: Driver for the HP3456a Digital Voltmeter.
#
# © 2014 Willem Dijkstra (wpd@xs4all.nl).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the HP3456a Digital Voltmeter

Originally contributed and copyright held by Willem Dijkstra (wpd@xs4all.nl)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

import time
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u
from instruments.util_fns import assume_units, bool_property, enum_property

# CLASSES #####################################################################


class HP3456a(Multimeter):

    """"""The `HP3456a` is a 6 1/2 digit bench multimeter.

    It supports DCV, ACV, ACV + DCV, 2 wire Ohms, 4 wire Ohms, DCV/DCV Ratio,
    ACV/DCV Ratio, Offset compensated 2 wire Ohms and Offset compensated 4 wire
    Ohms measurements.

    Measurements can be further extended using a system math mode that allows
    for pass/fail, statistics, dB/dBm, null, scale and percentage readings.

    `HP3456a` is a HPIB / pre-448.2 instrument.
    """"""

    def __init__(self, filelike):
        """"""
        Initialise the instrument, and set the required eos, eoi needed for
        communication.
        """"""
        super().__init__(filelike)
        self.timeout = 15 * u.second
        self.terminator = ""\r""
        self.sendcmd(""HO0T4SO1"")
        self._null = False

    # ENUMS ##

    class MathMode(IntEnum):

        """"""
        Enum with the supported math modes
        """"""

        off = 0
        pass_fail = 1
        statistic = 2
        null = 3
        dbm = 4
        thermistor_f = 5
        thermistor_c = 6
        scale = 7
        percent = 8
        db = 9

    class Mode(Enum):

        """"""
        Enum containing the supported mode codes
        """"""

        #: DC voltage
        dcv = ""S0F1""
        #: AC voltage
        acv = ""S0F2""
        #: RMS of DC + AC voltage
        acvdcv = ""S0F3""
        #: 2 wire resistance
        resistance_2wire = ""S0F4""
        #: 4 wire resistance
        resistance_4wire = ""S0F5""
        #: ratio DC / DC voltage
        ratio_dcv_dcv = ""S1F1""
        #: ratio AC / DC voltage
        ratio_acv_dcv = ""S1F2""
        #: ratio (AC + DC) / DC voltage
        ratio_acvdcv_dcv = ""S1F3""
        #: offset compensated 2 wire resistance
        oc_resistence_2wire = ""S1F4""
        #: offset compensated 4 wire resistance
        oc_resistence_4wire = ""S1F5""

    class Register(Enum):

        """"""
        Enum with the register names for all `HP3456a` internal registers.
        """"""

        number_of_readings = ""N""
        number_of_digits = ""G""
        nplc = ""I""
        delay = ""D""
        mean = ""M""
        variance = ""V""
        count = ""C""
        lower = ""L""
        r = ""R""
        upper = ""U""
        y = ""Y""
        z = ""Z""

    class TriggerMode(IntEnum):

        """"""
        Enum with valid trigger modes.
        """"""

        internal = 1
        external = 2
        single = 3
        hold = 4

    class ValidRange(Enum):

        """"""
        Enum with the valid ranges for voltage, resistance, and number of
        powerline cycles to integrate over.

        """"""

        voltage = (1e-1, 1e0, 1e1, 1e2, 1e3)
        resistance = (1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9)
        nplc = (1e-1, 1e0, 1e1, 1e2)

    # PROPERTIES ##

    mode = enum_property(
        """",
        Mode,
        doc=""""""Set the measurement mode.

        :type: `HP3456a.Mode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    autozero = bool_property(
        ""Z"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the autozero mode.

        This is used to compensate for offsets in the dc
        input amplifier circuit of the multimeter. If set, the amplifier""s input
        circuit is shorted to ground prior to actual measurement in order to
        take an offset reading. This offset is then used to compensate for
        drift in the next measurement. When disabled, one offset reading
        is taken immediately and stored into memory to be used for all
        successive measurements onwards. Disabling autozero increases the
        `HP3456a`""s measurement speed, and also makes the instrument more
        suitable for high impendance measurements since no input switching is
        done."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    filter = bool_property(
        ""FL"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the analog filter mode.

        The `HP3456a` has a 3 pole active filter with
        greater than 60dB attenuation at frequencies of 50Hz and higher. The
        filter is applied between the input terminals and input amplifier. When
        in ACV or ACV+DCV functions the filter is applied to the output of the
        ac converter and input amplifier. In these modes select the filter for
        measurements below 400Hz."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    math_mode = enum_property(
        ""M"",
        MathMode,
        doc=""""""Set the math mode.

        The `HP3456a` has a number of different math modes that
        can change measurement output, or can provide additional
        statistics. Interaction with these modes is done via the
        `HP3456a.Register`.

        :type: `HP3456a.MathMode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    trigger_mode = enum_property(
        ""T"",
        TriggerMode,
        doc=""""""Set the trigger mode.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`.

        :type: `HP3456a.TriggerMode`

        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    @property
    def number_of_readings(self):
        """"""Get/set the number of readings done per trigger/measurement cycle
        using `HP3456a.Register.number_of_readings`.

        :type: `float`
        :rtype: `float`

        """"""
        return self._register_read(HP3456a.Register.number_of_readings)

    @number_of_readings.setter
    def number_of_readings(self, value):
        self._register_write(HP3456a.Register.number_of_readings, value)

    @property
    def number_of_digits(self):
        """"""Get/set the number of digits used in measurements using
        `HP3456a.Register.number_of_digits`.

        Set to higher values to increase accuracy at the cost of measurement
        speed.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.number_of_digits))

    @number_of_digits.setter
    def number_of_digits(self, newval):
        newval = int(newval)
        if newval not in range(3, 7):
            raise ValueError(
                ""Valid number_of_digits are: "" ""{}"".format(list(range(3, 7)))
            )

        self._register_write(HP3456a.Register.number_of_digits, newval)

    @property
    def nplc(self):
        """"""Get/set the number of powerline cycles to integrate per measurement
        using `HP3456a.Register.nplc`.

        Setting higher values increases accuracy at the cost of a longer
        measurement time. The implicit assumption is that the input reading is
        stable over the number of powerline cycles to integrate.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.nplc))

    @nplc.setter
    def nplc(self, newval):
        newval = int(newval)
        valid = HP3456a.ValidRange[""nplc""].value
        if newval in valid:
            self._register_write(HP3456a.Register.nplc, newval)
        else:
            raise ValueError(""Valid nplc settings are: "" ""{}"".format(valid))

    @property
    def delay(self):
        """"""Get/set the delay that is waited after a trigger for the input to
        settle using `HP3456a.Register.delay`.

        :type: As specified, assumed to be `~quantaties.Quantity.s` otherwise
        :rtype: `~quantaties.Quantity.s`

        """"""
        return self._register_read(HP3456a.Register.delay) * u.s

    @delay.setter
    def delay(self, value):
        delay = assume_units(value, u.s).to(u.s).magnitude
        self._register_write(HP3456a.Register.delay, delay)

    @property
    def mean(self):
        """"""
        Get the mean over `HP3456a.Register.count` measurements from
        `HP3456a.Register.mean` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.mean)

    @property
    def variance(self):
        """"""
        Get the variance over `HP3456a.Register.count` measurements from
        `HP3456a.Register.variance` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.variance)

    @property
    def count(self):
        """"""
        Get the number of measurements taken from `HP3456a.Register.count` when
        in `HP3456a.MathMode.statistic`.

        :rtype: `int`
        """"""
        return int(self._register_read(HP3456a.Register.count))

    @property
    def lower(self):
        """"""
        Get/set the value in `HP3456a.Register.lower`, which indicates the
        lowest value measurement made while in `HP3456a.MathMode.statistic`, or
        the lowest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        """"""
        return self._register_read(HP3456a.Register.lower)

    @lower.setter
    def lower(self, value):
        self._register_write(HP3456a.Register.lower, value)

    @property
    def upper(self):
        """"""
        Get/set the value in `HP3456a.Register.upper`, which indicates the
        highest value measurement made while in `HP3456a.MathMode.statistic`,
        or the highest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.upper)

    @upper.setter
    def upper(self, value):
        return self._register_write(HP3456a.Register.upper, value)

    @property
    def r(self):
        """"""
        Get/set the value in `HP3456a.Register.r`, which indicates the resistor
        value used while in `HP3456a.MathMode.dbm` or the number of recalled
        readings in reading storage mode.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.r)

    @r.setter
    def r(self, value):
        self._register_write(HP3456a.Register.r, value)

    @property
    def y(self):
        """"""
        Get/set the value in `HP3456a.Register.y` to be used in calculations
        when in `HP3456a.MathMode.scale` or `HP3456a.MathMode.percent`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.y)

    @y.setter
    def y(self, value):
        self._register_write(HP3456a.Register.y, value)

    @property
    def z(self):
        """"""
        Get/set the value in `HP3456a.Register.z` to be used in calculations
        when in `HP3456a.MathMode.scale` or the first reading when in
        `HP3456a.MathMode.statistic`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.z)

    @z.setter
    def z(self, value):
        self._register_write(HP3456a.Register.z, value)

    @property
    def input_range(self):
        """"""Set the input range to be used.

        The `HP3456a` has separate ranges for `ohm` and for
        `volt`. The range value sent to the instrument depends on
        the unit set on the input range value. `auto` selects auto ranging.

        :type: `~pint.Quantity`
        """"""
        raise NotImplementedError

    @input_range.setter
    def input_range(self, value):
        if isinstance(value, str):
            if value.lower() == ""auto"":
                self.sendcmd(""R1W"")
            else:
                raise ValueError(
                    ""Only 'auto' is acceptable when specifying ""
                    ""the input range as a string.""
                )

        elif isinstance(value, u.Quantity):
            if value.units == u.volt:
                valid = HP3456a.ValidRange.voltage.value
                value = value.to(u.volt)
            elif value.units == u.ohm:
                valid = HP3456a.ValidRange.resistance.value
                value = value.to(u.ohm)
            else:
                raise ValueError(
                    ""Value {} not quantity.volt or quantity.ohm"" """".format(value)
                )

            value = float(value.magnitude)
            if value not in valid:
                raise ValueError(
                    ""Value {} outside valid ranges "" ""{}"".format(value, valid)
                )
            value = valid.index(value) + 2
            self.sendcmd(f""R{value}W"")
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                ""or the string 'auto', got {}"".format(type(value))
            )

    @property
    def relative(self):
        """"""
        Enable or disable `HP3456a.MathMode.Null` on the instrument.

        :type: `bool`
        """"""
        return self._null

    @relative.setter
    def relative(self, value):
        if value is True:
            self._null = True
            self.sendcmd(f""M{HP3456a.MathMode.null.value}"")
        elif value is False:
            self._null = False
            self.sendcmd(f""M{HP3456a.MathMode.off.value}"")
        else:
            raise TypeError(
                ""Relative setting must be specified as a bool, ""
                ""got {}"".format(type(value))
            )

    # METHODS ##

    def auto_range(self):
        """"""
        Set input range to auto. The `HP3456a` should upscale when a reading
        is at 120% and downscale when it below 11% full scale. Note that auto
        ranging can increase the measurement time.
        """"""
        self.input_range = ""auto""

    def fetch(self, mode=None):
        """"""Retrieve n measurements after the HP3456a has been instructed to
        perform a series of similar measurements. Typically the mode, range,
        nplc, analog filter, autozero is set along with the number of
        measurements to take. The series is then started at the trigger
        command.

        Example usage:

        >>> dmm.number_of_digits = 6
        >>> dmm.auto_range()
        >>> dmm.nplc = 1
        >>> dmm.mode = dmm.Mode.resistance_2wire
        >>> n = 100
        >>> dmm.number_of_readings = n
        >>> dmm.trigger()
        >>> time.sleep(n * 0.04)
        >>> v = dmm.fetch(dmm.Mode.resistance_2wire)
        >>> print len(v)
        10

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be returned.

        :type mode: `HP3456a.Mode`

        :return: A series of measurements from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            units = UNITS[mode]
        else:
            units = 1

        value = self.query("""", size=-1)
        values = [float(x) * units for x in value.split("","")]
        return values

    def measure(self, mode=None):
        """"""Instruct the HP3456a to perform a one time measurement. The
        measurement will use the current set registers for the measurement
        (number_of_readings, number_of_digits, nplc, delay, mean, lower, upper,
        y and z) and will immediately take place.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`

        Example usage:

        >>> dmm = ik.hp.HP3456a.open_gpibusb(""/dev/ttyUSB0"", 22)
        >>> dmm.number_of_digits = 6
        >>> dmm.nplc = 1
        >>> print dmm.measure(dmm.Mode.resistance_2wire)

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be
            returned.

        :type mode: `HP3456a.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`

        """"""
        if mode is not None:
            modevalue = mode.value
            units = UNITS[mode]
        else:
            modevalue = """"
            units = 1

        self.sendcmd(f""{modevalue}W1STNT3"")

        value = self.query("""", size=-1)
        return float(value) * units

    def _register_read(self, name):
        """"""
        Read a register on the HP3456a.

        :param name: The name of the register to read from
        :type name: `HP3456a.Register`
        :rtype: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        self.sendcmd(f""RE{name.value}"")
        time.sleep(0.1)
        return float(self.query("""", size=-1))

    def _register_write(self, name, value):
        """"""
        Write a register on the HP3456a.

        :param name: The name of the register to write to
        :type name: `HP3456a.Register`
        :type value: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        if name in [
            HP3456a.Register.mean,
            HP3456a.Register.variance,
            HP3456a.Register.count,
        ]:
            raise ValueError(f""register {name} is read only"")
        self.sendcmd(f""W{value}ST{name.value}"")
        time.sleep(0.1)

    def trigger(self):
        """"""
        Signal a single manual trigger event to the `HP3456a`.
        """"""
        self.sendcmd(""T3"")


# UNITS #######################################################################

UNITS = {
    None: 1,
    HP3456a.Mode.dcv: u.volt,
    HP3456a.Mode.acv: u.volt,
    HP3456a.Mode.acvdcv: u.volt,
    HP3456a.Mode.resistance_2wire: u.ohm,
    HP3456a.Mode.resistance_4wire: u.ohm,
    HP3456a.Mode.ratio_dcv_dcv: 1,
    HP3456a.Mode.ratio_acv_dcv: 1,
    HP3456a.Mode.ratio_acvdcv_dcv: 1,
    HP3456a.Mode.oc_resistence_2wire: u.ohm,
    HP3456a.Mode.oc_resistence_4wire: u.ohm,
}


"
388,551.0,Tektronix,Tektds 5 XX,Instrumentkit,,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,TDS500 Series,"[OrderedDict([('id', 'attDO3kJCZa3frTiz'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5qf-yTZpnjwZLauqs-rFpg/CbahSqD33kIO-Cv3tX9jGEB0H0A_DSwdfwy__Nw_1q9DxxzzZIRZXTaIrOdKrEWrtq8lhfxDR5aWT9BiYm_oPfvnv3oDW20cX1vVhhrRA4Q/TYneaJEZXOf3zQs3HrKaji6k-yOSD6T2bLghIYdX_pg'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HZ4ghy-_SwbRlTUHj-lXEg/0gcdQugd2_aoqqgn7uhfuUVdGJpTf5UEvbAqT0VGTK1o32VvknxomflpHzQy3n3rN8xDBCtzVgaMZd3GGNLHHw/sme59BS8xavUM5dVAMy_-RCHkyMKZX38qz9Xp_LB9KM'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N6Ul62FhJFIr2alg9UeY1Q/BvwGbFIKa-aRPAbSn0a6dtEh9t1a9bwH2RxVOx9JY1c7PLL5fEBBfqdCC5ddZdzAAgEoRbDyP_YIgos7ighSQw/AeteIMZDOlNfZQLCMmbkHyUOvC6h2zKZEKjLgsGAaog'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8f9wmAGsc9eFRWD5fB9K_A/B0AtgZpEwbtvJmoMYJ6aHXKNFbpmm9gZ5QCig5E5ZuhC4FuLcL74Cg24GdSsOSkgFuP3wFyzv_9xqFL7hOwR8A/hKNRgkOErHxYppYlxtzjwXOhN4zAZPYbfJPtLMm5qdw'), ('width', 3000), ('height', 3000)]))]))])]",,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782757/Instruments/Oscilloscopes/TDS500-Series/TDS500-Series.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
394,549.0,Tektronix,Tekdpo 4104,Instrumentkit,"The DPO4104 Digital Phosphor Oscilloscope delivers the performance you need to visualize even your most demanding signals. With a 1 GHz Bandwidth and offering a minimum of 5x oversampling on all channels and si (x)/x interpolation standard, you can be confident that even the fastest transient events will be captured and displayed accurately. The standard 10 M record length on all channels enables you to capture long windows of signal activity while maintaining fine timing resolution.",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo4104.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo4104-oscilloscope,DPO4104,"[OrderedDict([('id', 'attZKmurDfbgmKnMC'), ('width', 620), ('height', 413), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i-MLyIm4RM22ymAipNcb9Q/jnTLzVKRKqmc4hHu-MDZRtxuoB3-faOPcYgE1UqxXsCRXqi-kzPIj-vkEzBsw3tVrNFXhJq0fw3eRVwPgOQnRxDFtzPYpaEIGqKVZA81dPeJsEHeCUrcUD2b9AaU6WLT/6j44BM4VEspfAjj755E_ohTvKzbO9-jaMbMWPXrFhc0'), ('filename', 'Tektronix_MSO_DPO4000.jpg'), ('size', 63004), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kzpY2Hlj_gKM3NOkysGmCQ/Luyd_bYldevbRBLo1TvpYju1BwnbkjDI9rJ--WU0Ip_oePQQJtyHc33VPvJfgqfqdzohzFLzlPdJZxRqw6lQdg/_ZMLJByjbQSaRDkDUpmQsDUSVit3YmzE6JxIbKuO-g4'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UOPFYnKqLnXR77Vg-o0P1w/fOQEkPWNWisAs_cuxPaS-KvkGUQCaxVhpBREr8to2_piGfks2hTcMIhJIGHjnX8V90qSBxIaHTH8W8WPAeCRZw/NKs7mEUclWmTkP7-i0Ygo5v6QQ4aHhEIhioi2NFnReY'), ('width', 620), ('height', 413)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OIzbjX4xxwwRgXFAiJVjug/pr9fpwutN9kBrj8NbzN-cuyuAhe8-l9Le2LooJA2liSzp5T_dJEpwGwr3tC5MfAu_0kSpEiYl-_AdKB5mtIA1Q/VyI6x2sL35k4dN0fe1zmwpAuzzW90ox2z_lMvhdnidA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.valuetronics.com/product/dpo4104-tektronix-digital-oscilloscope-used,['Oscilloscopes'],"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://www.tek.com/en,https://download.tek.com/datasheet/DPO4000-Digital-Phosphor-Oscilloscope-Datasheet-48W1903210.pdf,USA,5800.0,"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Instrumentkit to connect to a DPO4104 Oscilloscopes,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782769/Instruments/Oscilloscopes/DPO4104/DPO4104.jpg,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,7995.0,,True,,
