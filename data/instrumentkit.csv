,Device datasheet (PDF),Category description link,Device picture,"Yearly revenue (millions, USD)",Vendor headquarters,Vendor logo URL,Device Description,Device Description Link,Device,Field 1,Device Category,Category Description,Vendor wikipedia or cruncbase description,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Library,Python docs link,Vendor,Vendor logo,Vendor website,Image URL,Corrected device name,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,QA Notes,docstring
2,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037,"[OrderedDict([('id', 'attE3gJZRoLQpO3nR'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/L3WnVH1jcTmGa3oP-wrc1Q/i9YJkRvcOMvPi-9_T0yKrpWpis1idaHI86gFZRpLFo-nGxMH9UXJg27VWzaSrb1in1MBMNuBxfy_jnP75jn7X0W3dCKGPe0njS10vtqqaLA/PDH-LCgYLgM3QWW-ejc05ncIeQhWkGGInWkcx8NFOAI'), ('filename', '8135_PM100USB_SGL.jpg'), ('size', 136075), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s5XChqt3l45-o0wOXWQXNg/0gsoGCdFGV3J_lVZSQGarCHSB5aPYkPvaVN5Vh-4CJf4qT7vjguWQ9XL045JxO4w6nzUgsi-eLo47eMox4vNoQ/bCgSl-tFRNNEoO08K2v10pX5qoH7252XavZL0bLCuNM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KzVGgQqJCtJT959R2OX5kQ/HhAIyUHDKLOLa8WUZrOpufgQDfx7I05Z-LZo7DX-n9rSi4_dg4cBT4iU7JJLhJgXHZo7KcQnJc-NWlTnx1HEDA/8zOIi8mUdgWmF0gRcEuNSMC1fFSkCTpmC00j8Ucv_A0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tu4KDopbR3ruCsJmKaQfmw/AzYamci3R8htlNyk-FEKBkCY4zYRbAfWS43AT6g8oNdZZBW1ouUqeUe4w3MyaUuVKu9kDy5F8kebTpqO0johcQ/C6hkc362JD70YxjSRsO3-DQlW4X2VwjIw_hn0UAYMh8'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The PM100USB Power and Energy Meter Interface is compatible with all our C-Series photodiode, thermal, and pyroelectric sensors except for the ES408C Fast Pyroelectric Sensor. Our C-Type standard photodiode, slim photodiode, integrating sphere, and fiber sensors can collectively measure optical powers from 100 pW to 20 W. Our thermal power sensors measure optical powers from 10 µW to 200 W. Compatible C-Series pyroelectric energy sensors can measure energies from 10 µJ to 15 J and repetition rates up to 2 kHz. Note that the ES408C sensor for repetition rates up to 10 kHz, also available below, is not recommended for use with the PM100USB interface, which supports a maximum repetition rate of 3 kHz. Alternatively, other unamplified anode- or cathode-grounded photodiodes with up to 5 mA photocurrent, thermal elements with a maximum output voltage of 1 V, or energy sensors with voltage outputs from 100 mV to 100 V may be used.

This interface can be operated and powered by a PC via the mini-USB port. A readout rate of 300 samples per second allows active signal monitoring while the interface is in use.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037&pn=PM100USB,PM 100 USB,606.0,['Power Meters'],These interfaces provide communication between an attached sensor and a PC or other external control unit. They are designed to be controlled via an external device or operated autonomously using the analog output; there are no controls or display screens.,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/pm100usb.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#pm100usb-usb-power-meter,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782423/Instruments/Power%20Meters/PM100USB/PM100USB.jpg,PM100USB,Write a Python script that uses Instrumentkit to connect to a PM100USB Power Meters,487.99,,,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units
"
3,https://www.newport.com/medias/sys_master/images/images/h8e/hfa/8797030088734/8742-Datasheet.pdf,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attloDMGvxGciAsjA'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/aY8RkkSUf6mcAhEHmVB5iQ/QmbcyAJOLosgUb2N5d9Vq13Y6cOeZL0YYbMsYOXY_AqHhTq1hl0QEcD5hTPslTPYY_mdbyrm4NcuWyl4tzn9OHWC1dmBs1cd7sYqQZYZCMI/9n8mnjRroggkiMgUUEiyYvWUC2P-q_0l4m_wDKd7x_c'), ('filename', '8742_with_RS485_400w.jpg'), ('size', 22135), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9NoYwepBzZTkIZEoXokmlw/dukZ2WyBCeuTeh8b1wJwygV15pTtdCNeZmbRZUI6hmYIBiVJfud7471qOrCHFvu5OKmHQQ4aMnlWIegXHaSbEw/Jfq1YEUohkAUFf9bYPgwFmoJc-SM8EQ1ZNu8LvvNZa4'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xeAEHJaKBC02uwq1-Ah5pQ/ZkHQwTtlV5XxgtYOHdtRg9tDkqXryWhT683JIzAUO1MSAOCU6-scSmrF5maNYPQmxutJHqgSOXCFCr6PHm_24Q/PeUHbCGaM2CslHmOkcp0-FQU64y9svgYBXI9IEKK__Q'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2KIEC5UfH4DiYJ588IMUOQ/yorVviUZx6ole4x3FFLlCMyhUGatkJqAfYXelBvvA7vFiA9WAieMnyuGbmV8InZhvTnFEmurceeTm68CtsktYA/Z98bLZOWEnhyxXlrrHmj3u37SS-gA4-sJGnBG0kPvUg'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,"The model 8742 is a 4-axis open-loop intelligent motion controller/driver that provides a compact and low cost solution for driving New Focus open-loop Picomotors products. It is a single-box solution that can be computer controlled via USB and Ethernet communication interfaces using Newport Motion Control Language (NMCL) command set. Both interfaces are well supported via Windows DLL, sample LabVIEW™VIs, and intuitive graphical user interface (GUI) Windows application with device auto-discovery feature. Each model 8742 controller/driver can control one of four 4-pin RJ-22 single output ports for use with any single-channel Picomotor actuator at any given time. The model 8725 multi-axis adapter can be used to connect the 4-pin RJ-22 output ports on the drivers to New Focus™ Picomotor products with 6-pin RJ-11 connectors. Note: Power Supply not included",https://www.newport.com/p/8742,Picomotorcontroller 8742,384.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newport_pmc8742.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#picomotorcontroller8742,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782424/Instruments/Positional%20Controller/Picomotorcontroller-8742/Picomotorcontroller-8742.jpg,Picomotorcontroller 8742,Write a Python script that uses Instrumentkit to connect to a Picomotorcontroller 8742 Positional Controller,1260.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Newport Pico Motor Controller 8742

Note that the class is currently only tested with one controller connected,
however, a main controller / secondary controller setup has also been
implemented already. Commands are as described in the Picomotor manual.

If a connection via TCP/IP is opened, the standard port that these devices
listen to is 23.

If you have only one controller connected, everything should work out of
the box. Please only use axiss 0 through 3.

If you have multiple controllers connected (up to 31), you need to set the
addresses of each controller. This can be done with this this class. See,
e.g., routines for `controller_address`, `scan_controller`, and `scan`.
Also make sure that you set `multiple_controllers` to `True`. This is
used for internal handling of the class only and does not communicate with
the instruments.
If you run with multiple controllers, the axiss are as following:
Ch 0 - 3 -> Motors 1 - 4 on controller with address 1
Ch 4 - 7 -> Motors 1 - 4 on controller with address 2
Ch i - i+4 -> Motors 1 - 4 on controller with address i / 4 + 1 (with i%4 = 0)

All network commands only work with the main controller (this should make
sense).

If in multiple controller mode, you can always send controller specific
commands by sending them to one individual axis of that controller.
Any axis works!
""""""

# IMPORTS #

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# pylint: disable=too-many-lines


class PicoMotorController8742(Instrument):
    """"""Newport Picomotor Controller 8742 Communications Class

    Use this class to communicate with the picomotor controller 8742.
    Single-controller and multi-controller setup can be used.

    Device can be talked to via TCP/IP or over USB.
    FixMe: InstrumentKit currently does not communicate correctly via USB!

    Example for TCP/IP controller in single controller mode:
        >>> import instruments as ik
        >>> ip = ""192.168.1.2""
        >>> port = 23   # this is the default port
        >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
        >>> motor1 = inst.axis[0]
        >>> motor1.move_relative = 100

    Example for communications via USB:
        >>> import instruments as ik
        >>> pid = 0x4000
        >>> vid = 0x104d
        >>> ik.newport.PicoMotorController8742.open_usb(pid=pid, vid=vid)
        >>> motor3 = inst.axis[2]
        >>> motor3.move_absolute = -200

    Example for multicontrollers with controller addresses 1 and 2:
        >>> import instruments as ik
        >>> ip = ""192.168.1.2""
        >>> port = 23   # this is the default port
        >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
        >>> inst.multiple_controllers = True
        >>> contr1mot1 = inst.axis[0]
        >>> contr2mot1 = inst.axis[4]
        >>> contr1mot1.move_absolute = 200
        >>> contr2mot1.move_relative = -212
    """"""

    def __init__(self, filelike):
        """"""Initialize the PicoMotorController class.""""""
        super().__init__(filelike)

        # terminator
        self.terminator = ""\r\n""

        # setup
        self._multiple_controllers = False

    # INNER CLASSES #

    class Axis:
        """"""PicoMotorController8742 Axis class for individual motors.""""""

        def __init__(self, parent, idx):
            """"""Initialize the axis with the parent and the number.

            :raises IndexError: Axis accessed looks like a main / secondary
                setup, but the flag for `multiple_controllers` is not set
                appropriately. See introduction.
            """"""
            if not isinstance(parent, PicoMotorController8742):
                raise TypeError(""Don't do that."")

            if idx > 3 and not parent.multiple_controllers:
                raise IndexError(
                    ""You requested an axis that is only ""
                    ""available in multi controller mode, ""
                    ""however, have not enabled it. See ""
                    ""`multi_controllers` routine.""
                )

            # set controller
            self._parent = parent
            self._idx = idx % 4 + 1

            # set _address:
            if self._parent.multiple_controllers:
                self._address = f""{idx // 4 + 1}>""
            else:
                self._address = """"

        # ENUMS #

        class MotorType(IntEnum):
            """"""IntEnum Class containing valid MotorTypes

            Use this enum to set the motor type. You can select that no or an
            unkown motor are connected. See also `motor_check` command to set
            these values per controller automatically.
            """"""

            none = 0
            unknown = 1
            tiny = 2
            standard = 3

        # PROPERTIES #

        @property
        def acceleration(self):
            """"""Get / set acceleration of axis in steps / sec^2.

            Valid values are between 1 and 200,000 (steps) 1 / sec^2 with the
            default as 100,000 (steps) 1 / sec^2. If quantity is not unitful,
            it is assumed that 1 / sec^2 is chosen.

            :return: Acceleration in 1 / sec^2
            :rtype: u.Quantity(int)

            :raises ValueError: Limit is out of bound.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.acceleration = u.Quantity(500, 1/u.s**-2)
            """"""
            return assume_units(int(self.query(""AC?"")), u.s**-2)

        @acceleration.setter
        def acceleration(self, value):
            value = int(assume_units(value, u.s**-2).to(u.s**-2).magnitude)
            if not 1 <= value <= 200000:
                raise ValueError(
                    f""Acceleration must be between 1 and ""
                    f""200,000 s^-2 but is {value}.""
                )
            self.sendcmd(f""AC{value}"")

        @property
        def home_position(self):
            """"""Get / set home position

            The home position of the device is used, e.g., when moving
            to a specific position instead of a relative move. Valid values
            are between -2147483648 and 2147483647.

            :return: Home position.
            :rtype: int

            :raises ValueError: Set value is out of range.

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.home_position = 444
            """"""
            return int(self.query(""DH?""))

        @home_position.setter
        def home_position(self, value):
            if not -2147483648 <= value <= 2147483647:
                raise ValueError(
                    f""Home position must be between -2147483648 ""
                    f""and 2147483647, but is {value}.""
                )
            self.sendcmd(f""DH{int(value)}"")

        @property
        def is_stopped(self):
            """"""Get if an axis is stopped (not moving).

            :return: Is the axis stopped?
            :rtype: bool

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.is_stopped
                True
            """"""
            return bool(int(self.query(""MD?"")))

        @property
        def motor_type(self):
            """"""Set / get the type of motor connected to the axis.

            Use a `MotorType` IntEnum to set this motor type.

            :return: Motor type set.
            :rtype: MotorType

            :raises TypeError: Set motor type is not of type `MotorType`.

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.motor_type = ax.MotorType.tiny
            """"""
            retval = int(self.query(""QM?""))
            return self.MotorType(retval)

        @motor_type.setter
        def motor_type(self, value):
            if not isinstance(value, self.MotorType):
                raise TypeError(
                    f""Set motor type must be of type `MotorType` ""
                    f""but is of type {type(value)}.""
                )
            self.sendcmd(f""QM{value.value}"")

        @property
        def move_absolute(self):
            """"""Get / set the absolute target position of a motor.

            Set with absolute position in steps. Valid values between
            -2147483648 and +2147483647.
            See also: `home_position`.

            :return: Absolute motion target position.
            :rtype: int

            :raises ValueError: Requested position out of range.

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.move_absolute = 100
            """"""
            return int(self.query(""PA?""))

        @move_absolute.setter
        def move_absolute(self, value):
            if not -2147483648 <= value <= 2147483647:
                raise ValueError(
                    f""Set position must be between -2147483648 ""
                    f""and 2147483647, but is {value}.""
                )
            self.sendcmd(f""PA{int(value)}"")

        @property
        def move_relative(self):
            """"""Get / set the relative target position of a motor.

            Set with relative motion in steps. Valid values between
            -2147483648 and +2147483647.
            See also: `home_position`.

            :return: Relative motion target position.
            :rtype: int

            :raises ValueError: Requested motion out of range.

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.move_relative = 100
            """"""
            return int(self.query(""PR?""))

        @move_relative.setter
        def move_relative(self, value):
            if not -2147483648 <= value <= 2147483647:
                raise ValueError(
                    f""Set motion must be between -2147483648 ""
                    f""and 2147483647, but is {value}.""
                )
            self.sendcmd(f""PR{int(value)}"")

        @property
        def position(self):
            """"""Queries current, actual position of motor.

            Positions are with respect to the home position.

            :return: Current position in steps.
            :rtype: int

            Example:
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.position
                123
            """"""
            return int(self.query(""TP?""))

        @property
        def velocity(self):
            """"""Get / set velocty of the connected motor (unitful).

            Velocity is given in (steps) per second (1/s).
            If a `MotorType.tiny` motor is connected, the maximum velocity
            allowed is 1750 /s, otherwise 2000 /s.
            If no units are given, 1/s are assumed.

            :return: Velocity in 1/s
            :rtype: u.Quantity(int)

            :raises ValueError: Set value is out of the allowed range.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.velocity = u.Quantity(500, 1/u.s)
            """"""
            retval = int(self.query(""VA?""))
            return u.Quantity(retval, 1 / u.s)

        @velocity.setter
        def velocity(self, value):
            if self.motor_type == self.MotorType.tiny:
                max_velocity = 1750
            else:
                max_velocity = 2000

            value = int(assume_units(value, 1 / u.s).to(1 / u.s).magnitude)
            if not 0 < value <= max_velocity:
                raise ValueError(
                    f""The maximum allowed velocity for the set ""
                    f""motor is {max_velocity}. The requested ""
                    f""velocity of {value} is out of range.""
                )
            self.sendcmd(f""VA{value}"")

        # METHODS #

        def move_indefinite(self, direction):
            """"""Move the motor indefinitely in the specific direction.

            To stop motion, issue `stop_motion` or `abort_motion` command.
            Direction is defined as a string of either ""+"" or ""-"".

            :param direction: Direction in which to move the motor, ""+"" or ""-""
            :type direction: str

            Example:
                >>> from time import sleep
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.move_indefinite(""+"")
                >>> sleep(1)   # wait a second
                >>> ax.stop()
            """"""
            if direction in [""+"", ""-""]:
                self.sendcmd(f""MV{direction}"")

        def stop(self):
            """"""Stops the specific axis if in motion.

            Example:
                >>> from time import sleep
                >>> import instruments as ik
                >>> ip = ""192.168.1.2""
                >>> port = 23   # this is the default port
                >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
                >>> ax = inst.axis[0]
                >>> ax.move_indefinite(""+"")
                >>> sleep(1)   # wait a second
                >>> ax.stop()
            """"""
            self.sendcmd(""ST"")

        # CONTROLLER SPECIFIC PROPERTIES #

        @property
        def controller_address(self):
            """"""Get / set the controller address.

            Valid address values are between 1 and 31. For setting up multiple
            instruments, see `multiple_controllers`.

            :return: Address of this device if secondary, otherwise `None`
            :rtype: int
            """"""
            retval = int(self.query(""SA?"", axs=False))
            return retval

        @controller_address.setter
        def controller_address(self, newval):
            self.sendcmd(f""SA{int(newval)}"", axs=False)

        @property
        def controller_configuration(self):
            """"""Get / set configuration of some of the controller’s features.

            Configuration is given as a bit mask. If changed, please save
            the settings afterwards if you would like to do so. See
            `save_settings`.

            The bitmask to be set can be either given as a number, or as a
            string of the mask itself. The following values are equivalent:
            3, 0b11, ""11""

            Bit 0:
                Value 0: Perform auto motor detection. Check and set motor
                    type automatically when commanded to move.
                Value 1: Do not perform auto motor detection on move.
            Bit 1:
                Value 0: Do not scan for motors connected to controllers upon
                    reboot (Performs ‘MC’ command upon power-up, reset or
                    reboot).
                Value 1: Scan for motors connected to controller upon power-up
                    or reset.

            :return: Bitmask of the controller configuration.
            :rtype: str, binary configuration
            """"""
            return self.query(""ZZ?"", axs=False)

        @controller_configuration.setter
        def controller_configuration(self, value):
            if isinstance(value, str):
                self.sendcmd(f""ZZ{value}"", axs=False)
            else:
                self.sendcmd(f""ZZ{str(bin(value))[2:]}"", axs=False)

        @property
        def error_code(self):
            """"""Get error code only.

            Error code0 means no error detected.

            :return: Error code.
            :rtype: int
            """"""
            return int(self.query(""TE?"", axs=False))

        @property
        def error_code_and_message(self):
            """"""Get error code and message.

            :return: Error code, error message
            :rtype: int, str
            """"""
            retval = self.query(""TB?"", axs=False)
            err_code, err_msg = retval.split("","")
            err_code = int(err_code)
            err_msg = err_msg.strip()
            return err_code, err_msg

        @property
        def firmware_version(self):
            """"""Get the controller firmware version.""""""
            return self.query(""VE?"", axs=False)

        @property
        def name(self):
            """"""Get the name of the controller.""""""
            return self.query(""*IDN?"", axs=False)

        # CONTROLLER SPECIFIC METHODS #

        def abort_motion(self):
            """"""Instantaneously stops any motion in progress.""""""
            self.sendcmd(""AB"", axs=False)

        def motor_check(self):
            """"""Check what motors are connected and set parameters.

            Use the save command `save_settings` if you want to save the
            configuration to the non-volatile memory.
            """"""
            self.sendcmd(""MC"", axs=False)

        def purge(self):
            """"""Purge the non-volatile memory of the controller.

            Perform a hard reset and reset all the saved variables. The
            following variables are reset to factory settings:
            1. Hostname
            2. IP Mode
            3. IP Address
            4. Subnet mask address
            5. Gateway address
            6. Configuration register
            7. Motor type
            8. Desired Velocity
            9. Desired Acceleration
            """"""
            self.sendcmd(""XX"", axs=False)

        def recall_parameters(self, value=0):
            """"""Recall parameter set.

            This command restores the controller working parameters from values
            saved in its non-volatile memory. It is useful when, for example,
            the user has been exploring and changing parameters (e.g., velocity)
            but then chooses to reload from previously stored, qualified
            settings. Note that “*RCL 0” command just restores the working
            parameters to factory default settings. It does not change the
            settings saved in EEPROM.

            :param value: 0 -> Recall factory default,
                1 -> Recall last saved settings
            :type int:
            """"""
            self.sendcmd(f""*RCL{1 if value else 0}"", axs=False)

        def reset(self):
            """"""Reset the controller.

            Perform a soft reset. Saved variables are not deleted! For a
            hard reset, see the `purge` command.

            ..note:: It might take up to 30 seconds to re-establish
            communications via TCP/IP
            """"""
            self.sendcmd(""*RST"", axs=False)

        def save_settings(self):
            """"""Save user settings.

            This command saves the controller settings in its non-volatile memory.
            The controller restores or reloads these settings to working registers
            automatically after system reset or it reboots. The purge
            command is used to clear non-volatile memory and restore to factory
            settings. Note that the SM saves parameters for all motors.

            Saves the following variables:
            1. Controller address
            2. Hostname
            3. IP Mode
            4. IP Address
            5. Subnet mask address
            6. Gateway address
            7. Configuration register
            8. Motor type
            9. Desired Velocity
            10. Desired Acceleration
            """"""
            self.sendcmd(""SM"", axs=False)

        # SEND AND QUERY #

        def sendcmd(self, cmd, axs=True):
            """"""Send a command to an axis object.

            :param cmd: Command
            :type cmd: str
            :param axs: Send axis address along? Not used for controller
                commands. Defaults to `True`
            :type axs: bool
            """"""
            if axs:
                command = f""{self._address}{self._idx}{cmd}""
            else:
                command = f""{self._address}{cmd}""
            self._parent.sendcmd(command)

        def query(self, cmd, size=-1, axs=True):
            """"""Query for an axis object.

            :param cmd: Command
            :type cmd: str
            :param size: bytes to read, defaults to ""until terminator"" (-1)
            :type size: int
            :param axs: Send axis address along? Not used for controller
                commands. Defaults to `True`
            :type axs: bool

            :raises IOError: The wrong axis answered.
            """"""
            if axs:
                command = f""{self._address}{self._idx}{cmd}""
            else:
                command = f""{self._address}{cmd}""

            retval = self._parent.query(command, size=size)

            if retval[: len(self._address)] != self._address:
                raise OSError(
                    f""Expected to hear back from secondary ""
                    f""controller {self._address}, instead ""
                    f""controller {retval[:len(self._address)]} ""
                    f""answered.""
                )

            return retval[len(self._address) :]

    @property
    def axis(self):
        """"""Return an axis object.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> ax = inst.axis[0]
        """"""
        return ProxyList(self, self.Axis, range(31 * 4))

    @property
    def controller_address(self):
        """"""Get / set the controller address.

        Valid address values are between 1 and 31. For setting up multiple
        instruments, see `multiple_controllers`.

        :return: Address of this device if secondary, otherwise `None`
        :rtype: int

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.controller_address = 13
        """"""
        return self.axis[0].controller_address

    @controller_address.setter
    def controller_address(self, newval):
        self.axis[0].controller_address = newval

    @property
    def controller_configuration(self):
        """"""Get / set configuration of some of the controller’s features.

        Configuration is given as a bit mask. If changed, please save
        the settings afterwards if you would like to do so. See
        `save_settings`.

        Bit 0:
            Value 0: Perform auto motor detection. Check and set motor
                type automatically when commanded to move.
            Value 1: Do not perform auto motor detection on move.
        Bit 1:
            Value 0: Do not scan for motors connected to controllers upon
                reboot (Performs ‘MC’ command upon power-up, reset or
                reboot).
            Value 1: Scan for motors connected to controller upon power-up
                or reset.

        :return: Bitmask of the controller configuration.
        :rtype: str

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.controller_configuration = ""11""
        """"""
        return self.axis[0].controller_configuration

    @controller_configuration.setter
    def controller_configuration(self, value):
        self.axis[0].controller_configuration = value

    @property
    def dhcp_mode(self):
        """"""Get / set if device is in DHCP mode.

        If not in DHCP mode, a static IP address, gateway, and netmask
        must be set.

        :return: Status if DHCP mode is enabled
        :rtype: `bool`

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.dhcp_mode = True
        """"""
        return bool(self.query(""IPMODE?""))

    @dhcp_mode.setter
    def dhcp_mode(self, newval):
        nn = 1 if newval else 0
        self.sendcmd(f""IPMODE{nn}"")

    @property
    def error_code(self):
        """"""Get error code only.

        Error code0 means no error detected.

        :return: Error code.
        :rtype: int

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.error_code
            0
        """"""
        return self.axis[0].error_code

    @property
    def error_code_and_message(self):
        """"""Get error code and message.

        :return: Error code, error message
        :rtype: int, str

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.error_code
            (0, 'NO ERROR DETECTED')
        """"""
        return self.axis[0].error_code_and_message

    @property
    def firmware_version(self):
        """"""Get the controller firmware version.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.firmware_version
            '8742 Version 2.2 08/01/13'
        """"""
        return self.axis[0].firmware_version

    @property
    def gateway(self):
        """"""Get / set the gateway of the instrument.

        :return: Gateway address
        :rtype: str

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.gateway = ""192.168.1.1""
        """"""
        return self.query(""GATEWAY?"")

    @gateway.setter
    def gateway(self, value):
        self.sendcmd(f""GATEWAY {value}"")

    @property
    def hostname(self):
        """"""Get / set the hostname of the instrument.

        :return: Hostname
        :rtype: `str`

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.hostname = ""asdf""
        """"""
        return self.query(""HOSTNAME?"")

    @hostname.setter
    def hostname(self, value):
        self.sendcmd(f""HOSTNAME {value}"")

    @property
    def ip_address(self):
        """"""Get / set the IP address of the instrument.

        :return: IP address
        :rtype: `str`

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.ip_address = ""192.168.1.2""
        """"""
        return self.query(""IPADDR?"")

    @ip_address.setter
    def ip_address(self, value):
        self.sendcmd(f""IPADDR {value}"")

    @property
    def mac_address(self):
        """"""Get the MAC address of the instrument.

        :return: MAC address
        :rtype: `str`

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.mac_address
            '5827809, 8087'
        """"""
        return self.query(""MACADDR?"")

    @property
    def multiple_controllers(self):
        """"""Get / set if multiple controllers are used.

        By default, this is initialized as `False`. Set to `True` if you
        have a main controller / secondary controller via RS-485 network
        set up.

        Instrument commands will always be sent to main controller.
        Axis specific commands will be set to the axis chosen, see
        `axis` description.

        :return: Status if multiple controllers are activated
        :rtype: bool

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.multiple_controllers = True
        """"""
        return self._multiple_controllers

    @multiple_controllers.setter
    def multiple_controllers(self, newval):
        self._multiple_controllers = True if newval else False

    @property
    def name(self):
        """"""Get the name of the controller.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.name
            'New_Focus 8742 v2.2 08/01/13 13991'
        """"""
        return self.axis[0].name

    @property
    def netmask(self):
        """"""Get / set the Netmask of the instrument.

        :return: Netmask
        :rtype: `str`

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.netmask = ""255.255.255.0""
        """"""
        return self.query(""NETMASK?"")

    @netmask.setter
    def netmask(self, value):
        self.sendcmd(f""NETMASK {value}"")

    @property
    def scan_controllers(self):
        """"""RS-485 controller address map query of all controllers.

        32 bit string that represents the following:
            Bit:    Value: (True: 1, False: 0)
            0       Address conflict?
            1:      Controller with address 1 exists?
                ...
            31:      Controller with address 31 exists

        Bits 1—31 are one-to-one mapped to controller addresses 1—31. The
        bit value is set to 1 only when there are no conflicts with that
        address. For example, if the master controller determines that there
        are unique controllers at addresses 1,2, and 7 and more than one
        controller at address 23, this query will return 135. The binary
        representation of 135 is 10000111. Bit #0 = 1 implies that the scan
        found at lease one address conflict during last scan. Bit #1,2, 7 = 1
        implies that the scan found controllers with addresses 1,2, and 7
        that do not conflict with any other controller.

        :return: Binary representation of controller configuration bitmask.
        :rtype: str

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.scan_controllers
            ""10000111""
        """"""
        return self.query(""SC?"")

    @property
    def scan_done(self):
        """"""Queries if a controller scan is done or not.

        :return: Controller scan done?
        :rtype: bool

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.scan_done
            True
        """"""
        return bool(int(self.query(""SD?"")))

    # METHODS #

    def abort_motion(self):
        """"""Instantaneously stop any motion in progress.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.abort_motion()
        """"""
        self.axis[0].abort_motion()

    def motor_check(self):
        """"""Check what motors are connected and set parameters.

        Use the save command `save_settings` if you want to save the
        configuration to the non-volatile memory.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.motor_check()
        """"""
        self.axis[0].motor_check()

    def scan(self, value=2):
        """"""Initialize and set controller addresses automatically.

        Scans the RS-485 network for connected controllers and set the
        addresses automatically. Three possible scan modes can be
        selected:
        Mode 0:
            Primary controller scans the network but does not resolve
            any address conflicts.
        Mode 1:
            Primary controller scans the network and resolves address
            conflicts, if any. This option preserves the non-conflicting
            addresses and reassigns the conflicting addresses starting
            with the lowest available address.
        Mode 2 (default):
            Primary controller reassigns the addresses of all
            controllers on the network in a sequential order starting
            with master controller set to address 1.

        See also: `scan_controllers` property.

        :param value: Scan mode.
        :type: int

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.scan(2)
        """"""
        self.sendcmd(f""SC{value}"")

    def purge(self):
        """"""Purge the non-volatile memory of the controller.

        Perform a hard reset and reset all the saved variables. The
        following variables are reset to factory settings:
        1. Hostname
        2. IP Mode
        3. IP Address
        4. Subnet mask address
        5. Gateway address
        6. Configuration register
        7. Motor type
        8. Desired Velocity
        9. Desired Acceleration

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.purge()
        """"""
        self.axis[0].purge()

    def recall_parameters(self, value=0):
        """"""Recall parameter set.

        This command restores the controller working parameters from values
        saved in its non-volatile memory. It is useful when, for example,
        the user has been exploring and changing parameters (e.g., velocity)
        but then chooses to reload from previously stored, qualified
        settings. Note that “*RCL 0” command just restores the working
        parameters to factory default settings. It does not change the
        settings saved in EEPROM.

        :param value: 0 -> Recall factory default,
            1 -> Recall last saved settings
        :type value: int

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.recall_parameters(1)
        """"""
        self.axis[0].recall_parameters(value)

    def reset(self):
        """"""Reset the controller.

        Perform a soft reset. Saved variables are not deleted! For a
        hard reset, see the `purge` command.

        ..note:: It might take up to 30 seconds to re-establish
        communications via TCP/IP

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.reset()
        """"""
        self.axis[0].reset()

    def save_settings(self):
        """"""Save user settings.

        This command saves the controller settings in its non-volatile memory.
        The controller restores or reloads these settings to working registers
        automatically after system reset or it reboots. The purge
        command is used to clear non-volatile memory and restore to factory
        settings. Note that the SM saves parameters for all motors.

        Saves the following variables:
        1. Controller address
        2. Hostname
        3. IP Mode
        4. IP Address
        5. Subnet mask address
        6. Gateway address
        7. Configuration register
        8. Motor type
        9. Desired Velocity
        10. Desired Acceleration

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> ip = ""192.168.1.2""
            >>> port = 23   # this is the default port
            >>> inst = ik.newport.PicoMotorController8742.open_tcpip(ip, port)
            >>> inst.save_settings()
        """"""
        self.axis[0].save_settings()

    # QUERY #

    def query(self, cmd, size=-1):
        """"""Query's the device and returns ASCII string.

        Must be queried as a raw string with terminator line ending. This is
        currently not implemented in instrument and therefore must be called
        directly from file.

        Sometimes, the instrument sends an undecodable 6 byte header along
        (usually for the first query). We'll catch it with a try statement.
        The 6 byte header was also remarked in this matlab script:
        https://github.com/cnanders/matlab-newfocus-model-8742
        """"""
        self.sendcmd(cmd)
        retval = self.read_raw(size=size)
        try:
            retval = retval.decode(""utf-8"")
        except UnicodeDecodeError:
            retval = retval[6:].decode(""utf-8"")

        return retval
"
18,https://www.newport.com/medias/sys_master/images/images/hda/h3e/9117547069470/ESP301-User-s-Manual.pdf,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attIAGKtQzOcnhr4i'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8_MZ8azQvJ6o_2mdTYlsEw/-8LqiwBUYbpCt_7kqvqeYLIqhbW0oDr6EMk7dFmut4h2eCuoNzwxTShDkZqizFhYfpIMp-vsw0rnYmTDkY4eSF5tIvef_T0S6HaOLqG_PGASJxhcItMfwvBaxKgsR6Dn/35sEEy9I_t5UIWRw2hJ97tJSM1fIfTg7W_OfkRYP_6c'), ('filename', 'MC-ESP301_06_Position_400w.jpg'), ('size', 11025), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PpTgPl3FqIzQRE9kBe2W7w/QP4b0HLFTyiusyXick8kvQ8BtuKSYkmpwdBCHD4WIOvuIZylAem9S_BORZ_viKlE6S-iZAKZY7aaYj-O4SoVOg/V9wfobdKUgC7Qp8lPA0rUoE-rNcO62q0WTr7eXRwCDg'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/W0FKVJplBUZw2fkZkAvhvQ/ml_qOTF-U-47CXg6kBQXpukbDxSCao3r-lkMhTL4axNn4536SJKkadf2P80VLCCFgcH3hnB-1JwlprVr0ytffA/sE9qskg8bmcEmZFy3tUVHoAbvb-dDysNZ7jjnCmYJoo'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zKRjkoRgyupi87ZaoTOmyg/SxFdXJ1I3PEmlGYHGaQE9YBF5CFSiJhEA_QvqWl-y4e9DImRQ7XtZ8kffHX0Ng91uzfQ4Bxc4EXaH3yJNzPKQQ/v0TUg9lZ8uRF7_wf4BDn3X9tLRoRCAF4rQYvhL-vLFw'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,"The ESP301-3N 3 Axis Motion Controller and Driver is the successor of the popular ESP300 motion controller. The ESP301 provides the same functionality as the ESP300 with a standard USB interface and extended front panel functions. For maximum backward compatibility, the ESP301 features the same motion commands and control algorithms and the same casing as the ESP300. The ESP301-3N drives and controls up to three axes of motion using any combination of DC or 2-phase stepper motors up to 3A per axis. This capability enables driving a large selection of Newport stages and actuators. Featuring an integrated manual front panel interface and Newport's unique ESP stage auto-detection and auto-configuration, the ESP301 provides most easy operation and excellent functionality at an affordable price.",https://www.newport.com/p/ESP301-3N,Newportesp 301,386.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newportesp301.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newportesp301-motor-controller,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782436/Instruments/Positional%20Controller/Newportesp-301/Newportesp-301.jpg,Newportesp 301,Write a Python script that uses Instrumentkit to connect to a Newportesp 301 Positional Controller,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Newport ESP-301 motor controller.

Due to the complexity of this piece of equipment, and relative lack of
documentation and following of normal SCPI guidelines, this file more than
likely contains bugs and non-complete behaviour.
""""""

# IMPORTS #####################################################################

from contextlib import contextmanager
from enum import IntEnum
from functools import reduce
import time

from instruments.abstract_instruments import Instrument
from instruments.newport.errors import NewportError
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList


# CLASSES #####################################################################


# pylint: disable=too-many-lines
class NewportESP301(Instrument):

    """"""
    Handles communication with the Newport ESP-301 multiple-axis motor
    controller using the protocol documented in the `user's guide`_.

    Due to the complexity of this piece of equipment, and relative lack of
    documentation and following of normal SCPI guidelines, this class more than
    likely contains bugs and non-complete behaviour.

    .. _user's guide: http://assets.newport.com/webDocuments-EN/images/14294.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._execute_immediately = True
        self._command_list = []
        self._bulk_query_resp = """"
        self.terminator = ""\r""

    class Axis:

        """"""
        Encapsulates communication concerning a single axis
        of an ESP-301 controller. This class should not be
        instantiated by the user directly, but is
        returned by `NewportESP301.axis`.
        """"""

        # quantities micro inch
        # micro_inch = u.UnitQuantity('micro-inch', u.inch / 1e6, symbol='uin')
        micro_inch = u.uinch

        # Some more work might need to be done here to make
        # the encoder_step and motor_step functional
        # I really don't have a concrete idea how I'm
        # going to do this until I have a physical device

        _unit_dict = {
            0: u.count,
            1: u.count,
            2: u.mm,
            3: u.um,
            4: u.inch,
            5: u.mil,
            6: micro_inch,  # compound unit for micro-inch
            7: u.deg,
            8: u.grad,
            9: u.rad,
            10: u.mrad,
            11: u.urad,
        }

        def __init__(self, controller, axis_id):
            if not isinstance(controller, NewportESP301):
                raise TypeError(
                    ""Axis must be controlled by a Newport ESP-301 "" ""motor controller.""
                )

            self._controller = controller
            self._axis_id = axis_id + 1

            self._units = self.units

        # CONTEXT MANAGERS ##

        @contextmanager
        def _units_of(self, units):
            """"""
            Sets the units for the corresponding axis to a those given by an integer
            label (see `NewportESP301.Units`), ensuring that the units are properly
            reset at the completion of the context manager.
            """"""
            old_units = self._get_units()
            self._set_units(units)
            yield
            self._set_units(old_units)

        # PRIVATE METHODS ##

        def _get_units(self):
            """"""
            Returns the integer label for the current units set for this axis.

            .. seealso::
                NewportESP301.Units
            """"""
            return self._controller.Units(
                int(self._newport_cmd(""SN?"", target=self.axis_id))
            )

        def _set_units(self, new_units):
            return self._newport_cmd(""SN"", target=self.axis_id, params=[int(new_units)])

        # PROPERTIES ##

        @property
        def axis_id(self):
            """"""
            Get axis number of Newport Controller

            :type: `int`
            """"""
            return self._axis_id

        @property
        def is_motion_done(self):
            """"""
            `True` if and only if all motion commands have
            completed. This method can be used to wait for
            a motion command to complete before sending the next
            command.

            :type: `bool`
            """"""
            return bool(int(self._newport_cmd(""MD?"", target=self.axis_id)))

        @property
        def acceleration(self):
            """"""
            Gets/sets the axis acceleration

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit
            :type: `~pint.Quantity` or `float`
            """"""

            return assume_units(
                float(self._newport_cmd(""AC?"", target=self.axis_id)),
                self._units / (u.s**2),
            )

        @acceleration.setter
        def acceleration(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / (u.s**2))
                .to(self._units / (u.s**2))
                .magnitude
            )
            self._newport_cmd(""AC"", target=self.axis_id, params=[newval])

        @property
        def deceleration(self):
            """"""
            Gets/sets the axis deceleration

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s^2}`
            :type: `~pint.Quantity` or float
            """"""
            return assume_units(
                float(self._newport_cmd(""AG?"", target=self.axis_id)),
                self._units / (u.s**2),
            )

        @deceleration.setter
        def deceleration(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / (u.s**2))
                .to(self._units / (u.s**2))
                .magnitude
            )
            self._newport_cmd(""AG"", target=self.axis_id, params=[newval])

        @property
        def estop_deceleration(self):
            """"""
            Gets/sets the axis estop deceleration

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s^2}`
            :type: `~pint.Quantity` or float
            """"""
            return assume_units(
                float(self._newport_cmd(""AE?"", target=self.axis_id)),
                self._units / (u.s**2),
            )

        @estop_deceleration.setter
        def estop_deceleration(self, decel):
            decel = float(
                assume_units(decel, self._units / (u.s**2))
                .to(self._units / (u.s**2))
                .magnitude
            )
            self._newport_cmd(""AE"", target=self.axis_id, params=[decel])

        @property
        def jerk(self):
            """"""
            Gets/sets the jerk rate for the controller

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit
            :type: `~pint.Quantity` or `float`
            """"""

            return assume_units(
                float(self._newport_cmd(""JK?"", target=self.axis_id)),
                self._units / (u.s**3),
            )

        @jerk.setter
        def jerk(self, jerk):
            jerk = float(
                assume_units(jerk, self._units / (u.s**3))
                .to(self._units / (u.s**3))
                .magnitude
            )
            self._newport_cmd(""JK"", target=self.axis_id, params=[jerk])

        @property
        def velocity(self):
            """"""
            Gets/sets the axis velocity

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""VA?"", target=self.axis_id)), self._units / u.s
            )

        @velocity.setter
        def velocity(self, velocity):
            velocity = float(
                assume_units(velocity, self._units / (u.s))
                .to(self._units / u.s)
                .magnitude
            )
            self._newport_cmd(""VA"", target=self.axis_id, params=[velocity])

        @property
        def max_velocity(self):
            """"""
            Gets/sets the axis maximum velocity

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""VU?"", target=self.axis_id)), self._units / u.s
            )

        @max_velocity.setter
        def max_velocity(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / u.s).to(self._units / u.s).magnitude
            )
            self._newport_cmd(""VU"", target=self.axis_id, params=[newval])

        @property
        def max_base_velocity(self):
            """"""
            Gets/sets the maximum base velocity for stepper motors

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""VB?"", target=self.axis_id)), self._units / u.s
            )

        @max_base_velocity.setter
        def max_base_velocity(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / u.s).to(self._units / u.s).magnitude
            )
            self._newport_cmd(""VB"", target=self.axis_id, params=[newval])

        @property
        def jog_high_velocity(self):
            """"""
            Gets/sets the axis jog high velocity

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""JH?"", target=self.axis_id)), self._units / u.s
            )

        @jog_high_velocity.setter
        def jog_high_velocity(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / u.s).to(self._units / u.s).magnitude
            )
            self._newport_cmd(""JH"", target=self.axis_id, params=[newval])

        @property
        def jog_low_velocity(self):
            """"""
            Gets/sets the axis jog low velocity

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""JW?"", target=self.axis_id)), self._units / u.s
            )

        @jog_low_velocity.setter
        def jog_low_velocity(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / u.s).to(self._units / u.s).magnitude
            )
            self._newport_cmd(""JW"", target=self.axis_id, params=[newval])

        @property
        def homing_velocity(self):
            """"""
            Gets/sets the axis homing velocity

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""OH?"", target=self.axis_id)), self._units / u.s
            )

        @homing_velocity.setter
        def homing_velocity(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / u.s).to(self._units / u.s).magnitude
            )
            self._newport_cmd(""OH"", target=self.axis_id, params=[newval])

        @property
        def max_acceleration(self):
            """"""
            Gets/sets the axis max acceleration

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s^2}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""AU?"", target=self.axis_id)),
                self._units / (u.s**2),
            )

        @max_acceleration.setter
        def max_acceleration(self, newval):
            if newval is None:
                return
            newval = float(
                assume_units(newval, self._units / (u.s**2))
                .to(self._units / (u.s**2))
                .magnitude
            )
            self._newport_cmd(""AU"", target=self.axis_id, params=[newval])

        @property
        def max_deceleration(self):
            """"""
            Gets/sets the axis max decceleration.
            Max deaceleration is always the same as acceleration.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\frac{unit}{s^2}`
            :type: `~pint.Quantity` or `float`
            """"""
            return self.max_acceleration

        @max_deceleration.setter
        def max_deceleration(self, decel):
            decel = float(
                assume_units(decel, self._units / (u.s**2))
                .to(self._units / (u.s**2))
                .magnitude
            )
            self.max_acceleration = decel

        @property
        def position(self):
            """"""
            Gets real position on axis in units

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""TP?"", target=self.axis_id)), self._units
            )

        @property
        def desired_position(self):
            """"""
            Gets desired position on axis in units

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""DP?"", target=self.axis_id)), self._units
            )

        @property
        def desired_velocity(self):
            """"""
            Gets the axis desired velocity in unit/s

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit/s
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""DV?"", target=self.axis_id)), self._units / u.s
            )

        @property
        def home(self):
            """"""
            Gets/sets the axis home position.
            Default should be 0 as that sets current position as home

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport unit
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""DH?"", target=self.axis_id)), self._units
            )

        @home.setter
        def home(self, newval):
            if newval is None:
                return
            newval = float(assume_units(newval, self._units).to(self._units).magnitude)
            self._newport_cmd(""DH"", target=self.axis_id, params=[newval])

        @property
        def units(self):
            """"""
            Get the units that all commands are in reference to.

            :type: `~pint.Unit` corresponding to units of axis connected  or
                int which corresponds to Newport unit number
            """"""
            self._units = self._get_pq_unit(self._get_units())
            return self._units

        @units.setter
        def units(self, newval):
            if newval is None:
                return
            if isinstance(newval, int):
                self._units = self._get_pq_unit(self._controller.Units(int(newval)))
            elif isinstance(newval, u.Unit):
                self._units = newval
                newval = self._get_unit_num(newval)
            self._set_units(newval)

        @property
        def encoder_resolution(self):
            """"""
            Gets/sets the resolution of the encode. The minimum number of units
            per step. Encoder functionality must be enabled.

            :units: The number of units per encoder step
            :type: `~pint.Quantity` or `float`
            """"""

            return assume_units(
                float(self._newport_cmd(""SU?"", target=self.axis_id)), self._units
            )

        @encoder_resolution.setter
        def encoder_resolution(self, newval):
            if newval is None:
                return
            newval = float(assume_units(newval, self._units).to(self._units).magnitude)
            self._newport_cmd(""SU"", target=self.axis_id, params=[newval])

        @property
        def full_step_resolution(self):
            """"""
            Gets/sets the axis resolution of the encode. The minimum number of
            units per step. Encoder functionality must be enabled.

            :units: The number of units per encoder step
            :type: `~pint.Quantity` or `float`
            """"""

            return assume_units(
                float(self._newport_cmd(""FR?"", target=self.axis_id)), self._units
            )

        @full_step_resolution.setter
        def full_step_resolution(self, newval):
            if newval is None:
                return
            newval = float(assume_units(newval, self._units).to(self._units).magnitude)
            self._newport_cmd(""FR"", target=self.axis_id, params=[newval])

        @property
        def left_limit(self):
            """"""
            Gets/sets the axis left travel limit

            :units: The limit in units
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""SL?"", target=self.axis_id)), self._units
            )

        @left_limit.setter
        def left_limit(self, limit):
            limit = float(assume_units(limit, self._units).to(self._units).magnitude)
            self._newport_cmd(""SL"", target=self.axis_id, params=[limit])

        @property
        def right_limit(self):
            """"""
            Gets/sets the axis right travel limit

            :units: units
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""SR?"", target=self.axis_id)), self._units
            )

        @right_limit.setter
        def right_limit(self, limit):
            limit = float(assume_units(limit, self._units).to(self._units).magnitude)
            self._newport_cmd(""SR"", target=self.axis_id, params=[limit])

        @property
        def error_threshold(self):
            """"""
            Gets/sets the axis error threshold

            :units: units
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""FE?"", target=self.axis_id)), self._units
            )

        @error_threshold.setter
        def error_threshold(self, newval):
            if newval is None:
                return
            newval = float(assume_units(newval, self._units).to(self._units).magnitude)
            self._newport_cmd(""FE"", target=self.axis_id, params=[newval])

        @property
        def current(self):
            """"""
            Gets/sets the axis current (amps)

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\text{A}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""QI?"", target=self.axis_id)), u.A
            )

        @current.setter
        def current(self, newval):
            if newval is None:
                return
            current = float(assume_units(newval, u.A).to(u.A).magnitude)
            self._newport_cmd(""QI"", target=self.axis_id, params=[current])

        @property
        def voltage(self):
            """"""
            Gets/sets the axis voltage

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of current newport :math:`\\text{V}`
            :type: `~pint.Quantity` or `float`
            """"""
            return assume_units(
                float(self._newport_cmd(""QV?"", target=self.axis_id)), u.V
            )

        @voltage.setter
        def voltage(self, newval):
            if newval is None:
                return
            voltage = float(assume_units(newval, u.V).to(u.V).magnitude)
            self._newport_cmd(""QV"", target=self.axis_id, params=[voltage])

        @property
        def motor_type(self):
            """"""
            Gets/sets the axis motor type
            * 0 = undefined
            * 1 = DC Servo
            * 2 = Stepper motor
            * 3 = commutated stepper motor
            * 4 = commutated brushless servo motor

            :type: `int`
            :rtype: `NewportESP301.MotorType`
            """"""
            return self._controller.MotorType(
                int(self._newport_cmd(""QM?"", target=self._axis_id))
            )

        @motor_type.setter
        def motor_type(self, newval):
            if newval is None:
                return
            self._newport_cmd(""QM"", target=self._axis_id, params=[int(newval)])

        @property
        def feedback_configuration(self):
            """"""
            Gets/sets the axis Feedback configuration

            :type: `int`
            """"""
            return int(self._newport_cmd(""ZB?"", target=self._axis_id)[:-2], 16)

        @feedback_configuration.setter
        def feedback_configuration(self, newval):
            if newval is None:
                return
            self._newport_cmd(""ZB"", target=self._axis_id, params=[int(newval)])

        @property
        def position_display_resolution(self):
            """"""
            Gets/sets the position display resolution

            :type: `int`
            """"""
            return int(self._newport_cmd(""FP?"", target=self._axis_id))

        @position_display_resolution.setter
        def position_display_resolution(self, newval):
            if newval is None:
                return
            self._newport_cmd(""FP"", target=self._axis_id, params=[int(newval)])

        @property
        def trajectory(self):
            """"""
            Gets/sets the axis trajectory

            :type: `int`
            """"""
            return int(self._newport_cmd(""TJ?"", target=self._axis_id))

        @trajectory.setter
        def trajectory(self, newval):
            if newval is None:
                return
            self._newport_cmd(""TJ"", target=self._axis_id, params=[int(newval)])

        @property
        def microstep_factor(self):
            """"""
            Gets/sets the axis microstep_factor

            :type: `int`
            """"""
            return int(self._newport_cmd(""QS?"", target=self._axis_id))

        @microstep_factor.setter
        def microstep_factor(self, newval):
            if newval is None:
                return
            newval = int(newval)
            if newval < 1 or newval > 250:
                raise ValueError(""Microstep factor must be between 1 and 250"")
            else:
                self._newport_cmd(""QS"", target=self._axis_id, params=[newval])

        @property
        def hardware_limit_configuration(self):
            """"""
            Gets/sets the axis hardware_limit_configuration

            :type: `int`
            """"""
            return int(self._newport_cmd(""ZH?"", target=self._axis_id)[:-2])

        @hardware_limit_configuration.setter
        def hardware_limit_configuration(self, newval):
            if newval is None:
                return
            self._newport_cmd(""ZH"", target=self._axis_id, params=[int(newval)])

        @property
        def acceleration_feed_forward(self):
            """"""
            Gets/sets the axis acceleration_feed_forward setting

            :type: `int`
            """"""
            return float(self._newport_cmd(""AF?"", target=self._axis_id))

        @acceleration_feed_forward.setter
        def acceleration_feed_forward(self, newval):
            if newval is None:
                return
            self._newport_cmd(""AF"", target=self._axis_id, params=[float(newval)])

        @property
        def proportional_gain(self):
            """"""
            Gets/sets the axis proportional_gain

            :type: `float`
            """"""
            return float(self._newport_cmd(""KP?"", target=self._axis_id)[:-1])

        @proportional_gain.setter
        def proportional_gain(self, newval):
            if newval is None:
                return
            self._newport_cmd(""KP"", target=self._axis_id, params=[float(newval)])

        @property
        def derivative_gain(self):
            """"""
            Gets/sets the axis derivative_gain

            :type: `float`
            """"""
            return float(self._newport_cmd(""KD?"", target=self._axis_id))

        @derivative_gain.setter
        def derivative_gain(self, newval):
            if newval is None:
                return
            self._newport_cmd(""KD"", target=self._axis_id, params=[float(newval)])

        @property
        def integral_gain(self):
            """"""
            Gets/sets the axis integral_gain

            :type: `float`
            """"""
            return float(self._newport_cmd(""KI?"", target=self._axis_id))

        @integral_gain.setter
        def integral_gain(self, newval):
            if newval is None:
                return
            self._newport_cmd(""KI"", target=self._axis_id, params=[float(newval)])

        @property
        def integral_saturation_gain(self):
            """"""
            Gets/sets the axis integral_saturation_gain

            :type: `float`
            """"""
            return float(self._newport_cmd(""KS?"", target=self._axis_id))

        @integral_saturation_gain.setter
        def integral_saturation_gain(self, newval):
            if newval is None:
                return
            self._newport_cmd(""KS"", target=self._axis_id, params=[float(newval)])

        @property
        def encoder_position(self):
            """"""
            Gets the encoder position

            :type:
            """"""
            with self._units_of(self._controller.Units.encoder_step):
                return self.position

        # MOVEMENT METHODS #

        def search_for_home(self, search_mode=None):
            """"""
            Searches this axis only
            for home using the method specified by ``search_mode``.

            :param HomeSearchMode search_mode: Method to detect when
                Home has been found. If None, the search mode is taken from
                HomeSearchMode.
            """"""
            if search_mode is None:
                search_mode = self._controller.HomeSearchMode.zero_position_count.value
            self._controller.search_for_home(axis=self.axis_id, search_mode=search_mode)

        def move(self, position, absolute=True, wait=False, block=False):
            """"""
            :param position: Position to set move to along this axis.
            :type position: `float` or :class:`~pint.Quantity`
            :param bool absolute: If `True`, the position ``pos`` is
                interpreted as relative to the zero-point of the encoder.
                If `False`, ``pos`` is interpreted as relative to the current
                position of this axis.
            :param bool wait: If True, will tell axis to not execute other
                commands until movement is finished
            :param bool block: If True, will block code until movement is finished
            """"""
            position = float(
                assume_units(position, self._units).to(self._units).magnitude
            )
            if absolute:
                self._newport_cmd(""PA"", params=[position], target=self.axis_id)
            else:
                self._newport_cmd(""PR"", params=[position], target=self.axis_id)

            if wait:
                self.wait_for_position(position)
                if block:
                    time.sleep(0.003)
                    mot = self.is_motion_done
                    while not mot:
                        mot = self.is_motion_done

        def move_to_hardware_limit(self):
            """"""
            move to hardware travel limit
            """"""
            self._newport_cmd(""MT"", target=self.axis_id)

        def move_indefinitely(self):
            """"""
            Move until told to stop
            """"""
            self._newport_cmd(""MV"", target=self.axis_id)

        def abort_motion(self):
            """"""
            Abort motion
            """"""
            self._newport_cmd(""AB"", target=self.axis_id)

        def wait_for_stop(self):
            """"""
            Waits for axis motion to stop before next command is executed
            """"""
            self._newport_cmd(""WS"", target=self.axis_id)

        def stop_motion(self):
            """"""
            Stop all motion on axis. With programmed deceleration rate
            """"""
            self._newport_cmd(""ST"", target=self.axis_id)

        def wait_for_position(self, position):
            """"""
            Wait for axis to reach position before executing next command

            :param position: Position to wait for on axis

            :type position: float or :class:`~pint.Quantity`
            """"""
            position = float(
                assume_units(position, self._units).to(self._units).magnitude
            )
            self._newport_cmd(""WP"", target=self.axis_id, params=[position])

        def wait_for_motion(self, poll_interval=0.01, max_wait=None):
            """"""
            Blocks until all movement along this axis is complete, as reported
            by `NewportESP301.Axis.is_motion_done`.

            :param float poll_interval: How long (in seconds) to sleep between
                checking if the motion is complete.
            :param float max_wait: Maximum amount of time to wait before
                raising a `IOError`. If `None`, this method will wait
                indefinitely.
            """"""
            # FIXME: make sure that the controller is not in
            #        programming mode, or else this might not work.
            #        In programming mode, the ""WS"" command should be
            #        sent instead, and the two parameters to this method should
            #        be ignored.
            poll_interval = float(assume_units(poll_interval, u.s).to(u.s).magnitude)
            if max_wait is not None:
                max_wait = float(assume_units(max_wait, u.s).to(u.s).magnitude)
            tic = time.time()
            while True:
                if self.is_motion_done:
                    return
                else:
                    if max_wait is None or (time.time() - tic) < max_wait:
                        time.sleep(poll_interval)
                    else:
                        raise OSError(""Timed out waiting for motion to finish."")

        def enable(self):
            """"""
            Turns motor axis on.
            """"""
            self._newport_cmd(""MO"", target=self._axis_id)

        def disable(self):
            """"""
            Turns motor axis off.
            """"""
            self._newport_cmd(""MF"", target=self._axis_id)

        def setup_axis(self, **kwargs):
            """"""
            Setup a non-newport DC servo motor stage. Necessary parameters are.

            * 'motor_type' = type of motor see 'QM' in Newport documentation
            * 'current' = motor maximum current (A)
            * 'voltage' = motor voltage (V)
            * 'units' = set units (see NewportESP301.Units)(U)
            * 'encoder_resolution' = value of encoder step in terms of (U)
            * 'max_velocity' = maximum velocity (U/s)
            * 'max_base_velocity' =  maximum working velocity (U/s)
            * 'homing_velocity' = homing speed (U/s)
            * 'jog_high_velocity' = jog high speed (U/s)
            * 'jog_low_velocity' = jog low speed (U/s)
            * 'max_acceleration' = maximum acceleration (U/s^2)
            * 'acceleration' = acceleration (U/s^2)
            * 'velocity' = velocity (U/s)
            * 'deceleration' = set deceleration (U/s^2)
            * 'error_threshold' = set error threshold (U)
            * 'estop_deceleration' = estop deceleration (U/s^2)
            * 'jerk' = jerk rate (U/s^3)
            * 'proportional_gain' = PID proportional gain (optional)
            * 'derivative_gain' = PID derivative gain (optional)
            * 'integral_gain' = PID internal gain (optional)
            * 'integral_saturation_gain' = PID integral saturation (optional)
            * 'trajectory' = trajectory mode (optional)
            * 'position_display_resolution' (U per step)
            * 'feedback_configuration'
            * 'full_step_resolution'  = (U per step)
            * 'home' = (U)
            * 'acceleration_feed_forward' = between 0 to 2e9
            * 'microstep_factor' = axis microstep factor
            * 'reduce_motor_torque_time' =  time (ms) between 0 and 60000,
            * 'reduce_motor_torque_percentage' = percentage between 0 and 100
            """"""

            self.motor_type = kwargs.get(""motor_type"")
            self.feedback_configuration = kwargs.get(""feedback_configuration"")
            self.full_step_resolution = kwargs.get(""full_step_resolution"")
            self.position_display_resolution = kwargs.get(
                ""position_display_"" ""resolution""
            )
            self.current = kwargs.get(""current"")
            self.voltage = kwargs.get(""voltage"")
            self.units = int(kwargs.get(""units""))
            self.encoder_resolution = kwargs.get(""encoder_resolution"")
            self.max_acceleration = kwargs.get(""max_acceleration"")
            self.max_velocity = kwargs.get(""max_velocity"")
            self.max_base_velocity = kwargs.get(""max_base_velocity"")
            self.homing_velocity = kwargs.get(""homing_velocity"")
            self.jog_high_velocity = kwargs.get(""jog_high_velocity"")
            self.jog_low_velocity = kwargs.get(""jog_low_velocity"")
            self.acceleration = kwargs.get(""acceleration"")
            self.velocity = kwargs.get(""velocity"")
            self.deceleration = kwargs.get(""deceleration"")
            self.estop_deceleration = kwargs.get(""estop_deceleration"")
            self.jerk = kwargs.get(""jerk"")
            self.error_threshold = kwargs.get(""error_threshold"")
            self.proportional_gain = kwargs.get(""proportional_gain"")
            self.derivative_gain = kwargs.get(""derivative_gain"")
            self.integral_gain = kwargs.get(""integral_gain"")
            self.integral_saturation_gain = kwargs.get(""integral_saturation_gain"")
            self.home = kwargs.get(""home"")
            self.microstep_factor = kwargs.get(""microstep_factor"")
            self.acceleration_feed_forward = kwargs.get(""acceleration_feed_forward"")
            self.trajectory = kwargs.get(""trajectory"")
            self.hardware_limit_configuration = kwargs.get(
                ""hardware_limit_"" ""configuration""
            )
            if (
                ""reduce_motor_torque_time"" in kwargs
                and ""reduce_motor_torque_percentage"" in kwargs
            ):
                motor_time = kwargs[""reduce_motor_torque_time""]
                motor_time = int(assume_units(motor_time, u.ms).to(u.ms).magnitude)
                if motor_time < 0 or motor_time > 60000:
                    raise ValueError(""Time must be between 0 and 60000 ms"")
                percentage = kwargs[""reduce_motor_torque_percentage""]
                percentage = int(
                    assume_units(percentage, u.percent).to(u.percent).magnitude
                )
                if percentage < 0 or percentage > 100:
                    raise ValueError(r""Percentage must be between 0 and 100%"")
                self._newport_cmd(
                    ""QR"", target=self._axis_id, params=[motor_time, percentage]
                )

            # update motor configuration
            self._newport_cmd(""UF"", target=self._axis_id)
            self._newport_cmd(""QD"", target=self._axis_id)
            # save configuration
            self._newport_cmd(""SM"")
            return self.read_setup()

        def read_setup(self):
            """"""
            Returns dictionary containing:
                'units'
                'motor_type'
                'feedback_configuration'
                'full_step_resolution'
                'position_display_resolution'
                'current'
                'max_velocity'
                'encoder_resolution'
                'acceleration'
                'deceleration'
                'velocity'
                'max_acceleration'
                'homing_velocity'
                'jog_high_velocity'
                'jog_low_velocity'
                'estop_deceleration'
                'jerk'
                'proportional_gain'
                'derivative_gain'
                'integral_gain'
                'integral_saturation_gain'
                'home'
                'microstep_factor'
                'acceleration_feed_forward'
                'trajectory'
                'hardware_limit_configuration'

            :rtype: dict of `pint.Quantity`, float and int
            """"""

            config = dict()
            config[""units""] = self.units
            config[""motor_type""] = self.motor_type
            config[""feedback_configuration""] = self.feedback_configuration
            config[""full_step_resolution""] = self.full_step_resolution
            config[""position_display_resolution""] = self.position_display_resolution
            config[""current""] = self.current
            config[""max_velocity""] = self.max_velocity
            config[""encoder_resolution""] = self.encoder_resolution
            config[""acceleration""] = self.acceleration
            config[""deceleration""] = self.deceleration
            config[""velocity""] = self.velocity
            config[""max_acceleration""] = self.max_acceleration
            config[""homing_velocity""] = self.homing_velocity
            config[""jog_high_velocity""] = self.jog_high_velocity
            config[""jog_low_velocity""] = self.jog_low_velocity
            config[""estop_deceleration""] = self.estop_deceleration
            config[""jerk""] = self.jerk
            # config['error_threshold'] = self.error_threshold
            config[""proportional_gain""] = self.proportional_gain
            config[""derivative_gain""] = self.derivative_gain
            config[""integral_gain""] = self.integral_gain
            config[""integral_saturation_gain""] = self.integral_saturation_gain
            config[""home""] = self.home
            config[""microstep_factor""] = self.microstep_factor
            config[""acceleration_feed_forward""] = self.acceleration_feed_forward
            config[""trajectory""] = self.trajectory
            config[""hardware_limit_configuration""] = self.hardware_limit_configuration
            return config

        def get_status(self):
            """"""
            Returns Dictionary containing values:
                'units'
                'position'
                'desired_position'
                'desired_velocity'
                'is_motion_done'

            :rtype: dict
            """"""
            status = dict()
            status[""units""] = self.units
            status[""position""] = self.position
            status[""desired_position""] = self.desired_position
            status[""desired_velocity""] = self.desired_velocity
            status[""is_motion_done""] = self.is_motion_done

            return status

        @staticmethod
        def _get_pq_unit(num):
            """"""
            Gets the units for the specified axis.

            :units: The units for the attached axis
            :type num: int
            """"""
            return NewportESP301.Axis._unit_dict[num]

        def _get_unit_num(self, quantity):
            """"""
            Gets the integer label used by the Newport ESP 301 corresponding to a
            given `~pint.Quantity`.

            :param pint.Quantity quantity: Units to return a label for.

            :return int:
            """"""
            for num, quant in self._unit_dict.items():
                if quant == quantity:
                    return num

            raise KeyError(f""{quantity} is not a valid unit for Newport Axis"")

        # pylint: disable=protected-access
        def _newport_cmd(self, cmd, **kwargs):
            """"""
            Passes the newport command from the axis class to the parent controller

            :param cmd:
            :param kwargs:
            :return:
            """"""
            return self._controller._newport_cmd(cmd, **kwargs)

    # ENUMS #

    class HomeSearchMode(IntEnum):

        """"""
        Enum containing different search modes code
        """"""

        #: Search along specified axes for the +0 position.
        zero_position_count = 0
        #: Search for combined Home and Index signals.
        home_index_signals = 1
        #: Search only for the Home signal.
        home_signal_only = 2
        #: Search for the positive limit signal.
        pos_limit_signal = 3
        #: Search for the negative limit signal.
        neg_limit_signal = 4
        #: Search for the positive limit and Index signals.
        pos_index_signals = 5
        #: Search for the negative limit and Index signals.
        neg_index_signals = 6

    class MotorType(IntEnum):

        """"""
        Enum for different motor types.
        """"""

        undefined = 0
        dc_servo = 1
        stepper_motor = 2
        commutated_stepper_motor = 3
        commutated_brushless_servo = 4

    class Units(IntEnum):

        """"""
        Enum containing what `units` return means.
        """"""

        encoder_step = 0
        motor_step = 1
        millimeter = 2
        micrometer = 3
        inches = 4
        milli_inches = 5
        micro_inches = 6
        degree = 7
        gradian = 8
        radian = 9
        milliradian = 10
        microradian = 11

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets the axes of the motor controller as a sequence. For instance,
        to move along a given axis::

        >>> controller = NewportESP301.open_serial(""COM3"")
        >>> controller.axis[0].move(-0.001, absolute=False)

        Note that the axes are numbered starting from zero, so that
        Python idioms can be used more easily. This is not the same convention
        used in the Newport ESP-301 user's manual, and so care must
        be taken when converting examples.

        :type: :class:`NewportESP301.Axis`
        """"""

        return ProxyList(self, self.Axis, range(100))
        # return _AxisList(self)

    # LOW-LEVEL COMMAND METHODS ##

    def _newport_cmd(self, cmd, params=tuple(), target=None, errcheck=True):
        """"""
        The Newport ESP-301 command set supports checking for errors,
        specifying different axes and allows for multiple parameters.
        As such, it is convienent to wrap calls to the low-level
        `~instruments.abstract_instruments.Instrument.sendcmd` method
        in a method that is aware of the eccenticities of the controller.

        This method sends a command, checks for errors on the device
        and turns them into exceptions as needed.

        :param bool errcheck: If `False`, suppresses the standard error
            checking. Note that since error-checking is unsupported
            during device programming, ``errcheck`` must be `False`
            during ``PGM`` mode.
        """"""
        query_resp = None
        if isinstance(target, self.Axis):
            target = target.axis_id
        raw_cmd = ""{target}{cmd}{params}"".format(
            target=target if target is not None else """",
            cmd=cmd.upper(),
            params="","".join(map(str, params)),
        )

        if self._execute_immediately:
            query_resp = self._execute_cmd(raw_cmd, errcheck)
        else:
            self._command_list.append(raw_cmd)

        # This works because ""return None"" is equivalent to ""return"".
        return query_resp

    def _execute_cmd(self, raw_cmd, errcheck=True):
        """"""
        Takes a string command and executes it on Newport


        :param str raw_cmd:
        :param bool errcheck:


        :return: response of device
        :rtype: `str`

        """"""
        query_resp = None

        if ""?"" in raw_cmd:
            query_resp = self.query(raw_cmd)
        else:
            self.sendcmd(raw_cmd)

        if errcheck:
            err_resp = self.query(""TB?"")

            # pylint: disable=unused-variable
            code, timestamp, msg = err_resp.split("","")
            code = int(code)
            if code != 0:
                raise NewportError(code)

        return query_resp

    # SPECIFIC COMMANDS ##

    def _home(self, axis, search_mode, errcheck=True):
        """"""
        Private method for searching for home ""OR"", so that
        the methods in this class and the axis class can both
        point to the same thing.
        """"""
        self._newport_cmd(""OR"", target=axis, params=[search_mode], errcheck=errcheck)

    def search_for_home(
        self,
        axis=1,
        search_mode=HomeSearchMode.zero_position_count.value,
        errcheck=True,
    ):
        """"""
        Searches the specified axis for home using the method specified
        by ``search_mode``.

        :param int axis: Axis ID for which home should be searched for. This
            value is 1-based indexing.
        :param HomeSearchMode search_mode: Method to detect when
            Home has been found.
        :param bool errcheck: Boolean to check for errors after each command
            that is sent to the instrument.
        """"""
        self._home(axis=axis, search_mode=search_mode, errcheck=errcheck)

    def reset(self):
        """"""
        Causes the device to perform a hardware reset. Note that
        this method is only effective if the watchdog timer is enabled
        by the physical jumpers on the ESP-301. Please see the `user's guide`_
        for more information.
        """"""
        self._newport_cmd(""RS"", errcheck=False)

    # USER PROGRAMS ##

    @contextmanager
    def define_program(self, program_id):
        """"""
        Erases any existing programs with a given program ID
        and instructs the device to record the commands within this
        ``with`` block to be saved as a program with that ID.

        For instance:

        >>> controller = NewportESP301.open_serial(""COM3"")
        >>> with controller.define_program(15):
        ...     controller.axis[0].move(0.001, absolute=False)
        ...
        >>> controller.run_program(15)

        :param int program_id: An integer label for the new program.
            Must be in ``range(1, 101)``.
        """"""
        if program_id not in range(1, 101):
            raise ValueError(
                ""Invalid program ID. Must be an integer from "" ""1 to 100 (inclusive).""
            )
        self._newport_cmd(""XX"", target=program_id)
        try:
            self._newport_cmd(""EP"", target=program_id)
            yield
        finally:
            self._newport_cmd(""QP"")

    @contextmanager
    def execute_bulk_command(self, errcheck=True):
        """"""
        Context manager to execute multiple commands in a single
        communication with device

        Example::

            with self.execute_bulk_command():
                execute commands as normal...

        :param bool errcheck: Boolean to check for errors after each command
            that is sent to the instrument.
        """"""
        self._execute_immediately = False
        yield
        command_string = reduce(lambda x, y: x + "" ; "" + y + "" ; "", self._command_list)
        # TODO: is _bulk_query_resp getting back to user?
        self._bulk_query_resp = self._execute_cmd(command_string, errcheck)
        self._command_list = []
        self._execute_immediately = True

    def run_program(self, program_id):
        """"""
        Runs a previously defined user program with a given program ID.

        :param int program_id: ID number for previously saved user program
        """"""
        if program_id not in range(1, 101):
            raise ValueError(
                ""Invalid program ID. Must be an integer from "" ""1 to 100 (inclusive).""
            )
        self._newport_cmd(""EX"", target=program_id)
"
20,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att89SCom6OfiH4jE'), ('width', 1157), ('height', 687), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/sDiIxQF-A7A21jOwRoZK6w/f_gAkZaDxRfue7yATuZl_3rTFOb1T8IQ6mUAU4IZoX1L2L92ejYIhKH99GeQ4yO5M14BZxorzYB-0d9xWU_hsEoBV5OOnSmkUE7iAF7z57A/09VSMv2G_AJrEEjbmd3pbFkqm7MlNDEG7dV4KZyr4S0'), ('filename', 'TDS224.jpeg'), ('size', 134607), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7WwyvPV3WM9PlOxe0ekOPg/-Y-S8wIUff1MhqbtY0JceN-76gkY2U6LbIDMFprTmtF6LwcqvAYqrLbFk4t3-TL5RGsLydTAAvofSv8bm4cMcg/LcibTpzNny6O9odVjMZmlPm83pcOE1PZ0c6ND3v6vTA'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/N6HhuTSluElhJjGOrbPl-A/bAkz5M_-89Bb7OGwgSyMo53UQSMUE9n5z3HDuzEfsmfc7RVbxZIuhNxmZs94h3QHnRp9G7FtvoUGe8fbgF5qRw/QnPxf3oMGXs3crAQf0_jgF7BteweW7oTpqHYZgAlNbs'), ('width', 862), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zLv5v_8DmEyKAOjxNnIIlw/FhTBkMClNF1Wc_l8d3i617V_D-mXs0iIJqOhqYt4V0PFT3-CWPRUS37u35vmqjgGlvujLTSXf4myMo2r0E9YrQ/yuCfsTaus417242iidNkZcASW_lKawRGS1Qpd51uUWo'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,,,Tektds 224,547.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tektds224.html,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/intro.html,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782513/Instruments/Oscilloscopes/TDS224/TDS224.jpg,TDS224,Write a Python script that uses Instrumentkit to connect to a TDS224 Oscilloscopes,,,,,
25,https://www.testequipmenthq.com/datasheets/KEITHLEY-485-Datasheet.pdf,https://en.wikipedia.org/wiki/Electricity_meter,"[OrderedDict([('id', 'attvUEoTPINWnGzN5'), ('width', 600), ('height', 318), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/aX-DaoCp3sMrtsX0Vk2V6g/G3QV3-nRM5ZxYD8uLk9LtelYypXVaHbd6c_M-aIg4COuBlQZqxtcidgB64VFJ-sRNYzIBgJg1MSLKHnrQegJkFLxMweFy31PHcbVbfIq9Vw/0AhPpH1AicEWjv03WGwuhuexpdkrwQs19E7fTR6qEtM'), ('filename', 'Keithley_485_View5.jpg'), ('size', 71051), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qdnP1t-HfQhVZmxepGCxqg/HKmRouuFhnAGaCqBdaaCnT815edLQga9Zp8l3Vb2WQAfCaevyUaMUO2csge6KFLOE2fY5G6WSzug5i27O4LGvw/z8Y3aAeZpQynzeklud2X56vWz9yrW_2qDg0AgnTS84U'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pX1THy30XKaO1H4b0ybYDw/ibTnvNrnoem5TiLaWejdH7M41rDT-ocErwtHt-8Itapm82Qg_EcDks5rl82wqMWCdgqmxv8naIPv7wR3s6GiSw/o-qG_WeAft33-QjWHe_6Wt0SDX-8oHdZvlkkBy0VbaE'), ('width', 600), ('height', 318)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qiOGNFRnvr_V2xiyjT_OIA/OnIqgDEpsAnGxth7c9w1eRU9U988jMaIBfq5coCO7O3dbT11vuSCc0fWgg-rq0nvauRMSc9KHCq6VINDFAHOjg/V8_GRFsQAyDdK7Yz1JGO9PIpg4NRSQhRsWt8rSRbPtc'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Keithley 485 Autoranging Picoammeter provides 100fA sensitivity with 4 1/2-digit resolution in a low-cost, highly sensitive, easy-to-use instrument. The 485 measures DC current on seven ranges covering 10 decades from 100fA to 2mA. The input can withstand overloads as high as 1000V (with 100kΩ limiting resistor) for flexibility in a wide range of applications in test, research, and student labs. An analog output linearly converts the incoming current to voltage for hard copy output or control loop applications.
",https://www.artisantg.com/TestMeasurement/67358-1/Keithley-485-Autoranging-Picoammeter,Keithley 485,237.0,['Power Meters'],"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley485.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley485-picoammeter,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782442/Instruments/Power%20Meters/Keithley-485/Keithley-485.jpg,Keithley 485,Write a Python script that uses Instrumentkit to connect to a Keithley 485 Power Meters,,,,,"#!/usr/bin/env python
#
# keithley485.py: Driver for the Keithley 485 picoammeter.
#
# © 2019 Francois Drielsma (francois.drielsma@gmail.com).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the Keithley 485 picoammeter.

Originally contributed and copyright held by Francois Drielsma
(francois.drielsma@gmail.com).

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

from struct import unpack
from enum import Enum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley485(Instrument):

    """"""
    The Keithley Model 485 is a 4 1/2 digit resolution autoranging
    picoammeter with a +- 20000 count LCD. It is designed for low
    current measurement requirements from 0.1pA to 2mA.

    The device needs some processing time (manual reports 300-500ms) after a
    command has been transmitted.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.keithley.Keithley485.open_gpibusb(""/dev/ttyUSB0"", 22)
    >>> inst.measure()  # Measures the current
    array(-1.278e-10) * A
    """"""

    # ENUMS #

    class TriggerMode(Enum):
        """"""
        Enum containing valid trigger modes for the Keithley 485
        """"""

        #: Continuously measures current, returns on talk
        continuous_ontalk = 0
        #: Measures current once and returns on talk
        oneshot_ontalk = 1
        #: Continuously measures current, returns on `GET`
        continuous_onget = 2
        #: Measures current once and returns on `GET`
        oneshot_onget = 3
        #: Continuously measures current, returns on `X`
        continuous_onx = 4
        #: Measures current once and returns on `X`
        oneshot_onx = 5

    class SRQDataMask(Enum):
        """"""
        Enum containing valid SRQ data masks for the Keithley 485
        """"""

        #: Service request (SRQ) disabled
        srq_disabled = 0
        #: Read overflow
        read_ovf = 1
        #: Read done
        read_done = 8
        #: Read done or read overflow
        read_done_ovf = 9
        #: Device busy
        busy = 16
        #: Device busy or read overflow
        busy_read_ovf = 17
        #: Device busy or read overflow
        busy_read_done = 24
        #: Device busy, read done or read overflow
        busy_read_done_ovf = 25

    class SRQErrorMask(Enum):
        """"""
        Enum containing valid SRQ error masks for the Keithley 485
        """"""

        #: Service request (SRQ) disabled
        srq_disabled = 0
        #: Illegal Device-Dependent Command Option (IDDCO)
        idcco = 1
        #: Illegal Device-Dependent Command (IDDC)
        idcc = 2
        #: IDDCO or IDDC
        idcco_idcc = 3
        #: Device not in remote
        not_remote = 4
        #: Device not in remote or IDDCO
        not_remote_idcco = 5
        #: Device not in remote or IDDC
        not_remote_idcc = 6
        #: Device not in remote, IDDCO or IDDC
        not_remote_idcco_idcc = 7

    class Status(Enum):
        """"""
        Enum containing valid status keys in the measurement string
        """"""

        #: Measurement normal
        normal = b""N""
        #: Measurement zero-check
        zerocheck = b""C""
        #: Measurement overflow
        overflow = b""O""
        #: Measurement relative
        relative = b""Z""

    # PROPERTIES #

    @property
    def zero_check(self):
        """"""
        Gets/sets the 'zero check' mode (C) of the Keithley 485.

        Once zero check is enabled (C1 sent), the display can be
        zeroed with the REL feature or the front panel pot.

        See the Keithley 485 manual for more information.

        :type: `bool`
        """"""
        return self.get_status()[""zerocheck""]

    @zero_check.setter
    def zero_check(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Zero Check mode must be a boolean."")
        self.sendcmd(f""C{int(newval)}X"")

    @property
    def log(self):
        """"""
        Gets/sets the 'log' mode (D) of the Keithley 485.

        Once log is enabled (D1 sent), the device will return
        the logarithm of the current readings.

        See the Keithley 485 manual for more information.

        :type: `bool`
        """"""
        return self.get_status()[""log""]

    @log.setter
    def log(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Log mode must be a boolean."")
        self.sendcmd(f""D{int(newval)}X"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range (R) of the Keithley 485 input terminals. The valid
        ranges are one of ``{auto|2e-9|2e-8|2e-7|2e-6|2e-5|2e-4|2e-3}``

        :type: `~pint.Quantity` or `str`
        """"""
        value = self.get_status()[""range""]
        if isinstance(value, str):
            return value
        return value * u.amp

    @input_range.setter
    def input_range(self, newval):
        valid = (""auto"", 2e-9, 2e-8, 2e-7, 2e-6, 2e-5, 2e-4, 2e-3)
        if isinstance(newval, str):
            newval = newval.lower()
            if newval == ""auto"":
                self.sendcmd(""R0X"")
                return
            else:
                raise ValueError(
                    ""Only `auto` is acceptable when specifying ""
                    ""the range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval)
            else:
                raise ValueError(f""Valid range settings are: {valid}"")
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                ""or the string `auto`, got {}"".format(type(newval))
            )
        self.sendcmd(f""R{newval}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the relative measurement mode (Z) of the Keithley 485.

        As stated in the manual: The relative function is used to establish a
        baseline reading. This reading is subtracted from all subsequent
        readings. The purpose of making relative measurements is to cancel test
        lead and offset currents or to store an input as a reference level.

        Once a relative level is established, it remains in effect until another
        relative level is set. The relative value is only good for the range the
        value was taken on and higher ranges. If a lower range is selected than
        that on which the relative was taken, inaccurate results may occur.
        Relative cannot be activated when ""OL"" is displayed.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.get_status()[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}X"")

    @property
    def eoi_mode(self):
        """"""
        Gets/sets the 'eoi' mode (K) of the Keithley 485.

        The model 485 will normally send an end of interrupt (EOI)
        during the last byte of its data string or status word.
        The EOI reponse of the instrument may be included or omitted.
        Warning: the default setting (K0) includes it.

        See the Keithley 485 manual for more information.

        :type: `bool`
        """"""
        return self.get_status()[""eoi_mode""]

    @eoi_mode.setter
    def eoi_mode(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""EOI mode must be a boolean."")
        self.sendcmd(f""K{1 - int(newval)}X"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode (T) of the Keithley 485.

        There are two different trigger settings for three different sources.
        This means there are six different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the current. One-shot performs a single
        current measurement when requested to do so.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". Last, on ""X"" is when one sends the ASCII character ""X"" to the
        instrument.

        It is recommended to leave it in the default mode (T0, continuous on talk),
        and simply ignore the output when other commands are called.

        :type: `Keithley485.TriggerMode`
        """"""
        return self.get_status()[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley485.TriggerMode[newval]
        if not isinstance(newval, Keithley485.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley485.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    # METHODS #

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 485.

        This is the same as calling the `Keithley485.set_current_range`
        method and setting the parameter to ""AUTO"".
        """"""
        self.sendcmd(""R0X"")

    def get_status(self):
        """"""
        Gets and parses the status word.

        Returns a `dict` with the following keys:
        ``{zerocheck,log,range,relative,eoi,relative,
        trigger,datamask,errormask,terminator}``

        :rtype: `dict`
        """"""
        return self._parse_status_word(self._get_status_word())

    def _get_status_word(self):
        """"""
        The device will not always respond with the statusword when asked. We
        use a simple heuristic here: request it up to 5 times.

        :rtype: `str`
        """"""
        tries = 5
        statusword = """"
        while statusword[:3] != ""485"" and tries != 0:
            statusword = self.query(""U0X"")
            tries -= 1

        if tries == 0:
            raise OSError(""Could not retrieve status word"")

        return statusword[:-1]

    def _parse_status_word(self, statusword):
        """"""
        Parse the status word returned by the function
        `~Keithley485.get_status_word`.

        Returns a `dict` with the following keys:
        ``{zerocheck,log,range,relative,eoi,relative,
        trigger,datamask,errormask,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :rtype: `dict`
        """"""
        if statusword[:3] != ""485"":
            raise ValueError(
                ""Status word starts with wrong "" ""prefix: {}"".format(statusword)
            )

        (
            zerocheck,
            log,
            device_range,
            relative,
            eoi_mode,
            trigger,
            datamask,
            errormask,
        ) = unpack(""@6c2s2s"", bytes(statusword[3:], ""utf-8""))

        valid_range = {
            b""0"": ""auto"",
            b""1"": 2e-9,
            b""2"": 2e-8,
            b""3"": 2e-7,
            b""4"": 2e-6,
            b""5"": 2e-5,
            b""6"": 2e-4,
            b""7"": 2e-3,
        }

        try:
            device_range = valid_range[device_range]
            trigger = self.TriggerMode(int(trigger)).name
            datamask = self.SRQDataMask(int(datamask)).name
            errormask = self.SRQErrorMask(int(errormask)).name
        except:
            raise RuntimeError(""Cannot parse status "" ""word: {}"".format(statusword))

        return {
            ""zerocheck"": zerocheck == b""1"",
            ""log"": log == b""1"",
            ""range"": device_range,
            ""relative"": relative == b""1"",
            ""eoi_mode"": eoi_mode == b""0"",
            ""trigger"": trigger,
            ""datamask"": datamask,
            ""errormask"": errormask,
            ""terminator"": self.terminator,
        }

    def measure(self):
        """"""
        Perform a current measurement with the Keithley 485.

        :rtype: `~pint.Quantity`
        """"""
        return self._parse_measurement(self.query(""X""))

    def _parse_measurement(self, measurement):
        """"""
        Parse the measurement string returned by the instrument.

        Returns the current formatted as a Quantity.

        :param measurement: String to be unpacked and parsed
        :type: `str`

        :rtype: `~pint.Quantity`
        """"""
        (status, function, base, current) = unpack(
            ""@1c2s1c10s"", bytes(measurement, ""utf-8"")
        )

        try:
            status = self.Status(status)
        except ValueError:
            raise ValueError(f""Invalid status word in measurement: {status}"")

        if status != self.Status.normal:
            raise ValueError(f""Instrument not in normal mode: {status.name}"")

        if function != b""DC"":
            raise ValueError(f""Instrument not returning DC function: {function}"")

        try:
            current = (
                float(current) * u.amp
                if base == b""A""
                else 10 ** (float(current)) * u.amp
            )
        except:
            raise Exception(f""Cannot parse measurement: {measurement}"")

        return current
"
35,https://download.tek.com/datasheet/2182A-15912.pdf,https://en.wikipedia.org/wiki/Voltmeter,"[OrderedDict([('id', 'attKCSe2wix9ghzw6'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eXnAEiXg0-NrkIYozDj7gQ/phuJGC_pAvDlA0QxGm0HSYGVKaC2LjbYj2-tq_NBKvWSthyZjtdySi0y2qRdK79GZq-09AHt67-XUpqMGHGCBg/OjihkiNLAAGP8EJd-FpNIDuaoitgMrrzIJtBI2uTY6c'), ('filename', '2182.jpg'), ('size', 23819), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jOuWFR0iAEpXr7Zx9QJf_Q/ofJbmewth6hoe11hrDlkI-0kXC3pitZElR1sMODhzhjVLC4ZMdMpsqOU5NE4JL0ZigyDyFQ1WJajjFCRspoa6A/PC2NANJf70QK1fK_0Zwcvv21f8lVQBHzD0tOL_t5HvI'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pKAyylm_DUB-D0r0O4Urnw/3WhOz14CWffIMqoDI4nE-r4ZUEsUgkm24A6RVsrhWJy9xdPqOjwVOZNnpgl3g_5TeTk7gyQcgr6OybKAhDTIAg/pR7h8KX7Z6EV5MMtRIST71VhTD3vSDO5KsvWr_3e1n0'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/N_lwuPcA8qtR35tr-Str-w/M4U_2DW3Mf2aQb9kG_4XTVCpKBZQSsjDhkpKW4Q_qSuDLlKnocWgAZ7czIgoGqRQv8C98WIgb9bKMygByuqgjA/J5UqFlRgOat2z4XQ7_8mgghv_g6ViHCPxpFy0GiXqIM'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The two-channel Model 2182A Nanovoltmeter is optimized for making stable, low noise voltage measurements and for characterizing low resistance materials and devices reliably and repeatably. It provides higher measurement speed and significantly better noise performance than alternative low voltage measurement solutions. It offers a simplified delta mode for making resistance measurements in combination with a reversing current source, such as the Model 6220 or 6221.",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/nanovoltmeter-model-2182a,Keithley 2182,250.0,['Power Meters'],A voltmeter is an instrument used for measuring electric potential difference between two points in an electric circuit. It is connected in parallel. It usually has a high resistance so that it takes negligible current from the circuit.,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley2182.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley2182-nano-voltmeter,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782450/Instruments/Power%20Meters/Keithley-2182/Keithley-2182.jpg,Keithley 2182,Write a Python script that uses Instrumentkit to connect to a Keithley 2182 Power Meters,7500.0,,,,"#!/usr/bin/env python
""""""
Driver for the Keithley 2182 nano-voltmeter
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Multimeter
from instruments.generic_scpi import SCPIMultimeter
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Keithley2182(SCPIMultimeter):

    """"""
    The Keithley 2182 is a nano-voltmeter. You can find the full specifications
    list in the `user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> meter = ik.keithley.Keithley2182.open_gpibusb(""/dev/ttyUSB0"", 10)
    >>> print(meter.measure(meter.Mode.voltage_dc))


    """"""

    # INNER CLASSES #

    class Channel(Multimeter):
        """"""
        Class representing a channel on the Keithley 2182 nano-voltmeter.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Keithley2182` class.
        """"""

        # pylint: disable=super-init-not-called
        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES #

        @property
        def mode(self):
            return Keithley2182.Mode(self._parent.query(""SENS:FUNC?""))

        @mode.setter
        def mode(self, newval):
            raise NotImplementedError

        @property
        def trigger_mode(self):
            raise NotImplementedError

        @trigger_mode.setter
        def trigger_mode(self, newval):
            raise NotImplementedError

        @property
        def relative(self):
            raise NotImplementedError

        @relative.setter
        def relative(self, newval):
            raise NotImplementedError

        @property
        def input_range(self):
            raise NotImplementedError

        @input_range.setter
        def input_range(self, newval):
            raise NotImplementedError

        # METHODS #

        def measure(self, mode=None):
            """"""
            Performs a measurement of the specified channel. If no mode
            parameter is specified then the current mode is used.

            :param mode: Mode that the measurement will be performed in
            :type mode: Keithley2182.Mode
            :return: The value of the measurement
            :rtype: `~pint.Quantity`
            """"""
            if mode is not None:
                # self.mode = mode
                raise NotImplementedError
            self._parent.sendcmd(f""SENS:CHAN {self._idx}"")
            value = float(self._parent.query(""SENS:DATA:FRES?""))
            unit = self._parent.units
            return u.Quantity(value, unit)

    # ENUMS #

    class Mode(Enum):
        """"""
        Enum containing valid measurement modes for the Keithley 2182
        """"""

        voltage_dc = ""VOLT""
        temperature = ""TEMP""

    class TriggerMode(Enum):
        """"""
        Enum containing valid trigger modes for the Keithley 2182
        """"""

        immediate = ""IMM""
        external = ""EXT""
        bus = ""BUS""
        timer = ""TIM""
        manual = ""MAN""

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets a specific Keithley 2182 channel object. The desired channel is
        specified like one would access a list.

        Although not default, the 2182 has up to two channels.

        For example, the following would print the measurement from channel 1:

        >>> meter = ik.keithley.Keithley2182.open_gpibusb(""/dev/ttyUSB0"", 10)
        >>> print meter.channel[0].measure()

        :rtype: `Keithley2182.Channel`
        """"""
        return ProxyList(self, Keithley2182.Channel, range(2))

    @property
    def relative(self):
        """"""
        Gets/sets the relative measurement function of the Keithley 2182.

        This is used to enable or disable the relative function for the
        currently set mode. When enabling, the current reading is used as a
        baseline which is subtracted from future measurements.

        If relative is already on, the stored value is refreshed with the
        currently read value.

        See the manual for more information.

        :type: `bool`
        """"""
        mode = self.channel[0].mode
        return self.query(f""SENS:{mode.value}:CHAN1:REF:STAT?"") == ""ON""

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        mode = self.channel[0].mode
        if self.relative:
            self.sendcmd(f""SENS:{mode.value}:CHAN1:REF:ACQ"")
        else:
            newval = ""ON"" if newval is True else ""OFF""
            self.sendcmd(f""SENS:{mode.value}:CHAN1:REF:STAT {newval}"")

    @property
    def input_range(self):
        raise NotImplementedError

    @input_range.setter
    def input_range(self, newval):
        raise NotImplementedError

    @property
    def units(self):
        """"""
        Gets the current measurement units of the instrument.

        :rtype: `~pint.Unit`
        """"""
        mode = self.channel[0].mode
        if mode == Keithley2182.Mode.voltage_dc:
            return u.volt
        unit = self.query(""UNIT:TEMP?"")
        if unit == ""C"":
            unit = u.celsius
        elif unit == ""K"":
            unit = u.kelvin
        elif unit == ""F"":
            unit = u.fahrenheit
        else:
            raise ValueError(""Unknown temperature units."")
        return unit

    # METHODS #

    def fetch(self):
        """"""
        Transfer readings from instrument memory to the output buffer, and thus
        to the computer.
        If currently taking a reading, the instrument will wait until it is
        complete before executing this command.
        Readings are NOT erased from memory when using fetch. Use the ``R?``
        command to read and erase data.
        Note that the data is transfered as ASCII, and thus it is not
        recommended to transfer a large number of data points using GPIB.

        :return: Measurement readings from the instrument output buffer.
        :rtype: `tuple`[`~pint.Quantity`, ...]
            or if numpy is installed, `~pint.Quantity` with `numpy.array` data
        """"""
        data = list(map(float, self.query(""FETC?"").split("","")))
        unit = self.units
        if numpy:
            return data * unit
        return tuple(d * unit for d in data)

    def measure(self, mode=None):
        """"""
        Perform and transfer a measurement of the desired type.

        :param mode: Desired measurement mode. If left at default the
            measurement will occur with the current mode.
        :type: `Keithley2182.Mode`

        :return: Returns a single shot measurement of the specified mode.
        :rtype: `~pint.Quantity`
        :units: Volts, Celsius, Kelvin, or Fahrenheit
        """"""
        if mode is None:
            mode = self.channel[0].mode
        if not isinstance(mode, Keithley2182.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley2182.Mode ""
                ""value, got {} instead."".format(mode)
            )
        value = float(self.query(f""MEAS:{mode.value}?""))
        unit = self.units
        return value * unit
"
42,,https://en.wikipedia.org/wiki/Coincidence_counting_(physics),"[OrderedDict([('id', 'attW3pZ1U5zs32JXd'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/dMJWwWyxurEf-JdGc9zkuw/VWEkzZAHiu5B1tU_pQ07sEf460UTOYEgsK54VphK3F1QoicU9u7VpQOqwNfeZVtbdN7K1jd-P5BqEOUUclcU4g-TctHZB3xe2kPg_I7d-NNS1r7-M2YtZa3gK6_ZSvpX/OhuhH_IetHpIJlHQs3w7mD_qt6Ma-3F18p1vFz8nkT4'), ('filename', 'QBTK006_Handheld_Coincidence_Counter.jpg'), ('size', 43231), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/m2I_772kOE6CWgA0sOsMgw/I1XkiWq8Iw5kwgcislqpJEPKO6qJ2KjXAHFdg9XKbBO2y9TsMhMK0jr9x6aIFkPJm3agAOwo_3hwgYyjpGkuyw/YlSljKVhgz3gXbaoyFF4WIikx9L5iqOcNXXFBumStiM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZhWUnYIQqdiyXoaE68ehLw/bUfXIThX6blOlG7cbKL2T3Lqt9U0Dse59KiKeRnfnS5ofYCecAPvMrrBceER9cP0aDBjcs8V79tOTStCzZ4Y0w/Yp5S-WoMXJRen7tx4oVNdtm79NABybr3Y3Cyk51J8Hs'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MOnVLKh65_10OaNMw_cKXg/KOw22-RxVqsX4RfF9MwkIt5psr5wN8lkNKeXHfRcTm3_LFJMpUL2-GPURUQrzQh_bAY-_fvcXlE5aRbzl0GeYw/FDuOPDHV6hhK34Y_L4gaS4U4u18GjipHy4i7psjYxnQ'), ('width', 3000), ('height', 3000)]))]))])]",5.0,"Vista, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125997/Instruments/Vendor%20Logos/Qubitekk.png,Qubitekk’s 2-channel Coincidence Counter provides researchers with a low-cost solution for nanosecond resolution coincidence counting. A third gating channel makes the counter suitable for use with pulsed sources.,https://qubitekk.com/products/coincidence-counter/,CC1,432.0,['Coincidence Counter'],"In quantum physics, coincidence counting is used in experiments testing particle non-locality and quantum entanglement. In these experiments two or more particles are created from the same initial packet of energy, inexorably linking/entangling their physical properties. Separate particle detectors measure the quantum states of each particle and send the resulting signal to a coincidence counter. In any experiment studying entanglement, the entangled particles are vastly outnumbered by non-entangled particles which are also detected; patternless noise that drowns out the entangled signal. In a two detector system, a coincidence counter alleviates this problem by only recording detection signals that strike both detectors simultaneously (or more accurately, recording only signals that arrive at both detectors and correlate to the same emission time). This ensures that the data represents only entangled particles.","Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/cc1.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#cc1-coincidence-counter,Qubitekk,"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ICeTYDCr0WQGoCNhnlqW9A/xWHniahKdTenvA9lCpqHem_Lv7-lnrQ1Yb6hidANH6zyMK1tuylXugb_keyksrHAicKHw65Ha5IXwmkTwmbOcqAWmG5_rqj8QQHeC9TxhmkOMK-RjPbmjcEejWAgNvNY/AAtLZ04IQ92tcE2cknKg36aBUNWf2jaO3twgAK8U_ek'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XmRul3lrntyXgK4pL2Nd2Q/Ro5AjtdlFYfeFuSGgauksuohj_nx7NvEyJKzf3SNWWNNFCiETYYDRkljznJoeTnWoIaxAZ5NRxUaJe8mF71rvQ/Y-CVWeWPJ1zKiGPCwPRvJduV7q0kg9nafWxPSyi89n8'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zQgrup5ODOnYB7NWnWnSng/DIzf_vAQ2O_E1g7kVT48u4cnPVWFMkqq6Bm3j8V6Jd0dS9uFxTOwRZERVFYUJr5RotjuPIZxz7IUnH8RBtoNnw/XSQaCxjsQvV609jyLsMS6T5DRyW0jIR9YJAnFAscIKQ'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/scghzrrRvnwV_s4Et9dEgA/IbHIKRXzptJVnf_y02jJDfS1ofbHQHmahnhHBOB7pX2JiYxIRYdZgymaEvewBOHzNFoEgCtdsO7qj5755Eb2hQ/jPeEtnV3Eb8-6uY_ldoq42OJ8PzeyrGgKB6IhaLUxiY'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782456/Instruments/Coincidence%20Counter/CC1/CC1.jpg,CC1,Write a Python script that uses Instrumentkit to connect to a CC1 Coincidence Counter,,,,,"#!/usr/bin/env python
""""""
Provides support for the Qubitekk CC1 Coincidence Counter instrument.

CC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi.scpi_instrument import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units, split_unit_str

# CLASSES #####################################################################


class CC1(SCPIInstrument):

    """"""
    The CC1 is a hand-held coincidence counter.

    It has two setting values, the dwell time and the coincidence window. The
    coincidence window determines the amount of time (in ns) that the two
    detections may be from each other and still be considered a coincidence.
    The dwell time is the amount of time that passes before the counter will
    send the clear signal.

    More information can be found at :
    http://www.qubitekk.com
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\n""
        self._channel_count = 3
        self._firmware = None
        self._ack_on = False
        self.sendcmd("":ACKN OF"")
        # a readline is required because if the firmware is prior to 2.2,
        # the cc1 will respond with 'Unknown Command'. After
        # 2.2, it will either respond by acknowledging the command (turning
        # acknowledgements off does not take place until after the current
        # exchange has been completed), or not acknowledging it (if the
        # acknowledgements are off). The try/except block is required to
        # handle the case in which acknowledgements are off.
        try:
            self.read(-1)
        except OSError:
            pass
        _ = self.firmware  # prime the firmware

        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            self._bool = (""ON"", ""OFF"")
            self._set_fmt = "":{}:{}""
            self.TriggerMode = self._TriggerModeNew

        else:
            self._bool = (""1"", ""0"")
            self._set_fmt = "":{} {}""
            self.TriggerMode = self._TriggerModeOld

    def _ack_expected(self, msg=""""):
        return (
            msg
            if self._ack_on and self.firmware[0] >= 2 and self.firmware[1] > 1
            else None
        )

    # ENUMS #

    class _TriggerModeNew(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""MODE CONT""
        start_stop = ""MODE STOP""

    class _TriggerModeOld(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""0""
        start_stop = ""1""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a channel on the Qubitekk CC1.
        """"""

        __CHANNEL_NAMES = {1: ""C1"", 2: ""C2"", 3: ""CO""}

        def __init__(self, cc1, idx):
            self._cc1 = cc1
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        # PROPERTIES #

        @property
        def count(self):
            """"""
            Gets the counts of this channel.

            :rtype: `int`
            """"""
            count = self._cc1.query(f""COUN:{self._chan}?"")
            tries = 5
            try:
                count = int(count)
            except ValueError:
                count = None
                while count is None and tries > 0:
                    # try to read again
                    try:
                        count = int(self._cc1.read(-1))
                    except ValueError:
                        count = None
                        tries -= 1

            if tries == 0:
                raise OSError(f""Could not read the count of channel "" f""{self._chan}."")

            self._count = count
            return self._count

    # PROPERTIES #

    @property
    def acknowledge(self):
        """"""
        Gets/sets the acknowledge message state. If True, the CC1 will echo
        back every command sent, then print the response (either Unable to
        comply, Unknown command or the response to a query). If False,
        the CC1 will only print the response.

        :units: None
        :type: boolean
        """"""
        return self._ack_on

    @acknowledge.setter
    def acknowledge(self, new_val):
        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            if self._ack_on and not new_val:
                self.sendcmd("":ACKN OF"")
                self._ack_on = False
            elif not self._ack_on and new_val:
                self.sendcmd("":ACKN ON"")
                self._ack_on = True
        else:
            raise NotImplementedError(
                ""Acknowledge message not implemented in "" ""this version.""
            )

    @property
    def gate(self):
        """"""
        Gets/sets the gate enable status

        :type: `bool`
        """"""
        return self.query(""GATE?"").strip() == self._bool[0]

    @gate.setter
    def gate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""GATE"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def subtract(self):
        """"""
        Gets/sets the subtract enable status

        :type: `bool`
        """"""
        return self.query(""SUBT?"").strip() == self._bool[0]

    @subtract.setter
    def subtract(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""SUBT"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode setting for the CC1. This can be set to
        ``continuous`` or ``start/stop`` modes.

        :type: `CC1.TriggerMode`
        """"""
        return self.TriggerMode(self.query(""TRIG?"").strip())

    @trigger_mode.setter
    def trigger_mode(self, newval):
        try:  # First assume newval is Enum.value
            newval = self.TriggerMode[newval]
        except KeyError:  # Check if newval is Enum.name instead
            try:
                newval = self.TriggerMode(newval)
            except ValueError:
                raise ValueError(""Enum property new value not in enum."")
        self.sendcmd(self._set_fmt.format(""TRIG"", self.TriggerMode(newval).value))

    @property
    def window(self):
        """"""
        Gets/sets the length of the coincidence window between the two signals.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units nanoseconds.
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(*split_unit_str(self.query(""WIND?""), ""ns""))

    @window.setter
    def window(self, new_val):
        new_val_mag = int(assume_units(new_val, u.ns).to(u.ns).magnitude)
        if new_val_mag < 0 or new_val_mag > 7:
            raise ValueError(""Window is out of range."")
        # window must be an integer!
        self.sendcmd(f"":WIND {new_val_mag}"")

    @property
    def delay(self):
        """"""
        Get/sets the delay value (in nanoseconds) on Channel 1.

        When setting, ``N`` may be ``0, 2, 4, 6, 8, 10, 12, or 14ns``.

        :rtype: `~pint.Quantity`
        :return: the delay value
        """"""
        return u.Quantity(*split_unit_str(self.query(""DELA?""), ""ns""))

    @delay.setter
    def delay(self, new_val):
        new_val = assume_units(new_val, u.ns).to(u.ns)
        if new_val < 0 * u.ns or new_val > 14 * u.ns:
            raise ValueError(""New delay value is out of bounds."")
        if new_val.magnitude % 2 != 0:
            raise ValueError(""New magnitude must be an even number"")
        self.sendcmd("":DELA "" + str(int(new_val.magnitude)))

    @property
    def dwell_time(self):
        """"""
        Gets/sets the length of time before a clear signal is sent to the
        counters.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units seconds.
        :type: `~pint.Quantity`
        """"""
        # the older versions of the firmware erroneously report the units of the
        # dwell time as being seconds rather than ms
        dwell_time = u.Quantity(*split_unit_str(self.query(""DWEL?""), ""s""))
        if self.firmware[0] <= 2 and self.firmware[1] <= 1:
            return dwell_time / 1000.0

        return dwell_time

    @dwell_time.setter
    def dwell_time(self, new_val):
        new_val_mag = assume_units(new_val, u.s).to(u.s).magnitude
        if new_val_mag < 0:
            raise ValueError(""Dwell time cannot be negative."")
        self.sendcmd(f"":DWEL {new_val_mag}"")

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                if self._firmware.find(""Unknown"") >= 0:
                    self._firmware = None
                else:
                    value = self._firmware.replace(""Firmware v"", """").split(""."")
                    if len(value) < 3:
                        for _ in range(3 - len(value)):
                            value.append(0)
                    value = tuple(map(int, value))
                    self._firmware = value
        return self._firmware

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> cc = ik.qubitekk.CC1.open_serial('COM8', 19200, timeout=1)
        >>> print(cc.channel[0].count)

        :rtype: `CC1.Channel`
        """"""
        return ProxyList(self, CC1.Channel, range(self._channel_count))

    # METHODS #

    def clear_counts(self):
        """"""
        Clears the current total counts on the counters.
        """"""
        self.sendcmd(""CLEA"")
"
44,https://holzworth.com/Portals/0/datasheets/hs9000-series_datasheet.pdf,https://en.wikipedia.org/wiki/Frequency_synthesizer,"[OrderedDict([('id', 'att9iBW4LwVyUukeF'), ('width', 1808), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hL-ONOFdju1puPT6SwGPMw/RsJFmS4mxCzVusMtUJNN_d6_rJK4cEuDhEeio1Hj_dCDK3y_YWPc4So0AzyjEbH5kFQqVLqhMg5j3-1O2vaeLWhu8Jl9RNtabEjm_FIUURc/OPvR13EYeOQSTmOlta4y_gK4aLDPRSSzu2Q6yxSpKgs'), ('filename', 'hs9008b-right-face.jpg'), ('size', 110410), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eSYJTT5ehyiIbAuapcL7AQ/53Bc_sSmIF2BrbjvPQn-t9VmA6PhGBqtqtszR4sKrZebUg1IVg54ay3y2TD7NpvMhseE0lZIQNTBDlSWoIG7gQ/TT7Fs0Bq8NhvpOg9TI2nq2dAkLC96jvGux5Xc3qRTzc'), ('width', 88), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6-_w9AsyaiFoUwz8ycsUeg/5XUInUjYTvv4lAE7Rtbc3MdjlQ-DvvdXZB-2femfSkmK4C6Jebs0ZmE9cQ3QZqLZ6WrbActkbDX4pKjEyzr0dw/P10Zqn0ExX1un_CvYroMsJH3QwGUr-g_iqKR0-pOPTA'), ('width', 1249), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9lgfKHaZ0HMxzZmLQdkYkQ/Q-ZlurJWNPr2G54Y_akZeiTd9U3zEeR4RW-YwOFPU2t0EHivO6vAbUJ5Prte3kdJMx1iLz3qkJx2EuOHQEHgcA/Ifu2dxjeKyYxRmyHHJq9_kVUIvkUgtEguoPDFaP_jxQ'), ('width', 3000), ('height', 3000)]))]))])]",3.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125994/Instruments/Vendor%20Logos/Holzworth.png,"HS9008B - 8 Channel, 1U RF Synthesizer - Phase Coherent",https://www.testforce.com/products/additional-products/accessories/hs9008b.html,"Holzworth HS 9000 
",169.0,['Frequency synthesizer'],A frequency synthesizer is an electronic circuit that generates a range of frequencies from a single reference frequency.,"**Holzworth** Instrumentation is a leader in high-performance phase noise analyzers and RF/microwave synthesizers optimized for ultra-low phase noise
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/holzworth/holzworth_hs9000.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/holzworth.html#hs9000-multichannel-frequency-synthesizer,Holzworth,"[OrderedDict([('id', 'attbKqwLCO8edU9zL'), ('width', 410), ('height', 116), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Xy1d1CvqVezqVsD7_a_0JQ/dAXdWS0UvTLpTTmLwNFKdMcPtt5G4f77plfht3Z9ZogFyBmHMZ8qdufVihRvYzZCjEWe8tQEEQk5n_L6jelL1JiFNYiEBvnvM9QxAxFzITY/rP94quStrQCqkyXJC6bxh8GZsHvyWVS-xU_rDDj5QbU'), ('filename', 'logo-Holzworth.jpg'), ('size', 8728), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GydxEuoXv6rZzJSZQSl8EA/3kW175cniuMbLayoQyFWqDqZ-BbfOXSQRwLNm5sNjX8nAU7bIKm5OnYezSZBgFgYjtnnPUloGi1CUN0L9bsFGA/tPD5j6MVf5_pWQ-KeaVJ5s09pjAyE0KhzvyWAPkj7kE'), ('width', 127), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MozBf8BWP6oQW6XsjX7mmQ/_PXe4DEJ0f5tKlATEsHowMn5CqLy29VGCmFf3QtSZfEI6MEWHBcFd7HkpO7Y0lQUQGfHErxvvb3W64cyD-ZttQ/HNgl-PWtxGcwDwjohEBuJw_S-eJUWKBzUyQ0WduD-cc'), ('width', 410), ('height', 116)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Cfwz_jImg9HGpYiFSekzKA/NpXaFN63mI_vDRh7RIWIQnFKZVbesAYyTz9oToENlxZRUqXDH2lcZij_RfB6KcDVrWlDCtMgwl4liOvlmmA6sw/5nyvLCEyrxb6M4M4-n0c1jGXQfsRAeXoKCIFsDOkah8'), ('width', 3000), ('height', 3000)]))]))])]",https://holzworth.com,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782458/Instruments/Frequency%20synthesizer/HS-9008B/HS-9008B.jpg,HS 9008B,Write a Python script that uses Instrumentkit to connect to a HS 9008B Frequency synthesizer,6700.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Holzworth HS9000
""""""

# IMPORTS #####################################################################


from instruments.units import ureg as u

from instruments.abstract_instruments.signal_generator import SignalGenerator, SGChannel
from instruments.util_fns import (
    ProxyList,
    split_unit_str,
    bounded_unitful_property,
    bool_property,
)

# CLASSES #####################################################################


class HS9000(SignalGenerator):

    """"""
    Communicates with a `Holzworth HS-9000 series`_ multi-channel frequency
    synthesizer.

    .. _Holzworth HS-9000 series: http://www.holzworth.com/synthesizers-multi.htm
    """"""

    # INNER CLASSES #

    class Channel(SGChannel):
        """"""
        Class representing a physical channel on the Holzworth HS9000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `HS9000` class.
        """"""

        def __init__(self, hs, idx_chan):
            self._hs = hs
            self._idx = idx_chan

            # We unpacked the channel index from the string of the form ""CH1"",
            # in order to make the API more Pythonic, but now we need to put
            # it back.
            # Some channel names, like ""REF"", are special and are preserved
            # as strs.
            self._ch_name = (
                idx_chan if isinstance(idx_chan, str) else f""CH{idx_chan + 1}""
            )

        # PRIVATE METHODS #

        def sendcmd(self, cmd):
            """"""
            Function used to send a command to the instrument while wrapping
            the command with the neccessary identifier for the channel.

            :param str cmd: Command that will be sent to the instrument after
                being prefixed with the channel identifier
            """"""
            self._hs.sendcmd(f"":{self._ch_name}:{cmd}"")

        def query(self, cmd):
            """"""
            Function used to send a command to the instrument while wrapping
            the command with the neccessary identifier for the channel.

            :param str cmd: Command that will be sent to the instrument after
                being prefixed with the channel identifier
            :return: The result from the query
            :rtype: `str`
            """"""
            return self._hs.query(f"":{self._ch_name}:{cmd}"")

        # STATE METHODS #

        def reset(self):
            """"""
            Resets the setting of the specified channel

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].reset()
            """"""
            self.sendcmd(""*RST"")

        def recall_state(self):
            """"""
            Recalls the state of the specified channel from memory.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].recall_state()
            """"""
            self.sendcmd(""*RCL"")

        def save_state(self):
            """"""
            Saves the current state of the specified channel.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> hs.channel[0].save_state()
            """"""
            self.sendcmd(""*SAV"")

        # PROPERTIES #

        @property
        def temperature(self):
            """"""
            Gets the current temperature of the specified channel.

            :units: As specified by the instrument.
            :rtype: `~pint.Quantity`
            """"""
            val, units = split_unit_str(self.query(""TEMP?""))
            units = f""deg{units}""
            return u.Quantity(val, units)

        frequency, frequency_min, frequency_max = bounded_unitful_property(
            ""FREQ"",
            units=u.GHz,
            doc=""""""
            Gets/sets the frequency of the specified channel. When setting,
            values are bounded between what is returned by `frequency_min`
            and `frequency_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].frequency)
            >>> print(hs.channel[0].frequency_min)
            >>> print(hs.channel[0].frequency_max)

            :type: `~pint.Quantity`
            :units: As specified or assumed to be of units GHz
            """""",
        )
        power, power_min, power_max = bounded_unitful_property(
            ""PWR"",
            units=u.dBm,
            doc=""""""
            Gets/sets the output power of the specified channel. When setting,
            values are bounded between what is returned by `power_min`
            and `power_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].power)
            >>> print(hs.channel[0].power_min)
            >>> print(hs.channel[0].power_max)

            :type: `~pint.Quantity`
            :units: `instruments.units.dBm`
            """""",
        )
        phase, phase_min, phase_max = bounded_unitful_property(
            ""PHASE"",
            units=u.degree,
            doc=""""""
            Gets/sets the output phase of the specified channel. When setting,
            values are bounded between what is returned by `phase_min`
            and `phase_max`.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].phase)
            >>> print(hs.channel[0].phase_min)
            >>> print(hs.channel[0].phase_max)

            :type: `~pint.Quantity`
            :units: As specified or assumed to be of units degrees
            """""",
        )

        output = bool_property(
            ""PWR:RF"",
            inst_true=""ON"",
            inst_false=""OFF"",
            set_fmt=""{}:{}"",
            doc=""""""
            Gets/sets the output status of the channel. Setting to `True` will
            turn the channel's output stage on, while a value of `False` will
            turn it off.

            Example usage:
            >>> import instruments as ik
            >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
            >>> print(hs.channel[0].output)
            >>> hs.channel[0].output = True

            :type: `bool`
            """""",
        )

    # PROXY LIST ##

    def _channel_idxs(self):
        """"""
        Internal function used to get the list of valid channel names
        to be used by `HS9000.channel`

        :return: A list of valid channel indicies
        :rtype: `list` of `int` and `str`
        """"""
        # The command :ATTACH? returns a string of the form "":CH1:CH2"" to
        # indicate what channels are attached to the internal USB bus.
        # We convert what channel names we can to integers, and leave the
        # rest as strings.
        return [
            (
                int(ch_name.replace(""CH"", """")) - 1
                if ch_name.startswith(""CH"")
                else ch_name.strip()
            )
            for ch_name in self.query("":ATTACH?"").split("":"")
            if ch_name
        ]

    @property
    def channel(self):
        """"""
        Gets a specific channel on the HS9000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> hs = ik.holzworth.HS9000.open_tcpip(""192.168.0.2"", 8080)
        >>> print(hs.channel[0].frequency)

        :return: A channel object for the HS9000
        :rtype: `~HS9000.Channel`
        """"""
        return ProxyList(self, self.Channel, self._channel_idxs())

    # OTHER PROPERTIES #

    @property
    def name(self):
        """"""
        Gets identification string of the HS9000

        :return: The string as usually returned by ``*IDN?`` on SCPI instruments
        :rtype: `str`
        """"""
        # This is a weird one; the HS-9000 associates the :IDN? command
        # with each individual channel, though we want it to be a synthesizer-
        # wide property. To solve this, we assume that CH1 is always a channel
        # and ask its name.
        return self.channel[0].query(""IDN?"")

    @property
    def ready(self):
        """"""
        Gets the ready status of the HS9000.

        :return: If the instrument is ready for operation
        :rtype: `bool`
        """"""
        return ""Ready"" in self.query("":COMM:READY?"")
"
45,,,,3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,,,Newporterror,382.0,['Miscellaneous'],Miscellaneous,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/errors.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newporterror,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,,Newporterror,Write a Python script that uses Instrumentkit to connect to a Newporterror Miscellaneous,,,,,"#!/usr/bin/env python
""""""
Provides common error handling for Newport devices.
""""""

# IMPORTS ####################################################################


import datetime

# CLASSES ####################################################################


class NewportError(IOError):
    """"""
    Raised in response to an error with a Newport-brand instrument.
    """"""

    start_time = datetime.datetime.now()

    # Dict Containing all possible errors.
    # Uses strings for keys in order to handle axis
    messageDict = {
        ""0"": ""NO ERROR DETECTED"",
        ""1"": ""PCI COMMUNICATION TIME-OUT"",
        ""2"": ""Reserved for future use"",
        ""3"": ""Reserved for future use"",
        ""4"": ""EMERGENCY SOP ACTIVATED"",
        ""5"": ""Reserved for future use"",
        ""6"": ""COMMAND DOES NOT EXIST"",
        ""7"": ""PARAMETER OUT OF RANGE"",
        ""8"": ""CABLE INTERLOCK ERROR"",
        ""9"": ""AXIS NUMBER OUT OF RANGE"",
        ""10"": ""Reserved for future use"",
        ""11"": ""Reserved for future use"",
        ""12"": ""Reserved for future use"",
        ""13"": ""GROUP NUMBER MISSING"",
        ""14"": ""GROUP NUMBER OUT OF RANGE"",
        ""15"": ""GROUP NUMBER NOT ASSIGNED"",
        ""16"": ""GROUP NUMBER ALREADY ASSIGNED"",
        ""17"": ""GROUP AXIS OUT OF RANGE"",
        ""18"": ""GROUP AXIS ALREADY ASSIGNED"",
        ""19"": ""GROUP AXIS DUPLICATED"",
        ""20"": ""DATA ACQUISITION IS BUSY"",
        ""21"": ""DATA ACQUISITION SETUP ERROR"",
        ""22"": ""DATA ACQUISITION NOT ENABLED"",
        ""23"": ""SERVO CYCLE (400 µS) TICK FAILURE"",
        ""24"": ""Reserved for future use"",
        ""25"": ""DOWNLOAD IN PROGRESS"",
        ""26"": ""STORED PROGRAM NOT STARTEDL"",
        ""27"": ""COMMAND NOT ALLOWEDL"",
        ""28"": ""STORED PROGRAM FLASH AREA FULL"",
        ""29"": ""GROUP PARAMETER MISSING"",
        ""30"": ""GROUP PARAMETER OUT OF RANGE"",
        ""31"": ""GROUP MAXIMUM VELOCITY EXCEEDED"",
        ""32"": ""GROUP MAXIMUM ACCELERATION EXCEEDED"",
        ""33"": ""GROUP MAXIMUM DECELERATION EXCEEDED"",
        ""34"": "" GROUP MOVE NOT ALLOWED DURING MOTION"",
        ""35"": ""PROGRAM NOT FOUND"",
        ""36"": ""Reserved for future use"",
        ""37"": ""AXIS NUMBER MISSING"",
        ""38"": ""COMMAND PARAMETER MISSING"",
        ""39"": ""PROGRAM LABEL NOT FOUND"",
        ""40"": ""LAST COMMAND CANNOT BE REPEATED"",
        ""41"": ""MAX NUMBER OF LABELS PER PROGRAM EXCEEDED"",
        ""x00"": ""MOTOR TYPE NOT DEFINED"",
        ""x01"": ""PARAMETER OUT OF RANGE"",
        ""x02"": ""AMPLIFIER FAULT DETECTED"",
        ""x03"": ""FOLLOWING ERROR THRESHOLD EXCEEDED"",
        ""x04"": ""POSITIVE HARDWARE LIMIT DETECTED"",
        ""x05"": ""NEGATIVE HARDWARE LIMIT DETECTED"",
        ""x06"": ""POSITIVE SOFTWARE LIMIT DETECTED"",
        ""x07"": ""NEGATIVE SOFTWARE LIMIT DETECTED"",
        ""x08"": ""MOTOR / STAGE NOT CONNECTED"",
        ""x09"": ""FEEDBACK SIGNAL FAULT DETECTED"",
        ""x10"": ""MAXIMUM VELOCITY EXCEEDED"",
        ""x11"": ""MAXIMUM ACCELERATION EXCEEDED"",
        ""x12"": ""Reserved for future use"",
        ""x13"": ""MOTOR NOT ENABLED"",
        ""x14"": ""Reserved for future use"",
        ""x15"": ""MAXIMUM JERK EXCEEDED"",
        ""x16"": ""MAXIMUM DAC OFFSET EXCEEDED"",
        ""x17"": ""ESP CRITICAL SETTINGS ARE PROTECTED"",
        ""x18"": ""ESP STAGE DEVICE ERROR"",
        ""x19"": ""ESP STAGE DATA INVALID"",
        ""x20"": ""HOMING ABORTED"",
        ""x21"": ""MOTOR CURRENT NOT DEFINED"",
        ""x22"": ""UNIDRIVE COMMUNICATIONS ERROR"",
        ""x23"": ""UNIDRIVE NOT DETECTED"",
        ""x24"": ""SPEED OUT OF RANGE"",
        ""x25"": ""INVALID TRAJECTORY MASTER AXIS"",
        ""x26"": ""PARAMETER CHARGE NOT ALLOWED"",
        ""x27"": ""INVALID TRAJECTORY MODE FOR HOMING"",
        ""x28"": ""INVALID ENCODER STEP RATIO"",
        ""x29"": ""DIGITAL I/O INTERLOCK DETECTED"",
        ""x30"": ""COMMAND NOT ALLOWED DURING HOMING"",
        ""x31"": ""COMMAND NOT ALLOWED DUE TO GROUP"",
        ""x32"": ""INVALID TRAJECTORY MODE FOR MOVING"",
    }

    def __init__(self, errcode=None, timestamp=None):
        if timestamp is None:
            self._timestamp = datetime.datetime.now() - NewportError.start_time
        else:
            self._timestamp = datetime.datetime.now() - timestamp

        if errcode is not None:
            # Break the error code into an axis number
            # and the rest of the code.
            self._errcode = int(errcode) % 100
            self._axis = errcode // 100
            if self._axis == 0:
                self._axis = None
                error_message = self.get_message(str(errcode))
                error = ""Newport Error: {}. Error Message: {}. "" ""At time : {}"".format(
                    str(errcode), error_message, self._timestamp
                )
                super().__init__(error)
            else:
                error_message = self.get_message(f""x{self._errcode:02d}"")
                error = (
                    ""Newport Error: {}. Axis: {}. ""
                    ""Error Message: {}. ""
                    ""At time : {}"".format(
                        str(self._errcode), self._axis, error_message, self._timestamp
                    )
                )
                super().__init__(error)

        else:
            self._errcode = None
            self._axis = None
            super().__init__("""")

    # PRIVATE METHODS ##

    @staticmethod
    def get_message(code):
        """"""
        Returns the error string for a given error code

        :param str code: Error code as returned by instrument
        :return: Full error code string
        :rtype: `str`
        """"""
        return NewportError.messageDict.get(code, ""Error code not recognised"")

    # PROPERTIES ##

    @property
    def timestamp(self):
        """"""
        Geturns the timestamp reported by the device as the time
        at which this error occured.

        :type: `datetime`
        """"""
        return self._timestamp

    @property
    def errcode(self):
        """"""
        Gets the error code reported by the device.

        :type: `int`
        """"""
        return self._errcode

    @property
    def axis(self):
        """"""
        Gets the axis with which this error is concerned, or
        `None` if the error was not associated with any particlar
        axis.

        :type: `int`
        """"""
        return self._axis
"
55,https://cdn.tmi.yokogawa.com/IM7651-01E.is.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attI6RnDjug8zxuhg'), ('width', 800), ('height', 502), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rC5dEo2WiNl5ac9oO43ZVQ/zRLOMxIV2jLzUfnYL298NTXE2JBrgIak-4TJZy5kPZj0q2-33KkWHL5O_-x3NyoGy5EnUj8nG2REtpEt2osPymbBoRe78VGcqytuYkjgdVo/jDWkxytsI5eCHMGtZzfrX3-wzojiCDtYmfEljwzT_5g'), ('filename', '7651_lg.jpg'), ('size', 302628), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/i0a5kFK5IDdV4EnwpGnSHw/lV7_0nBe_75r_piGeedrmloylAr4-GU5_VPN2E5lTr6oTHSCvNkgmmOP8cOKJ6hYxVH7V8FaKzaniwS2GsTJjg/z3bs7s39hWpFG_URpCRj5Z93y14AzybbKARL7xwYut4'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GidQoq8jVZvKJZbnaSgPZw/jq0Fpnu7wSb8c3amt0hVjDtbE-eK1YSH2ogZaH_TG5heAdgR91KZQs89XwEwW4rWgSrP3RB8zWrj72Wp_rUOSQ/EIAcvEd5V5ztEKg0h57eA8hMapneiyycjZ5ZWwes6-Q'), ('width', 800), ('height', 502)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DS5o_csPBUJfGvwvFIA1GQ/W7v7XA4wImrHLaUCZGyFe2jwu5JJnQhAQAvGKd4UIGx8ViXtXRZh7a2E8Ah1wadhkiwi6BW3BdoR0J3LbppDmA/ScKVdyKzDYrkP1qplBl4Wk9mIEVE5w9InQTz6R6ARak'), ('width', 3000), ('height', 3000)]))]))])]",318.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125993/Instruments/Vendor%20Logos/Yokogawa.png,"The 7651 is a general-purpose DC source developed on YOKOGAWA's state-of-the-art DC standard technology. The dual multiplying D/A converter has enabled the compatibility of high-speed response and high resolution. The 7651 also provides high accuracy and stability. In addition to the source function (current supply), the sink function (current absorption) is also available, so the 7651 can be used as not only DC voltage/current source but also high-precision electronic load. Further, a series of powerful functions to meet the system use such as the programming function up to 50 steps, the IC memory card capable of storing 7 patterns of programs, and GP-IB interface are provided as standard. This 7651 can be used for a wide range of fields from R & D to production line, service and maintenance.",https://tmi.yokogawa.com/ca/solutions/discontinued/7651-programmable-dc-source/,Yokogawa 7651,640.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa7651.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa7651,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/91EkiaJqR32pXT_9j2ikkA/EA8IX6bgJJ5AWHxSJn_XsjdpYAbFM-YDdqUbrZWF93R43aeTp5aElLydj7HEdEh8wo2jzLCFOTdCKUYUpJSqs1zbr_NokqlVS5aCZUEOXdQ/4kbrVwXBbGOLMD1hKLvO7wdukSK2boAdCxBHEMhRvXw'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mLKN3BYMkiZUdn2rlRmVtw/cw3TDV5BlW5jr47wsWYGUsjqEQZbKDvc2mw_Lv9aXzgXtFoYC1bkplw5NhTSdUeNveYCSzsYG9fK-1b24lGzfQ/umhRd2RrT6tf47pL7QQ-NfYCvL9z9J5dB71Th5o0jzE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/a3VAY9DVGC-aEBfsilZ3xw/8a9ejY3MgpFLh3YMiQ-k86blOpOc7VPmtTlcvVeTvXbTwq9ckonmesZx3cT_rNdybRDFFOAT9g5kdq8SOraK_Q/uf6rR_lz7JMeO4cE-hHB-59T8gCRIwI7dhqfDVgASSo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EXvJLqLv0Q1zEcaZ4OYDWw/W05CyYIR7E-TtqueHjX1znSLYTjKMcUW9Z2jdHtLIXhVcPktYi-xnoq2dtrhqqf6FOnJ9gLxlUF3R1y-zUaZzw/5MptEU6yLCcaC2jBAtxU_UfVh58yJurgp_UIp0qIdX8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782436/Instruments/Power%20Supplies/Yokogawa-7651/Yokogawa-7651.jpg,Yokogawa 7651,Write a Python script that uses Instrumentkit to connect to a Yokogawa 7651 Power Supplies,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Yokogawa 7651 power supply.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import PowerSupply
from instruments.abstract_instruments import Instrument
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class Yokogawa7651(PowerSupply, Instrument):

    """"""
    The Yokogawa 7651 is a single channel DC power supply.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa7651.open_gpibusb(""/dev/ttyUSB0"", 1)
    >>> inst.voltage = 10 * u.V
    """"""

    # INNER CLASSES #

    class Channel(PowerSupply.Channel):

        """"""
        Class representing the only channel on the Yokogawa 7651.

        This class inherits from `PowerSupply.Channel`.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa7651` class.
        """"""

        def __init__(self, parent, name):
            self._parent = parent
            self._name = name

        # PROPERTIES #

        @property
        def mode(self):
            """"""
            Sets the output mode for the power supply channel.
            This is either constant voltage or constant current.

            Querying the mode is not supported by this instrument.

            :type: `Yokogawa7651.Mode`
            """"""
            raise NotImplementedError(
                ""This instrument does not support "" ""querying the operation mode.""
            )

        @mode.setter
        def mode(self, newval):
            if not isinstance(newval, Yokogawa7651.Mode):
                raise TypeError(
                    ""Mode setting must be a `Yokogawa7651.Mode` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._parent.sendcmd(f""F{newval.value};"")
            self._parent.trigger()

        @property
        def voltage(self):
            """"""
            Sets the voltage of the specified channel. This device has a voltage
            range of 0V to +30V.

            Querying the voltage is not supported by this instrument.

            :units: As specified (if a `~pint.Quantity`) or
                assumed to be of units Volts.
            :type: `~pint.Quantity` with units Volt
            """"""
            raise NotImplementedError(
                ""This instrument does not support ""
                ""querying the output voltage setting.""
            )

        @voltage.setter
        def voltage(self, newval):
            newval = assume_units(newval, u.volt).to(u.volt).magnitude
            self.mode = self._parent.Mode.voltage
            self._parent.sendcmd(f""SA{newval};"")
            self._parent.trigger()

        @property
        def current(self):
            """"""
            Sets the current of the specified channel. This device has an max
            setting of 100mA.

            Querying the current is not supported by this instrument.

            :units: As specified (if a `~pint.Quantity`) or
                assumed to be of units Amps.
            :type: `~pint.Quantity` with units Amp
            """"""
            raise NotImplementedError(
                ""This instrument does not support ""
                ""querying the output current setting.""
            )

        @current.setter
        def current(self, newval):
            newval = assume_units(newval, u.amp).to(u.amp).magnitude
            self.mode = self._parent.Mode.current
            self._parent.sendcmd(f""SA{newval};"")
            self._parent.trigger()

        @property
        def output(self):
            """"""
            Sets the output status of the specified channel. This either enables
            or disables the output.

            Querying the output status is not supported by this instrument.

            :type: `bool`
            """"""
            raise NotImplementedError(
                ""This instrument does not support "" ""querying the output status.""
            )

        @output.setter
        def output(self, newval):
            if newval is True:
                self._parent.sendcmd(""O1;"")
                self._parent.trigger()
            else:
                self._parent.sendcmd(""O0;"")
                self._parent.trigger()

    # ENUMS #

    class Mode(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 7651
        """"""

        voltage = 1
        current = 5

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets the specific power supply channel object. Since the Yokogawa7651
        is only equiped with a single channel, a list with a single element
        will be returned.

        This (single) channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> yoko = ik.yokogawa.Yokogawa7651.open_gpibusb('/dev/ttyUSB0', 10)
        >>> yoko.channel[0].voltage = 1 # Sets output voltage to 1V

        :rtype: `~Yokogawa7651.Channel`
        """"""
        return ProxyList(self, Yokogawa7651.Channel, [0])

    @property
    def voltage(self):
        """"""
        Sets the voltage. This device has a voltage range of 0V to +30V.

        Querying the voltage is not supported by this instrument.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Volts.
        :type: `~pint.Quantity` with units Volt
        """"""
        raise NotImplementedError(
            ""This instrument does not support querying "" ""the output voltage setting.""
        )

    @voltage.setter
    def voltage(self, newval):
        self.channel[0].voltage = newval

    @property
    def current(self):
        """"""
        Sets the current. This device has an max setting of 100mA.

        Querying the current is not supported by this instrument.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Amps.
        :type: `~pint.Quantity` with units Amp
        """"""
        raise NotImplementedError(
            ""This instrument does not support querying "" ""the output current setting.""
        )

    @current.setter
    def current(self, newval):
        self.channel[0].current = newval

    # METHODS #

    def trigger(self):
        """"""
        Triggering function for the Yokogawa 7651.

        After changing any parameters of the instrument (for example, output
        voltage), the device needs to be triggered before it will update.
        """"""
        self.sendcmd(""E;"")
"
69,https://www.testequipmenthq.com/datasheets/KEITHLEY-580-Datasheet.pdf,https://en.wikipedia.org/wiki/Ohmmeter,"[OrderedDict([('id', 'attqllbRtWoi3InUL'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-DEjUFya4Ik5VhYSckNwsg/mrSVK4_bWUQeCsDjuXZuG6klXVm2MD-PuOBmIFGbL4W3-Oet9mvkgEgUhcpbU5HujH2SiBzCNuVCO0OMqna6eA/RZc29i-PGUG8OX2hJjY93R6s3LWKtNead8TnBW28LMQ'), ('filename', '580.jpg'), ('size', 8047), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_SFHvk0GxAlf-hyobhZcHA/msYsSp1RMiNgg92iP-wyW59698K5YIu5aaECx-VPQz2oCtsp_QuI1wn3JaTklAklzq8jfDUEzjcvydpneccJwA/MtxH9aK4-oaLaY1bjor6aKR0cDOrlDGYa8VmUOjWolw'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/NrFrw9O7nyGFokqQA1D5FQ/PLEOTVOfZ98vYe74eCKtI6vvxdK3xE8tLseEqyuWzZVlYvhYO--l7n6Voj957Txi6yXxqadUf3DIkLfujfF7WQ/pU6o6Zzb7KCwiTxA6E1cmcnjoeyvRIMIVXBN-bZUl2g'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yc9rmcJpGKdVRG_1Afx2mg/yaBe8c8t2Newx4Z5oIdJpSJHrBwsdULx1ljEQeu7Q57oOTgdpeS7r-ospKlrZoEFJD7WLHmwayiXbX-5NI2Tpg/i_cAJvxt8XI1rKxnctCBIxoewZoXG0SNMIm71zJjb1c'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Keithley 580 Micro-ohmmeter combines high accuracy, resolution, and sensitivity with three special capabilities that make micro-ohm measurements easier and more versatile than ever. When measuring contact and connector resistances, it is important not to puncture oxides and films that may have formed. The Model 580 ensures this dry-circuit condition by clamping the open-circuit test voltage to 20mV on the 200m, 2, and 20 ranges when the 20mV MAX button is pressed.

The Keithley 580 can test more devices by enabling both test current polarity and waveform (DC or pulsed) to be selected. When using pulsed test current, the Model 580 automatically compensates for thermoelectric EMFs. Tests on inductive devices are best performed using DC test current, as this avoids the effects of time constants on pulsed current resistance measurements. For temperature-sensitive components, a single trigger mode of operation minimizes power delivered to the device.",https://www.valuetronics.com/product/580-keithley-micro-ohmmeter-used,Keithley 580,234.0,['Power Meters'],An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law.,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley580.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley580-microohm-meter,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782479/Instruments/Power%20Meters/Keithley-580/Keithley-580.jpg,Keithley 580,Write a Python script that uses Instrumentkit to connect to a Keithley 580 Power Meters,3295.0,,,,"#!/usr/bin/env python
#
# keithley580.py: Driver for the Keithley 580 micro-ohmmeter.
#
# © 2013 Willem Dijkstra (wpd@xs4all.nl).
#   2014 Steven Casagrande (scasagrande@galvant.ca)
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the HP6632b DC power supply

Originally contributed and copyright held by Willem Dijkstra (wpd@xs4all.nl)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

import time
import struct

from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import Instrument

# CLASSES #####################################################################


class Keithley580(Instrument):

    """"""
    The Keithley Model 580 is a 4 1/2 digit resolution autoranging
    micro-ohmmeter with a +- 20,000 count LCD. It is designed for low
    resistance measurement requirements from 10uΩ to 200kΩ.

    The device needs some processing time (manual reports 300-500ms) after a
    command has been transmitted.
    """"""

    def __init__(self, filelike):
        """"""
        Initialise the instrument and remove CRLF line termination
        """"""
        super().__init__(filelike)
        self.sendcmd(""Y:X"")  # Removes the termination CRLF characters

    # ENUMS #

    class Polarity(IntEnum):
        """"""
        Enum containing valid polarity modes for the Keithley 580
        """"""

        positive = 0
        negative = 1

    class Drive(IntEnum):
        """"""
        Enum containing valid drive modes for the Keithley 580
        """"""

        pulsed = 0
        dc = 1

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 580
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        trigger_continuous = 4
        trigger_one_shot = 5

    # PROPERTIES #

    @property
    def polarity(self):
        """"""
        Gets/sets instrument polarity.

        Example use:

        >>> import instruments as ik
        >>> keithley = ik.keithley.Keithley580.open_gpibusb('/dev/ttyUSB0', 1)
        >>> keithley.polarity = keithley.Polarity.positive

        :type: `Keithley580.Polarity`
        """"""
        value = self.parse_status_word(self.get_status_word())[""polarity""]
        if value == ""+"":
            return Keithley580.Polarity.positive
        else:
            return Keithley580.Polarity.negative

    @polarity.setter
    def polarity(self, newval):
        if isinstance(newval, str):
            newval = Keithley580.Polarity[newval]
        if not isinstance(newval, Keithley580.Polarity):
            raise TypeError(
                ""Polarity must be specified as a ""
                ""Keithley580.Polarity, got {} ""
                ""instead."".format(newval)
            )

        self.sendcmd(f""P{newval.value}X"")

    @property
    def drive(self):
        """"""
        Gets/sets the instrument drive to either pulsed or DC.

        Example use:

        >>> import instruments as ik
        >>> keithley = ik.keithley.Keithley580.open_gpibusb('/dev/ttyUSB0', 1)
        >>> keithley.drive = keithley.Drive.pulsed

        :type: `Keithley580.Drive`
        """"""
        value = self.parse_status_word(self.get_status_word())[""drive""]
        return Keithley580.Drive[value]

    @drive.setter
    def drive(self, newval):
        if isinstance(newval, str):
            newval = Keithley580.Drive[newval]
        if not isinstance(newval, Keithley580.Drive):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley580.Drive, got {} ""
                ""instead."".format(newval)
            )

        self.sendcmd(f""D{newval.value}X"")

    @property
    def dry_circuit_test(self):
        """"""
        Gets/sets the 'dry circuit test' mode of the Keithley 580.

        This mode is used to minimize any physical and electrical changes in
        the contact junction by limiting the maximum source voltage to 20mV.
        By limiting the voltage, the measuring circuit will leave the resistive
        surface films built up on the contacts undisturbed. This allows for
        measurement of the resistance of these films.

        See the Keithley 580 manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""drycircuit""]

    @dry_circuit_test.setter
    def dry_circuit_test(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""DryCircuitTest mode must be a boolean."")
        self.sendcmd(f""C{int(newval)}X"")

    @property
    def operate(self):
        """"""
        Gets/sets the operating mode of the Keithley 580. If set to true, the
        instrument will be in operate mode, while false sets the instruments
        into standby mode.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""operate""]

    @operate.setter
    def operate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Operate mode must be a boolean."")
        self.sendcmd(f""O{int(newval)}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the relative measurement mode of the Keithley 580.

        As stated in the manual: The relative function is used to establish a
        baseline reading. This reading is subtracted from all subsequent
        readings. The purpose of making relative measurements is to cancel test
        lead and offset resistances or to store an input as a reference level.

        Once a relative level is established, it remains in effect until another
        relative level is set. The relative value is only good for the range the
        value was taken on and higher ranges. If a lower range is selected than
        that on which the relative was taken, inaccurate results may occur.
        Relative cannot be activated when ""OL"" is displayed.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}X"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 580.

        There are two different trigger settings for three different sources.
        This means there are six different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". Last, on ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.

        :type: `Keithley580.TriggerMode`
        """"""
        raise NotImplementedError

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley580.TriggerMode[newval]
        if not isinstance(newval, Keithley580.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley580.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 580 input terminals. The valid
        ranges are one of ``{AUTO|2e-1|2|20|200|2000|2e4|2e5}``

        :type: `~pint.Quantity` or `str`
        """"""
        value = self.parse_status_word(self.get_status_word())[""range""]
        if isinstance(value, str):  # if range is 'auto'
            return value
        else:
            return float(value) * u.ohm

    @input_range.setter
    def input_range(self, newval):
        valid = (""auto"", 2e-1, 2e0, 2e1, 2e2, 2e3, 2e4, 2e5)
        if isinstance(newval, str):
            newval = newval.lower()
            if newval == ""auto"":
                self.sendcmd(""R0X"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval)
            else:
                raise ValueError(f""Valid range settings are: {valid}"")
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}X"")

    # METHODS #

    def trigger(self):
        """"""
        Tell the Keithley 580 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 580 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 580.

        This is the same as calling the `Keithley580.set_resistance_range`
        method and setting the parameter to ""AUTO"".
        """"""
        self.sendcmd(""R0X"")

    def set_calibration_value(self, value):
        """"""
        Sets the calibration value. This is not currently implemented.

        :param value: Calibration value to write
        """"""
        # self.write('V+n.nnnnE+nn')
        raise NotImplementedError(""setCalibrationValue not implemented"")

    def store_calibration_constants(self):
        """"""
        Instructs the instrument to store the calibration constants. This is
        not currently implemented.
        """"""
        # self.write('L0X')
        raise NotImplementedError(""storeCalibrationConstants not implemented"")

    def get_status_word(self):
        """"""
        The keithley will not always respond with the statusword when asked. We
        use a simple heuristic here: request it up to 5 times, using a 1s
        delay to allow the keithley some thinking time.

        :rtype: `str`
        """"""
        tries = 5
        statusword = """"
        while statusword[:3] != b""580"" and tries != 0:
            tries -= 1
            self.sendcmd(""U0X"")
            time.sleep(1)
            self.sendcmd("""")
            statusword = self._file.read_raw()

        if tries == 0:
            raise OSError(""could not retrieve status word"")

        return statusword[:-1]

    def parse_status_word(self, statusword):
        """"""
        Parse the status word returned by the function
        `~Keithley580.get_status_word`.

        Returns a `dict` with the following keys:
        ``{drive,polarity,drycircuit,operate,range,relative,eoi,trigger,
        sqrondata,sqronerror,linefreq,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :rtype: `dict`
        """"""
        if statusword[:3] != b""580"":
            raise ValueError(
                ""Status word starts with wrong "" ""prefix: {}"".format(statusword)
            )

        (
            drive,
            polarity,
            drycircuit,
            operate,
            rng,
            relative,
            eoi,
            trigger,
            sqrondata,
            sqronerror,
            linefreq,
        ) = struct.unpack(""@8c2s2sc"", statusword[3:16])

        valid = {
            ""drive"": {b""0"": ""pulsed"", b""1"": ""dc""},
            ""polarity"": {b""0"": ""+"", b""1"": ""-""},
            ""range"": {
                b""0"": ""auto"",
                b""1"": 0.2,
                b""2"": 2,
                b""3"": 20,
                b""4"": 2e2,
                b""5"": 2e3,
                b""6"": 2e4,
                b""7"": 2e5,
            },
            ""linefreq"": {b""0"": ""60Hz"", b""1"": ""50Hz""},
        }

        try:
            drive = valid[""drive""][drive]
            polarity = valid[""polarity""][polarity]
            rng = valid[""range""][rng]
            linefreq = valid[""linefreq""][linefreq]
        except:
            raise RuntimeError(""Cannot parse status "" ""word: {}"".format(statusword))

        return {
            ""drive"": drive,
            ""polarity"": polarity,
            ""drycircuit"": (drycircuit == b""1""),
            ""operate"": (operate == b""1""),
            ""range"": rng,
            ""relative"": (relative == b""1""),
            ""eoi"": eoi,
            ""trigger"": (trigger == b""1""),
            ""sqrondata"": sqrondata,
            ""sqronerror"": sqronerror,
            ""linefreq"": linefreq,
            ""terminator"": self.terminator,
        }

    def measure(self):
        """"""
        Perform a measurement with the Keithley 580.

        The usual mode parameter is ignored for the Keithley 580 as the only
        valid mode is resistance.

        :rtype: `~pint.Quantity`
        """"""
        self.trigger()
        self.sendcmd("""")
        return self.parse_measurement(self._file.read_raw()[:-1])[""resistance""]

    @staticmethod
    def parse_measurement(measurement):
        """"""
        Parse the measurement string returned by the instrument.

        Returns a dict with the following keys:
        ``{status,polarity,drycircuit,drive,resistance}``

        :param measurement: String to be unpacked and parsed
        :type: `str`

        :rtype: `dict`
        """"""
        (status, polarity, drycircuit, drive, resistance) = struct.unpack(
            ""@4c11s"", measurement
        )

        valid = {
            ""status"": {
                b""S"": ""standby"",
                b""N"": ""normal"",
                b""O"": ""overflow"",
                b""Z"": ""relative"",
            },
            ""polarity"": {b""+"": ""+"", b""-"": ""-""},
            ""drycircuit"": {b""N"": False, b""D"": True},
            ""drive"": {b""P"": ""pulsed"", b""D"": ""dc""},
        }
        try:
            status = valid[""status""][status]
            polarity = valid[""polarity""][polarity]
            drycircuit = valid[""drycircuit""][drycircuit]
            drive = valid[""drive""][drive]
            resistance = float(resistance) * u.ohm
        except:
            raise Exception(f""Cannot parse measurement: {measurement}"")

        return {
            ""status"": status,
            ""polarity"": polarity,
            ""drycircuit"": drycircuit,
            ""drive"": drive,
            ""resistance"": resistance,
        }

    # COMMUNICATOR METHODS #

    def sendcmd(self, cmd):
        super().sendcmd(cmd + "":"")

    def query(self, cmd, size=-1):
        return super().query(cmd + "":"", size)[:-1]
"
71,https://download.tek.com/datasheet/76W_10020_2_1.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attqkHYzPkKkFIskn'), ('width', 800), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zeO9Nqhwl0fbSwTNDacw3g/5Cjp9Y_6Tp6o0bdrvFCOU3EioNbf8O77Pg9j0sX2xCSXqoj7W9A7AB8n10ApdbmJY8ZhiNv6NHQGvs3uUB5LSEaMbYFUiFsFLmSQodciozi0QCyWD4YSKygB1K8Lsoto/EuEVSa5pdGBHsLm1kJ5CXwsGGzF9IJuxAWY4VEFOkf4'), ('filename', 'Alltest-Tektronix-AWG2005-23811.jpg'), ('size', 84919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tpIXIW3ZTA5o0aw3KyGUKA/JauLfMbybzoNDJdF0YWToEhC5oJpQrcnL_ywUdie-xQTkY8sgcKWPbb0Drsud9yA7m9X8NVOgYKvTLLZ0vxOJQ/FBabNl3jJBhjgsCy1MDNcdp--0IohA6rQTUrWK2Qdis'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xg0RZHdrYypx5Qi-8-1OUw/fHx_ME1zlfv6bHY-Aag1gIzAl4uCG_4YE2KkVsOFgJab2UpduJTFM9lFCx8o451Z6UQmSRf3zuwlkX2lwsVbHg/zB7A-Od6tM5F1Agy502AUmJBsC6sv6nztHtmVFYkn7c'), ('width', 800), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KPDdR849QdTjqi0i0SBG1A/JsQMTRNgGmt_tn8WfTIxQ8USGes-xMjcVobsdZmh0sezX2XuqkMhwGPJAyoR7l6I0bPJ9-Qq62PHtZQG-SknHw/_g-0VxxHxReFy7cPScogNFIcU-med8Jg4oEWQyNSjRg'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The AWG2005 offers 20 MS/s and 64 k deep memory. As with the entire AWG2000 Series, the graphical user interface allows on-screen viewing of waveform editing, simplifying ""what if"" test scenarios by allowing the easy creation of composite signals. The standard AWG2005 configuration provides two independent 10 V outputs or a third and fourth 10 V output (Option 02) each with 12-Bits vertical resolution. Option 04 adds TTL digital levels with (2) 12-Bit, 100 MS/s ports and combines with the marker outputs to provide a total of 28-Bits wide. The built-in sweep generator (Option 05) provides even more flexibility by offering linear and logarithmic swept frequencies, but even more significantly the AWG2005 has user definable sweep capability. This allows creation of digitally modulated signals at IF frequencies. The built-in frequency domain (FFT) editor (Option 09) is a perfect addition for customers performing proprietary or standard I & Q modulation simulations, filter design or in circuit testing of physical layer. Real time waveform sequencing extends the effective record length output to over a billion points! The AWG2005 easily simulates signals where moderate point definition and long records are required for simulating complex waveform conditions. Direct waveform transfer capability makes the AWG2005 the perfect complement to selected Tektronix oscilloscopes.",https://alltest.net/categories/products/AWG2005-Tektronix,Tekawg 2000,555.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekawg2000.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekawg2000-arbitrary-wave-generator,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782481/Instruments/RF%20Signal%20Generator/AWG2005/AWG2005.jpg,AWG2005,Write a Python script that uses Instrumentkit to connect to a AWG2005 RF Signal Generator,495.0,,True,,"#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")
"
87,https://www.toptica.com/fileadmin/Editors_English/11_brochures_datasheets/01_brochures/toptica_BR_TopMode.pdf,https://en.wikipedia.org/wiki/Laser_diode,"[OrderedDict([('id', 'attySc0bj6E4RhJ6k'), ('width', 1200), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MReqGJ0exnkowvQDuq4Vpg/wxXawzVP1uHNAjnQM4mIiEunsbZxJAqh8f-S7VrZS1tbhMH3LHOelvuAB6JhNFkfoBOBullTgF5xEsVq-E-itQ4W7jzXN04rX494WTh7va2rHSkGqCFzGfJbgkNjjeZ-/BE3r6xW7ZXlIheySXedVv1TsVT1l-gmShNNm3rcv8_U'), ('filename', 'toptica_topmode_3x_1200x350_w.jpg'), ('size', 83757), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AZn2jBCh-JWWjta4DIBeSw/vkly9-Liw43BebErLuV3J9quBER3dx3BjrybY821oCCIuKfqazBdX0cgYA9yr1qjm1VfmlNq8zoxXto1_jg6Fg/1kTGQL2s-EXzClZYSz1-3IrjysgbuV5nMdIfBHL5lgI'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-VxkkuyBP5N8B1V2M2QDLw/hGVbYvGu-HIpPNUXusKVuZLCAuzslzD9csTc1sOWITsNBb1Lj_y90CW6S8E_OxhaXdgiWkb7TbbKFwlsgYdFPw/3HOHR19cpI_lkjUK2ArSP3npJiKXS0eSPrAbdwOLuMQ'), ('width', 1200), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5Rmd5THQZDhWp9wzcHIRYA/1TpIa7RkOiqDVidu4DDJGK7yXsDoGu7A8OihPqzXFwPjH5qCzm1lSCqKaS23Thg2J47_bjWEatE4Nzqt-ez3wA/sg282uzH_V_czvjUi3pT__OF65cLQxBVB0zGCxLSkwc'), ('width', 3000), ('height', 3000)]))]))])]",75.0,Germany,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125974/Instruments/Vendor%20Logos/Toptica.png,"TOPTICA’s TopMode lasers operate as easily as a HeNe, but also offer higher power and the choice of wavelength. The TopMode series sets records in terms of power, coherence and wavelength stability. The proprietary CoHerence-Advanced Regulation Method (CHARM) provides an active stabilization of the lasers’ coherence and ensures continuous single-frequency operation. TopMode and CHARM means nothing less than reliable 24/7 operation.",https://www.toptica.com/products/single-frequency-lasers/topmode,Topmode,626.0,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction","TOPTICA Photonics is a manufacturer of [lasers](https://en.wikipedia.org/wiki/Laser) for quantum technologies, biophotonics and material inspection
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/toptica/topmode.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/toptica.html,Toptica,"[OrderedDict([('id', 'attdPu3r6YQ3XuoNe'), ('width', 469), ('height', 107), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TeQgYrDvE5mLqia6IJsurg/7zvIiAICYJhM9loo-_SvZEQSb-0jk1xp5wA1Fp37JLLL8MsILzlizzTued7SlqqxoejiZtY_VrHxhr4bXaxDlBdo85NilbLMAkKWgyo97TI/9V4G3Bg1P3ECsdKSzVK3lGTwjYMfAZ-p6rS9JOixX6Q'), ('filename', 'download.png'), ('size', 4105), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PhGBRWF-WfMypvv-VsWTDw/QmSRGhgQKXHg7creAi1wQHIBhyVsACwIDY5MJiqYRrGejneAEvMkUKwQR2TdVgJWq1ziYBZrm5Lb8ynNv3yeyg/bBiW0hNOoJiZDynQdxSlEil1I2e0RIhULCBv1q74-M8'), ('width', 158), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3_ZsOFGT0BWiy9uxloMNWQ/pMOJeqYLqs1ydyrE9W2GgRivW1Lw_Azb-kNbBQttjI0vVLPKkXnsdYlFRTjJBrMP0qPrBJybxYNar5dKB2T5MA/_NAf6c2MXOilFUL1lzJJ_1e8CBIK4lmrehK14xkVt_0'), ('width', 469), ('height', 107)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qfs4hpFhRCybbwHsJNBRfg/VRl3tGj2PssadCmzClw0Sj-FayUMxwKPT7Fl-NXV2OBOGD0S0YI_Oyf3XEOWbAwcqmjq2w5QqVQWJ_WTQLPcAA/63bwfMF2UwLL7QvwD0SzxQXottc22FQdWc7RNkAUNuQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782495/Instruments/Lasers/TopMode/TopMode.jpg,TopMode,Write a Python script that uses Instrumentkit to connect to a TopMode Lasers,,,,,"#!/usr/bin/env python
""""""
Provides the support for the Toptica Topmode diode laser.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.toptica.toptica_utils import convert_toptica_boolean as ctbool
from instruments.toptica.toptica_utils import convert_toptica_datetime as ctdate
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TopMode(Instrument):

    """"""
    Communicates with a `Toptica Topmode`_ instrument.

    The TopMode is a diode laser with active stabilization, produced by Toptica.

    Example usage:

    >>> import instruments as ik
    >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
    >>> print(tm.laser[0].wavelength)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.prompt = ""> ""
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if ""reboot"" in msg:
            return [msg, ""reboot process started.""]
        elif ""start-correction"" in msg:
            return [msg, ""()""]

        return msg

    # ENUMS #

    class CharmStatus(IntEnum):

        """"""
        Enum containing valid charm statuses for the lasers
        """"""

        un_initialized = 0
        in_progress = 1
        success = 2
        failure = 3

    # INNER CLASSES #

    class Laser:

        """"""
        Class representing a laser on the Toptica Topmode.

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `Topmode` class.
        """"""

        def __init__(self, parent, idx):
            self.parent = parent
            self.name = f""laser{idx + 1}""

        # PROPERTIES #

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the laser

            :return: The serial number of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":serial-number"")

        @property
        def model(self):
            """"""
            Gets the model type of the laser

            :return: The model of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":model"")

        @property
        def wavelength(self):
            """"""
            Gets the wavelength of the laser

            :return: The wavelength of the specified laser
            :units: Nanometers (nm)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":wavelength"")) * u.nm

        @property
        def production_date(self):
            """"""
            Gets the production date of the laser

            :return: The production date of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":production-date"")

        @property
        def enable(self):
            """"""
            Gets/sets the enable/disable status of the laser. Value of `True`
            is for enabled, and `False` for disabled.

            :return: Enable status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":emission""))

        @enable.setter
        def enable(self, newval):
            if not isinstance(newval, bool):
                raise TypeError(
                    ""Emission status must be a boolean, got: "" ""{}"".format(type(newval))
                )
            if not self.is_connected:
                raise RuntimeError(
                    ""Laser was not recognized by charm "" ""controller. Is it plugged in?""
                )
            self.parent.set(self.name + "":enable-emission"", newval)

        @property
        def is_connected(self):
            """"""
            Check whether a laser is connected.

            :return: Whether the controller successfully connected to a laser
            :type: `bool`
            """"""
            if self.serial_number == ""unknown"":
                return False
            return True

        @property
        def on_time(self):
            """"""
            Gets the 'on time' value for the laser

            :return: The 'on time' value for the specified laser
            :units: Seconds (s)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":ontime"")) * u.s

        @property
        def charm_status(self):
            """"""
            Gets the 'charm status' of the laser

            :return: The 'charm status' of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 7) % 2 == 1

        @property
        def temperature_control_status(self):
            """"""
            Gets the temperature control status of the laser

            :return: The temperature control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 5) % 2 == 1

        @property
        def current_control_status(self):
            """"""
            Gets the current control status of the laser

            :return: The current control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 6) % 2 == 1

        @property
        def tec_status(self):
            """"""
            Gets the TEC status of the laser

            :return: The TEC status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":tec:ready""))

        @property
        def intensity(self):
            """"""
            Gets the intensity of the laser. This property is unitless.

            :return: the intensity of the specified laser
            :units: Unitless
            :type: `float`
            """"""
            return float(self.parent.reference(self.name + "":intensity""))

        @property
        def mode_hop(self):
            """"""
            Gets whether the laser has mode-hopped

            :return: Mode-hop status of the specified laser
            :type: `bool`
            """"""
            response = self.parent.reference(self.name + "":charm:reg:mh-occurred"")
            return ctbool(response)

        @property
        def lock_start(self):
            """"""
            Gets the date and time of the start of mode-locking

            :return: The datetime of start of mode-locking for specified laser
            :type: `datetime`
            """"""
            # if mode locking has not started yet, the device will respond with
            # an empty date string. This causes a problem with ctdate.
            _corr_stat = self.correction_status
            if (
                _corr_stat == TopMode.CharmStatus.un_initialized
                or _corr_stat == TopMode.CharmStatus.failure
            ):
                raise RuntimeError(""Laser has not yet successfully locked"")

            response = self.parent.reference(self.name + "":charm:reg:started"")
            return ctdate(response)

        @property
        def first_mode_hop_time(self):
            """"""
            Gets the date and time of the first mode hop

            :return: The datetime of the first mode hop for the specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:first-mh"")

            return ctdate(response)

        @property
        def latest_mode_hop_time(self):
            """"""
            Gets the date and time of the latest mode hop

            :return: The datetime of the latest mode hop for the
                specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:latest-mh"")
            return ctdate(response)

        @property
        def correction_status(self):
            """"""
            Gets the correction status of the laser

            :return: The correction status of the specified laser
            :type: `~TopMode.CharmStatus`
            """"""
            value = self.parent.reference(self.name + "":charm:correction-status"")
            return TopMode.CharmStatus(int(value))

        # METHODS #

        def correction(self):
            """"""
            Run the correction against the specified laser
            """"""
            if self.correction_status == TopMode.CharmStatus.un_initialized:
                self.parent.execute(self.name + "":charm:start-correction-initial"")
            else:
                self.parent.execute(self.name + "":charm:start-correction"")

    # TOPMODE CONTROL LANGUAGE #

    def execute(self, command):
        """"""
        Sends an execute command to the Topmode. This is used to automatically
        append (exec ' + command + ) to your command.

        :param str command: The command to be executed.
        """"""
        self.sendcmd(""(exec '"" + command + "")"")

    def set(self, param, value):
        """"""
        Sends a param-set command to the Topmode. This is used to automatically
        handle appending ""param-set!"" and the rest of the param-set message
        structure to your message.

        :param str param: Parameter that will be set
        :param value: Value that the parameter will be set to
        :type value: `str`, `tuple`, `list`, or `bool`
        """"""

        if isinstance(value, str):
            self.query(f'(param-set! \'{param} ""{value}"")')
        elif isinstance(value, (tuple, list)):
            self.query(""(param-set! '{} '({}))"".format(param, "" "".join(value)))
        elif isinstance(value, bool):
            value = ""t"" if value else ""f""
            self.query(f""(param-set! '{param} #{value})"")

    def reference(self, param):
        """"""
        Sends a reference commands to the Topmode. This is effectively a query
        request. It will append the required (param-ref ' + param + ).

        :param str param: Parameter that should be queried
        :return: Response to the reference request
        :rtype: `str`
        """"""
        response = self.query(f""(param-ref '{param})"").replace('""', """")
        return response

    def display(self, param):
        """"""
        Sends a display command to the Topmode.

        :param str param: Parameter that will be sent with a display request
        :return: Response to the display request
        """"""
        return self.query(f""(param-disp '{param})"")

    # PROPERTIES #

    @property
    def laser(self):
        """"""
        Gets a specific Topmode laser object. The desired laser is
        specified like one would access a list.

        For example, the following would print the wavelength from laser 1:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
        >>> print(tm.laser[0].wavelength)

        :rtype: `~TopMode.Laser`
        """"""
        return ProxyList(self, self.Laser, range(2))

    @property
    def enable(self):
        """"""
        is the laser lasing?
        :return:
        """"""
        return ctbool(self.reference(""emission""))

    @enable.setter
    def enable(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(
                ""Emission status must be a boolean, "" ""got: {}"".format(type(newval))
            )
        self.set(""enable-emission"", newval)

    @property
    def locked(self):
        """"""
        Gets the key switch lock status

        :return: `True` if key switch is locked, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""front-key-locked""))

    @property
    def interlock(self):
        """"""
        Gets the interlock switch open state

        :return: `True` if interlock switch is open, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""interlock-open""))

    @property
    def firmware(self):
        """"""
        Gets the firmware version of the charm controller

        :return: The firmware version of the charm controller
        :type: `tuple`
        """"""
        firmware = tuple(map(int, self.reference(""fw-ver"").split(""."")))
        return firmware

    @property
    def fpga_status(self):
        """"""
        Gets the FPGA health status

        :return: `False` if there has been a failure for the FPGA,
            `True` otherwise
        :type: `bool`
        """"""
        response = self.reference(""system-health"")
        if response.find(""#f"") >= 0:
            return False
        response = int(response)
        return False if response % 2 else True

    @property
    def serial_number(self):
        """"""
        Gets the serial number of the charm controller

        :return: The serial number of the charm controller
        :type: `str`
        """"""
        return self.reference(""serial-number"")

    @property
    def temperature_status(self):
        """"""
        Gets the temperature controller board health status

        :return: `False` if there has been a failure for the temperature
            controller board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 1) % 2 else True

    @property
    def current_status(self):
        """"""
        Gets the current controller board health status

        :return: `False` if there has been a failure for the current controller
            board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 2) % 2 else True

    # METHODS #

    def reboot(self):
        """"""
        Reboots the system (note that the serial connect might have to be
        re-opened after this)
        """"""
        self.execute(""reboot-system"")
"
92,https://xdevs.com/doc/Tektronix/TDS520/TEKTRONIX_Company_Ad_TDS520_w_Datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attBqUxbkbvswUSvd'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/47ShJJr4Bv6Cjm52imTQyQ/cVsGEibUtt5QYssb5ZvgY-ZI20bobpDb6r5zksB4TDc9O-0uAo109_88O7vYsFO8Tjr8_g1BCaB737-EElIsmxSLjyjJyZUQaTC1XKV2IN4/BW3PB2P4gqdgFo4EeyxSwlh_HmlEtGffU5zGlCRwM7c'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vrRiYhDgfuPPVTPBi_-WOQ/exS4Yl2g4_rfxVG3rCNrhIffiEi_-nAfsu1okyq8JSNsULGw-zx9aTM8viKaIyuEMuMfOXS2C-cbDaWJSJv8PQ/5K57uuV1DjnCm9pm_OiYFHMien2ROx1H9BaHgqNFdZw'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tRNoOVO8yFeZXkQlzlX2sg/El4P14QgQJux0O15JsRfI8R_6pEwm2e-2iPbkG3I1EoSl-5LN4huegD6YjFNAbGLc3O6pckGu9xr_J0GxJ1TOw/kdcnXKthSf520o3g1cgoC1KzF0NfCml48-dRO_twgvc'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wpB0QsfMVplWUTFoXjnkew/2woDt54TBngBVCa8IVzWZojHVNUQe6tY_H5ZuwnUGuF8eh40_D04pzQ7YAEgAY0yive9p70Z_v4rWgGhVrNi5A/yZXbHk260irHo9mXJDLPEGvTGyh6ICQ738tzPSg3M8g'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,,,Tektds 5 XX,551.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782499/Instruments/Oscilloscopes/TDS520-TDS540/TDS520-TDS540.jpg,TDS520/TDS540,Write a Python script that uses Instrumentkit to connect to a TDS520/TDS540 Oscilloscopes,450.0,,True,,"#!/usr/bin/env python
#
# tektds5xx.py: Driver for the Tektronix TDS 5xx series oscilloscope.
#
# © 2014 Chris Schimp (silverchris@gmail.com)
#
# Modified from tektds224.py
# © 2013 Steven Casagrande (scasagrande@galvant.ca).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Provides support for the Tektronix DPO 500 oscilloscope series.

Originally contributed by Chris Schimp (silverchris@gmail.com) in 2014.
Based off of tektds224.py written by Steven Casagrande.
""""""

# IMPORTS #####################################################################

from datetime import datetime
from enum import Enum
from functools import reduce
import operator
import struct
import time


from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TekTDS5xx(SCPIInstrument, Oscilloscope):

    """"""
    Support for the TDS5xx series of oscilloscopes
     Implemented from:
      | TDS Family Digitizing Oscilloscopes
      | (TDS 410A, 420A, 460A, 520A, 524A, 540A, 544A,
      | 620A, 640A, 644A, 684A, 744A & 784A)
      | Tektronix Document: 070-8709-07
    """"""

    class Measurement:

        """"""
        Class representing a measurement channel on the Tektronix TDS5xx
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            self._id = idx + 1
            resp = self._tek.query(f""MEASU:MEAS{self._id}?"")
            self._data = dict(
                zip(
                    [
                        ""enabled"",
                        ""type"",
                        ""units"",
                        ""src1"",
                        ""src2"",
                        ""edge1"",
                        ""edge2"",
                        ""dir"",
                    ],
                    resp.split("";""),
                )
            )

        def read(self):
            """"""
            Gets the current measurement value of the channel, and returns a dict
            of all relevant information

            :rtype: `dict` of measurement parameters
            """"""
            if int(self._data[""enabled""]):
                resp = self._tek.query(f""MEASU:MEAS{self._id}:VAL?"")
                self._data[""value""] = float(resp)
                return self._data

            return self._data

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, or ref) on the Tektronix
        TDS 5xx.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        @property
        def name(self):
            """"""
            Gets the name of this data source, as identified over SCPI.

            :type: `str`
            """"""
            return self._name

        def read_waveform(self, bin_format=True):
            """"""
            Read waveform from the oscilloscope.
            This function is all inclusive. After reading the data from the
            oscilloscope, it unpacks the data and scales it accordingly.

            Supports both ASCII and binary waveform transfer. For 2500 data
            points, with a width of 2 bytes, transfer takes approx 2 seconds for
            binary, and 7 seconds for ASCII over Galvant Industries' GPIBUSB
            adapter.

            Function returns a tuple (x,y), where both x and y are numpy arrays.

            :param bool bin_format: If `True`, data is transfered
                in a binary format. Otherwise, data is transferred in ASCII.

            :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]
            """"""
            with self:
                if not bin_format:
                    # Set the data encoding format to ASCII
                    self._parent.sendcmd(""DAT:ENC ASCI"")
                    raw = self._parent.query(""CURVE?"")
                    raw = raw.split("","")  # Break up comma delimited string
                    if numpy:
                        raw = numpy.array(raw, dtype=float)  # Convert to numpy array
                    else:
                        raw = map(float, raw)
                else:
                    # Set encoding to signed, big-endian
                    self._parent.sendcmd(""DAT:ENC RIB"")
                    data_width = self._parent.data_width
                    self._parent.sendcmd(""CURVE?"")
                    # Read in the binary block, data width of 2 bytes
                    raw = self._parent.binblockread(data_width)

                    # pylint: disable=protected-access
                    # read line separation character
                    self._parent._file.read_raw(1)

                # Retrieve Y offset
                yoffs = float(self._parent.query(f""WFMP:{self.name}:YOF?""))
                # Retrieve Y multiply
                ymult = float(self._parent.query(f""WFMP:{self.name}:YMU?""))
                # Retrieve Y zero
                yzero = float(self._parent.query(f""WFMP:{self.name}:YZE?""))

                # Retrieve X incr
                xincr = float(self._parent.query(f""WFMP:{self.name}:XIN?""))
                # Retrieve number of data points
                ptcnt = int(self._parent.query(f""WFMP:{self.name}:NR_P?""))

                if numpy:
                    x = numpy.arange(float(ptcnt)) * float(xincr)
                    y = ((raw - yoffs) * float(ymult)) + float(yzero)
                else:
                    x = tuple(float(val) * float(xincr) for val in range(ptcnt))
                    y = tuple(((x - yoffs) * float(ymult)) + float(yzero) for x in raw)

                return x, y

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on the Tektronix TDS 5xx.

        This class inherits from `TekTDS5xx.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        def __init__(self, parent, idx):
            super().__init__(parent, f""CH{idx + 1}"")
            self._idx = idx + 1

        @property
        def coupling(self):
            """"""
            Gets/sets the coupling setting for this channel.

            :type: `TekTDS5xx.Coupling`
            """"""
            return TekTDS5xx.Coupling(self._parent.query(f""CH{self._idx}:COUPL?""))

        @coupling.setter
        def coupling(self, newval):
            if not isinstance(newval, TekTDS5xx.Coupling):
                raise TypeError(
                    ""Coupling setting must be a `TekTDS5xx.Coupling`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:COUPL {newval.value}"")

        @property
        def bandwidth(self):
            """"""
            Gets/sets the Bandwidth setting for this channel.

            :type: `TekTDS5xx.Bandwidth`
            """"""
            return TekTDS5xx.Bandwidth(self._parent.query(f""CH{self._idx}:BAND?""))

        @bandwidth.setter
        def bandwidth(self, newval):
            if not isinstance(newval, TekTDS5xx.Bandwidth):
                raise TypeError(
                    ""Bandwidth setting must be a `TekTDS5xx.Bandwidth`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:BAND {newval.value}"")

        @property
        def impedance(self):
            """"""
            Gets/sets the impedance setting for this channel.

            :type: `TekTDS5xx.Impedance`
            """"""
            return TekTDS5xx.Impedance(self._parent.query(f""CH{self._idx}:IMP?""))

        @impedance.setter
        def impedance(self, newval):
            if not isinstance(newval, TekTDS5xx.Impedance):
                raise TypeError(
                    ""Impedance setting must be a `TekTDS5xx.Impedance`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:IMP {newval.value}"")

        @property
        def probe(self):
            """"""
            Gets the connected probe value for this channel

            :type: `float`
            """"""
            return round(1 / float(self._parent.query(f""CH{self._idx}:PRO?"")), 0)

        @property
        def scale(self):
            """"""
            Gets/sets the scale setting for this channel.

            :type: `float`
            """"""
            return float(self._parent.query(f""CH{self._idx}:SCA?""))

        @scale.setter
        def scale(self, newval):
            self._parent.sendcmd(f""CH{self._idx}:SCA {newval:.3E}"")
            resp = float(self._parent.query(f""CH{self._idx}:SCA?""))
            if newval != resp:
                raise ValueError(
                    ""Tried to set CH{} Scale to {} but got {}""
                    "" instead"".format(self._idx, newval, resp)
                )

    # ENUMS ##

    class Coupling(Enum):

        """"""
        Available coupling options for input sources and trigger
        """"""

        ac = ""AC""
        dc = ""DC""
        ground = ""GND""

    class Bandwidth(Enum):

        """"""
        Bandwidth in MHz
        """"""

        Twenty = ""TWE""
        OneHundred = ""HUN""
        TwoHundred = ""TWO""
        FULL = ""FUL""

    class Impedance(Enum):

        """"""
        Available options for input source impedance
        """"""

        Fifty = ""FIF""
        OneMeg = ""MEG""

    class Edge(Enum):

        """"""
        Available Options for trigger slope
        """"""

        Rising = ""RIS""
        Falling = ""FALL""

    class Trigger(Enum):

        """"""
        Available Trigger sources
        (AUX not Available on TDS520A/TDS540A)
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        AUX = ""AUX""
        LINE = ""LINE""

    class Source(Enum):

        """"""
        Available Data sources
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        Math1 = ""MATH1""
        Math2 = ""MATH2""
        Math3 = ""MATH3""
        Ref1 = ""REF1""
        Ref2 = ""REF2""
        Ref3 = ""REF3""
        Ref4 = ""REF4""

    # PROPERTIES ##
    @property
    def measurement(self):
        """"""
        Gets a specific oscilloscope measurement object. The desired channel is
        specified like one would access a list.

        :rtype: `TekTDS5xx.Measurement`
        """"""
        return ProxyList(self, self.Measurement, range(3))

    @property
    def channel(self):
        """"""
        Gets a specific oscilloscope channel object. The desired channel is
        specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.channel[0].read_waveform()

        :rtype: `TekTDS5xx.Channel`
        """"""
        return ProxyList(self, self.Channel, range(4))

    @property
    def ref(self):
        """"""
        Gets a specific oscilloscope reference channel object. The desired
        channel is specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.ref[0].read_waveform()

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""REF{idx + 1}""),
            range(4),
        )

    @property
    def math(self):
        """"""
        Gets a data source object corresponding to the MATH channel.

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""MATH{idx + 1}""),
            range(3),
        )

    @property
    def sources(self):
        """"""
        Returns list of all active sources

        :rtype: `list`
        """"""
        active = []
        channels = list(map(int, self.query(""SEL?"").split("";"")[0:11]))
        for idx in range(0, 4):
            if channels[idx]:
                active.append(self.Channel(self, idx))
        for idx in range(4, 7):
            if channels[idx]:
                active.append(self.DataSource(self, f""MATH{idx - 3}""))
        for idx in range(7, 11):
            if channels[idx]:
                active.append(self.DataSource(self, f""REF{idx - 6}""))
        return active

    @property
    def data_source(self):
        """"""
        Gets/sets the the data source for waveform transfer.

        :type: `TekTDS5xx.Source` or `TekTDS5xx.DataSource`
        :rtype: `TekTDS5xx.DataSource`
        """"""
        name = self.query(""DAT:SOU?"")
        if name.startswith(""CH""):
            return self.Channel(self, int(name[2:]) - 1)

        return self.DataSource(self, name)

    @data_source.setter
    def data_source(self, newval):
        if isinstance(newval, self.DataSource):
            newval = TekTDS5xx.Source(newval.name)
        if not isinstance(newval, TekTDS5xx.Source):
            raise TypeError(
                ""Source setting must be a `TekTDS5xx.Source`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""DAT:SOU {newval.value}"")
        time.sleep(0.01)  # Let the instrument catch up.

    @property
    def data_width(self):
        """"""
        Gets/Sets the data width for waveform transfers

        :type: `int`
        """"""
        return int(self.query(""DATA:WIDTH?""))

    @data_width.setter
    def data_width(self, newval):
        if int(newval) not in [1, 2]:
            raise ValueError(""Only one or two byte-width is supported."")

        self.sendcmd(f""DATA:WIDTH {newval}"")

    def force_trigger(self):
        raise NotImplementedError

    @property
    def horizontal_scale(self):
        """"""
        Get/Set Horizontal Scale

        :type: `float`
        """"""
        return float(self.query(""HOR:MAI:SCA?""))

    @horizontal_scale.setter
    def horizontal_scale(self, newval):
        self.sendcmd(f""HOR:MAI:SCA {newval:.3E}"")
        resp = float(self.query(""HOR:MAI:SCA?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set Horizontal Scale to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_level(self):
        """"""
        Get/Set trigger level

        :type: `float`
        """"""
        return float(self.query(""TRIG:MAI:LEV?""))

    @trigger_level.setter
    def trigger_level(self, newval):
        self.sendcmd(f""TRIG:MAI:LEV {newval:.3E}"")
        resp = float(self.query(""TRIG:MAI:LEV?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set trigger level to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_coupling(self):
        """"""
        Get/Set trigger coupling

        :type: `TekTDS5xx.Coupling`
        """"""
        return TekTDS5xx.Coupling(self.query(""TRIG:MAI:EDGE:COUP?""))

    @trigger_coupling.setter
    def trigger_coupling(self, newval):
        if not isinstance(newval, TekTDS5xx.Coupling):
            raise TypeError(
                ""Coupling setting must be a `TekTDS5xx.Coupling`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:COUP {newval.value}"")

    @property
    def trigger_slope(self):
        """"""
        Get/Set trigger slope

        :type: `TekTDS5xx.Edge`
        """"""
        return TekTDS5xx.Edge(self.query(""TRIG:MAI:EDGE:SLO?""))

    @trigger_slope.setter
    def trigger_slope(self, newval):
        if not isinstance(newval, TekTDS5xx.Edge):
            raise TypeError(
                ""Edge setting must be a `TekTDS5xx.Edge`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SLO {newval.value}"")

    @property
    def trigger_source(self):
        """"""
        Get/Set trigger source

        :type: `TekTDS5xx.Trigger`
        """"""
        return TekTDS5xx.Trigger(self.query(""TRIG:MAI:EDGE:SOU?""))

    @trigger_source.setter
    def trigger_source(self, newval):
        if not isinstance(newval, TekTDS5xx.Trigger):
            raise TypeError(
                ""Trigger source setting must be a ""
                ""`TekTDS5xx.Trigger` value, got {} ""
                ""instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SOU {newval.value}"")

    @property
    def clock(self):
        """"""
        Get/Set oscilloscope clock

        :type: `datetime.datetime`
        """"""
        resp = self.query(""DATE?;:TIME?"")
        return datetime.strptime(resp, '""%Y-%m-%d"";""%H:%M:%S""')

    @clock.setter
    def clock(self, newval):
        if not isinstance(newval, datetime):
            raise ValueError(
                ""Expected datetime.datetime "" ""but got {} instead"".format(type(newval))
            )
        self.sendcmd(newval.strftime('DATE ""%Y-%m-%d"";:TIME ""%H:%M:%S""'))

    @property
    def display_clock(self):
        """"""
        Get/Set the visibility of clock on the display

        :type: `bool`
        """"""
        return bool(int(self.query(""DISPLAY:CLOCK?"")))

    @display_clock.setter
    def display_clock(self, newval):
        if not isinstance(newval, bool):
            raise ValueError(""Expected bool but got "" ""{} instead"".format(type(newval)))
        self.sendcmd(f""DISPLAY:CLOCK {int(newval)}"")

    def get_hardcopy(self):
        """"""
        Gets a screenshot of the display

        :rtype: `string`
        """"""
        self.sendcmd(""HARDC:PORT GPI;HARDC:LAY PORT;:HARDC:FORM BMP"")
        self.sendcmd(""HARDC START"")
        time.sleep(1)
        header = self._file.read_raw(size=54)
        # Get BMP Length  in kilobytes from DIB header, because file header is
        # bad
        length = reduce(operator.mul, struct.unpack(""<iihh"", header[18:30])) / 8
        length = int(length) + 8  # Add 8 bytes for our monochrome colour table
        data = header + self._file.read_raw(size=length)
        self._file.flush_input()  # Flush input buffer
        return data
"
94,https://download.tek.com/document/55W-22447-9.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VcxH5ObsOzQlIWzGuBfNWA/E8fcF2u2ZPH-p0pj43QA6Uoj9ozGwf4zaQlAZToxa9JMcWVhMAJAEsqQUUOTL2dDb9sEMs1TpHCQOslS6-8OLinxJYCw-ziLkxlKRlFn68y7EUHmjFynurKJix0ifviaKi1RexWFSII_ce2gH5T2Dg/17iDCUaBSZMeZp3tB5iwx18LGQOkfakh1HtQIAQMFJ0'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UlFVOF8fF0qdFUMefasM2Q/C6biAJptiRrcO1tMPSvJqkaEHY08GzbpkgLM-zVmo-ehthA4lOFcMDzH-JIoImQSun8atPsRvQwKXuSwUdmRl-kqYFEFSKWoYqKgXGDbZd0/pkNKcFh08vGk-hNduCzB7LgoLceh9jvOK5Crt3g8xDM'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qvDo11-P97kWgXR7w_ieEQ/eQIXjSuUFqooaP6-hc957n09Ukl9UnXbEkR2wJWmNAGsZ7ZLbgaqamWdLeJ9UV_fgSY0d5mQYapzU3zWgGJ9ZO_y81JysrBRxTjK6nGDHLM/r_F6Jln28X7anov_gfH_Es_BdvhbGD9Wwp1qYoZ3EHg'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Sv7ApjP01MnyB7WDY7dNXA/jlhNVwLOLXgLbeIqvFTZ0sKlI2ux9TrCdnUBfc6Cs5OnSpWF7aMduWfoTZXZJzSMNReR_FdpkDgvz7wyU8lMm1OF5syVeMgsRv97Nd8TICY/YX_zeOnPcLxCI4tU5f8-h9I4mAJ2ukPH1RmyHYi2TQk'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,Tekdpo 70000,548.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo70000.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo70000-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782501/Instruments/Oscilloscopes/DPO70000/DPO70000.webp,DPO70000,Write a Python script that uses Instrumentkit to connect to a DPO70000 Oscilloscopes,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Tektronix DPO 70000 oscilloscope series
""""""

# IMPORTS #####################################################################

import abc
from enum import Enum
import time

from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import (
    enum_property,
    string_property,
    int_property,
    unitful_property,
    unitless_property,
    bool_property,
    ProxyList,
)

# CLASSES #####################################################################

# pylint: disable=too-many-lines


class TekDPO70000(SCPIInstrument, Oscilloscope):

    """"""
    The Tektronix DPO70000 series  is a multi-channel oscilloscope with analog
    bandwidths ranging up to 33GHz.

    This class inherits from `~instruments.generic_scpi.SCPIInstrument`.

    Example usage:

    >>> import instruments as ik
    >>> tek = ik.tektronix.TekDPO70000.open_tcpip(""192.168.0.2"", 8888)
    >>> [x, y] = tek.channel[0].read_waveform()
    """"""

    # CONSTANTS #

    # The number of horizontal and vertical divisions.
    HOR_DIVS = 10
    VERT_DIVS = 10

    # ENUMS #

    class AcquisitionMode(Enum):

        """"""
        Enum containing valid acquisition modes for the Tektronix 70000 series
        oscilloscopes.
        """"""

        sample = ""SAM""
        peak_detect = ""PEAK""
        hi_res = ""HIR""
        average = ""AVE""
        waveform_db = ""WFMDB""
        envelope = ""ENV""

    class AcquisitionState(Enum):

        """"""
        Enum containing valid acquisition states for the Tektronix 70000 series
        oscilloscopes.
        """"""

        on = ""ON""
        off = ""OFF""
        run = ""RUN""
        stop = ""STOP""

    class StopAfter(Enum):

        """"""
        Enum containing valid stop condition modes for the Tektronix 70000
        series oscilloscopes.
        """"""

        run_stop = ""RUNST""
        sequence = ""SEQ""

    class SamplingMode(Enum):

        """"""
        Enum containing valid sampling modes for the Tektronix 70000
        series oscilloscopes.
        """"""

        real_time = ""RT""
        equivalent_time_allowed = ""ET""
        interpolation_allowed = ""IT""

    class HorizontalMode(Enum):

        """"""
        Enum containing valid horizontal scan modes for the Tektronix 70000
        series oscilloscopes.
        """"""

        auto = ""AUTO""
        constant = ""CONST""
        manual = ""MAN""

    class WaveformEncoding(Enum):

        """"""
        Enum containing valid waveform encoding modes for the Tektronix 70000
        series oscilloscopes.
        """"""

        # NOTE: For some reason, it uses the full names here instead of
        # returning the mneonics listed in the manual.
        ascii = ""ASCII""
        binary = ""BINARY""

    class BinaryFormat(Enum):

        """"""
        Enum containing valid binary formats for the Tektronix 70000
        series oscilloscopes (int, unsigned-int, floating-point).
        """"""

        int = ""RI""
        uint = ""RP""
        float = ""FP""  # Single-precision!

    class ByteOrder(Enum):

        """"""
        Enum containing valid byte order (big-/little-endian) for the
        Tektronix 70000 series oscilloscopes.
        """"""

        little_endian = ""LSB""
        big_endian = ""MSB""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger states for the Tektronix 70000
        series oscilloscopes.
        """"""

        armed = ""ARMED""
        auto = ""AUTO""
        dpo = ""DPO""
        partial = ""PARTIAL""
        ready = ""READY""

    # STATIC METHODS #

    @staticmethod
    def _dtype(binary_format, byte_order, n_bytes):
        return ""{}{}{}"".format(
            {
                TekDPO70000.ByteOrder.big_endian: "">"",
                TekDPO70000.ByteOrder.little_endian: ""<"",
            }[byte_order],
            (n_bytes if n_bytes is not None else """"),
            {
                TekDPO70000.BinaryFormat.int: ""i"",
                TekDPO70000.BinaryFormat.uint: ""u"",
                TekDPO70000.BinaryFormat.float: ""f"",
            }[binary_format],
        )

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, or ref) on the
        Tektronix DPO 70000.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `TekDPO70000` class.
        """"""

        @property
        def name(self):
            return self._name

        @abc.abstractmethod
        def _scale_raw_data(self, data):
            """"""
            Takes the int16 data and figures out how to make it unitful.
            """"""

        # pylint: disable=protected-access
        def read_waveform(self, bin_format=True):
            # We want to get the data back in binary, as it's just too much
            # otherwise.
            with self:
                self._parent.select_fastest_encoding()
                n_bytes = self._parent.outgoing_n_bytes
                dtype = self._parent._dtype(
                    self._parent.outgoing_binary_format,
                    self._parent.outgoing_byte_order,
                    n_bytes=None,
                )
                self._parent.sendcmd(""CURV?"")
                raw = self._parent.binblockread(n_bytes, fmt=dtype)
                # Clear the queue by reading the end of line character
                self._parent._file.read_raw(1)

                return self._scale_raw_data(raw)

        def __enter__(self):
            self._old_dsrc = self._parent.data_source
            if self._old_dsrc != self:
                # Set the new data source, and let __exit__ cleanup.
                self._parent.data_source = self
            else:
                # There's nothing to do or undo in this case.
                self._old_dsrc = None

        def __exit__(self, type, value, traceback):
            if self._old_dsrc is not None:
                self._parent.data_source = self._old_dsrc

    class Math(DataSource):

        """"""
        Class representing a math channel on the Tektronix DPO 70000.

        This class inherits from `TekDPO70000.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `TekDPO70000` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based.

            # Initialize as a data source with name MATH{}.
            super().__init__(parent, f""MATH{self._idx}"")

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class with
            identifiers for the specified math channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""MATH{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Wraps queries sent from property factories in this class with
            identifiers for the specified math channel.

            :param str cmd: Query command to send to the instrument
            :param int size: Number of characters to read from the response.
                Default value reads until a termination character is found.
            :return: The query response
            :rtype: `str`
            """"""
            return self._parent.query(f""MATH{self._idx}:{cmd}"", size)

        class FilterMode(Enum):
            """"""
            Enum containing valid filter modes for a math channel on the
            TekDPO70000 series oscilloscope.
            """"""

            centered = ""CENT""
            shifted = ""SHIF""

        class Mag(Enum):
            """"""
            Enum containing valid amplitude units for a math channel on the
            TekDPO70000 series oscilloscope.
            """"""

            linear = ""LINEA""
            db = ""DB""
            dbm = ""DBM""

        class Phase(Enum):
            """"""
            Enum containing valid phase units for a math channel on the
            TekDPO70000 series oscilloscope.
            """"""

            degrees = ""DEG""
            radians = ""RAD""
            group_delay = ""GROUPD""

        class SpectralWindow(Enum):
            """"""
            Enum containing valid spectral windows for a math channel on the
            TekDPO70000 series oscilloscope.
            """"""

            rectangular = ""RECTANG""
            hamming = ""HAMM""
            hanning = ""HANN""
            kaiser_besse = ""KAISERB""
            blackman_harris = ""BLACKMANH""
            flattop2 = ""FLATTOP2""
            gaussian = ""GAUSS""
            tek_exponential = ""TEKEXP""

        define = string_property(
            ""DEF"",
            doc=""""""
            A text string specifying the math to do, ex. CH1+CH2
            """""",
        )

        filter_mode = enum_property(""FILT:MOD"", FilterMode)

        filter_risetime = unitful_property(""FILT:RIS"", u.second)

        label = string_property(
            ""LAB:NAM"",
            doc=""""""
            Just a human readable label for the channel.
            """""",
        )

        label_xpos = unitless_property(
            ""LAB:XPOS"",
            doc=""""""
            The x position, in divisions, to place the label.
            """""",
        )

        label_ypos = unitless_property(
            ""LAB:YPOS"",
            doc=""""""The y position, in divisions, to place the label.
            """""",
        )

        num_avg = unitless_property(
            ""NUMAV"",
            doc=""""""
            The number of acquisistions over which exponential averaging is
            performed.
            """""",
        )

        spectral_center = unitful_property(
            ""SPEC:CENTER"",
            u.Hz,
            doc=""""""
            The desired frequency of the spectral analyzer output data span
            in Hz.
            """""",
        )

        spectral_gatepos = unitful_property(
            ""SPEC:GATEPOS"",
            u.second,
            doc=""""""
            The gate position. Units are represented in seconds, with respect
            to trigger position.
            """""",
        )

        spectral_gatewidth = unitful_property(
            ""SPEC:GATEWIDTH"",
            u.second,
            doc=""""""
            The time across the 10-division screen in seconds.
            """""",
        )

        spectral_lock = bool_property(""SPEC:LOCK"", inst_true=""ON"", inst_false=""OFF"")

        spectral_mag = enum_property(
            ""SPEC:MAG"",
            Mag,
            doc=""""""
            Whether the spectral magnitude is linear, db, or dbm.
            """""",
        )

        spectral_phase = enum_property(
            ""SPEC:PHASE"",
            Phase,
            doc=""""""
            Whether the spectral phase is degrees, radians, or group delay.
            """""",
        )

        spectral_reflevel = unitless_property(
            ""SPEC:REFL"",
            doc=""""""
            The value that represents the topmost display screen graticule.
            The units depend on spectral_mag.
            """""",
        )

        spectral_reflevel_offset = unitless_property(""SPEC:REFLEVELO"")

        spectral_resolution_bandwidth = unitful_property(
            ""SPEC:RESB"",
            u.Hz,
            doc=""""""
            The desired resolution bandwidth value. Units are represented in
            Hertz.
            """""",
        )

        spectral_span = unitful_property(
            ""SPEC:SPAN"",
            u.Hz,
            doc=""""""
            Specifies the frequency span of the output data vector from the
            spectral analyzer.
            """""",
        )

        spectral_suppress = unitless_property(
            ""SPEC:SUPP"",
            doc=""""""
            The magnitude level that data with magnitude values below this
            value are displayed as zero phase.
            """""",
        )

        spectral_unwrap = bool_property(
            ""SPEC:UNWR"",
            inst_true=""ON"",
            inst_false=""OFF"",
            doc=""""""
            Enables or disables phase wrapping.
            """""",
        )

        spectral_window = enum_property(""SPEC:WIN"", SpectralWindow)

        threshhold = unitful_property(
            ""THRESH"",
            u.volt,
            doc=""""""
            The math threshhold in volts
            """""",
        )

        unit_string = string_property(
            ""UNITS"",
            doc=""""""
            Just a label for the units...doesn""t actually change anything.
            """""",
        )

        autoscale = bool_property(
            ""VERT:AUTOSC"",
            inst_true=""ON"",
            inst_false=""OFF"",
            doc=""""""
            Enables or disables the auto-scaling of new math waveforms.
            """""",
        )

        position = unitless_property(
            ""VERT:POS"",
            doc=""""""
            The vertical position, in divisions from the center graticule.
            """""",
        )

        scale = unitful_property(
            ""VERT:SCALE"",
            u.volt,
            doc=""""""
            The scale in volts per division. The range is from
            ``100e-36`` to ``100e+36``.
            """""",
        )

        def _scale_raw_data(self, data):
            # TODO: incorperate the unit_string somehow
            if numpy:
                return self.scale * (
                    (TekDPO70000.VERT_DIVS / 2) * data.astype(float) / (2**15)
                    - self.position
                )

            scale = self.scale
            position = self.position
            rval = tuple(
                scale * ((TekDPO70000.VERT_DIVS / 2) * d / (2**15) - position)
                for d in map(float, data)
            )
            return rval

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on the Tektronix DPO 70000.

        This class inherits from `TekDPO70000.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `TekDPO70000` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based.

            # Initialize as a data source with name CH{}.
            super().__init__(self._parent, f""CH{self._idx}"")

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class with
            identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""CH{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Wraps queries sent from property factories in this class with
            identifiers for the specified channel.

            :param str cmd: Query command to send to the instrument
            :param int size: Number of characters to read from the response.
                Default value reads until a termination character is found.
            :return: The query response
            :rtype: `str`
            """"""
            return self._parent.query(f""CH{self._idx}:{cmd}"", size)

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope channel
            """"""

            ac = ""AC""
            dc = ""DC""
            dc_reject = ""DCREJ""
            ground = ""GND""

        coupling = enum_property(
            ""COUP"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> inst = ik.tektronix.TekDPO70000.open_tcpip(""192.168.0.1"", 8080)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.ac
            """""",
        )

        bandwidth = unitful_property(""BAN"", u.Hz)

        deskew = unitful_property(""DESK"", u.second)

        termination = unitful_property(""TERM"", u.ohm)

        label = string_property(
            ""LAB:NAM"",
            doc=""""""
            Just a human readable label for the channel.
            """""",
        )

        label_xpos = unitless_property(
            ""LAB:XPOS"",
            doc=""""""
            The x position, in divisions, to place the label.
            """""",
        )

        label_ypos = unitless_property(
            ""LAB:YPOS"",
            doc=""""""
            The y position, in divisions, to place the label.
            """""",
        )

        offset = unitful_property(
            ""OFFS"",
            u.volt,
            doc=""""""
            The vertical offset in units of volts. Voltage is given by
            ``offset+scale*(5*raw/2^15 - position)``.
            """""",
        )

        position = unitless_property(
            ""POS"",
            doc=""""""
            The vertical position, in divisions from the center graticule,
            ranging from ``-8`` to ``8``. Voltage is given by
            ``offset+scale*(5*raw/2^15 - position)``.
            """""",
        )

        scale = unitful_property(
            ""SCALE"",
            u.volt,
            doc=""""""
            Vertical channel scale in units volts/division. Voltage is given
            by ``offset+scale*(5*raw/2^15 - position)``.
            """""",
        )

        def _scale_raw_data(self, data):
            scale = self.scale
            position = self.position
            offset = self.offset

            if numpy:
                return (
                    scale
                    * (
                        (TekDPO70000.VERT_DIVS / 2) * data.astype(float) / (2**15)
                        - position
                    )
                    + offset
                )

            return tuple(
                scale * ((TekDPO70000.VERT_DIVS / 2) * d / (2**15) - position)
                + offset
                for d in map(float, data)
            )

    # PROPERTIES ##

    @property
    def channel(self):
        return ProxyList(self, self.Channel, range(4))

    @property
    def math(self):
        return ProxyList(self, self.Math, range(4))

    @property
    def ref(self):
        raise NotImplementedError

    # For some settings that probably won't be used that often, use
    # string_property instead of setting up an enum property.
    acquire_enhanced_enob = string_property(
        ""ACQ:ENHANCEDE"",
        bookmark_symbol="""",
        doc=""""""
        Valid values are AUTO and OFF.
        """""",
    )

    acquire_enhanced_state = bool_property(
        ""ACQ:ENHANCEDE:STATE"",
        inst_false=""0"",  # TODO: double check that these are correct
        inst_true=""1"",
    )

    acquire_interp_8bit = string_property(
        ""ACQ:INTERPE"",
        bookmark_symbol="""",
        doc=""""""
        Valid values are AUTO, ON and OFF.
        """""",
    )

    acquire_magnivu = bool_property(""ACQ:MAG"", inst_true=""ON"", inst_false=""OFF"")

    acquire_mode = enum_property(""ACQ:MOD"", AcquisitionMode)

    acquire_mode_actual = enum_property(""ACQ:MOD:ACT"", AcquisitionMode, readonly=True)

    acquire_num_acquisitions = int_property(
        ""ACQ:NUMAC"",
        readonly=True,
        doc=""""""
        The number of waveform acquisitions that have occurred since starting
        acquisition with the ACQuire:STATE RUN command
        """""",
    )

    acquire_num_avgs = int_property(
        ""ACQ:NUMAV"",
        doc=""""""
        The number of waveform acquisitions to average.
        """""",
    )

    acquire_num_envelop = int_property(
        ""ACQ:NUME"",
        doc=""""""
        The number of waveform acquisitions to be enveloped
        """""",
    )

    acquire_num_frames = int_property(
        ""ACQ:NUMFRAMESACQ"",
        readonly=True,
        doc=""""""
        The number of frames acquired when in FastFrame Single Sequence and
        acquisitions are running.
        """""",
    )

    acquire_num_samples = int_property(
        ""ACQ:NUMSAM"",
        doc=""""""
        The minimum number of acquired samples that make up a waveform
        database (WfmDB) waveform for single sequence mode and Mask Pass/Fail
        Completion Test. The default value is 16,000 samples. The range is
        5,000 to 2,147,400,000 samples.
        """""",
    )

    acquire_sampling_mode = enum_property(""ACQ:SAMP"", SamplingMode)

    acquire_state = enum_property(
        ""ACQ:STATE"",
        AcquisitionState,
        doc=""""""
        This command starts or stops acquisitions.
        """""",
    )

    acquire_stop_after = enum_property(
        ""ACQ:STOPA"",
        StopAfter,
        doc=""""""
        This command sets or queries whether the instrument continually
        acquires acquisitions or acquires a single sequence.
        """""",
    )

    data_framestart = int_property(""DAT:FRAMESTAR"")

    data_framestop = int_property(""DAT:FRAMESTOP"")

    data_start = int_property(
        ""DAT:STAR"",
        doc=""""""
        The first data point that will be transferred, which ranges from 1 to
        the record length.
        """""",
    )

    # TODO: Look into the following troublesome datasheet note: ""When using the
    # CURVe command, DATa:STOP is ignored and WFMInpre:NR_Pt is used.""
    data_stop = int_property(
        ""DAT:STOP"",
        doc=""""""
        The last data point that will be transferred.
        """""",
    )

    data_sync_sources = bool_property(""DAT:SYNCSOU"", inst_true=""ON"", inst_false=""OFF"")

    @property
    def data_source(self):
        """"""
        Gets/sets the data source for the oscilloscope. This will return
        the actual Channel/Math/DataSource object as if it was accessed
        through the usual `TekDPO70000.channel`, `TekDPO70000.math`, or
        `TekDPO70000.ref` properties.

        :type: `TekDPO70000.Channel` or `TekDPO70000.Math`
        """"""
        val = self.query(""DAT:SOU?"")
        if val[0:2] == ""CH"":
            out = self.channel[int(val[2]) - 1]
        elif val[0:2] == ""MA"":
            out = self.math[int(val[4]) - 1]
        elif val[0:2] == ""RE"":
            out = self.ref[int(val[3]) - 1]
        else:
            raise NotImplementedError
        return out

    @data_source.setter
    def data_source(self, newval):
        if not isinstance(newval, self.DataSource):
            raise TypeError(f""{type(newval)} is not a valid data source."")
        self.sendcmd(f""DAT:SOU {newval.name}"")

        # Some Tek scopes require this after the DAT:SOU command, or else
        # they will stop responding.
        time.sleep(0.02)

    horiz_acq_duration = unitful_property(
        ""HOR:ACQDURATION"",
        u.second,
        readonly=True,
        doc=""""""
        The duration of the acquisition.
        """""",
    )

    horiz_acq_length = int_property(
        ""HOR:ACQLENGTH"",
        readonly=True,
        doc=""""""
        The record length.
        """""",
    )

    horiz_delay_mode = bool_property(""HOR:DEL:MOD"", inst_true=""1"", inst_false=""0"")

    horiz_delay_pos = unitful_property(
        ""HOR:DEL:POS"",
        u.percent,
        doc=""""""
        The percentage of the waveform that is displayed left of the center
        graticule.
        """""",
    )

    horiz_delay_time = unitful_property(
        ""HOR:DEL:TIM"",
        u.second,
        doc=""""""
        The base trigger delay time setting.
        """""",
    )

    horiz_interp_ratio = unitless_property(
        ""HOR:MAI:INTERPR"",
        readonly=True,
        doc=""""""
        The ratio of interpolated points to measured points.
        """""",
    )

    horiz_main_pos = unitful_property(
        ""HOR:MAI:POS"",
        u.percent,
        doc=""""""
        The percentage of the waveform that is displayed left of the center
        graticule.
        """""",
    )

    horiz_unit = string_property(""HOR:MAI:UNI"")

    horiz_mode = enum_property(""HOR:MODE"", HorizontalMode)

    horiz_record_length_lim = int_property(
        ""HOR:MODE:AUTO:LIMIT"",
        doc=""""""
        The recond length limit in samples.
        """""",
    )

    horiz_record_length = int_property(
        ""HOR:MODE:RECO"",
        doc=""""""
        The recond length in samples. See `horiz_mode`; manual mode lets you
        change the record length, while the length is readonly for auto and
        constant mode.
        """""",
    )

    horiz_sample_rate = unitful_property(
        ""HOR:MODE:SAMPLER"",
        u.Hz,
        doc=""""""
        The sample rate in samples per second.
        """""",
    )

    horiz_scale = unitful_property(
        ""HOR:MODE:SCA"",
        u.second,
        doc=""""""
        The horizontal scale in seconds per division. The horizontal scale is
        readonly when `horiz_mode` is manual.
        """""",
    )

    horiz_pos = unitful_property(
        ""HOR:POS"",
        u.percent,
        doc=""""""
        The position of the trigger point on the screen, left is 0%, right
        is 100%.
        """""",
    )

    horiz_roll = string_property(
        ""HOR:ROLL"",
        bookmark_symbol="""",
        doc=""""""
        Valid arguments are AUTO, OFF, and ON.
        """""",
    )

    trigger_state = enum_property(""TRIG:STATE"", TriggerState)

    # Waveform Transfer Properties
    outgoing_waveform_encoding = enum_property(
        ""WFMO:ENC"",
        WaveformEncoding,
        doc=""""""
        Controls the encoding used for outgoing waveforms (instrument → host).
        """""",
    )

    outgoing_binary_format = enum_property(
        ""WFMO:BN_F"",
        BinaryFormat,
        doc=""""""
        Controls the data type of samples when transferring waveforms from
        the instrument to the host using binary encoding.
        """""",
    )

    outgoing_byte_order = enum_property(
        ""WFMO:BYT_O"",
        ByteOrder,
        doc=""""""
        Controls whether binary data is returned in little or big endian.
        """""",
    )

    outgoing_n_bytes = int_property(
        ""WFMO:BYT_N"",
        valid_set={1, 2, 4, 8},
        doc=""""""
        The number of bytes per sample used in representing outgoing
        waveforms in binary encodings.

        Must be either 1, 2, 4 or 8.
        """""",
    )

    # METHODS #

    def select_fastest_encoding(self):
        """"""
        Sets the encoding for data returned by this instrument to be the
        fastest encoding method consistent with the current data source.
        """"""
        self.sendcmd(""DAT:ENC FAS"")

    def force_trigger(self):
        """"""
        Forces a trigger event to happen for the oscilloscope.
        """"""
        self.sendcmd(""TRIG FORC"")

    # TODO: consider moving the next few methods to Oscilloscope.
    def run(self):
        """"""
        Enables the trigger for the oscilloscope.
        """"""
        self.sendcmd("":RUN"")

    def stop(self):
        """"""
        Disables the trigger for the oscilloscope.
        """"""
        self.sendcmd("":STOP"")
"
95,http://www.cryotrade.ru/uploads/documents/temperature/LakeShore370.pdf,https://en.wikipedia.org/wiki/Ohmmeter,"[OrderedDict([('id', 'atto87LIsOZVAKm9z'), ('width', 505), ('height', 157), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5r6YCeTFL7PMcqn007XBZQ/4WVMJs69rtMKV42m-ttlKmoweDZkXhEcgIHfYDUFef8DDuN-OZ63J9wCUNUt47SipVISofQ6x3tATUzWalFFRQ/kEkTwEBnKvmnOTj3CkmBypZFhdyWYMIGO9t9d2pkApQ'), ('filename', '370.png'), ('size', 99490), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/So37M1iq2INm5k5b22ljLg/uOGlntbNOZ6aQT51n6uivJwaE0eoaE1y2uBYJLRcgbNxW_9tt4SIQ0MEwyGqP9qXc-XKxQqZeuur6zFMn7-xPA/nLQ00N0c1SF3nw_ZsD0CELnZ3QvihO3N58BEYMQ_HTY'), ('width', 116), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/dg2-6gblDdr4gsYub_iOcg/Ji3G159pTyBU4pHVWK9fwzqIDFN2hZ8frrAFQnucxv2TkgeJAvZd-HVzV4AHIP1wE74Kn6Gf0LHgFN9BnNTfrA/Z7NF6uu92udjqj2OMECDtHMjt5P4P7jAT1cYrXpYhHI'), ('width', 505), ('height', 157)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AP4VDrbc0eG-DO89VZUfxQ/nNUk8ylIUu8pTmV2HiF-0k-J0BL_sg11tIFk8vhSJ5hboseSnuG9U_9gIIQrY3Wx6FVfRPMFGWsQaPOxSKSOAg/wLTl4i-4pYqLjHqlgcvVFIA45znOqAwqBCqVvz76s1g'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 370 AC resistance bridge is designed for precise, accurate, low noise, low excitation power AC resistance measurements. Its primary application is the measurement of resistive materials in cryogenic environments from 20 mK to 1 K. Fully integrated, the Model 370 includes features to reduce and control noise at every step of the resistance measurement process. A unique, patented, matched impedance current source and active common mode reduction circuitry minimize noise and self-heating errors. With up to 16 channels, IEEE-488 and serial interfaces, and closed loop temperature control, the Model 370 offers seamless integration with existing cryogenic systems and is the most complete package on the market today. Used with Lake Shore calibrated subkelvin resistance temperature sensors, it not only measures and displays, but also controls temperature for dilution refrigerators and other cryogenic systems.",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-370-ac-resistance-bridge-,Lakeshore 370,347.0,['Power Meters'],An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore370.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore370-ac-resistance-bridge,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782502/Instruments/Power%20Meters/Lakeshore-370/Lakeshore-370.png,Lakeshore 370,Write a Python script that uses Instrumentkit to connect to a Lakeshore 370 Power Meters,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Lakeshore 370 AC resistance bridge.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore370(SCPIInstrument):

    """"""
    The Lakeshore 370 is a multichannel AC resistance bridge for use in low
    temperature dilution refridgerator setups.

    Example usage:

    >>> import instruments as ik
    >>> bridge = ik.lakeshore.Lakeshore370.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(bridge.channel[0].resistance)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        # Disable termination characters and enable EOI
        self.sendcmd(""IEEE 3,0"")

    # INNER CLASSES ##

    class Channel:

        """"""
        Class representing a sensor attached to the Lakeshore 370.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def resistance(self):
            """"""
            Gets the resistance of the specified sensor.

            :units: Ohm
            :rtype: `~pint.Quantity`
            """"""
            value = self._parent.query(f""RDGR? {self._idx}"")
            return u.Quantity(float(value), u.ohm)

    # PROPERTIES ##

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would query the resistance of the first channel::

        >>> import instruments as ik
        >>> bridge = ik.lakeshore.Lakeshore370.open_serial(""COM5"")
        >>> print(bridge.channel[0].resistance)

        The Lakeshore 370 supports up to 16 channels (index 0-15).

        :rtype: `~Lakeshore370.Channel`
        """"""
        return ProxyList(self, Lakeshore370.Channel, range(16))
"
105,https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attO8NgzXv6EBjVdD'), ('width', 1000), ('height', 929), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/K60eg29cxMJ_ApAaL-W6wA/66DsVq-EC-ouGTZk8ncHIX_rYvP30VJ_61NA1CfWGBGJFPkDjtPsNnq0b6f3m0KO7CQ7tiUs83Y8Q1hESzhHfsuFqEARTVsR_yfg3v_9Kxs/fZS1eKmsahEhIbr68nGmj0wDXsGwLMIGJQ0uVKniRD4'), ('filename', 'wr9000-hero.webp'), ('size', 138832), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jdR2wJUEHOCx2UKVgt83qQ/l1izqelX0LKImqiSLxPvsLiU4pxLr0SdJr65S6GhH-eqzyjGUkBMc08BPjYfXMOEDpTIvlM34VgNcrwMeNauhNsRPrAFKv7zLSLa3uTOPII/5aRtbEdfY3-p-HfLar5mJ_dxGWCL-KxMflahylmqZDU'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GNgCWXImWlrCKnQXadvaSg/auV_mDF01Jm2Fp76zK-qjHl6ZAJhDWq0ycX0OdykaFn_DkAv84H_wjef3O8OkOwIlbQpnTz0Wzgde8zl9iwmrA9KaJSfmKV-SUuo7wagTQM/ckc5o9Y8_IBngmNwLpwFKPPLMrt56n6M5PxULEywjeI'), ('width', 551), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ytkveNdCIkElu0h4Xccp5A/KEATMD57YFpOyRP0wv7Eu2SxlDMPpPEBREgfqv6aU4ceRnPlbzVzu08lGtiBWSEgV-85McYR5P3TcyGcLXjxIHQ1W3TGPPvzk4jHNuz5xcI/fuvg51zH4YGT2pjJgb_6rSgahhRcGZ4O9u3FTUIj0xA'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"WaveRunner 9000 oscilloscopes have the industry's widest and deepest collection of tools, making it unbelievably powerful and MAUI with OneTouch makes measurement setup insanely easy, providing faster time to insight.",https://www.teledynelecroy.com/oscilloscope/waverunner-9000-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782511/Instruments/Oscilloscopes/WaveRunner-9000/WaveRunner-9000.webp,WaveRunner 9000,Write a Python script that uses Instrumentkit to connect to a WaveRunner 9000 Oscilloscopes,16800.0,,,price from here: https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
107,https://www.testequipmenthq.com/datasheets/TEKTRONIX-TDS224-Datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attogh5LFg8s7lsw4'), ('width', 798), ('height', 566), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yK3o6L8PQJwW7AGC5c_R7Q/kD4sNRc60Ay0_xHTflXx02isJDdbfj7pCH7asDwCpidv_w2VTfj1CU3PZ131eW23AcpvZReKnDfs_zs3sgWLJwcvWN9kIn82Fp0h1SgPxH0/s_CS8CQX4e-rZ9pr002pnqg6Y92jyjX8BL4ux62JtD4'), ('filename', 'TDS224.jpg'), ('size', 323986), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8LBWP4su7-xw3kIdoAi8A/Y0BhOaoeGs_WabZIvyOn-S1sjY9CWPLCP4J_S4ModyPeZV4Jb6ttH9-5H5BQC_c4CpkEau_YFpBHOiUrGVRuVA/VKt8oAyHAg8YRA_TjUHXT9kDLRGDdeyIU8VUo6S531s'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBMXG9ULnn7O9ZGzyRJ8YQ/LLRiS07hXwlA15p9uITh1izJlX-ecJ6cLOJwSxUYEm4zQoyqMWP7EeD0u1_JqNIRyQFK0VPwSBuSBa4K-gUPww/JU0FYbj-jbrCtjdW2yTJEs49txgEJk-Y4mb1CpWSciY'), ('width', 722), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/noX0X7QTOyKrygiyfdKu3w/5NiuoYeqsTEUDJBa1HD3aha3mbZpcg29kRU4pt3QrN-3ea8yVOIDpRUFYoKwdIZMOK5bmYr2PkNxoGRH-rWWpg/MtT8K9v5M4yE47V0TVtBgTTISdiSI1Pu1LtqLNnqxEY'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,The Tektronix TDS224 is a portable four-channel digital scope with 1 GS/s sampling rate and 100 MHz bandwidth.,https://w140.com/tekwiki/wiki/TDS224,Tektds 224,552.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds224.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds224-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782513/Instruments/Oscilloscopes/TDS224/TDS224.jpg,TDS224,Write a Python script that uses Instrumentkit to connect to a TDS224 Oscilloscopes,650.0,,True,price from the following: https://bmisurplus.com/product/tektronix-tds-224-100-mhz-4-channel-oscilloscope/,"#!/usr/bin/env python
""""""
Provides support for the Tektronix TDS 224 oscilloscope
""""""

# IMPORTS #####################################################################

import time

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.util_fns import ProxyList
from instruments.units import ureg as u


# CLASSES #####################################################################


class TekTDS224(SCPIInstrument, Oscilloscope):
    """"""
    The Tektronix TDS224 is a multi-channel oscilloscope with analog
    bandwidths of 100MHz.

    This class inherits from `~instruments.generic_scpi.SCPIInstrument`.

    Example usage:

    >>> import instruments as ik
    >>> tek = ik.tektronix.TekTDS224.open_gpibusb(""/dev/ttyUSB0"", 1)
    >>> [x, y] = tek.channel[0].read_waveform()
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._file.timeout = 3 * u.second

    class DataSource(Oscilloscope.DataSource):
        """"""
        Class representing a data source (channel, math, or ref) on the Tektronix
        TDS 224.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS224` class.
        """"""

        def __init__(self, tek, name):
            super().__init__(tek, name)
            self._tek = self._parent

        @property
        def name(self):
            """"""
            Gets the name of this data source, as identified over SCPI.

            :type: `str`
            """"""
            return self._name

        def read_waveform(self, bin_format=True):
            """"""
            Read waveform from the oscilloscope.
            This function is all inclusive. After reading the data from the
            oscilloscope, it unpacks the data and scales it accordingly.

            Supports both ASCII and binary waveform transfer. For 2500 data
            points, with a width of 2 bytes, transfer takes approx 2 seconds for
            binary, and 7 seconds for ASCII over Galvant Industries' GPIBUSB
            adapter.

            Function returns a tuple (x,y), where both x and y are numpy arrays.

            :param bool bin_format: If `True`, data is transfered
                in a binary format. Otherwise, data is transferred in ASCII.

            :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]
            """"""
            with self:
                if not bin_format:
                    self._tek.sendcmd(""DAT:ENC ASCI"")
                    # Set the data encoding format to ASCII
                    raw = self._tek.query(""CURVE?"")
                    raw = raw.split("","")  # Break up comma delimited string
                    if numpy:
                        raw = numpy.array(raw, dtype=float)  # Convert to ndarray
                    else:
                        raw = tuple(map(float, raw))
                else:
                    self._tek.sendcmd(""DAT:ENC RIB"")
                    # Set encoding to signed, big-endian
                    data_width = self._tek.data_width
                    self._tek.sendcmd(""CURVE?"")
                    raw = self._tek.binblockread(
                        data_width
                    )  # Read in the binary block,
                    # data width of 2 bytes

                    # pylint: disable=protected-access
                    self._tek._file.flush_input()  # Flush input buffer

                yoffs = self._tek.query(f""WFMP:{self.name}:YOF?"")  # Retrieve Y offset
                ymult = self._tek.query(f""WFMP:{self.name}:YMU?"")  # Retrieve Y multiply
                yzero = self._tek.query(f""WFMP:{self.name}:YZE?"")  # Retrieve Y zero

                xzero = self._tek.query(""WFMP:XZE?"")  # Retrieve X zero
                xincr = self._tek.query(""WFMP:XIN?"")  # Retrieve X incr
                ptcnt = self._tek.query(
                    f""WFMP:{self.name}:NR_P?""
                )  # Retrieve number of data points

                if numpy:
                    x = numpy.arange(float(ptcnt)) * float(xincr) + float(xzero)
                    y = ((raw - float(yoffs)) * float(ymult)) + float(yzero)
                else:
                    x = tuple(
                        float(val) * float(xincr) + float(xzero)
                        for val in range(int(ptcnt))
                    )
                    y = tuple(
                        ((x - float(yoffs)) * float(ymult)) + float(yzero) for x in raw
                    )

                return x, y

    class Channel(DataSource, Oscilloscope.Channel):
        """"""
        Class representing a channel on the Tektronix TDS 224.

        This class inherits from `TekTDS224.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS224` class.
        """"""

        def __init__(self, parent, idx):
            super().__init__(parent, f""CH{idx + 1}"")
            self._idx = idx + 1

        @property
        def coupling(self):
            """"""
            Gets/sets the coupling setting for this channel.

            :type: `TekTDS224.Coupling`
            """"""
            return TekTDS224.Coupling(self._tek.query(f""CH{self._idx}:COUPL?""))

        @coupling.setter
        def coupling(self, newval):
            if not isinstance(newval, TekTDS224.Coupling):
                raise TypeError(
                    f""Coupling setting must be a `TekTDS224.Coupling` value,""
                    f""got {type(newval)} instead.""
                )
            self._tek.sendcmd(f""CH{self._idx}:COUPL {newval.value}"")

    # ENUMS #

    class Coupling(Enum):
        """"""
        Enum containing valid coupling modes for the Tek TDS224
        """"""

        ac = ""AC""
        dc = ""DC""
        ground = ""GND""

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets a specific oscilloscope channel object. The desired channel is
        specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> import instruments as ik
        >>> tek = ik.tektronix.TekTDS224.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.channel[0].read_waveform()

        :rtype: `TekTDS224.Channel`
        """"""
        return ProxyList(self, self.Channel, range(4))

    @property
    def ref(self):
        """"""
        Gets a specific oscilloscope reference channel object. The desired
        channel is specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> import instruments as ik
        >>> tek = ik.tektronix.TekTDS224.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.ref[0].read_waveform()

        :rtype: `TekTDS224.DataSource`
        """"""
        return ProxyList(
            self, lambda s, idx: self.DataSource(s, f""REF{idx + 1}""), range(4)
        )

    @property
    def math(self):
        """"""
        Gets a data source object corresponding to the MATH channel.

        :rtype: `TekTDS224.DataSource`
        """"""
        return self.DataSource(self, ""MATH"")

    @property
    def data_source(self):
        """"""
        Gets/sets the the data source for waveform transfer.
        """"""
        name = self.query(""DAT:SOU?"")
        if name.startswith(""CH""):
            return self.Channel(self, int(name[2:]) - 1)

        return self.DataSource(self, name)

    @data_source.setter
    def data_source(self, newval):
        # TODO: clean up type-checking here.
        if not isinstance(newval, str):
            if hasattr(newval, ""value""):  # Is an enum with a value.
                newval = newval.value
            elif hasattr(newval, ""name""):  # Is a datasource with a name.
                newval = newval.name
        self.sendcmd(f""DAT:SOU {newval}"")
        time.sleep(0.01)  # Let the instrument catch up.

    @property
    def data_width(self):
        """"""
        Gets/sets the byte-width of the data points being returned by the
        instrument. Valid widths are ``1`` or ``2``.

        :type: `int`
        """"""
        return int(self.query(""DATA:WIDTH?""))

    @data_width.setter
    def data_width(self, newval):
        if int(newval) not in [1, 2]:
            raise ValueError(""Only one or two byte-width is supported."")

        self.sendcmd(f""DATA:WIDTH {newval}"")

    def force_trigger(self):
        raise NotImplementedError
"
126,https://www.newport.com/mam/celum/celum_assets/np/resources/Agilis_Piezo_Motor_Driven_Components_User_Manual.pdf?1,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attwW1zLjGpXPjApa'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/p9bEn3Selo3nJ8p68WTVEg/1E3wcA79DhlwgnZPMgkYJN96YngKZ6jQR9Eq4Mvs15cDhVN8NCDSaf5jg2SSDZ56rFmxBm1-5cGARoBUA0z53piXKb7PNufsCBsntTW4lrw/wlfko7G3u6xcTKJ51RGVrXPI7XpvoO2xDTDwfEjDXR4'), ('filename', 'AG-UC8_400w (1).jpg'), ('size', 15942), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/orBtzUmGsVi6R1OqLLvR7w/o9iVmt4xNU4DJXuVRiJ130DulxlwmMPzkVwvjNlaivMhh6hAyZM__8WUVjilT_SLzsTFrrauQMpbugSLDD0Wjw/SD-_qXSV7PKSQsGDrgMOugD04VF4nNNv4H2byh7ANFI'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VdIw2DF7HGsZz6OMlHOJtA/lw9FdYab0xUTp7H8Rcjl_YccnW8dnATUjNHhLnMDZVpWViUdOnEeBTkVIWirp1XkL2nPe43DpTcsb9AA63CTWg/AnrLkYmmr4DEt_jL5YELSksauZws2xLI77lUm3VS5L0'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IlOj_vtj8tdA1IDCwphFOQ/FaHkBH8b0hR4ilSptwzi-i-75p9z-WWqMHPdBL_qD9e0QY8o09xbUCrOTFqYV4qRwm1-F95HeHTnctYqbeRLCg/Bg3hyu1_ENuAJ71eJZyNuuy6INsBtFT0Vl9FwOtvWUo'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,Agilis™ Piezo Motion Controllers provide convenient and compact fine positioning control of the Agilis family of piezo motion stages and mounts.,https://www.newport.com/f/agilis-piezo-motion-controllers,Agilis,390.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/agilis.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#agilis-piezo-motor-controller,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782528/Instruments/Positional%20Controller/Agilis/Agilis.jpg,Agilis,Write a Python script that uses Instrumentkit to connect to a Agilis Positional Controller,1022.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""
"
137,https://cdn.teledynelecroy.com/files/pdf/hdo6000b-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attj3CSnSBkmM2yoT'), ('width', 800), ('height', 552), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YuIsp8lleL-BRIakn6qNwA/RtQy5_TVJvouvaYUA_WZpmSAqiH8Vtx4Z2nAmgTaQJgcIBLLEcibGWCwx2GUEWo0N4eT9PBymdRnqDB2dH41pu2-jU0oB7QS3HyBy63u1N0/lCjQD_j0b8ZuYX2xl-BowjGYiRASgTCykys9FCek9K0'), ('filename', 'hdo6000b09.webp'), ('size', 69476), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/gsmulRHx04epIaO_iQnvLQ/YP4A3-jNdcv4j_-u6s1OzUKPo5Ai9khlEreRjdZdp7j9BzRkVgnuv03iXEdpLolSWwUxDGdhx3iYdWnSahiXH115PEu6EubA3B7Hymn9hHs/qK9V2FdvdqoWWP3spOfP5x99X4je8eOlTKblVrMujbQ'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mWB4sarupVBqvcQRGvWMYg/nBhTkMQZA4I5UYm-i2THcPgrzw4tUdofSbR9-H8G7LaAE9NvxWtAsPoxEDjUl_lj1wRrB921QgkktV3uagl2FqW1-ShGWxotYpdTDAh_bJM/LTBwVoAMFHA7srmdul3Ueu4wLZGXlEz2DGbDhQ0sFPM'), ('width', 742), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tLf1whBIEuM2WUTYZ6h7uA/Vz71C3899qRAIsXCfi3ZsR7yUeVOPtoE437Eolyu23WEPBHQb3J1RPfqbJ2ooP2Y3CXf52Xq9gEbK4ONtvVG0J4wUtqY5c0rfvOUFJAxMOA/kJ-HLMdds9hk-exm3buWmVpHX8FyE_SCrqOnhxeIyM0'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"Providing 12 bits all the time, a bigger display, smaller footprint, and more capability, the HDO6000B captures every detail.",https://www.teledynelecroy.com/oscilloscope/hdo6000b-high-definition-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782540/Instruments/Oscilloscopes/HDO6000B/HDO6000B.webp,HDO6000B,Write a Python script that uses Instrumentkit to connect to a HDO6000B Oscilloscopes,16990.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
139,https://cdn.teledynelecroy.com/files/pdf/waverunner-8000hd-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att2AevkrfFPeXyJ8'), ('width', 648), ('height', 475), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kYxAV4NLbQHm80mXtIIRog/XU3AnYnk69uEtzrkbxvuT7-wXbxqi0qPRF0n9hU922g1-QNtSADlGz0bNVglfpJN3tGv7MmmNHh3OjdYC1cVcLcet4wC6rIcvB7W7RTlRfQ/QwjQ-5jqbu1-hc737jOD6cplhnkDB_Ey9xbuXur6fU0'), ('filename', 'wr8000-1.webp'), ('size', 62720), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WijtAiniiVT292q-dfq97g/l31MDoyjp7YkrkGMECBYT-iFgahfMRiAWise1XlXBvlSpr_UiH6xZ2ifZeXBx623alNw90qMskGKZMri7isw6XoLwa2QnEASxKulD7k5pPY/a0K2Ch7xvMWdZCgXXYbhAz7xRuf2adqRIL23gHORGS4'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5QsAyO_p8WCTunxG0l-LwA/WbmpYws2VW3tEXVIxKA2CupK3hMZkGbzibxx_bwQf-qXbHegRbkGXaeSoOODemRSESSLL3xjlr5dzFBa9pzQY4w2AHd9QyCq7EOsaqlF62g/MNzNhHDm7Qm51UmTKZMM_Yf0ged2WuW0I7JGgQFKOpE'), ('width', 648), ('height', 475)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6fmE7OG9Dl_DIra1SDMf2Q/cDjTZujml8qN9vGCFlC-Qh2yevyHjtB86k5kyUn0ymbDDGNSB4z_WnRU1ISMqqOZ9fGrnnZNNW4aBK8eX72ygtkXmxG8PtpmmCJFRgtPdAA/t9JdA4Rea3UrAqGc2xhlti8gQ9vTRC400EYaHgpjgvo'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"Providing 12 bits all the time, more channels than any other oscilloscope, and long memory without tradeoffs – the WaveRunner 8000HD 8 channel oscilloscope captures every detail.",https://www.teledynelecroy.com/oscilloscope/waverunner-8000hd-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782542/Instruments/Oscilloscopes/WaveRunner-8000HD/WaveRunner-8000HD.webp,WaveRunner 8000HD,Write a Python script that uses Instrumentkit to connect to a WaveRunner 8000HD Oscilloscopes,28625.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
151,https://www.instrumex.de/datasheet/TDS510A.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attxkUJsDPlUzetik'), ('width', 944), ('height', 708), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CYU4JTlj_RF95kfefXWRKA/mdtE3Yi63GVh-A8khg_YAYt4kBbsQcifJ0sOZ4VFm4imW12M__IuAUs_ZScNqtMhCxj9R5kuL9lYjkNKBBjWJCOB0hEjL6i9T6Qo_siKOoM/kZNSHs94YhZUy0VZRHZ_uq5ogOGKKa_d0eWfB7CBCxA'), ('filename', 'TDS510A.jpeg.webp'), ('size', 31982), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ltWNdMzAu2xhR6aWVhNXqA/7Fh5Yy5GPkw8SFjifvb9nvaZEbfisFgmLzg6rtGxjxwiInd6CsAQwYQ4Dn2uvrsHsZGIm2Tc8HvR9IzKwBz0Ylptn3bxgPKvtnZMTXtcQJo/w0T9etfX9nYSJX6mnNBoN4-M9NgPle7m4UVp_0bm0cU'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2zpaw2jwE0GSn1LmszaqBg/aCTZ6KoSs9NgGpq-Mw_5j7msdb3uTRwe-t5Pfzsa1JdhmS5Kl3fV6MNpiPdCBl1QOuIrA5CBDyRd3IFZG3uBk7zhosQKf2QLA7ymw7bbVvM/8MbqoU3Xt-RQ90Jyw0IFj_jBLGq3hQIoltsy05gKAjs'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_2QxB8AwXpVcb7KOdnPgsw/WSHa4mkLkK7iy2ot7e9GQbjY5JUA-WfCMzJGsi7sT72Rulf73x2Dm3WWGuseK_tu4rj5EgLXLIG7R7lyrwAVP6iyq-L9-hM3Z34uP8pojUQ/gr125-CUiBiCbmX3gYHW8uN1JaHkDATpp15eqRgmvJE'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The TDS510A Digital Oscilloscope is a full-featured, cost-effective, versatile oscilloscope which meets the measurement requirements for general-purpose research and design. Its industry-preferred graphical user interface makes it easy to learn and efficient to use. The TDS510A advanced trigger capability allows the user to trigger and view signals in a wide variety of simple as well as complex design and analysis settings. With four channels, 50 K points per channel record length, and powerful waveform acquisition modes, the TDS510A can satisfy most complex design, debug, and analysis requirements.",https://www.tek.com/en/datasheet/tds510a,Tektds 5 XX,551.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782554/Instruments/Oscilloscopes/TDS510A/TDS510A.webp,TDS510A,Write a Python script that uses Instrumentkit to connect to a TDS510A Oscilloscopes,1030.0,,True,,"#!/usr/bin/env python
#
# tektds5xx.py: Driver for the Tektronix TDS 5xx series oscilloscope.
#
# © 2014 Chris Schimp (silverchris@gmail.com)
#
# Modified from tektds224.py
# © 2013 Steven Casagrande (scasagrande@galvant.ca).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Provides support for the Tektronix DPO 500 oscilloscope series.

Originally contributed by Chris Schimp (silverchris@gmail.com) in 2014.
Based off of tektds224.py written by Steven Casagrande.
""""""

# IMPORTS #####################################################################

from datetime import datetime
from enum import Enum
from functools import reduce
import operator
import struct
import time


from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TekTDS5xx(SCPIInstrument, Oscilloscope):

    """"""
    Support for the TDS5xx series of oscilloscopes
     Implemented from:
      | TDS Family Digitizing Oscilloscopes
      | (TDS 410A, 420A, 460A, 520A, 524A, 540A, 544A,
      | 620A, 640A, 644A, 684A, 744A & 784A)
      | Tektronix Document: 070-8709-07
    """"""

    class Measurement:

        """"""
        Class representing a measurement channel on the Tektronix TDS5xx
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            self._id = idx + 1
            resp = self._tek.query(f""MEASU:MEAS{self._id}?"")
            self._data = dict(
                zip(
                    [
                        ""enabled"",
                        ""type"",
                        ""units"",
                        ""src1"",
                        ""src2"",
                        ""edge1"",
                        ""edge2"",
                        ""dir"",
                    ],
                    resp.split("";""),
                )
            )

        def read(self):
            """"""
            Gets the current measurement value of the channel, and returns a dict
            of all relevant information

            :rtype: `dict` of measurement parameters
            """"""
            if int(self._data[""enabled""]):
                resp = self._tek.query(f""MEASU:MEAS{self._id}:VAL?"")
                self._data[""value""] = float(resp)
                return self._data

            return self._data

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, or ref) on the Tektronix
        TDS 5xx.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        @property
        def name(self):
            """"""
            Gets the name of this data source, as identified over SCPI.

            :type: `str`
            """"""
            return self._name

        def read_waveform(self, bin_format=True):
            """"""
            Read waveform from the oscilloscope.
            This function is all inclusive. After reading the data from the
            oscilloscope, it unpacks the data and scales it accordingly.

            Supports both ASCII and binary waveform transfer. For 2500 data
            points, with a width of 2 bytes, transfer takes approx 2 seconds for
            binary, and 7 seconds for ASCII over Galvant Industries' GPIBUSB
            adapter.

            Function returns a tuple (x,y), where both x and y are numpy arrays.

            :param bool bin_format: If `True`, data is transfered
                in a binary format. Otherwise, data is transferred in ASCII.

            :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]
            """"""
            with self:
                if not bin_format:
                    # Set the data encoding format to ASCII
                    self._parent.sendcmd(""DAT:ENC ASCI"")
                    raw = self._parent.query(""CURVE?"")
                    raw = raw.split("","")  # Break up comma delimited string
                    if numpy:
                        raw = numpy.array(raw, dtype=float)  # Convert to numpy array
                    else:
                        raw = map(float, raw)
                else:
                    # Set encoding to signed, big-endian
                    self._parent.sendcmd(""DAT:ENC RIB"")
                    data_width = self._parent.data_width
                    self._parent.sendcmd(""CURVE?"")
                    # Read in the binary block, data width of 2 bytes
                    raw = self._parent.binblockread(data_width)

                    # pylint: disable=protected-access
                    # read line separation character
                    self._parent._file.read_raw(1)

                # Retrieve Y offset
                yoffs = float(self._parent.query(f""WFMP:{self.name}:YOF?""))
                # Retrieve Y multiply
                ymult = float(self._parent.query(f""WFMP:{self.name}:YMU?""))
                # Retrieve Y zero
                yzero = float(self._parent.query(f""WFMP:{self.name}:YZE?""))

                # Retrieve X incr
                xincr = float(self._parent.query(f""WFMP:{self.name}:XIN?""))
                # Retrieve number of data points
                ptcnt = int(self._parent.query(f""WFMP:{self.name}:NR_P?""))

                if numpy:
                    x = numpy.arange(float(ptcnt)) * float(xincr)
                    y = ((raw - yoffs) * float(ymult)) + float(yzero)
                else:
                    x = tuple(float(val) * float(xincr) for val in range(ptcnt))
                    y = tuple(((x - yoffs) * float(ymult)) + float(yzero) for x in raw)

                return x, y

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on the Tektronix TDS 5xx.

        This class inherits from `TekTDS5xx.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        def __init__(self, parent, idx):
            super().__init__(parent, f""CH{idx + 1}"")
            self._idx = idx + 1

        @property
        def coupling(self):
            """"""
            Gets/sets the coupling setting for this channel.

            :type: `TekTDS5xx.Coupling`
            """"""
            return TekTDS5xx.Coupling(self._parent.query(f""CH{self._idx}:COUPL?""))

        @coupling.setter
        def coupling(self, newval):
            if not isinstance(newval, TekTDS5xx.Coupling):
                raise TypeError(
                    ""Coupling setting must be a `TekTDS5xx.Coupling`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:COUPL {newval.value}"")

        @property
        def bandwidth(self):
            """"""
            Gets/sets the Bandwidth setting for this channel.

            :type: `TekTDS5xx.Bandwidth`
            """"""
            return TekTDS5xx.Bandwidth(self._parent.query(f""CH{self._idx}:BAND?""))

        @bandwidth.setter
        def bandwidth(self, newval):
            if not isinstance(newval, TekTDS5xx.Bandwidth):
                raise TypeError(
                    ""Bandwidth setting must be a `TekTDS5xx.Bandwidth`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:BAND {newval.value}"")

        @property
        def impedance(self):
            """"""
            Gets/sets the impedance setting for this channel.

            :type: `TekTDS5xx.Impedance`
            """"""
            return TekTDS5xx.Impedance(self._parent.query(f""CH{self._idx}:IMP?""))

        @impedance.setter
        def impedance(self, newval):
            if not isinstance(newval, TekTDS5xx.Impedance):
                raise TypeError(
                    ""Impedance setting must be a `TekTDS5xx.Impedance`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:IMP {newval.value}"")

        @property
        def probe(self):
            """"""
            Gets the connected probe value for this channel

            :type: `float`
            """"""
            return round(1 / float(self._parent.query(f""CH{self._idx}:PRO?"")), 0)

        @property
        def scale(self):
            """"""
            Gets/sets the scale setting for this channel.

            :type: `float`
            """"""
            return float(self._parent.query(f""CH{self._idx}:SCA?""))

        @scale.setter
        def scale(self, newval):
            self._parent.sendcmd(f""CH{self._idx}:SCA {newval:.3E}"")
            resp = float(self._parent.query(f""CH{self._idx}:SCA?""))
            if newval != resp:
                raise ValueError(
                    ""Tried to set CH{} Scale to {} but got {}""
                    "" instead"".format(self._idx, newval, resp)
                )

    # ENUMS ##

    class Coupling(Enum):

        """"""
        Available coupling options for input sources and trigger
        """"""

        ac = ""AC""
        dc = ""DC""
        ground = ""GND""

    class Bandwidth(Enum):

        """"""
        Bandwidth in MHz
        """"""

        Twenty = ""TWE""
        OneHundred = ""HUN""
        TwoHundred = ""TWO""
        FULL = ""FUL""

    class Impedance(Enum):

        """"""
        Available options for input source impedance
        """"""

        Fifty = ""FIF""
        OneMeg = ""MEG""

    class Edge(Enum):

        """"""
        Available Options for trigger slope
        """"""

        Rising = ""RIS""
        Falling = ""FALL""

    class Trigger(Enum):

        """"""
        Available Trigger sources
        (AUX not Available on TDS520A/TDS540A)
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        AUX = ""AUX""
        LINE = ""LINE""

    class Source(Enum):

        """"""
        Available Data sources
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        Math1 = ""MATH1""
        Math2 = ""MATH2""
        Math3 = ""MATH3""
        Ref1 = ""REF1""
        Ref2 = ""REF2""
        Ref3 = ""REF3""
        Ref4 = ""REF4""

    # PROPERTIES ##
    @property
    def measurement(self):
        """"""
        Gets a specific oscilloscope measurement object. The desired channel is
        specified like one would access a list.

        :rtype: `TekTDS5xx.Measurement`
        """"""
        return ProxyList(self, self.Measurement, range(3))

    @property
    def channel(self):
        """"""
        Gets a specific oscilloscope channel object. The desired channel is
        specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.channel[0].read_waveform()

        :rtype: `TekTDS5xx.Channel`
        """"""
        return ProxyList(self, self.Channel, range(4))

    @property
    def ref(self):
        """"""
        Gets a specific oscilloscope reference channel object. The desired
        channel is specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.ref[0].read_waveform()

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""REF{idx + 1}""),
            range(4),
        )

    @property
    def math(self):
        """"""
        Gets a data source object corresponding to the MATH channel.

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""MATH{idx + 1}""),
            range(3),
        )

    @property
    def sources(self):
        """"""
        Returns list of all active sources

        :rtype: `list`
        """"""
        active = []
        channels = list(map(int, self.query(""SEL?"").split("";"")[0:11]))
        for idx in range(0, 4):
            if channels[idx]:
                active.append(self.Channel(self, idx))
        for idx in range(4, 7):
            if channels[idx]:
                active.append(self.DataSource(self, f""MATH{idx - 3}""))
        for idx in range(7, 11):
            if channels[idx]:
                active.append(self.DataSource(self, f""REF{idx - 6}""))
        return active

    @property
    def data_source(self):
        """"""
        Gets/sets the the data source for waveform transfer.

        :type: `TekTDS5xx.Source` or `TekTDS5xx.DataSource`
        :rtype: `TekTDS5xx.DataSource`
        """"""
        name = self.query(""DAT:SOU?"")
        if name.startswith(""CH""):
            return self.Channel(self, int(name[2:]) - 1)

        return self.DataSource(self, name)

    @data_source.setter
    def data_source(self, newval):
        if isinstance(newval, self.DataSource):
            newval = TekTDS5xx.Source(newval.name)
        if not isinstance(newval, TekTDS5xx.Source):
            raise TypeError(
                ""Source setting must be a `TekTDS5xx.Source`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""DAT:SOU {newval.value}"")
        time.sleep(0.01)  # Let the instrument catch up.

    @property
    def data_width(self):
        """"""
        Gets/Sets the data width for waveform transfers

        :type: `int`
        """"""
        return int(self.query(""DATA:WIDTH?""))

    @data_width.setter
    def data_width(self, newval):
        if int(newval) not in [1, 2]:
            raise ValueError(""Only one or two byte-width is supported."")

        self.sendcmd(f""DATA:WIDTH {newval}"")

    def force_trigger(self):
        raise NotImplementedError

    @property
    def horizontal_scale(self):
        """"""
        Get/Set Horizontal Scale

        :type: `float`
        """"""
        return float(self.query(""HOR:MAI:SCA?""))

    @horizontal_scale.setter
    def horizontal_scale(self, newval):
        self.sendcmd(f""HOR:MAI:SCA {newval:.3E}"")
        resp = float(self.query(""HOR:MAI:SCA?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set Horizontal Scale to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_level(self):
        """"""
        Get/Set trigger level

        :type: `float`
        """"""
        return float(self.query(""TRIG:MAI:LEV?""))

    @trigger_level.setter
    def trigger_level(self, newval):
        self.sendcmd(f""TRIG:MAI:LEV {newval:.3E}"")
        resp = float(self.query(""TRIG:MAI:LEV?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set trigger level to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_coupling(self):
        """"""
        Get/Set trigger coupling

        :type: `TekTDS5xx.Coupling`
        """"""
        return TekTDS5xx.Coupling(self.query(""TRIG:MAI:EDGE:COUP?""))

    @trigger_coupling.setter
    def trigger_coupling(self, newval):
        if not isinstance(newval, TekTDS5xx.Coupling):
            raise TypeError(
                ""Coupling setting must be a `TekTDS5xx.Coupling`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:COUP {newval.value}"")

    @property
    def trigger_slope(self):
        """"""
        Get/Set trigger slope

        :type: `TekTDS5xx.Edge`
        """"""
        return TekTDS5xx.Edge(self.query(""TRIG:MAI:EDGE:SLO?""))

    @trigger_slope.setter
    def trigger_slope(self, newval):
        if not isinstance(newval, TekTDS5xx.Edge):
            raise TypeError(
                ""Edge setting must be a `TekTDS5xx.Edge`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SLO {newval.value}"")

    @property
    def trigger_source(self):
        """"""
        Get/Set trigger source

        :type: `TekTDS5xx.Trigger`
        """"""
        return TekTDS5xx.Trigger(self.query(""TRIG:MAI:EDGE:SOU?""))

    @trigger_source.setter
    def trigger_source(self, newval):
        if not isinstance(newval, TekTDS5xx.Trigger):
            raise TypeError(
                ""Trigger source setting must be a ""
                ""`TekTDS5xx.Trigger` value, got {} ""
                ""instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SOU {newval.value}"")

    @property
    def clock(self):
        """"""
        Get/Set oscilloscope clock

        :type: `datetime.datetime`
        """"""
        resp = self.query(""DATE?;:TIME?"")
        return datetime.strptime(resp, '""%Y-%m-%d"";""%H:%M:%S""')

    @clock.setter
    def clock(self, newval):
        if not isinstance(newval, datetime):
            raise ValueError(
                ""Expected datetime.datetime "" ""but got {} instead"".format(type(newval))
            )
        self.sendcmd(newval.strftime('DATE ""%Y-%m-%d"";:TIME ""%H:%M:%S""'))

    @property
    def display_clock(self):
        """"""
        Get/Set the visibility of clock on the display

        :type: `bool`
        """"""
        return bool(int(self.query(""DISPLAY:CLOCK?"")))

    @display_clock.setter
    def display_clock(self, newval):
        if not isinstance(newval, bool):
            raise ValueError(""Expected bool but got "" ""{} instead"".format(type(newval)))
        self.sendcmd(f""DISPLAY:CLOCK {int(newval)}"")

    def get_hardcopy(self):
        """"""
        Gets a screenshot of the display

        :rtype: `string`
        """"""
        self.sendcmd(""HARDC:PORT GPI;HARDC:LAY PORT;:HARDC:FORM BMP"")
        self.sendcmd(""HARDC START"")
        time.sleep(1)
        header = self._file.read_raw(size=54)
        # Get BMP Length  in kilobytes from DIB header, because file header is
        # bad
        length = reduce(operator.mul, struct.unpack(""<iihh"", header[18:30])) / 8
        length = int(length) + 8  # Add 8 bytes for our monochrome colour table
        data = header + self._file.read_raw(size=length)
        self._file.flush_input()  # Flush input buffer
        return data
"
159,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,https://en.wikipedia.org/wiki/Electricity_meter,"[OrderedDict([('id', 'attGUuYhDgUI2msSE'), ('width', 799), ('height', 416), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iQQt309D_rmjbZyyF4PUJw/cRTX4NUZXtxuw3C9geF73yXdRzbyJ9l1OVC2uT7zqu6CxgxTHlCrMiC9XFUqNIHTQGfKv4cy4ooifPa4GXVjr8o-TbEg_AiHmtY_6jHuNN4/ImXzWanq5Vq5D0eUdRW9Eiz6HGybyh5C4kX0U0Fiid0'), ('filename', 'Keithley_6220.jpg'), ('size', 79670), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AmmKhTa-VPSmoF2IgqCUEg/5j8gAM5n3mgAebRwc5Hxf1zyMjWjzFXlm5Mo2ExBQ_5_kpwuZErN8VOaXcoVnGKoG0l7i0x_dQ8O3ZkEKW6JvA/e6myEl4biwgz5CB25H-uvzvCHbQpF2zclLcRfN_s1E8'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ndQYZOc4FIDGJaGU_qO7PQ/olOTKMKK9AakWedqOvDjCnpb8FJUG8lTn489q0pnYZQkL11fbspqHk2SIJLeSF3Zo1kxfKavU1pcOB0lu3ba8A/ji1Y4J8o87zzpBLso_hd8iGwFKaD1PPNWy08N7aCpX8'), ('width', 799), ('height', 416)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ONCPivnGOw_VQenfDW-nbw/OHeC2k2O996NDIJCsF2PM9URXsm-C76by1teayH300AIeZXRylK94JSkDbyLXAZZKsRPh1krcsifyGYzwvhIXA/OehLX6TE6VfXGJNEFboTfTvgaxdE8G9N6dKSAI-CKDE'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High DC power supply sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://canada.newark.com/keithley/6220/source-meter-dc-current-11w/dp/43K0016,Keithley 6220,233.0,['Power Meters'],"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782562/Instruments/Power%20Meters/Keithley-6220/Keithley-6220.jpg,Keithley 6220,Write a Python script that uses Instrumentkit to connect to a Keithley 6220 Power Meters,8631.9,,,,"#!/usr/bin/env python
""""""
Provides support for the Keithley 6220 constant current supply
""""""

# IMPORTS #####################################################################


from instruments.units import ureg as u

from instruments.abstract_instruments import PowerSupply
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import bounded_unitful_property

# CLASSES #####################################################################


class Keithley6220(SCPIInstrument, PowerSupply):

    """"""
    The Keithley 6220 is a single channel constant current supply.

    Because this is a constant current supply, most features that a regular
    power supply have are not present on the 6220.

    Example usage:

    >>> import instruments.units as u
    >>> import instruments as ik
    >>> ccs = ik.keithley.Keithley6220.open_gpibusb(""/dev/ttyUSB0"", 10)
    >>> ccs.current = 10 * u.milliamp # Sets current to 10mA
    >>> ccs.disable() # Turns off the output and sets the current to 0A
    """"""

    # PROPERTIES ##

    @property
    def channel(self):
        """"""
        For most power supplies, this would return a channel specific object.
        However, the 6220 only has a single channel, so this function simply
        returns a tuple containing itself. This is for compatibility reasons
        if a multichannel supply is replaced with the single-channel 6220.

        For example, the following commands are the same and both set the
        current to 10mA:

        >>> ccs.channel[0].current = 0.01
        >>> ccs.current = 0.01
        """"""
        return (self,)

    @property
    def voltage(self):
        """"""
        This property is not supported by the Keithley 6220.
        """"""
        raise NotImplementedError(
            ""The Keithley 6220 does not support voltage "" ""settings.""
        )

    @voltage.setter
    def voltage(self, newval):
        raise NotImplementedError(
            ""The Keithley 6220 does not support voltage "" ""settings.""
        )

    current, current_min, current_max = bounded_unitful_property(
        ""SOUR:CURR"",
        u.amp,
        valid_range=(-105 * u.milliamp, +105 * u.milliamp),
        doc=""""""
        Gets/sets the output current of the source. Value must be between
        -105mA and +105mA.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    # METHODS #

    def disable(self):
        """"""
        Set the output current to zero and disable the output.
        """"""
        self.sendcmd(""SOUR:CLE:IMM"")
"
164,https://cdn.teledynelecroy.com/files/pdf/waveprohd-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att4IDQeQoh37ZEzt'), ('width', 940), ('height', 627), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qyGpwrjwqhvJv-wW9EWbfw/nOrV9DIOIl74OmBsOimrdPHCcRn_wOOmtkLft27VIeRJ2lr8jw8M8DyJrMGd6sfD2YI5qpGAxdCyZVQjlofrFBVGuMXfy0cZ00bee5EV7Ug/HpxJ3Kk0zkGe-3sFO97elPfRbw1EpyHLHcRFaoP9588'), ('filename', 'wphd-04.png'), ('size', 406177), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1i5uo8DpRZQqbjYZkYqQFg/5ypr_C45DbPH5L6agF_XX9CrEkpLQb0t70vfKM7Nt6gAzBDZq1EQPtI79uADBEEW1Vgg6gSBcuRFnqUvT1h_Bg/v4DZM5WWlUtHMQS2Nhw21gOb1Vr8IvnLGOR98s3cbv0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xlxGCrwAe7QqRogEK8C9gA/zJOPEe1N3MzpY-5B3M-tLMM77U2dPiz-xosX0gIG8vbe06_2UZ9OJMijQeuIRumwEQ64MhB_3GKR0gz0_0ht5w/7Rs7uU5s9fLw1tH84kGRHPcPTJrpXLkvtnafc10AuY0'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HHHajNBJXlnHai9AstgKQw/VZSqH03S_IQA4riZ1WoBpgplDhINdudMAdBPV-9Gkp0nQquiWmwumwqk3iYhV6YgHNZ6KcRpp7Nj6XNCmUx4Gg/KA-_KHVN9NjULuXbmI-WDRn2PIi48jT_KowKtq5o0ws'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"WavePro HD High-Definition oscilloscopes employ unique Teledyne LeCroy HD4096 technology to achieve 12-bit resolution at up to 8 GHz bandwidth, for the lowest noise and unmatched signal fidelity. Up to 5 Gpt of highly responsive acquisition memory gives more visibility into system behavior, and the exceptional analysis toolbox enables deep insight.",https://www.teledynelecroy.com/oscilloscope/wavepro-hd-oscilloscope,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782567/Instruments/Oscilloscopes/WavePro-HD/WavePro-HD.png,WavePro HD,Write a Python script that uses Instrumentkit to connect to a WavePro HD Oscilloscopes,31000.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
166,https://www.keysight.com/us/en/assets/7018-06785/data-sheets/5968-9726.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attSpS8B1W8Re8bpU'), ('width', 582), ('height', 431), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/500Jp60N5jo98ah1ulvURw/LLBCpzu9vzXGBu7mkvDt-y8X5NgP7wVe7uMeOIUosu5seDmkYixM_jqeLQr3HCnCHpZZ4qjxM2QKgFdTcvLU5DOBP4Ub37LSVJUDKLj8TJA/Aw447bp_kyyGuVfiJgoU4dxEzAvagoD9JOXFDC8W7Eg'), ('filename', 'E3631.png'), ('size', 222345), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CXfnzzDbJ3ZUPz2tmTENQQ/xy6ZsiBknVIMpzO9tmdeJJ048SbPfClHpnv7OjxQM9Hbdu3TgD2BZar9ETZx8CbvbuX8NTZZpWXByA4jnAq0jg/La5jcpiFmzX62D4eC6Tb735LvFZDBawORIUVopHtJgc'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/q-berzvnazpB8nucZnD0rA/1vG1rliInE1l3pSNe-gLIrVj8yEJg-6KlaBIUhLFuoqldbPJP5QeRLRueaALfQEkvUPkOdSa_YEQaA0YgxvQNg/gtckB3U5a8TKz1KtwHCjMSk3wGIBtOisJvB8R71Dueo'), ('width', 582), ('height', 431)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZZ3E7YUN8y1y1SwGZEsV6g/2LwDgiF0_GKFY1dKz8iHh9fZYmny9MrTlEsHAdzjquWBq8l_tieEushAVEX3q7Q8RUpGx8LNSHY3_9cvV7i2qw/pwU7TeMer7S9KOj6UA92DAdn9PW95TeEazmpAmoMXSk'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,"E3631A 80W Triple Output Power Supply, 6V, 5A & ±25V, 1A",https://www.keysight.com/us/en/product/E3631A/80w-triple-output-power-supply-6v-5a--25v-1a.html,HPE 3631 A,156.0,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hp/hpe3631a.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/hp.html#hpe3631a-power-supply,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782569/Instruments/Power%20Supplies/Keysight-E3631A/Keysight-E3631A.png,Keysight E3631A,Write a Python script that uses Instrumentkit to connect to a Keysight E3631A Power Supplies,2300.0,,,,"#!/usr/bin/env python
#
# hpe3631a.py: Driver for the HP E3631A Power Supply
#
# © 2019 Francois Drielsma (francois.drielsma@gmail.com).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the HP E3631A Power Supply

Originally contributed and copyright held by Francois Drielsma
(francois.drielsma@gmail.com)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

import time

from instruments.units import ureg as u

from instruments.abstract_instruments import PowerSupply
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import (
    int_property,
    unitful_property,
    bounded_unitful_property,
    bool_property,
    split_unit_str,
    assume_units,
)

# CLASSES #####################################################################


class HPe3631a(PowerSupply, PowerSupply.Channel, SCPIInstrument):

    """"""
    The HPe3631a is a three channels voltage/current supply.
    - Channel 1 is a positive +6V/5A channel (P6V)
    - Channel 2 is a positive +25V/1A channel (P25V)
    - Channel 3 is a negative -25V/1A channel (N25V)

    This module is designed for the power supply to be set to
    a specific channel and remain set afterwards as this device
    does not offer commands to set or read multiple channels
    without calling the channel set command each time (0.5s). It is
    possible to call a specific channel through psu.channel[idx],
    which will automatically reset the channel id, when necessary.

    This module is likely to work as is for the Agilent E3631 and
    Keysight E3631 which seem to be rebranded but identical devices.

    Example usage:

    >>> import instruments as ik
    >>> psu = ik.hp.HPe3631a.open_gpibusb(""/dev/ttyUSB0"", 10)
    >>> psu.channelid = 2           # Sets channel to P25V
    >>> psu.voltage = 12.5          # Sets voltage to 12.5V
    >>> psu.voltage                 # Reads back set voltage
    array(12.5) * V
    >>> psu.voltage_sense           # Reads back sensed voltage
    array(12.501) * V
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""SYST:REM"")  # Puts the device in remote operation
        time.sleep(0.1)

    # INNER CLASSES #

    class Channel:
        """"""
        Class representing a power output channel on the HPe3631a.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `HPe3631a` class.
        """"""

        def __init__(self, parent, valid_set):
            self._parent = parent
            self._valid_set = valid_set

        def __getitem__(self, idx):
            # Check that the channel is available. If it is, set the
            # channelid of the device and return the device object.
            if self._parent.channelid != idx:
                self._parent.channelid = idx
                time.sleep(0.5)
            return self._parent

        def __len__(self):
            return len(self._valid_set)

    # PROPERTIES ##

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        :rtype: `HPe3631a.Channel`

        .. seealso::
            `HPe3631a` for example using this property.
        """"""
        return self.Channel(self, [1, 2, 3])

    @property
    def mode(self):
        """"""
        Gets/sets the mode for the specified channel.

        The constant-voltage/constant-current modes of the power supply
        are selected automatically depending on the load (resistance)
        connected to the power supply. If the load greater than the set
        V/I is connected, a voltage V is applied and the current flowing
        is lower than I. If the load is smaller than V/I, the set current
        I acts as a current limiter and the voltage is lower than V.
        """"""
        raise AttributeError(""The `HPe3631a` sets its mode automatically"")

    channelid = int_property(
        ""INST:NSEL"",
        valid_set=[1, 2, 3],
        doc=""""""
        Gets/Sets the active channel ID.

        :type: `HPe3631a.ChannelType`
        """""",
    )

    @property
    def voltage(self):
        """"""
        Gets/sets the output voltage of the source.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        raw = self.query(""SOUR:VOLT?"")
        return u.Quantity(*split_unit_str(raw, u.volt)).to(u.volt)

    @voltage.setter
    def voltage(self, newval):
        """"""
        Gets/sets the output voltage of the source.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        min_value, max_value = self.voltage_range
        if newval < min_value:
            raise ValueError(
                ""Voltage quantity is too low. Got {}, minimum ""
                ""value is {}"".format(newval, min_value)
            )

        if newval > max_value:
            raise ValueError(
                ""Voltage quantity is too high. Got {}, maximum ""
                ""value is {}"".format(newval, max_value)
            )

        # Rescale to the correct unit before printing. This will also
        # catch bad units.
        strval = f""{assume_units(newval, u.volt).to(u.volt).magnitude:e}""
        self.sendcmd(f""SOUR:VOLT {strval}"")

    @property
    def voltage_min(self):
        """"""
        Gets the minimum voltage for the current channel.

        :units: :math:`\\text{V}`.
        :type: `~pint.Quantity`
        """"""
        return self.voltage_range[0]

    @property
    def voltage_max(self):
        """"""
        Gets the maximum voltage for the current channel.

        :units: :math:`\\text{V}`.
        :type: `~pint.Quantity`
        """"""
        return self.voltage_range[1]

    @property
    def voltage_range(self):
        """"""
        Gets the voltage range for the current channel.

        The MAX function SCPI command is designed in such a way
        on this device that it always returns the largest absolute value.
        There is no need to query MIN, as it is always 0., but one has to
        order the values as MAX can be negative.

        :units: :math:`\\text{V}`.
        :type: array of `~pint.Quantity`
        """"""
        value = u.Quantity(*split_unit_str(self.query(""SOUR:VOLT? MAX""), u.volt))
        if value < 0.0:
            return value, 0.0
        return 0.0, value

    current, current_min, current_max = bounded_unitful_property(
        ""SOUR:CURR"",
        u.amp,
        min_fmt_str=""{}? MIN"",
        max_fmt_str=""{}? MAX"",
        doc=""""""
        Gets/sets the output current of the source.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    voltage_sense = unitful_property(
        ""MEAS:VOLT"",
        u.volt,
        readonly=True,
        doc=""""""
        Gets the actual output voltage as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `~pint.Quantity`
        """""",
    )

    current_sense = unitful_property(
        ""MEAS:CURR"",
        u.amp,
        readonly=True,
        doc=""""""
        Gets the actual output current as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `~pint.Quantity`
        """""",
    )

    output = bool_property(
        ""OUTP"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""
        Gets/sets the outputting status of the specified channel.

        This is a toggle setting. ON will turn on the channel output
        while OFF will turn it off.

        :type: `bool`
        """""",
    )
"
169,"https://res.cloudinary.com/iwh/image/upload/q_auto,g_center/assets/1/26/wavesurfer510-ds-24mar17-prelim.pdf",https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attoBSvdaeYOq105z'), ('width', 1024), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lIdQ8qKwwHUhYiggLo4sUA/OU9CRPLnLRT1v_nm98aWs1EVr0LBf6MUIH7J2QTHsZCoPqQCu3hlYtMuv0MU7nkWKe6T_ezVuihODr_I4SsgC2WBBpJjirowfs4n4aEJdSUQbty84IGwJ7adXnIqndhB/LlmC4HkHBLEClZosGTvFzXCVwQW8m3fyCx99N6ayKTA'), ('filename', 'LeCroy_WaveSurfer-510_img2.jpg'), ('size', 73189), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y4wFf1ehBG2LQqFuOKfJNg/v0RTX2tr8Tj2L-T0YSMDcKNCtYjiYSWbL7VXNyUsXME_QFbvImOqZQ1j2jWbnvY6w_S9roJY6m6inEiSMrr9yw/vswv9Gzmti55cqf2ueKH4YMwMvdg9IEym1pCPBS4GXs'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hvLxazFFBywfQHtgBXKChA/P6LOC6jiafRGlkRIalIu2DK-b1GiL6svItbo4YaTX1b_FOUMF2ZQxiGWcwkNUE-xGpbODx8LYtShlKaScmZ99Q/9q1i6iodqihT4GQKDJWaItMR_j3BLfiqYZkkcI43sRc'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uk6d4A472HOTcvVlzPXrmA/NyAYfMgaOqLkwhS2yjJftmt2oAQoKzJ9H5NZwHHq0MwKVabiNnUA5rwCTCK2R36MDY8bfcQUfZN4fAIoLd7b4g/nOEozIKN9Zs2fvaBmL-Tu9T-Utt3lcbIMHQ7W_8DHkQ'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"The WaveSurfer 510 combines the MAUI with OneTouch user interface with powerful waveform processing, in addition to advanced math, measurement, and debug tools, to quickly analyze and find the root cause of problems. The 12.1” touch-screen display of the WaveSurfer 510 is the largest in its class and makes viewing waveform abnormalities fast and easy.",https://www.tequipment.net/LeCroy/WaveSurfer-510/Digital-Oscilloscopes/,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782572/Instruments/Oscilloscopes/WaveSurfer-510/WaveSurfer-510.jpg,WaveSurfer 510,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 510 Oscilloscopes,13553.0,,True,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
171,https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=14074,"[OrderedDict([('id', 'attHPq5FREiy9RqsJ'), ('width', 1200), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nCp7bKBOklpZNJE8MQScMA/N6rye6xm4Bes98tywWqZQfsQEgCqSSVt9TlmugYIz0RzFrm-Oe0mElDHl5Pqdl2QSOo54ZuoTyYPgd7QpFR7zWqT12bOQ2iDaAeF4y1Q59Q/VMgtXc7eASLbslNte_-f8lRto1bhjlL0wrzzLDjFy_g'), ('filename', 'LCC25.jpg'), ('size', 110410), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qp1RQkam15RJFn7IlqPOPw/StIjVMgy1zzeNyXJTLPq5aV1pDxXc6cg8Ri4C8Pcp8ChjEGxWczAbDs3Lk1yid9czNcRU-n6Z090cWP3kTw0vw/1H7WAtzN1IRIQ4ImyFaVtgGT4hT07umO_B2Zj27VpgI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5fYTPkpMtragk9H3BT-ojA/etOLXcUkGOgXicxtRdLzFBd7z8KxHdMYgrf6_7-CxIOHPf7LUlNtHv0yRqpVWm7BK-7Skv68iBR2tIOHPA55jA/AhCrKWBwrDQjOT0YmMm8jNZl2TKxbT6HDFE9ac9FoZ4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DW8GuvNukU9zwBYuMmClfQ/l4kYUo1TZOWK_yNFgaZ61pwF7Jf7wMHdqvsSwpc2lGe2KAo9rXbxKNMAYVjIPbQ0UzQlxaokR1qLTUMCxh9IWQ/LfPYJREjPGjHh_wcKzS6Kny19jqhoFoQneiqbCKlRtg'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The LCC25 is a liquid crystal controller compatible with all Thorlabs LC Variable
Retarders. The LCC25 will drive most nematic liquid crystal devices. The liquid crystal
device is connected to the BNC voltage output port. The amplitude of the output voltage,
adjusted by the front panel knob, and external signal, and a computer via a USB interface,
controls the retardance of the LC device.",https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,LCC 25,607.0,['Power Supplies'],"A part of Thorlabs' growing line of high-end, compact controllers and is designed to drive many of Thorlabs' liquid crystal variable retarders, polarization rotators, and cells","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/lcc25.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#lcc25-liquid-crystal-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782574/Instruments/Power%20Supplies/LCC25/LCC25.jpg,LCC25,Write a Python script that uses Instrumentkit to connect to a LCC25 Power Supplies,1512.85,,,,"#!/usr/bin/python
""""""
Provides the support for the Thorlabs LCC25 liquid crystal controller.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.thorlabs.thorlabs_utils import check_cmd

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import enum_property, bool_property, unitful_property

# CLASSES #####################################################################


class LCC25(Instrument):

    """"""
    The LCC25 is a controller for the thorlabs liquid crystal modules.
    it can set two voltages and then oscillate between them at a specific
    repetition rate.

    The user manual can be found here:
    http://www.thorlabs.com/thorcat/18800/LCC25-Manual.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.prompt = ""> ""

    def _ack_expected(self, msg=""""):
        return msg

    # ENUMS #

    class Mode(IntEnum):

        """"""
        Enum containing valid output modes of the LCC25
        """"""

        normal = 0
        voltage1 = 1
        voltage2 = 2

    # PROPERTIES #

    @property
    def name(self):
        """"""
        Gets the name and version number of the device

        :rtype: `str`
        """"""
        return self.query(""*idn?"")

    frequency = unitful_property(
        ""freq"",
        u.Hz,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(5, 150),
        doc=""""""
        Gets/sets the frequency at which the LCC oscillates between the
        two voltages.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Hertz.
        :rtype: `~pint.Quantity`
        """""",
    )

    mode = enum_property(
        ""mode"",
        Mode,
        input_decoration=int,
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the output mode of the LCC25

        :rtype: `LCC25.Mode`
        """""",
    )

    enable = bool_property(
        ""enable"",
        inst_true=""1"",
        inst_false=""0"",
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the output enable status.

        If output enable is on (`True`), there is a voltage on the output.

        :rtype: `bool`
        """""",
    )

    extern = bool_property(
        ""extern"",
        inst_true=""1"",
        inst_false=""0"",
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the use of the external TTL modulation.

        Value is `True` for external TTL modulation and `False` for internal
        modulation.

        :rtype: `bool`
        """""",
    )

    remote = bool_property(
        ""remote"",
        inst_true=""1"",
        inst_false=""0"",
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets front panel lockout status for remote instrument operation.

        Value is `False` for normal operation and `True` to lock out the front
        panel buttons.

        :rtype: `bool`
        """""",
    )

    voltage1 = unitful_property(
        ""volt1"",
        u.V,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 25),
        doc=""""""
        Gets/sets the voltage value for output 1.

        :units: As specified (if a `~pint.Quantity`) or
            assumed to be of units Volts.
        :rtype: `~pint.Quantity`
        """""",
    )

    voltage2 = unitful_property(
        ""volt2"",
        u.V,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 25),
        doc=""""""
        Gets/sets the voltage value for output 2.

        :units: As specified (if a `~pint.Quantity`) or
            assumed to be of units Volts.
        :rtype: `~pint.Quantity`
        """""",
    )

    min_voltage = unitful_property(
        ""min"",
        u.V,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 25),
        doc=""""""
        Gets/sets the minimum voltage value for the test mode.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Volts.
        :rtype: `~pint.Quantity`
        """""",
    )

    max_voltage = unitful_property(
        ""max"",
        u.V,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 25),
        doc=""""""
        Gets/sets the maximum voltage value for the test mode. If the maximum
        voltage is less than the minimum voltage, nothing happens.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Volts.
        :rtype: `~pint.Quantity`
        """""",
    )

    dwell = unitful_property(
        ""dwell"",
        units=u.ms,
        format_code=""{:n}"",
        set_fmt=""{}={}"",
        valid_range=(0, None),
        doc=""""""
        Gets/sets the dwell time for voltages for the test mode.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units milliseconds.
        :rtype: `~pint.Quantity`
        """""",
    )

    increment = unitful_property(
        ""increment"",
        units=u.V,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0, None),
        doc=""""""
        Gets/sets the voltage increment for voltages for the test mode.

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units Volts.
        :rtype: `~pint.Quantity`
        """""",
    )

    # METHODS #

    def default(self):
        """"""
        Restores instrument to factory settings.

        Returns 1 if successful, 0 otherwise

        :rtype: `int`
        """"""
        response = self.query(""default"")
        return check_cmd(response)

    def save(self):
        """"""
        Stores the parameters in static memory

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""save"")
        return check_cmd(response)

    def set_settings(self, slot):
        """"""
        Saves the current settings to memory.

        Returns 1 if successful, zero otherwise.

        :param slot: Memory slot to use, valid range `[1,4]`
        :type slot: `int`
        :rtype: `int`
        """"""
        if slot not in range(1, 5):
            raise ValueError(""Cannot set memory out of `[1,4]` range"")
        response = self.query(f""set={slot}"")
        return check_cmd(response)

    def get_settings(self, slot):
        """"""
        Gets the current settings to memory.

        Returns 1 if successful, zero otherwise.

        :param slot: Memory slot to use, valid range `[1,4]`
        :type slot: `int`
        :rtype: `int`
        """"""
        if slot not in range(1, 5):
            raise ValueError(""Cannot set memory out of `[1,4]` range"")
        response = self.query(f""get={slot}"")
        return check_cmd(response)

    def test_mode(self):
        """"""
        Puts the LCC in test mode - meaning it will increment the output
        voltage from the minimum value to the maximum value, in increments,
        waiting for the dwell time

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""test"")
        return check_cmd(response)
"
172,,https://en.wikipedia.org/wiki/Motion_control,,5.0,"Vista, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125997/Instruments/Vendor%20Logos/Qubitekk.png,,,MC1,433.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/mc1.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#mc1-motor-controller,Qubitekk,"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ICeTYDCr0WQGoCNhnlqW9A/xWHniahKdTenvA9lCpqHem_Lv7-lnrQ1Yb6hidANH6zyMK1tuylXugb_keyksrHAicKHw65Ha5IXwmkTwmbOcqAWmG5_rqj8QQHeC9TxhmkOMK-RjPbmjcEejWAgNvNY/AAtLZ04IQ92tcE2cknKg36aBUNWf2jaO3twgAK8U_ek'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XmRul3lrntyXgK4pL2Nd2Q/Ro5AjtdlFYfeFuSGgauksuohj_nx7NvEyJKzf3SNWWNNFCiETYYDRkljznJoeTnWoIaxAZ5NRxUaJe8mF71rvQ/Y-CVWeWPJ1zKiGPCwPRvJduV7q0kg9nafWxPSyi89n8'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zQgrup5ODOnYB7NWnWnSng/DIzf_vAQ2O_E1g7kVT48u4cnPVWFMkqq6Bm3j8V6Jd0dS9uFxTOwRZERVFYUJr5RotjuPIZxz7IUnH8RBtoNnw/XSQaCxjsQvV609jyLsMS6T5DRyW0jIR9YJAnFAscIKQ'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/scghzrrRvnwV_s4Et9dEgA/IbHIKRXzptJVnf_y02jJDfS1ofbHQHmahnhHBOB7pX2JiYxIRYdZgymaEvewBOHzNFoEgCtdsO7qj5755Eb2hQ/jPeEtnV3Eb8-6uY_ldoq42OJ8PzeyrGgKB6IhaLUxiY'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/,,MC1,Write a Python script that uses Instrumentkit to connect to a MC1 Positional Controller,,,,,"#!/usr/bin/env python
""""""
Provides support for the Qubitekk MC1 Motor Controller.

MC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import (
    int_property,
    enum_property,
    unitful_property,
    assume_units,
)

# CLASSES #####################################################################


class MC1(Instrument):
    """"""
    The MC1 is a controller for the qubitekk motor controller. Used with a
    linear actuator to perform a HOM dip.
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self._increment = 1 * u.ms
        self._lower_limit = -300 * u.ms
        self._upper_limit = 300 * u.ms
        self._firmware = None
        self._controller = None

    # ENUMS #

    class MotorType(Enum):
        """"""
        Enum for the motor types for the MC1
        """"""

        radio = ""Radio""
        relay = ""Relay""

    # PROPERTIES #

    @property
    def increment(self):
        """"""
        Gets/sets the stepping increment value of the motor controller

        :units: As specified, or assumed to be of units milliseconds
        :type: `~pint.Quantity`
        """"""
        return self._increment

    @increment.setter
    def increment(self, newval):
        self._increment = assume_units(newval, u.ms).to(u.ms)

    @property
    def lower_limit(self):
        """"""
        Gets/sets the stepping lower limit value of the motor controller

        :units: As specified, or assumed to be of units milliseconds
        :type: `~pint.Quantity`
        """"""
        return self._lower_limit

    @lower_limit.setter
    def lower_limit(self, newval):
        self._lower_limit = assume_units(newval, u.ms).to(u.ms)

    @property
    def upper_limit(self):
        """"""
        Gets/sets the stepping upper limit value of the motor controller

        :units: As specified, or assumed to be of units milliseconds
        :type: `~pint.Quantity`
        """"""
        return self._upper_limit

    @upper_limit.setter
    def upper_limit(self, newval):
        self._upper_limit = assume_units(newval, u.ms).to(u.ms)

    direction = unitful_property(
        command=""DIRE"",
        doc=""""""
        Get the internal direction variable, which is a function of how far
        the motor needs to go.

        :type: `~pint.Quantity`
        :units: milliseconds
        """""",
        units=u.ms,
        readonly=True,
    )

    inertia = unitful_property(
        command=""INER"",
        doc=""""""
        Gets/Sets the amount of force required to overcome static inertia. Must
         be between 0 and 100 milliseconds.

        :type: `~pint.Quantity`
        :units: milliseconds
        """""",
        format_code=""{:.0f}"",
        units=u.ms,
        valid_range=(0 * u.ms, 100 * u.ms),
        set_fmt="":{} {}"",
    )

    @property
    def internal_position(self):
        """"""
        Get the internal motor state position, which is equivalent to the total
         number of milliseconds that voltage has been applied to the motor in
         the positive direction minus the number of milliseconds that voltage
         has been applied to the motor in the negative direction.

        :type: `~pint.Quantity`
        :units: milliseconds
        """"""
        response = int(self.query(""POSI?"")) * self.step_size
        return response

    metric_position = unitful_property(
        command=""METR"",
        doc=""""""
        Get the estimated motor position, in millimeters.

        :type: `~pint.Quantity`
        :units: millimeters
        """""",
        units=u.mm,
        readonly=True,
    )

    setting = int_property(
        command=""OUTP"",
        doc=""""""
        Gets/sets the output port of the optical switch. 0 means input 1 is
        directed to output 1, and input 2 is directed to output 2. 1 means that
         input 1 is directed to output 2 and input 2 is directed to output 1.

        :type: `int`
        """""",
        valid_set=range(2),
        set_fmt="":{} {}"",
    )

    step_size = unitful_property(
        command=""STEP"",
        doc=""""""
        Gets/Sets the number of milliseconds per step. Must be between 1
        and 100 milliseconds.

        :type: `~pint.Quantity`
        :units: milliseconds
        """""",
        format_code=""{:.0f}"",
        units=u.ms,
        valid_range=(1 * u.ms, 100 * u.ms),
        set_fmt="":{} {}"",
    )

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                value = self._firmware.split(""."")
                if len(value) < 3:
                    for _ in range(3 - len(value)):
                        value.append(0)
                value = tuple(map(int, value))
                self._firmware = value
        return self._firmware

    controller = enum_property(
        ""MOTO"",
        MotorType,
        doc=""""""
        Get the motor controller type.
        """""",
        readonly=True,
    )

    @property
    def move_timeout(self):
        """"""
        Get the motor's timeout value, which indicates the number of
        milliseconds before the motor can start moving again.

        :type: `~pint.Quantity`
        :units: milliseconds
        """"""
        response = int(self.query(""TIME?""))
        return response * self.step_size

    # METHODS #

    def is_centering(self):
        """"""
        Query whether the motor is in its centering phase

        :return: False if not centering, True if centering
        :rtype: `bool`
        """"""
        response = self.query(""CENT?"")
        return True if int(response) == 1 else False

    def center(self):
        """"""
        Commands the motor to go to the center of its travel range
        """"""
        self.sendcmd("":CENT"")

    def reset(self):
        """"""
        Sends the stage to the limit of one of its travel ranges
        """"""
        self.sendcmd("":RESE"")

    def move(self, new_position):
        """"""
        Move to a specified location. Position is unitless and is defined as
        the number of motor steps. It varies between motors.

        :param new_position: the location
        :type new_position: `~pint.Quantity`
        """"""
        new_position = assume_units(new_position, u.ms).to(u.ms)
        if self.lower_limit <= new_position <= self.upper_limit:
            clock_cycles = new_position / self.step_size
            cmd = f"":MOVE {int(clock_cycles)}""
            self.sendcmd(cmd)
        else:
            raise ValueError(""Location out of range"")
"
176,http://chrisgrossman.com/manuals/keithley/KEITHLEY-195A-Datasheet.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attY6gK1wdeglTdjY'), ('width', 600), ('height', 373), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1sn-wUsqRvIZh4deWHZuiQ/cl0FuMAGZSpPiALSd0X8AUQj3qBQUpycLbpI-oByOputBtp4dQMK8HB0eaZXo-lupYjIjDVMsmqPdEI9KWkdEA/B5iV0X3MuO5znxcgr1nmzaADQUE66am2CPAktt7_phE'), ('filename', '195.jpg'), ('size', 28452), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KHWJ3ewELP3kO2FlWbH-Mg/xVWTOdEJ2TEEUgDvaazfOTknr2Apf9_8ZTmyKvaiqyoDsPVAXoHebkFJs2Fj5D58qNzXwe-rQ0JOra0icI6bUw/KGM5roSVid7DYjlxoKJE7_4azMXQoJ1WVt4sJwCfddc'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/RBMsd3t5zgqPU1eKBxgJVA/UW0RkqYVM0gPo3-IaS_CwJz-PmT38zKXqpGDyC9yIpOsk2nNjwb7cfumtUxdgk_el7CmAXamfh_640I7GvfH9g/DhYU0CHBLj8BwEaRRlUv6aqZovs809wFK2UZ0HXHzg8'), ('width', 600), ('height', 373)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/us-J7JrvPIAyr-0kIRRCxA/QuMn6mcRopyl1oEmry26M4i8sv0fUsDRPvcWeQcmdQ_fu6fFO6cRbS5EhU__W6NS8YQfMrDjmmOVFTmbVDiTNA/x0fwv5-rfyrzFqf8q2JWUaIpb3VhXh4swWrExaHm7So'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Keithley 195A Digital Multimeter is a fully programmable instrument with a 5.5 digit resolution. In standard configuration, the Model 195A is capable of DC voltage measurements between 100nV and 1000V on six ranges, 2-terminal and 4-terminal resistance measurements between 100µO and 20MO on seven ranges. The instrument is designed to work with platinum RTD probes, a factor which contributes to high accuracy.",https://www.artisantg.com/TestMeasurement/78005-3/Keithley-195A-Digital-Multimeter,Keithley 195,210.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley195.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley195-digital-multimeter,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782580/Instruments/Multimeters/Keithley-195/Keithley-195.jpg,Keithley 195,Write a Python script that uses Instrumentkit to connect to a Keithley 195 Multimeters,,,,,"#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}
"
177,https://www.thorlabs.com/_sd.cfm?fileName=ETN040053-D02.pdf&partNumber=KIM101,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ikmeULh0xPXQ3S2OP7niPQ/4FFgBZ0zDcnT_uQ7Er5g-yifKXK4KUdNTFOyj2Ne5P_V6QjNEr_ROoDly8axC8Rv9Cl9DgbLYMtJeL8jk_msul6l-lsAJldryb_M7691g9Q/e80FgngEatgR471d9aT2qmyRrHJbjGAwwf3MAz-g3RY'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FBgUwDsb1bj8han4Myz-mg/_MRQC4MHlgzafX_YM-FqcgWfxFDB0Ta8FhbI441-QovJtrd-8_4L4WeHlhpjo1nPPm3W4PMz-gUDvMSm_wSPKQ/vi21FV8lnE4PdtGB17SHPH-hQbVBmxqi3ghKPagZ87U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nSe386AzoppYVSR1Ix0j9g/ZJqu2XJLlsCueaTUh3ARMglC2OeMfd-xGJtdm-FYr4gLkHOJJXcpXco2gco_e_eVZ2TrrFj1Hh5_Ajd29BR0_w/qdG0NiZ--pnhxfTv9djuoRhREnsuj6Nlr6goL9ho_ZI'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/irf7zNlom7ANLOcab_z-Fw/mdKCFY4dPmn5tzMMC68j3sCBP74maUIU9SdzB7oEmnOLWxuCypVbp33OwiLztEmL-1gBtLnzqDu7QSE-irKJzw/ZrwKvdsySuPhEZo7TbjXpmpGWDMZ-d8agu2Yn7ZzAIk'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"This four-channel controller features four SMC outputs to drive piezo inertia devices. The channels can be controlled independently or simultaneously in pairs using the dual-axis joystick on the controller's top panel. The controller can be configured to operate up to four PD series piezo inertia stages, up to four PIA series piezo inertia actuators, or up to two PIM series piezo inertia optic mounts; one KIM101 can only concurrently drive devices that use the same ""Select Stage"" configuration in the controller's menu options",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,APTPiezoInertiaActuator,597.0,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782580/Instruments/Positional%20Controller/KIM101/KIM101.jpg,KIM101,Write a Python script that uses Instrumentkit to connect to a KIM101 Positional Controller,1183.98,,,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs APT Controller.
""""""

# IMPORTS #####################################################################


import re
import struct
import logging
import codecs
import warnings

from instruments.thorlabs import _abstract, _packets, _cmds
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################

# pylint: disable=too-many-lines


class ThorLabsAPT(_abstract.ThorLabsInstrument):

    """"""
    Generic ThorLabs APT hardware device controller. Communicates using the
    ThorLabs APT communications protocol, whose documentation is found in the
    thorlabs source folder.
    """"""

    class APTChannel:

        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.
        """"""

        def __init__(self, apt, idx_chan):
            self._apt = apt
            # APT is 1-based, but we want the Python representation to be
            # 0-based.
            self._idx_chan = idx_chan + 1

        @property
        def enabled(self):
            """"""
            Gets/sets the enabled status for the specified APT channel

            :type: `bool`

            :raises TypeError: If controller is not supported
            """"""
            if self._apt.model_number[0:3] == ""KIM"":
                raise TypeError(
                    ""For KIM controllers, use the ""
                    ""`enabled_single` function to enable ""
                    ""one axis. For KIM101 controllers, ""
                    ""multiple axes can be enabled using ""
                    ""the `enabled_multi` function from the ""
                    ""controller level.""
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_REQ_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOD_GET_CHANENABLESTATE
            )
            return not bool(resp.parameters[1] - 1)

        @enabled.setter
        def enabled(self, newval):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_SET_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x01 if newval else 0x02,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

    _channel_type = APTChannel

    def __init__(self, filelike):
        super().__init__(filelike)
        self._dest = 0x50  # Generic USB device; make this configurable later.

        # Provide defaults in case an exception occurs below.
        self._serial_number = None
        self._model_number = None
        self._hw_type = None
        self._fw_version = None
        self._notes = """"
        self._hw_version = None
        self._mod_state = None
        self._n_channels = 0
        self._channel = ()

        # Perform a HW_REQ_INFO to figure out the model number, serial number,
        # etc.
        try:
            req_packet = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.HW_REQ_INFO,
                param1=0x00,
                param2=0x00,
                dest=self._dest,
                source=0x01,
                data=None,
            )
            hw_info = self.querypacket(
                req_packet,
                expect=_cmds.ThorLabsCommands.HW_GET_INFO,
                expect_data_len=84,
            )

            self._serial_number = codecs.encode(hw_info.data[0:4], ""hex"").decode(
                ""ascii""
            )
            self._model_number = (
                hw_info.data[4:12].decode(""ascii"").replace(""\x00"", """").strip()
            )

            hw_type_int = struct.unpack(""<H"", hw_info.data[12:14])[0]
            if hw_type_int == 45:
                self._hw_type = ""Multi-channel controller motherboard""
            elif hw_type_int == 44:
                self._hw_type = ""Brushless DC controller""
            else:
                self._hw_type = f""Unknown type: {hw_type_int}""

            # Note that the fourth byte is padding, so we strip out the first
            # three bytes and format them.
            # pylint: disable=invalid-format-index
            self._fw_version = ""{0[0]:x}.{0[1]:x}.{0[2]:x}"".format(hw_info.data[14:18])
            self._notes = (
                hw_info.data[18:66].replace(b""\x00"", b"""").decode(""ascii"").strip()
            )

            self._hw_version = struct.unpack(""<H"", hw_info.data[78:80])[0]
            self._mod_state = struct.unpack(""<H"", hw_info.data[80:82])[0]
            self._n_channels = struct.unpack(""<H"", hw_info.data[82:84])[0]
        except OSError as e:
            logger.error(""Exception occured while fetching hardware info: %s"", e)

        # Create a tuple of channels of length _n_channel_type
        if self._n_channels > 0:
            self._channel = tuple(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels)
            )

    @property
    def serial_number(self):
        """"""
        Gets the serial number for the APT controller

        :type: `str`
        """"""
        return self._serial_number

    @property
    def model_number(self):
        """"""
        Gets the model number for the APT controller

        :type: `str`
        """"""
        return self._model_number

    @property
    def name(self):
        """"""
        Gets the name of the APT controller. This is a human readable string
        containing the model, serial number, hardware version, and firmware
        version.

        :type: `str`
        """"""
        return (
            ""ThorLabs APT Instrument model {model}, serial {serial} ""
            ""(HW version {hw_ver}, FW version {fw_ver})"".format(
                hw_ver=self._hw_version,
                serial=self.serial_number,
                fw_ver=self._fw_version,
                model=self.model_number,
            )
        )

    @property
    def channel(self):
        """"""
        Gets the list of channel objects attached to the APT controller.

        A specific channel object can then be accessed like one would access
        a list.

        :type: `tuple` of `APTChannel`
        """"""
        return self._channel

    @property
    def n_channels(self):
        """"""
        Gets/sets the number of channels attached to the APT controller

        :type: `int`
        """"""
        return self._n_channels

    @n_channels.setter
    def n_channels(self, nch):
        # Change the number of channels so as not to modify those instances
        # already existing:
        # If we add more channels, append them to the list,
        # If we remove channels, remove them from the end of the list.
        if nch > self._n_channels:
            self._channel = list(self._channel) + list(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels, nch)
            )
        elif nch < self._n_channels:
            self._channel = self._channel[:nch]
        self._n_channels = nch

    def identify(self):
        """"""
        Causes a light on the APT instrument to blink, so that it can be
        identified.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.MOD_IDENTIFY,
            param1=0x00,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        self.sendpacket(pkt)

    @property
    def destination(self):
        """"""
        Gets the destination for the APT controller

        :type: `int`
        """"""
        return self._dest


class APTPiezoDevice(ThorLabsAPT):

    """"""
    Generic ThorLabs APT piezo device, superclass of more specific piezo
    devices.
    """"""

    class PiezoDeviceChannel(ThorLabsAPT.APTChannel):
        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.

        This class represents piezo stage channels.
        """"""

        # PIEZO COMMANDS #

        @property
        def max_travel(self):
            """"""
            Gets the maximum travel for the specified piezo channel.

            :type: `~pint.Quantity`
            :units: Nanometers
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_MAXTRAVEL,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(pkt, expect_data_len=4)

            # Not all APT piezo devices support querying the maximum travel
            # distance. Those that do not simply ignore the PZ_REQ_MAXTRAVEL
            # packet, so that the response is empty.
            if resp is None:
                return NotImplemented

            # chan, int_maxtrav
            _, int_maxtrav = struct.unpack(""<HH"", resp.data)
            return int_maxtrav * u.Quantity(100, ""nm"")

    @property
    def led_intensity(self):
        """"""
        Gets/sets the output intensity of the LED display.

        :type: `float` between 0 and 1.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_REQ_TPZ_DISPSETTINGS,
            param1=0x01,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        resp = self.querypacket(pkt, expect_data_len=2)

        # Not all APT piezo devices support querying the LED intenstiy
        # distance, e.g., TIM, KIM. Those that do not simply ignore the
        # PZ_REQ_TPZ_DISPSETTINGS packet, so that the response is empty.
        # Setting will be ignored as well.
        if resp is None:
            return NotImplemented
        else:
            return float(struct.unpack(""<H"", resp.data)[0]) / 255

    @led_intensity.setter
    def led_intensity(self, intensity):
        # pylint: disable=round-builtin
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_SET_TPZ_DISPSETTINGS,
            param1=None,
            param2=None,
            dest=self._dest,
            source=0x01,
            data=struct.pack(""<H"", int(round(255 * intensity))),
        )
        self.sendpacket(pkt)

    _channel_type = PiezoDeviceChannel


class APTPiezoInertiaActuator(APTPiezoDevice):

    """"""Represent a Thorlabs APT piezo inertia actuator.

    Currently only the KIM piezo inertia actuator is implemented.
    Some routines will work with the TIM actuator as well. Routines
    that are specific for the KIM101 controller will raise a TypeError
    if not implemented for this controller. Unfortunately, handling all
    these controller specific functions is fairly messy, but necessary.

    Example for a KIM101 controller:
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> # call the controller
        >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # set first channel to enabled
        >>> ch = kim.channel[0]
        >>> ch.enabled_single = True
        >>> # define and set drive parameters
        >>> max_volts = u.Quantity(110, u.V)
        >>> step_rate = u.Quantity(1000, 1/u.s)
        >>> acceleration = u.Quantity(10000, 1/u.s**2)
        >>> ch.drive_op_parameters = [max_volts, step_rate, acceleration]
        >>> # aboslute move to 1000 steps
        >>> ch.move_abs(1000)
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PROPERTIES #

        @property
        def drive_op_parameters(self):
            """"""Get / Set various drive parameters for move motion.

            Defines the speed and acceleration of moves initiated in
            the following ways:
            - by clicking in the position display
            - via the top panel controls when ‘Go To Position’ mode is
            selected (in the Set_TIM_JogParameters (09) or
            Set_KCubeMMIParams (15) sub‐messages).
            - via software using the MoveVelocity, MoveAbsoluteStepsEx
            or MoveRelativeStepsEx methods.

            :setter: The setter must be be given as a list of 3
                entries. The three entries are:
                -  Maximum Voltage:
                The maximum piezo drive voltage, in the range 85V
                to 125V. Unitful, if no unit given, V are assumed.
                - Step Rate:
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the drive parameters, unitful.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # change the step rate to 2000 /s
                >>> drive_params = ch.drive_op_parameters
                >>> drive_params[1] = 2000
                >>> ch.drive_op_parameters = drive_params
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x07,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=14
            )

            # unpack
            ret_val = struct.unpack(""<HHHll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4]]

            # set units and formats
            ret_val = [
                u.Quantity(int(ret_val[0]), u.V),
                u.Quantity(int(ret_val[1]), 1 / u.s),
                u.Quantity(int(ret_val[2]), 1 / u.s**2),
            ]
            return ret_val

        @drive_op_parameters.setter
        def drive_op_parameters(self, params):
            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 3:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 3."")

            # ensure units
            volt = int(assume_units(params[0], u.V).to(u.V).magnitude)
            rate = int(assume_units(params[1], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[2], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if volt < 85 or volt > 125:
                raise ValueError(
                    ""The voltage ({} V) is out of range. It must ""
                    ""be between 85 V and 125 V."".format(volt)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )

            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHHll"", 0x07, self._idx_chan, volt, rate, accl),
            )
            self._apt.sendpacket(pkt)

        @property
        def enabled_single(self):
            """"""Get / Set single axis enabled.

            .. note:: Enabling multi channels for KIM101 is defined in
            the controller class.

            :return: Axis status enabled.
            :rtype: bool

            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # enable channel 0
                >>> ch.enabled_single = True
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise (
                    ""This command is only valid with KIM001 and ""
                    ""KIM101 controllers. Your controller is a {}."".format(
                        self._apt.model_number
                    )
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2B,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
            )

            ret_val = struct.unpack(""<HH"", resp.data)[1] == self._idx_chan

            return ret_val

        @enabled_single.setter
        def enabled_single(self, newval):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            param = self._idx_chan if newval else 0x00
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", 0x2B, param),
            )
            self._apt.sendpacket(pkt)

        @property
        def jog_parameters(self):
            """"""Get / Set the jog parameters.

            Define the speed and acceleration of moves initiated in the
            following ways:
            - By clicking the jog buttons on the GUI panel
            - By moving the joystick on the unit when ‘Jog Mode’ is
            selected.
            - via software using the MoveJog method.

            It differs from the normal motor jog message in that there
            are two jog step sizes, one for forward and one for reverse.
            The reason for this is that due to the inherent nature of
            the PIA actuators going further in one direction as
            compared with another this will allow the user to
            potentially make adjustments to get fore and aft movement
            the same or similar.

            :setter: The setter must be be given as a list of 5
                entries. The three entries are:
                - Jog Mode (1 for continuus, i.e., until stop command
                is issued, or 2 jog by the number of steps defined)
                - Jog Step Size Forward: Range 1 - 2000
                - Jog Step Size Backward: Range 1 - 2000
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Jog Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the jog parameters.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.
            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> mode = 2  # only move by set step size
                >>> step = 100  # step size
                >>> rate = u.Quantity(1000, 1/u.s)  # step rate
                >>> # if no quantity given, SI units assumed
                >>> accl = 10000
                >>> ch.jog_parameters = [mode, step, step, rate, accl]
                >>> ch.jog_parameters
                [2, 100, 100, array(1000) * 1/s, array(10000) * 1/s**2]
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2D,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=22
            )

            # unpack response
            ret_val = struct.unpack(""<HHHllll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4], ret_val[5], ret_val[6]]

            # assign the appropriate units, forms
            ret_val = [
                int(ret_val[0]),
                int(ret_val[1]),
                int(ret_val[2]),
                u.Quantity(int(ret_val[3]), 1 / u.s),
                u.Quantity(int(ret_val[4]), 1 / u.s**2),
            ]

            return ret_val

        @jog_parameters.setter
        def jog_parameters(self, params):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 5:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 5."")

            # ensure units
            mode = int(params[0])
            steps_fwd = int(params[1])
            steps_bkw = int(params[2])
            rate = int(assume_units(params[3], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[4], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if mode != 1 and mode != 2:
                raise ValueError(
                    ""The mode ({}) must be either set to 1 ""
                    ""(continuus) or 2 (steps)."".format(mode)
                )
            if steps_fwd < 1 or steps_fwd > 2000:
                raise ValueError(
                    ""The steps forward ({}) are out of range. It ""
                    ""must be between 1 and 2,000."".format(steps_fwd)
                )
            if steps_bkw < 1 or steps_bkw > 2000:
                raise ValueError(
                    ""The steps backward ({}) are out of range. ""
                    ""It must be between 1 and 2,000."".format(steps_bkw)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )
            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHllll"",
                    0x2D,
                    self._idx_chan,
                    mode,
                    steps_fwd,
                    steps_bkw,
                    rate,
                    accl,
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def position_count(self):
            """"""Get/Set the position count of a given channel.

            :setter pos: Position (steps) of axis.
            :type pos: int

            :return: Position (steps) of axis.
            :rtype: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set position count to zero
                >>> ch.position_count = 0
                >>> ch.position_count
                0
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x05,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=12
            )

            ret_val = int(struct.unpack(""<HHll"", resp.data)[2])

            return ret_val

        @position_count.setter
        def position_count(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHll"", 0x05, self._idx_chan, pos, 0x00),
            )
            self._apt.sendpacket(pkt)

        # METHODS #

        def move_abs(self, pos):
            """"""
            Moves the axis to a position specified as the number of
            steps away from the zero position.

            To set the moving parameters, use the setter for
            `drive_op_parameters`.

            :param pos: Position to move to, in steps.
            :type pos: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # move to 314 steps
                >>> ch.move_abs(314)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_ABSOLUTE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

        def move_jog(self, direction=""fwd""):
            """"""
            Jogs the axis in forward or backward direction by the number
            of steps that are stored in the controller.

            To set the moving parameters, use the setter for
            `jog_parameters`.

            :param str direction: Direction of jog. 'fwd' for forward,
                'rev' for backward. 'fwd' if invalid argument given

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> params = ch.jog_parameters
                >>> params[0] = 2  # move by number of steps
                >>> params[1] = 100  # step size forward
                >>> params[2] = 200  # step size reverse
                >>> ch.jog_parameters = params  # set parameters
                >>> # jog forward (default)
                >>> ch.move_jog()
                >>> # jog reverse
                >>> ch.move_jog('rev')
            """"""
            if direction == ""rev"":
                param2 = 0x02
            else:
                param2 = 0x01

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=param2,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        def move_jog_stop(self):
            """"""Stops the current motor movement.

            Stop a jog command. The regular motor move stop command does
            not work for jogging. This command somehow does...

            .. note:: This information is quite empirical. It would
                only be really needed if jogging parameters are set to
                continuous. The safer method is to set the step range.
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel

    # PROPERTIES #

    @property
    def enabled_multi(self):
        """"""Enable / Query mulitple channel mode.

        For KIM101 controller, where multiple axes can be selected
        simultaneously (i. e., for a mirror mount).

        :setter mode: Channel pair to be activated.
            0:  All channels deactivated
            1:  First channel pair activated (channel 0 & 1)
            2:  Second channel pair activated (channel 2 & 3)
        :type mode: int

        :return: The selected mode:
            0 - multi-channel selection disabled
            1 - Channel 0 & 1 enabled
            2 - Channel 2 & 3 enabled
        :rtype: int

        :raises ValueError: No valid channel pair selected
        :raises TypeError: Invalid controller for this command.

        Example:
            >>> import instruments as ik
            >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
            >>> # activate the first two channels
            >>> kim.enabled_multi = 1
            >>> # read back
            >>> kim.enabled_multi
            1
        """"""
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
            param1=0x2B,
            param2=0x00,
            dest=self.destination,
            source=0x01,
            data=None,
        )

        resp = self.querypacket(
            pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
        )

        ret_val = int(struct.unpack(""<HH"", resp.data)[1])

        if ret_val == 5:
            return 1
        elif ret_val == 6:
            return 2
        else:
            return 0

    @enabled_multi.setter
    def enabled_multi(self, mode):
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        if mode == 0:
            param = 0x00
        elif mode == 1:
            param = 0x05
        elif mode == 2:
            param = 0x06
        else:
            raise ValueError(
                ""Please select a valid mode: 0 - all ""
                ""disabled, 1 - Channel 1 & 2 enabled, ""
                ""2 - Channel 3 & 4 enabled.""
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
            param1=None,
            param2=None,
            dest=self.destination,
            source=0x01,
            data=struct.pack(""<HH"", 0x2B, param),
        )

        self.sendpacket(pkt)


class APTPiezoStage(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT piezo stage
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PIEZO COMMANDS #

        @property
        def position_control_closed(self):
            """"""
            Gets the status if the position control is closed or not.

            `True` means that the position control is closed, `False` otherwise

            :type: `bool`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_POSCONTROLMODE
            )
            return bool((resp.parameters[1] - 1) & 1)

        def change_position_control_mode(self, closed, smooth=True):
            """"""
            Changes the position control mode of the piezo channel

            :param bool closed: `True` for closed, `False` for open
            :param bool smooth: `True` for smooth, `False` for otherwise.
                Default is `True`.
            """"""
            mode = 1 + (int(closed) | int(smooth) << 1)
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=mode,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        @property
        def output_position(self):
            """"""
            Gets/sets the output position for the piezo channel.

            :type: `str`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_OUTPUTPOS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_OUTPUTPOS, expect_data_len=4
            )
            # chan, pos
            _, pos = struct.unpack(""<HH"", resp.data)
            return pos

        @output_position.setter
        def output_position(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_OUTPUTPOS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel


class APTStrainGaugeReader(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT strain gauge reader.

    .. warning:: This is not currently implemented
    """"""

    class StrainGaugeChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single strain gauge channel attached to a
        `APTStrainGaugeReader` on the Thorlabs APT controller.

        .. warning:: This is not currently implemented
        """"""

    _channel_type = StrainGaugeChannel


class APTMotorController(ThorLabsAPT):

    """"""
    Class representing a Thorlabs APT motor controller.

    .. note:: A motor model must be selected in order to use unitful
        distances.

    Example:
        >>> import instruments as ik
        >>> import instruments.units as u

        >>> # load the controller, a KDC101 cube
        >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # assign a channel to `ch`
        >>> ch = kdc.channel[0]
        >>> # select the stage that is connected to the controller
        >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

        >>> # home the stage
        >>> ch.go_home()
        >>> # move to 52 degrees absolute position
        >>> ch.move(u.Quantity(52, u.deg))
        >>> # move 10 degrees back from current position
        >>> ch.move(u.Quantity(-10, u.deg), absolute=False)
    """"""

    class MotorChannel(ThorLabsAPT.APTChannel):

        """"""
        Class representing a single motor attached to a Thorlabs APT motor
        controller (`APTMotorController`).
        """"""

        # INSTANCE VARIABLES #

        _motor_model = None

        #: Sets the scale between the encoder counts and physical units
        #: for the position, velocity and acceleration parameters of this
        #: channel. By default, set to dimensionless, indicating that the proper
        #: scale is not known.
        #:
        #: In keeping with the APT protocol documentation, the scale factor
        #: is multiplied by the physical quantity to get the encoder count,
        #: such that scale factors should have units similar to microsteps/mm,
        #: in the example of a linear motor.
        #:
        #: Encoder counts are represented by the quantities package unit
        #: ""ct"", which is considered dimensionally equivalent to dimensionless.
        #: Finally, note that the ""/s"" and ""/s**2"" are not included in scale
        #: factors, so as to produce quantities of dimension ""ct/s"" and
        #: ""ct/s**2""
        #: from dimensionful input.
        #:
        #: For more details, see the APT protocol documentation.
        scale_factors = (u.Quantity(1, ""dimensionless""),) * 3

        _motion_timeout = u.Quantity(10, ""second"")

        __SCALE_FACTORS_BY_MODEL = {
            # TODO: add other tables here.
            re.compile(""TST001|BSC00.|BSC10.|MST601""): {
                # Note that for these drivers, the scale factors are identical
                # for position, velcoity and acceleration. This is not true for
                # all drivers!
                ""DRV001"": (u.Quantity(51200, ""count/mm""),) * 3,
                ""DRV013"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV014"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV113"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""DRV114"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""FW103"": (u.Quantity(25600 / 360, ""count/deg""),) * 3,
                ""NR360"": (u.Quantity(25600 / 5.4546, ""count/deg""),) * 3,
            },
            re.compile(""TDC001|KDC101""): {
                ""MTS25-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                ""MTS50-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                # TODO: Z8xx and Z6xx models. Need to add regex support to motor models, too.
                ""PRM1-Z8"": (
                    u.Quantity(1919.64, ""count/deg""),
                    u.Quantity(42941.66, u.sec / u.deg),
                    u.Quantity(14.66, u.sec**2 / u.deg),
                ),
            },
        }

        __STATUS_BIT_MASK = {
            ""CW_HARD_LIM"": 0x00000001,
            ""CCW_HARD_LIM"": 0x00000002,
            ""CW_SOFT_LIM"": 0x00000004,
            ""CCW_SOFT_LIM"": 0x00000008,
            ""CW_MOVE_IN_MOTION"": 0x00000010,
            ""CCW_MOVE_IN_MOTION"": 0x00000020,
            ""CW_JOG_IN_MOTION"": 0x00000040,
            ""CCW_JOG_IN_MOTION"": 0x00000080,
            ""MOTOR_CONNECTED"": 0x00000100,
            ""HOMING_IN_MOTION"": 0x00000200,
            ""HOMING_COMPLETE"": 0x00000400,
            ""INTERLOCK_STATE"": 0x00001000,
        }

        # IK-SPECIFIC PROPERTIES #
        # These properties don't correspond to any particular functionality
        # of the underlying device, but control how we interact with it.

        @property
        def motion_timeout(self):
            """"""
            Gets/sets the motor channel motion timeout.

            :units: Seconds
            :type: `~pint.Quantity`
            """"""
            return self._motion_timeout

        @motion_timeout.setter
        def motion_timeout(self, newval):
            self._motion_timeout = assume_units(newval, u.second)

        # UNIT CONVERSION METHODS #

        def _set_scale(self, motor_model):
            """"""
            Sets the scale factors for this motor channel, based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel.

            :param str motor_model: Name of the model of the attached motor,
                as indicated in the APT protocol documentation (page 14, v9).
            """"""
            for driver_re, motor_dict in self.__SCALE_FACTORS_BY_MODEL.items():
                if driver_re.match(self._apt.model_number) is not None:
                    if motor_model in motor_dict:
                        self.scale_factors = motor_dict[motor_model]
                        return
                    else:
                        break
            # If we've made it down here, emit a warning that we didn't find the
            # model.
            logger.warning(
                ""Scale factors for controller %s and motor %s are "" ""unknown"",
                self._apt.model_number,
                motor_model,
            )

        # We copy the docstring below, so it's OK for this method
        # to not have a docstring of its own.
        # pylint: disable=missing-docstring
        def set_scale(self, motor_model):
            warnings.warn(
                ""The set_scale method has been deprecated in favor ""
                ""of the motor_model property."",
                DeprecationWarning,
            )
            return self._set_scale(motor_model)

        set_scale.__doc__ = _set_scale.__doc__

        @property
        def motor_model(self):
            """"""
            Gets or sets the model name of the attached motor.
            Note that the scale factors for this motor channel are based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel, such that setting a new motor model will update
            the scale factors accordingly.

            :type: `str` or `None`
            """"""
            return self._motor_model

        @motor_model.setter
        def motor_model(self, newval):
            self._set_scale(newval)
            self._motor_model = newval

        # MOTOR COMMANDS #

        @property
        def backlash_correction(self):
            """"""Get / set backlash correctionf or given stage.

            If no units are given, ``u.counts`` are assumed. If you have
            the stage defined (see example below), unitful values can be
            used for setting the backlash correction, e.g., ``u.mm`` or
            ``u.deg``.

            :return: Unitful quantity of backlash correction.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> ch.backlash_correction = 4 * u.deg  # set it to 4 degrees
                >>> ch.backlash_correction  # read it back
                <Quantity(4, 'degree')>
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_GENMOVEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_GENMOVEPARAMS,
                expect_data_len=6,
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @backlash_correction.setter
        def backlash_correction(self, pos):
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )
            # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_GENMOVEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )
            self._apt.sendpacket(pkt)

        @property
        def home_parameters(self):
            """"""Get the home parameters for the motor channel.

            Parameters are stage specific and not all parameters can be set
            for every stage. For example, the MLS203 stage only allows the
            homing velocity to be changed.

            .. note:: When setting the quantity, pass `None` to values
                that you want to leave unchanged (see example below).

            .. note:: After changing the offset, the stage must be homed
                in order to show the new offset in its values.

            :return: Home Direction (1: forward/positive, 2 reverse/negative),
                Limit Switch (1: hardware reverse, 4: hardware forward),
                Home Velocity,
                Offset distance
            :rtype: Tuple[int, int, u.Quantity, u.Quantity]


            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> # set offset distance to 4 degrees, leave other values
                >>> ch.home_parameters = None, None, None, 4 * u.deg
                >>> ch.home_parameters  # read it back
                (2, 1, <Quantity(9.99, 'degree / second')>, <Quantity(3.99, 'degree')>)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_HOMEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_HOMEPARAMS,
                expect_data_len=14,
            )
            # chan, home_dir, limit_switch, velocity, ,offset_dist
            _, home_dir, lim_sw, vel, offset = struct.unpack(""<HHHll"", response.data)
            return (
                int(home_dir),
                int(lim_sw),
                u.Quantity(vel) / self.scale_factors[1],
                u.Quantity(offset, ""counts"") / self.scale_factors[0],
            )

        @home_parameters.setter
        def home_parameters(self, values):
            if len(values) != 4:
                raise ValueError(
                    ""Home parameters muust be set with four values: ""
                    ""Home direction, limit switch settings, velocity, and offset. ""
                    ""For settings you want to leave untouched, pass `None`.""
                )

            # replace values that are `None`
            if None in values:
                set_params = self.home_parameters
                values = [x if x is not None else y for x, y in zip(values, set_params)]

            home_dir, lim_sw, velocity, offset = values
            if isinstance(velocity, u.Quantity):
                velocity = (velocity * self.scale_factors[1]).to_reduced_units()
                if velocity.dimensionless:
                    velocity = int(velocity.magnitude)
                else:
                    raise ValueError(
                        ""Provided units for velocity are not compatible ""
                        ""with current motor scale factor.""
                    )
            if isinstance(offset, u.Quantity):
                if offset.units == u.counts:
                    offset = int(offset.magnitude)
                else:
                    scaled_vel = offset * self.scale_factors[0]
                    try:
                        offset = int(scaled_vel.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units for offset are not compatible ""
                            ""with current motor scale factor.""
                        )

                # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_HOMEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHll"",
                    self._idx_chan,
                    int(home_dir),
                    int(lim_sw),
                    int(velocity),
                    int(offset),
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def status_bits(self):
            """"""
            Gets the status bits for the specified motor channel.

            .. note:: This command, as currently implemented, is only
                available for certain devices and will result in an
                ``OSError`` otherwise. Devices that work according to the
                manual are: TSC001, KSC101, BSC10x, BSC20x, LTS150, LTS300,
                MLJ050, MLJ150, TIM101, KIM101.

            :type: `dict`
            """"""
            # NOTE: the difference between MOT_REQ_STATUSUPDATE and
            # MOT_REQ_DCSTATUSUPDATE confuses me
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_STATUSUPDATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            # The documentation claims there are 14 data bytes, but it seems
            # there are sometimes some extra random ones...
            # fixme: wrong expected datatype? MOT_GET_STATUSUPDATE expected
            resp_data = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER,
                expect_data_len=14,
            ).data[:14]
            # ch_ident, position, enc_count, status_bits
            _, _, _, status_bits = struct.unpack(""<HLLL"", resp_data)

            status_dict = {
                key: (status_bits & bit_mask > 0)
                for key, bit_mask in self.__STATUS_BIT_MASK.items()
            }

            return status_dict

        @property
        def position(self):
            """"""
            Gets the current position of the specified motor channel

            :type: `~pint.Quantity`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_POSCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @property
        def position_encoder(self):
            """"""
            Gets the position of the encoder of the specified motor channel

            :type: `~pint.Quantity`
            :units: Encoder ``counts``
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_ENCCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_ENCCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"")

        def go_home(self):
            """"""
            Instructs the specified motor channel to return to its home
            position
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_HOME,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_HOMED,
                timeout=self.motion_timeout,
            )

        def move(self, pos, absolute=True):
            """"""
            Instructs the specified motor channel to move to a specific
            location. The provided position can be either an absolute or
            relative position.

            :param pos: The position to move to. Provided value will be
                converted to encoder counts.
            :type pos: `~pint.Quantity`
            :units pos: As specified, or assumed to of units encoder counts

            :param bool absolute: Specify if the position is a relative or
                absolute position. ``True`` means absolute, while ``False``
                is for a relative move.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> # select the stage that is connected to the controller
                >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

                >>> # move to 32 degrees absolute position
                >>> ch.move(u.Quantity(32, u.deg))

                >>> # move 10 degrees forward from current position
                >>> ch.move(u.Quantity(10, u.deg), absolute=False)
            """"""
            # Handle units as follows:
            # 1. Treat raw numbers as encoder counts.
            # 2. If units are provided (as a Quantity), check if they're encoder
            #    counts. If they aren't, apply scale factor.
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )

            # Now that we have our position as an integer number of encoder
            # counts, we're good to move.
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_ABSOLUTE
                if absolute
                else _cmds.ThorLabsCommands.MOT_MOVE_RELATIVE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )

            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_COMPLETED,
                timeout=self.motion_timeout,
                expect_data_len=14,
            )

    _channel_type = MotorChannel

    # CONTROLLER PROPERTIES AND METHODS #
"
187,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ITC503.pdf,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attrty3FFFzJUtuMr'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qibwwm-B2RWplylc8T92Qg/8ErRMqyjrOd3oAmUDMqlLZsWz22souca8pYc4AZh1dl6tqlh_uUjlc_MU7xdsmYUQQL2rF_aBc9G-G-z3I3CUUoTjiPq5nqNwhsktlSuw5Q/hSQMn_2HAcNrGwCd5P4UYcJoZxMlVTI_h180yinqeM0'), ('filename', 's-l1600.jpg'), ('size', 266225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iFPmSkvVVxcr6n-ejdM37w/YrUCvZsFARH6Ks8MZpCTXebMX13A3_t2ku-zXcku-d-5mI5IIfpZ2X6e5dW7ooL9FTPHtDIKJeBWpQuijPBKKA/tJlBeeSTFy-2_tlrAywMF65-Rn95yJm72JQwdrO9ROc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/4j5DHeCC4vFQjkwaczldGA/YZ-bvD6MPwy3FqpMwuquavAiYgo0DRsXX8-iTD0Ee7MSGsvrXXxtWxEi5oB43kKfTj4l6ePW85bwynK5L9eUeA/YowZpkBSsw_FdZjeHKBs8xe30odL6o4OQohhRV_ZyFQ'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xD6za_XoziL5NdA3-5kkLQ/l3CdAUIEgQ8u-hrCZ4F133jliu_UMcifvot8dJGorYGDx7AT0OQC4op3h5tlkR2Yl1kG4gSNxhJlbDYXbKh3Vg/B0z7dsuSmtGp00HENs28V9KbD8-ikHO_cB4aRZQFPFQ'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125988/Instruments/Vendor%20Logos/Oxford_Instruments.png,"Oxford Intelligent Temperature Controller ITC 502. Oxford Instruments ITC502 Intelligent Temperature Controller (Model 611-968) is a three term controller. It has the capability of monitoring up to three thermometers at the same time, and supplying heat to control the temperature of one part of the cryostat. The sensor interface can be configured to suit a wide range of thermometers (typically within the temperature range of 0.25 to 500 K).",https://picclick.com/Oxford-Intelligent-Temperature-Controller-ITC-502-132299188022.html,Oxford itc 503,400.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/oxford/oxforditc503.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/oxford.html#oxforditc503-temperature-controller,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TmODz0hi9OJUWi8T_d03Sg/Z2IpZm1otBFaV4dd1Z-YtqnyJyVrn1XmjrAJ-f5S_iVw7bPjL7yB9-iP7oED2Apt8U7BWIgETKyocFr_7AB4ANlqGjCMDVi0jOaDoDmBEeY/fb6Rw-KSmBuKxPZBvzrwQHM2Od5u72NtOxyRcoYmp1k'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wLs8zjCAwM09gWDMI3xu8Q/oeHC2OPJ20vnWtvfKmZUu5tq6Qs8soCa05gu5GwUon7E_fXVQPnVlYkLXr8b89l5PSrYNLwdT0-CaM0qfQxfkQ/-ax23cOalgUh6YtKYQnXV1PHde7iBMdvwmUkMoLyC4g'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jgZc4LIcvZHeQFduBTSAqA/Ekyj1R3Uue0-wDCxuF4HJMJgjIi6LufK6pQen9vYQvrGtTJ02DFBb9vf_SftJYHGiiKwYcBl1y0ZxBQRsYc_9g/zsDCrHyIVVMco4QM3Ug2jLafjuWb_kNyFMD1jMv7l3E'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PhngqIRF78CMgJpGxBi3aA/Q4c_1vbgbHc9v_mECxRUCccMTG-Ca72dEMwKqczOB_oBg3yhQVaWSPj9-Cyp88i9XS_-NvyHrb6FmV0sZXsnhg/yJDJjhkTUYCH-6uR2EfIACKa09g3qImdFcMG16-hnng'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782452/Instruments/Temperature%20Controllers/ITC-503/ITC-503.jpg,ITC 503,Write a Python script that uses Instrumentkit to connect to a ITC 503 Temperature Controllers,2150.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Oxford ITC 503 temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class OxfordITC503(Instrument):

    """"""
    The Oxford ITC503 is a multi-sensor temperature controller.

    Example usage::

    >>> import instruments as ik
    >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(itc.sensor[0].temperature)
    >>> print(itc.sensor[1].temperature)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.sendcmd(""C3"")  # Enable remote commands

    # INNER CLASSES #

    class Sensor:

        """"""
        Class representing a probe sensor on the Oxford ITC 503.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `OxfordITC503` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES #

        @property
        def temperature(self):
            """"""
            Read the temperature of the attached probe to the specified channel.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = float(self._parent.query(f""R{self._idx}"")[1:])
            return u.Quantity(value, u.kelvin)

    # PROPERTIES #

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
        >>> print(itc.sensor[0].temperature)

        :type: `OxfordITC503.Sensor`
        """"""
        return ProxyList(self, OxfordITC503.Sensor, range(3))
"
193,https://drive.google.com/file/d/1dvlmTTycCDXEis8rC74uM3bgh-szW-_n/view?usp=sharing,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attrSHmyzn2qlEPy2'), ('width', 1200), ('height', 564), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TZhQCofw4xgRtfd5Kwhh8g/hSyuMUcbbtQe6vepXiMgfSbrW-jpt_kXNItjiE_Yd2GFAqyPnttt4QU7oEDi_3GoQFUvkhzzXTH9i_kqZ5S1A-9H2GzDjhTTKoGCcIPGmZw/KNyWjQoGr3wz8bVGxio4HwvvWIsHlkG_onmxGidy3YQ'), ('filename', 'TC038D.webp'), ('size', 40894), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/G5eQjSTXzNHA5_b0j3u9cQ/hqVEBq7yUNOqUDZ0t4MN9rlGm_IG1QWXz5qmc8V75wj02Rzb_pGJnhM4NzLoUAtv2T_hOvWoKDTpDwbMEaBrVcrG6mN4UMcDrCvDlD0ugHc/ppa_ddDatmvZ4j3i2QfTWEYHkCZkKrlfbyMR8mSjBqM'), ('width', 77), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/l_PyTdFxFIXhZxaRjRcTNQ/-K20lWv533Ag7KB2O31l2sZ2Hw_bO81v0jzjijd0yuWx59bGoYFTqcwSM67vqLTZiAIAdKX1O8Ym0CZZ4z-U-7P3UJCL17rgZroi-BlK3sw/Tikh9zbzdT1ls619rgRYqbQfD1iuQA1O3OlUkKEDWPw'), ('width', 1089), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UCYdVHdJ9th0VGNMQDN_mQ/tI6xVlc5DL9peK7S6WJ1tEfI_XsGS3eXotMxq8zYytLp8xw-gvWnYNPY4kNzvkrfklQYhyfwp1B-sa2dxHluMqhH8A8R8JlGpjmuDgkwDiQ/fEx1PWgBT6Tpk_f_pCYGG2plXMhddegRMr4dnsQ1smI'), ('width', 3000), ('height', 3000)]))]))])]",7.0,Taiwan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/HCP.png,"Temperature controller, TC-038D, goes along with different ovens (OV-30D, OV-50D, WG OVENs) with extreme temperature tunability up to 200 deg
",https://www.hcphotonics.com/accessories,TC-038D,146.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**HC Photonics** (HCP) provides crystal ovens and controllers to well manage the temperature of nonlinear crystals, especially PPLN and PPLT. 
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hcp/tc038d.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/hcp.html#tc038d-crystal-oven-dc,HCP,"[OrderedDict([('id', 'att0HIJANIUaKbEnj'), ('width', 969), ('height', 327), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0z6Zbm35WXT4_MHTq1E4yQ/th_-fv-RnUKW4i3no9S-_zL2s-VS-PAP7sCZBhDqMWIfh8l3Z7KOdDZp43toUhVKSfdarBMh6ZyHNnE0CsDxdKW6bYSACYBwvq2eJUn2dsNjn6hwu5H6OtRYHwP6VJqV/L2QMaqqP8ceIuxlPKtLh_zlYLAggzzSz3zScKk-btbg'), ('filename', '88959ca5c0458434_HCP Logo_web 1.jpg'), ('size', 71666), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/JQ1fgBYPY_rR_3fU7HgWeQ/KcKw7-KRLGpacIijDAeVGYTda4PLLqWMH1mtb2IAqKyDP6rAkpnf8zRNcLumINrqmMQy8V3qbRSd7McauuI4dw/YiP50UUqAl5F1AbgbUrj2kNwkxdzuqIlOWvliQmVn6E'), ('width', 107), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/gpSvkqncMEnRWh9XMrM3jQ/Tr1oqY4qpBEPr1M0eLdxWEKuy4LhJxiDYO0pOQCR1NUkPH_zB4cVANzRSrdon3vtLDSJwQR9pJthfbVuA113cA/0lYvI3j5gzWvsLrQvMAOoIc1GSmTyTwlrqq6S-X7Le8'), ('width', 969), ('height', 327)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/BbfBXl2N4ECPZWYaAAQ9ow/C6WgjkcVnCVRUVrUh9xZ4jUlhkrwAjl3-Ybq-Uc1i75Wi4KGCktOTgAU42BgbTjZbrLwNyWKWirQSjj4fPobdA/HqAkyo-LtQGy8htBcw6poBRXgYcyPEPq8QIkhMSs0_k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.hcphotonics.com,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782598/Instruments/Temperature%20Controllers/TC-038D/TC-038D.webp,TC-038D,Write a Python script that uses Instrumentkit to connect to a TC-038D Temperature Controllers,,,,Nothing on Github Yet,"#!/usr/bin/env python
""""""
Provides support for the TC038 AC crystal oven by HC Photonics.
""""""


# IMPORTS #####################################################################


from instruments.units import ureg as u

from instruments.abstract_instruments.instrument import Instrument
from instruments.util_fns import assume_units


# CLASSES #####################################################################


class TC038D(Instrument):
    """"""
    Communication with the HCP TC038D oven.

    This is the newer version with DC heating.

    The temperature controller is on default set to modbus communication.
    The oven expects raw bytes written, no ascii code, and sends raw bytes.
    For the variables are two or four-byte modes available. We use the
    four-byte mode addresses, so do we. In that case element count has to be
    double the variables read.
    """"""

    functions = {""read"": 0x03, ""writeMultiple"": 0x10, ""writeSingle"": 0x06, ""echo"": 0x08}

    byteMode = 4

    def __init__(self, *args, **kwargs):
        """"""
        The TC038 is a crystal oven.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.hcp.TC038.open_serial('COM10')
        >>> inst.setpoint = 45.3
        >>> print(inst.temperature)
        """"""
        super().__init__(*args, **kwargs)
        self.addr = 1

    @staticmethod
    def CRC16(data):
        """"""Calculate the CRC16 checksum for the data byte array.""""""
        CRC = 0xFFFF
        for octet in data:
            CRC ^= octet
            for j in range(8):
                lsb = CRC & 0x1  # least significant bit
                CRC = CRC >> 1
                if lsb:
                    CRC ^= 0xA001
        return [CRC & 0xFF, CRC >> 8]

    def readRegister(self, address, count=1):
        """"""Read count variables from start address on.""""""
        # Count has to be double the number of elements in 4-byte-mode.
        count *= self.byteMode // 2
        data = [self.addr]
        data.append(self.functions[""read""])  # function code
        data += [address >> 8, address & 0xFF]  # 2B address
        data += [count >> 8, count & 0xFF]  # 2B number of elements
        data += self.CRC16(data)
        self._file.write_raw(bytes(data))
        # Slave address, function, length
        got = self.read_raw(3)
        if got[1] == self.functions[""read""]:
            length = got[2]
            # data length, 2 Byte CRC
            read = self.read_raw(length + 2)
            if read[-2:] != bytes(self.CRC16(got + read[:-2])):
                raise ConnectionError(""Response CRC does not match."")
            return read[:-2]
        else:  # an error occurred
            end = self.read_raw(2)  # empty the buffer
            if got[2] == 0x02:
                raise ValueError(""The read start address is incorrect."")
            if got[2] == 0x03:
                raise ValueError(""The number of elements exceeds the allowed range"")
            raise ConnectionError(f""Unknown read error. Received: {got} {end}"")

    def writeMultiple(self, address, values):
        """"""Write multiple variables.""""""
        data = [self.addr]
        data.append(self.functions[""writeMultiple""])  # function code
        data += [address >> 8, address & 0xFF]  # 2B address
        if isinstance(values, int):
            data += [0x0, self.byteMode // 2]  # 2B number of elements
            data.append(self.byteMode)  # 1B number of write data
            for i in range(self.byteMode - 1, -1, -1):
                data.append(values >> i * 8 & 0xFF)
        elif hasattr(values, ""__iter__""):
            elements = len(values) * self.byteMode // 2
            data += [elements >> 8, elements & 0xFF]  # 2B number of elements
            data.append(len(values) * self.byteMode)  # 1B number of write data
            for element in values:
                for i in range(self.byteMode - 1, -1, -1):
                    data.append(element >> i * 8 & 0xFF)
        else:
            raise ValueError(
                ""Values has to be an integer or an iterable of ""
                f""integers. values: {values}""
            )
        data += self.CRC16(data)
        self._file.write_raw(bytes(data))
        got = self.read_raw(2)
        # slave address, function
        if got[1] == self.functions[""writeMultiple""]:
            # start address, number elements, CRC; each 2 Bytes long
            got += self.read_raw(2 + 2 + 2)
            if got[-2:] != bytes(self.CRC16(got[:-2])):
                raise ConnectionError(""Response CRC does not match."")
        else:
            end = self.read_raw(3)  # error code and CRC
            errors = {
                0x02: ""Wrong start address"",
                0x03: ""Variable data error"",
                0x04: ""Operation error"",
            }
            raise ValueError(errors[end[0]])

    @property
    def setpoint(self):
        """"""Get the current setpoint in °C.""""""
        value = int.from_bytes(self.readRegister(0x106), byteorder=""big"") / 10
        return u.Quantity(value, u.degC)

    @setpoint.setter
    def setpoint(self, value):
        """"""Set the setpoint in °C.""""""
        number = assume_units(value, u.degC).to(u.degC).magnitude
        value = int(round(value.to(""degC"").magnitude * 10, 0))
        self.writeMultiple(0x106, int(round(number * 10)))

    @property
    def temperature(self):
        """"""Get the current temperature in °C.""""""
        value = int.from_bytes(self.readRegister(0x0), byteorder=""big"") / 10
        return u.Quantity(value, u.degC)
"
196,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attH1B9TOst5XXL94'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Fmjgf3MeorZZ8bER9S8ZPg/YzvKt6gzmqvAcZDAl09fwXQQtsuovuTndZ-dntBpSTUTlVu6MlfQFbDQwXNFicvf8yk0sDMdNx_eHbqpgjTZN5mDoxp919lWoB_svDusS3s/sk1_K56YiHFoBz3ISbSLeg4m-o2jCnOwuzE_5sln2G8'), ('filename', 'tds500.jpeg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_BJ6wfbMwdhpHnrcnuGreA/tIjQIFAf_5NjXrMyM3EGnUZpchZLRgwOU0TqXBgeC5VwlVDoNxxXMw5qsmHN1YdH4wLMvcqw3VmWPlXOg21duA/PHfKgYliIp5RLY6yoaieQYNrBPKhvcj3dnLvzp39NlQ'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cJfnyYePsJHKc7agKIugUg/4Z-HmBDtnrWqPTlFsk_AUbFQqyUn7hgpm9UOVYiU4iZHpxni-SjnlfB_uRRcao6G9nFsfhpZsR5Rxdm-GdhCAw/F9GFd3SuFXPEe07KTF_cBNyku3VDIyIw7Gpc1iqaoQ0'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/McqJaFF8SQndukRAADgt6w/4NU_vBY5arDUNr0wLVrcoPMBX5JMMK9Sns36gKihfIJVWgzgnUobVJAjp8Rw1vD0EXMvhFQFBTUmFZZUt1KuAg/frs8WCJRvPn_d5BzscGKoW7RpXVW8bsH_zR5MVW4e8E'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,,,Tektds 5 XX,546.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tektds5xx.html,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/intro.html,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782600/Instruments/Oscilloscopes/TDS5XX/TDS5XX.jpg,TDS5XX,Write a Python script that uses Instrumentkit to connect to a TDS5XX Oscilloscopes,,,,,
197,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-3000z-oscilloscope-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attVTXwZRFz6jxMyZ'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3g-DNskAMkvkULpV7_ldjQ/HqBODZWFIFvl-HAQtTaUKISh9CBiCojNs47oX46uBkTxQyXPEIjWfG-cWio20I3UU0hu9O-GIkvGa9jIWaxA0dC3glZUUUzOKxi1OgKHQLY/VCYKnXIpEKV0o0V-A-2a0cd9f9uwMS2b1PoM1I6uaR8'), ('filename', 'WAVESURFER-3014Z_DSL.jpg'), ('size', 31613), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZrD3qZnMpKXbSc30bXj3dA/RiWLegNzD8k_Sy2z60Sl69svQVPh5SSTS7nGdvX9ZFEb-i6i0tZqh54z5LU4iDr7LFJIpsdOE0tHedxSqHV9cA/Qe9jCwkY6qyKoSXpnOm9cAQFwgyQeRh_iOm3vxiygIg'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ry1d50-umTK_kxYogMFJuw/0Z8eb_0k_SQFp6FQdLmyucM2uWrs5ZbmdVOzEG_6_6J04dQdWUmPWUUMevd3oQNFmmFXddf4momTHIJHjmhw7g/l_rUiYKfzSyLlDFg2dQjv_cB38tkoLMo8jKDWbZyMoE'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IaHF3Lw-O8zsCqLyhVU6Zg/amun63e9sbi7oXFqEx9oW7GTMdErW_ZpDa5JRFwk3PZvY0T-m89BS2nu6UkKq4NMCkFdSABDz9oHltxM0cj_kA/EFf4MYO1T_0sdd3FmkTkJG-XTG8vOaauFASdTZaiPwc'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"The WaveSurfer 3000z has a 10.1"" capacitive touch display, the longest memory, and the deepest toolbox – all at an affordable price.",https://www.teledynelecroy.com/oscilloscope/wavesurfer-3000z-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782601/Instruments/Oscilloscopes/WaveSurfer-3000z/WaveSurfer-3000z.jpg,WaveSurfer 3000z,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 3000z Oscilloscopes,5780.0,,,Price from this website: https://www.globaltestsupply.com/online/teledyne-lecroy-wavesurfer-3000z-oscilloscopes,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
201,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-4000hd-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attSL7iJBGpDPbEEX'), ('width', 740), ('height', 667), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eUjNkecfIKWUV1Y9hwa_yQ/ZmnsQ8DHGqHR1kRZXIWiuq_sVymbBXeVFummzZnM0ESxYV0f44edoQ2uV1eCOExqFDJAjq2n1f8nQ84IMPJsuZaQtXu2-SulQnNCo6ZnOC8/K9WswaRXZbJ0-rJrvl-lzkSMLUn5B2cXZtEEPO-1znI'), ('filename', 'ws4000hd-img-1.2.webp'), ('size', 68826), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1HJ8cGVI32SindOp42ANZQ/0Mqs4EOYTMK4hxOAazyv23Ya-zMAErgdXXWDDTgXlKzo4Wd8B6geRvNDZZe0PmYnJF3xp72U44CFP_YYu-PhjVmGGsCFnjkLMcSyc9vGUUA/uJlRlcyD2aawOyxVHpsJPIATOeqx9ZfyMaJVtXtRM34'), ('width', 40), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F0pzpm3btsE1ibnN6CLQpQ/mGUfX5WX9sf_lEa9mLdwjqTkxOD1POSHRABAylab_MQ4kSqPWREAIxPx9g7zt377JdLfJQcxJwe2qMyY4sfkVcKp_yTiHWD2_VqYdxE3DsY/pC7UXT94rCshZDNYyOyi2tMzzrRCaZaJWUBPGRfd_iA'), ('width', 568), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OHR70ijnWkzzayg5lmqUlw/sis0troMp6pNpskrLqInrrUZ9Eh2k8ogZFFWeqbkbGHwVd8RLs82ur7i3vinurI3YjtJeZ_3ouz3bgVCJd9YITnv7XZYg29i2N8XUxWDmU0/wO20pJBPFMDgZRVJQHTwv48gHARB-lLl4xQA3e7iI9g'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"WaveSurfer 4000HD extends Teledyne LeCroy’s leadership in High Definition Oscilloscopes with a bright, 12.1” touch screen display, performance without compromise, and price points that fit your budget.",https://www.teledynelecroy.com/oscilloscope/wavesurfer-4000hd-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782604/Instruments/Oscilloscopes/WaveSurfer-4000HD/WaveSurfer-4000HD.webp,WaveSurfer 4000HD,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 4000HD Oscilloscopes,8850.0,,,price from here: https://www.globaltestsupply.com/,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
224,https://www.xppower.com/portals/0/pdfs/SF_FJ.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attkmac7fxPBBo0P7'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-mOA6OGY7od3ycB17utqtQ/sb3mDIO4oVetQOzSP77q6Q4g9b6Pv7MOIq9PyPeaIJJ6gJjqhH8Lj4X6YOm6TwT1-zynUieJY84YWZ2U74xq9vNXDCnyVNjI26mNoTXJ_Uw/MQdPk7kSXjM5gwLJls88gd57GlrfqsrEeH4nUfh0ZEE'), ('filename', 'FJ_prod_lrg.webp'), ('size', 34698), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PMJWbVsXb3oeYKOp7UHOfw/mukegF5hzTtKT0dONDpcXC4gINBGYrDwIY8Hg7uv1n0j8Qm8paWU64O4WoLWIW7ZyzOYRRE0_5wG17ET5j2rGJ-Srj2K0zh93H3Medtl1Zc/mEjkpCqZjSmeBT0yoa5y-nDV64BKMnrg8E05jhToVK4'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9GGr5uhRn0_sBhU01zvPFg/lkyIckandePhF6aC6Tv7-QUKw62Nfi5xDw5ysXpuUvKPiCT8sqm8-HjR2AIqWP-0DcNyLriJat6xx7YM9SoiK59ShwPxNR_2rASMY3JCms0/d2ejpWoCI_9OjTSBkt2iRNfzocRtuSTN8excwI_AMAA'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zg3GuXduIgBc1-v-V_S3Yg/tn3Q8S1EgyHUqtI8VHpY6Dli85pDfwV3CuOxe-YfqgXMs-mnSMwwj6GvXZ6O1ZCsMma17nN9jOklBjZQT_SL_-XzV4oOtQ6QInf86hc8oI8/9vHH1woUqITcEsbqsJ-80sF5kwyEDMs9cf3NVMmnl80'), ('width', 3000), ('height', 3000)]))]))])]",295.0,Singapore,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125998/Instruments/Vendor%20Logos/Glassman.png,FJ Series - 120W regulated high voltage AC-DC power supplies with outputs from 0 - 1kVDC to 0 - 60kVDC,https://www.xppower.com/product/FJ-Series,"XP GlassMan FJ

",141.0,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,"Looking for the leading manufacturer of AC-DC **power** supplies, DC-DC converters, high voltage, RF & custom **power** products? Discover our extensive range.

",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/glassman/glassmanfr.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/glassman.html#glassmanfr-single-output-power-supply,Glassman,"[OrderedDict([('id', 'attQ9jak9WrU3JbmU'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_M7hsxGq6fYHH5u1gAO90w/y1gux2vSmI1GB1qXG1HxrHTpTzxEXHGhBpsAmzKHT_NC4RhF-7WRRNC_xkjOG2ySETSLQ5kGttcDC-Hjfx9E3mcIwpZz69FYG6oNYbbS8co/I0etOK6XLu06xfp6rhWDANe2nquqrjghTM4G1uZ68Vc'), ('filename', 'XP_Power.png'), ('size', 5633), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/r-lpmEJIArWWHmfG8nMEag/DrBsb6EkskmxJBU-0rHVEMoBIhalvcqHsc1RQ7BjziN69ZLNqNkjlrLuq-tlZVd3cdwFa9oCyOjxyyYe0JvNRA/FEddDL_yI5UE6zQs-stNu8aE1m8g6xzk2HJcI-GYWXs'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s2HMAnGyXOaVkgBtFti0Rw/fgQSL8ZUlA1EZClMNta7UMrhjR50b5AamMHfuETaE4NZuhSWLrvh5vhbbskz2uU4SE59XEbTLgQ23fdK3vgfaQ/HQs6bkYvF-CCs4BbvkJzwgPZ1Xw1jnMZDDHC35NpDBg'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/sg0njRLyuLDnNxwbU8P6KQ/_VuSY9e7dTQ5d-WjoK-mg3znEQk9xaaeUMncuh3WeuXZxGMS22trMsdu4wDEGIyjL9Ikq0pdIXRGzqbEesJBow/tbgdkr6KW2tvEUdOOXsr5_28g75STlYcJaMLfyEValw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.xppower.com,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782626/Instruments/Power%20Supplies/FJ-Series/FJ-Series.webp,FJ Series,Write a Python script that uses Instrumentkit to connect to a FJ Series Power Supplies,,,,Python Package for a Series of Products,"#!/usr/bin/env python
#
# hpe3631a.py: Driver for the Glassman FR Series Power Supplies
#
# © 2019 Francois Drielsma (francois.drielsma@gmail.com).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the Glassman FR Series Power Supplies

Originally contributed and copyright held by Francois Drielsma
(francois.drielsma@gmail.com)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""
# IMPORTS #####################################################################

from struct import unpack
from enum import Enum

from instruments.abstract_instruments import PowerSupply
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class GlassmanFR(PowerSupply, PowerSupply.Channel):

    """"""
    The GlassmanFR is a single output power supply.

    Because it is a single channel output, this object inherits from both
    PowerSupply and PowerSupply.Channel.

    This class should work for any of the Glassman FR Series power supplies
    and is also likely to work for the EJ, ET, EY and FJ Series which seem
    to share their communication protocols. The code has only been tested
    by the author with an Glassman FR50R6 power supply.

    Before this power supply can be remotely operated, remote communication
    must be enabled and the HV must be on. Please refer to the manual.

    Example usage:

    >>> import instruments as ik
    >>> psu = ik.glassman.GlassmanFR.open_serial('/dev/ttyUSB0', 9600)
    >>> psu.voltage = 100 # Sets output voltage to 100V.
    >>> psu.voltage
    array(100.0) * V
    >>> psu.output = True # Turns on the power supply
    >>> psu.voltage_sense < 200 * u.volt
    True

    This code uses default values of `voltage_max`, `current_max` and
    `polarity` that are only valid of the FR50R6 in its positive setting.
    If your power supply differs, reset those values by calling:

    >>> import instruments.units as u
    >>> psu.voltage_max = 40.0 * u.kilovolt
    >>> psu.current_max = 7.5 * u.milliamp
    >>> psu.polarity = -1
    """"""

    def __init__(self, filelike):
        """"""
        Initialize the instrument, and set the properties needed for communication.
        """"""
        super().__init__(filelike)
        self.terminator = ""\r""
        self.voltage_max = 50.0 * u.kilovolt
        self.current_max = 6.0 * u.milliamp
        self.polarity = +1
        self._device_timeout = False
        self._voltage = 0.0 * u.volt
        self._current = 0.0 * u.amp

    # ENUMS ##

    class Mode(Enum):
        """"""
        Enum containing the possible modes of operations of the instrument
        """"""

        #: Constant voltage mode
        voltage = ""0""
        #: Constant current mode
        current = ""1""

    class ResponseCode(Enum):
        """"""
        Enum containing the possible reponse codes returned by the instrument.
        """"""

        #: A set command expects an acknowledge response (`A`)
        S = ""A""
        #: A query command expects a response packet (`R`)
        Q = ""R""
        #: A version query expects a different response packet (`B`)
        V = ""B""
        #: A configure command expects an acknowledge response (`A`)
        C = ""A""

    class ErrorCode(Enum):
        """"""
        Enum containing the possible error codes returned by the instrument.
        """"""

        #: Undefined command received (not S, Q, V or C)
        undefined_command = ""1""
        #: The checksum calculated by the instrument does not correspond to the one received
        checksum_error = ""2""
        #: The command was longer than expected
        extra_bytes = ""3""
        #: The digital control byte set was not one of HV On, HV Off or Power supply Reset
        illegal_control = ""4""
        #: A send command was sent without a reset byte while the power supply is faulted
        illegal_while_fault = ""5""
        #: Command valid, error while executing it
        processing_error = ""6""

    # PROPERTIES ##

    @property
    def channel(self):
        """"""
        Return the channel (which in this case is the entire instrument, since
        there is only 1 channel on the GlassmanFR.)

        :rtype: 'tuple' of length 1 containing a reference back to the parent
            GlassmanFR object.
        """"""
        return [self]

    @property
    def voltage(self):
        """"""
        Gets/sets the output voltage setting.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        return self.polarity * self._voltage

    @voltage.setter
    def voltage(self, newval):
        self.set_status(voltage=assume_units(newval, u.volt))

    @property
    def current(self):
        """"""
        Gets/sets the output current setting.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `float` or `~pint.Quantity`
        """"""
        return self.polarity * self._current

    @current.setter
    def current(self, newval):
        self.set_status(current=assume_units(newval, u.amp))

    @property
    def voltage_sense(self):
        """"""
        Gets the output voltage as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `~pint.Quantity`
        """"""
        return self.get_status()[""voltage""]

    @property
    def current_sense(self):
        """"""
        Gets/sets the output current as measured by the sense wires.

        :units: As specified, or assumed to be :math:`\\text{A}` otherwise.
        :type: `~pint.Quantity`
        """"""
        return self.get_status()[""current""]

    @property
    def mode(self):
        """"""
        Gets/sets the mode for the specified channel.

        The constant-voltage/constant-current modes of the power supply
        are selected automatically depending on the load (resistance)
        connected to the power supply. If the load greater than the set
        V/I is connected, a voltage V is applied and the current flowing
        is lower than I. If the load is smaller than V/I, the set current
        I acts as a current limiter and the voltage is lower than V.

        :type: `GlassmanFR.Mode`
        """"""
        return self.get_status()[""mode""]

    @property
    def output(self):
        """"""
        Gets/sets the output status.

        This is a toggle setting. True will turn on the instrument output
        while False will turn it off.

        :type: `bool`
        """"""
        return self.get_status()[""output""]

    @output.setter
    def output(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Output status mode must be a boolean."")
        self.set_status(output=newval)

    @property
    def fault(self):
        """"""
        Gets the output status.

        Returns True if the instrument has a fault.

        :type: `bool`
        """"""
        return self.get_status()[""fault""]

    @property
    def version(self):
        """"""
        The software revision level of the power supply's
        data intereface via the `V` command

        :rtype: `str`
        """"""
        return self.query(""V"")

    @property
    def device_timeout(self):
        """"""
        Gets/sets the timeout instrument side.

        This is a toggle setting. ON will set the timeout to 1.5
        seconds while OFF will disable it.

        :type: `bool`
        """"""
        return self._device_timeout

    @device_timeout.setter
    def device_timeout(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Device timeout mode must be a boolean."")
        self.query(f""C{int(not newval)}"")  # Device acknowledges
        self._device_timeout = newval

    # METHODS ##

    def sendcmd(self, cmd):
        """"""
        Overrides the default `setcmd` by padding the front of each
        command sent to the instrument with an SOH character and the
        back of it with a checksum.

        :param str cmd: The command message to send to the instrument
        """"""
        checksum = self._get_checksum(cmd)
        self._file.sendcmd(""\x01"" + cmd + checksum)  # Add SOH and checksum

    def query(self, cmd, size=-1):
        """"""
        Overrides the default `query` by padding the front of each
        command sent to the instrument with an SOH character and the
        back of it with a checksum.

        This implementation also automatically check that the checksum
        returned by the instrument is consistent with the message. If
        the message returned is an error, it parses it and raises.

        :param str cmd: The query message to send to the instrument
        :param int size: The number of bytes to read back from the instrument
            response.
        :return: The instrument response to the query
        :rtype: `str`
        """"""
        self.sendcmd(cmd)
        result = self._file.read(size)
        if result[0] != getattr(self.ResponseCode, cmd[0]).value and result[0] != ""E"":
            raise ValueError(f""Invalid response code: {result}"")
        if result[0] == ""A"":
            return ""Acknowledged""
        if not self._verify_checksum(result):
            raise ValueError(f""Invalid checksum: {result}"")
        if result[0] == ""E"":
            error_name = self.ErrorCode(result[1]).name
            raise ValueError(f""Instrument responded with error: {error_name}"")

        return result[1:-2]  # Remove SOH and checksum

    def reset(self):
        """"""
        Reset device to default status (HV Off, V=0.0, A=0.0)
        """"""
        self.set_status(reset=True)

    def set_status(self, voltage=None, current=None, output=None, reset=False):
        """"""
        Sets the requested variables on the instrument.

        This instrument can only set all of its variables simultaneously,
        if some of them are omitted in this function, they will simply be
        kept as what they were set to previously.
        """"""
        if reset:
            self._voltage = 0.0 * u.volt
            self._current = 0.0 * u.amp
            cmd = format(4, ""013d"")
        else:
            # The maximum value is encoded as the maximum of three hex characters (4095)
            cmd = """"
            value_max = int(0xFFF)

            # If the voltage is not specified, keep it as is
            voltage = (
                assume_units(voltage, u.volt) if voltage is not None else self.voltage
            )
            ratio = float(voltage.to(u.volt) / self.voltage_max.to(u.volt))
            voltage_int = int(round(value_max * ratio))
            self._voltage = self.voltage_max * float(voltage_int) / value_max
            assert 0.0 * u.volt <= self._voltage <= self.voltage_max
            cmd += format(voltage_int, ""03X"")

            # If the current is not specified, keep it as is
            current = (
                assume_units(current, u.amp) if current is not None else self.current
            )
            ratio = float(current.to(u.amp) / self.current_max.to(u.amp))
            current_int = int(round(value_max * ratio))
            self._current = self.current_max * float(current_int) / value_max
            assert 0.0 * u.amp <= self._current <= self.current_max
            cmd += format(current_int, ""03X"")

            # If the output status is not specified, keep it as is
            output = output if output is not None else self.output
            control = f""00{int(output)}{int(not output)}""
            cmd += format(int(control, 2), ""07X"")

        self.query(""S"" + cmd)  # Device acknowledges

    def get_status(self):
        """"""
        Gets and parses the response packet.

        Returns a `dict` with the following keys:
        ``{voltage,current,mode,fault,output}``

        :rtype: `dict`
        """"""
        return self._parse_response(self.query(""Q""))

    def _parse_response(self, response):
        """"""
        Parse the response packet returned by the power supply.

        Returns a `dict` with the following keys:
        ``{voltage,current,mode,fault,output}``

        :param response: Byte string to be unpacked and parsed
        :type: `str`

        :rtype: `dict`
        """"""
        (voltage, current, monitors) = unpack(""@3s3s3x1c2x"", bytes(response, ""utf-8""))

        try:
            voltage = self._parse_voltage(voltage)
            current = self._parse_current(current)
            mode, fault, output = self._parse_monitors(monitors)
        except:
            raise RuntimeError(""Cannot parse response "" ""packet: {}"".format(response))

        return {
            ""voltage"": voltage,
            ""current"": current,
            ""mode"": mode,
            ""fault"": fault,
            ""output"": output,
        }

    def _parse_voltage(self, word):
        """"""
        Converts the three-bytes voltage word returned in the
        response packet to a single voltage quantity.

        :param word: Byte string to be parsed
        :type: `bytes`

        :rtype: `~pint.Quantity`
        """"""
        value = int(word.decode(""utf-8""), 16)
        value_max = int(0x3FF)
        return self.polarity * self.voltage_max * float(value) / value_max

    def _parse_current(self, word):
        """"""
        Converts the three-bytes current word returned in the
        response packet to a single current quantity.

        :param word: Byte string to be parsed
        :type: `bytes`

        :rtype: `~pint.Quantity`
        """"""
        value = int(word.decode(""utf-8""), 16)
        value_max = int(0x3FF)
        return self.polarity * self.current_max * float(value) / value_max

    def _parse_monitors(self, word):
        """"""
        Converts the monitors byte returned in the response packet
        to a mode, a fault boolean and an output boolean.

        :param word: Byte to be parsed
        :type: `byte`

        :rtype: `str, bool, bool`
        """"""
        bits = format(int(word, 16), ""04b"")
        mode = self.Mode(bits[-1])
        fault = bits[-2] == ""1""
        output = bits[-3] == ""1""
        return mode, fault, output

    def _verify_checksum(self, word):
        """"""
        Calculates the modulo 256 checksum of a string of characters
        and compares it to the one returned by the instrument.

        Returns True if they agree, False otherwise.

        :param word: Byte string to be checked
        :type: `str`

        :rtype: `bool`
        """"""
        data = word[1:-2]
        inst_checksum = word[-2:]
        calc_checksum = self._get_checksum(data)
        return inst_checksum == calc_checksum

    @staticmethod
    def _get_checksum(data):
        """"""
        Calculates the modulo 256 checksum of a string of characters.
        This checksum, expressed in hexadecimal, is used in every
        communication of this instrument, as a sanity check.

        Returns a string corresponding to the hexademical value
        of the checksum, without the `0x` prefix.

        :param data: Byte string to be checksummed
        :type: `str`

        :rtype: `str`
        """"""
        chrs = list(data)
        total = 0
        for c in chrs:
            total += ord(c)

        return format(total % 256, ""02X"")
"
225,,https://en.wikipedia.org/wiki/Function_generator#Function_generator,"[OrderedDict([('id', 'atthHXPfbt5sZJn0O'), ('width', 560), ('height', 560), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/c1HG7hro-O2eFjeqSuSb6A/RDGfpeo_M34dXmpxyjlBslZMl0DJEwvGP8o7ZFt4TLJxSildoQHu7OIszO_Urq3V9NAkRCJhiQrMohboxO29SA/3AAbUw5BE6qfBUoWrf0AfTPc9vjN18Bnn2wCp5EgL6s'), ('filename', 'raw.jpg'), ('size', 92012), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/G3L9NxtiWur4bYgmZ237Zg/KvoEw8gemkE84rgHDaILMfD0by02N_ttqz-Pod8MzZ6A2WqT5RlqIfuiST6ELC_oG2oCyjtKh_lW9alGmMC6Rg/lDcIsS-wNi92LqnH_1-qnc3sDeh1DSMJii1an2MtqHc'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/POqhae0Pyqo2ULGAdWfN8g/JQFfU0ONXWkiTuyHgVeGz1iOPDBt7lIqJAM-gTNLxNYkyKJ-NuchPYs5iwgBXN2bAG0xO6MxYbmlwaii2rOOAA/f7lymV2Ny4ErvL5dmCNElE0QE4ziQYUvDbj0zZWUOyI'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Mu9DvfycTX_nZ-SZujCmWg/pUD-SDBt_F4SCRNGzcwFWzneOj4YuPVeYVyCyJsvvfbHOPodUFXQneqtfiy7goYDXAylWl901tnsa2Hwdcqx-g/XJ5IQ78SkIJJAzNg9SgOhh8E2_J6ipVKpFvYnut6Gno'), ('width', 3000), ('height', 3000)]))]))])]",,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692142672/Instruments/Vendor%20Logos/FLOJOY_TEXT.png,"MHS-5200A series instruments using large scale integrated circuits andhigh-speed FPGA MCU microprocessor, the internal circuit to take surface mounttechnology has greatly enhanced the instrument's noise immunity and service life.Display interface using LC1602 LCD display is divided into two lines, the top lineshows the current frequency, the following line displays additional parameters orfunction variable and flexible use of flip key setting, greatly enhances the operability.",https://www.manualslib.com/manual/1302069/Minghe-Instruments-Mhs-5200a-Series.html?page=3#manual,MHS 5200 A,370.0,['Function Generators'],"A function generator is electronic test equipment that generates standard waveforms, such as sine, square, ramp, or sawtooth waves, to a device under test (DUT).","Could not find

",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/minghe/mhs5200a.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/minghe.html,Minghe,"[OrderedDict([('id', 'attJoEjL7HtaAtqwT'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/m81LgKTA7wEZW0xemS9geA/2KYm38F6T2KR3ibKRgz1PwCMZCdOIMzRR0uBy_BjaVogVe47-XdLmhgXsjNNzcjVt0qHnlS0cykoeWcJ2X5ZNv4NkViVK9atsQjeP2PuXq0/lT-TQ2wfvQBA0OQtdbbE3AJSt_p30QMLOM9tUaiWoyU'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/as0DLL1a3tCxAJvnoQDhEg/t0RJIZnwXCVzNBiymc87kxcj86JBRZFjDNbsYxVj7CwnOOcEvap70jmrA71ELA8QLz-DWDqPp4wBvZCQyX5LEQ/2ibA5DHVWPd6iXImqjL-vLhNIHqqoSZ-yY7GYeoySdg'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HB5oZmYizdZmqGCP6O-Rhw/G36Qk2Yv3vUzHyMdHfa1S5qO43h3lXpO8zGWMNpQQ71HxuucGdQK1oAx-xH2O2MWX84Bv17iEO0ESaFncFUWlQ/CgJIXgb5iAo-wRj-9MWxWWLQ9VsDnrzMnuYLFUaFowM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_vooZ9-OamJpBOe4wtvPow/9zlTJl1hU-ryANvZ-_Sr0_3Ml9AK17cxpt2lLJYjnw4zqAFIdvbBtdR1cBYGeamUSu0EwPFUaLICOlpgoWGmQQ/bhewOXZVFl8rHPmaor5s-0bG6z7fIRSrHbcaeIspglY'), ('width', 3000), ('height', 3000)]))]))])]",https://sigrok.org/wiki/MHINSTEK_MHS-5200A,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782627/Instruments/Function%20Generators/MHS-5200-A/MHS-5200-A.jpg,MHS 5200 A,Write a Python script that uses Instrumentkit to connect to a MHS 5200 A Function Generators,,,True,,"#!/usr/bin/env python
""""""
Provides the support for the MingHe low-cost function generator.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import FunctionGenerator
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units

# CLASSES #####################################################################


class MHS5200(FunctionGenerator):
    """"""
    The MHS5200 is a low-cost, 2 channel function generator.

    There is no user manual, but Al Williams has reverse-engineered the
    communications protocol:
    https://github.com/wd5gnr/mhs5200a/blob/master/MHS5200AProtocol.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._channel_count = 2
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if msg.find("":r"") == 0:
            return None
        # most commands res
        return ""ok""

    # INNER CLASSES #

    class Channel(FunctionGenerator.Channel):
        """"""
        Class representing a channel on the MHS52000.
        """"""

        # pylint: disable=protected-access

        __CHANNEL_NAMES = {1: ""1"", 2: ""2""}

        def __init__(self, mhs, idx):
            self._mhs = mhs
            super().__init__(parent=mhs, name=idx)
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        def _get_amplitude_(self):
            query = f"":r{self._chan}a""
            response = self._mhs.query(query)
            return float(response.replace(query, """")) / 100.0, self._mhs.VoltageMode.rms

        def _set_amplitude_(self, magnitude, units):
            if (
                units == self._mhs.VoltageMode.peak_to_peak
                or units == self._mhs.VoltageMode.rms
            ):
                magnitude = assume_units(magnitude, ""V"").to(u.V).magnitude
            elif units == self._mhs.VoltageMode.dBm:
                raise NotImplementedError(""Decibel units are not supported."")
            magnitude *= 100
            query = f"":s{self._chan}a{int(magnitude)}""
            self._mhs.sendcmd(query)

        @property
        def duty_cycle(self):
            """"""
            Gets/Sets the duty cycle of this channel.

            :units: A fraction
            :type: `float`
            """"""
            query = f"":r{self._chan}d""
            response = self._mhs.query(query)
            duty = float(response.replace(query, """")) / 10.0
            return duty

        @duty_cycle.setter
        def duty_cycle(self, new_val):
            query = f"":s{self._chan}d{int(100.0 * new_val)}""
            self._mhs.sendcmd(query)

        @property
        def enable(self):
            """"""
            Gets/Sets the enable state of this channel.

            :type: `bool`
            """"""
            query = f"":r{self._chan}b""
            return int(self._mhs.query(query).replace(query, """").replace(""\r"", """"))

        @enable.setter
        def enable(self, newval):
            query = f"":s{self._chan}b{int(newval)}""
            self._mhs.sendcmd(query)

        @property
        def frequency(self):
            """"""
            Gets/Sets the frequency of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units hertz.
            :type: `~pint.Quantity`
            """"""
            query = f"":r{self._chan}f""
            response = self._mhs.query(query)
            freq = float(response.replace(query, """")) * u.Hz
            return freq / 100.0

        @frequency.setter
        def frequency(self, new_val):
            new_val = assume_units(new_val, u.Hz).to(u.Hz).magnitude * 100.0
            query = f"":s{self._chan}f{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def offset(self):
            """"""
            Gets/Sets the offset of this channel.

            The fraction of the duty cycle to offset the function by.

            :type: `float`
            """"""
            # need to convert
            query = f"":r{self._chan}o""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) / 100.0 - 1.20

        @offset.setter
        def offset(self, new_val):
            new_val = int(new_val * 100) + 120
            query = f"":s{self._chan}o{new_val}""
            self._mhs.sendcmd(query)

        @property
        def phase(self):
            """"""
            Gets/Sets the phase of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of degrees.
            :type: `~pint.Quantity`
            """"""
            # need to convert
            query = f"":r{self._chan}p""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) * u.deg

        @phase.setter
        def phase(self, new_val):
            new_val = assume_units(new_val, u.deg).to(""deg"").magnitude
            query = f"":s{self._chan}p{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def function(self):
            """"""
            Gets/Sets the wave type of this channel.

            :type: `MHS5200.Function`
            """"""
            query = f"":r{self._chan}w""
            response = self._mhs.query(query).replace(query, """")
            return self._mhs.Function(int(response))

        @function.setter
        def function(self, new_val):
            query = f"":s{self._chan}w{self._mhs.Function(new_val).value}""
            self._mhs.sendcmd(query)

    class Function(Enum):
        """"""
        Enum containing valid wave modes for
        """"""

        sine = 0
        square = 1
        triangular = 2
        sawtooth_up = 3
        sawtooth_down = 4

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> import instruments as ik
        >>> mhs = ik.minghe.MHS5200.open_serial(vid=1027, pid=24577,
        baud=19200, timeout=1)
        >>> print(mhs.channel[0].frequency)

        :rtype: `list`[`MHS5200.Channel`]
        """"""
        return ProxyList(self, MHS5200.Channel, range(self._channel_count))

    @property
    def serial_number(self):
        """"""
        Get the serial number, as an int

        :rtype: int
        """"""
        query = "":r0c""
        response = self.query(query)
        response = response.replace(query, """").replace(""\r"", """")
        return response

    def _get_amplitude_(self):
        raise NotImplementedError()

    def _set_amplitude_(self, magnitude, units):
        raise NotImplementedError()
"
229,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_340_l.pdf?sfvrsn=ad773cdf_1,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'atthNL1cSca5MCqeq'), ('width', 505), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZPL1_b6fRmIrxBe4y81gLQ/oueBHKRuGBDG-sY0L90VYmVlfWPxWFUvMWJ3yMiNPY6XMqlhoVTfXTzvit4YnRcvV4Y1S9qMWE5mCRoHi7TvNw/Ewdr8WnugHu3GPPRHPpERyFyu95Zx3oCYjrBDYMsu8w'), ('filename', '340.png'), ('size', 89525), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pU3X_99-PnQ40tE2LLACRg/okysoxkIl-KD9bjFIP4CfoH9PicohczB4nTtXM_43ilDK8PRj6WvEghZ3lvPzYy6cLVrnv9aHS8lMLc6YoQhtg/s0srnPF7v8lx9hk0OuQwysUopy-WWOEri6mW4JaT3iw'), ('width', 114), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/m9VYDakwbSsTNqUZlj2d5Q/plbTVAG9N9wbOKnaL89u8QH0kVFOInpXBNy2P6cXV-mkauEjqTN3UobHEO-sK7uBXQR3uNuZ4vHfpgWFHFltkQ/qXHMCQPCLKbNXN7sRtPwg1C7qILRtSPLADS7j0qoguI'), ('width', 505), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vjbMKLKrVbOHkOHt_aiAUg/LHEV9aAKwSoY_yauB6ZIR8_sDtsYWGz4JpWQ8Sxd2j-I1yIEpLd0bZujehy7YSC_-w917pBIuPYpGsXllMSTnw/yJPi059ZcVzBwjmWyBVT-mn8Tf5lrL0sA4DhsqJEees'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 340 cryogenic temperature controller is our most advanced temperature controller and offers unsurpassed resolution, accuracy, and stability for temperature measurement and control applications to as low as 100 mK. Operating with diodes, platinum RTDs, and negative temperature coefficient (NTC) resistor sensors, the Model 340 is expandable to ten sensor inputs or to operate with thermocouple or capacitance sensors. It has two control loops, with the first loop powered to 100 W.",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-340-cryogenic-temperature-controller,Lakeshore 340,350.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore340.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore340-cryogenic-temperature-controller,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782630/Instruments/Temperature%20Controllers/Lakeshore-340/Lakeshore-340.png,Lakeshore 340,Write a Python script that uses Instrumentkit to connect to a Lakeshore 340 Temperature Controllers,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))
"
230,https://cdn.teledynelecroy.com/files/pdf/mda8000hd-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att8urLApvEdo7Bqk'), ('width', 260), ('height', 263), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rbZn01xjY5s5Iv11RXW31g/SQH5wOlWTdlV-fk8BwbwMqmPulLVlE288GqUeGFYm-uub28q_zlk15zahPJDTS1LjsSC68Y25BSXU4WpmLzUTVUidVfwn9kHeWQPjXEipmE/G7C0FucmD-9GQWMy5UdETFyOg17CnbE8-esmtTkn7p8'), ('filename', 'mda8000hd-title.webp'), ('size', 25102), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2b8j4p9T2TmHt71nTU0ODw/Yb_m8wkodiPJXRlnnhBMA2_fU8RHwx37GPl077sX76hwVqbliaUkMXOHYPeyesdtXSieBjjjMq0J18HOYQamRHUmhoPrhBDdfVYlTFUt8x4/3LvoHYoWdk03j82-TjrKCivIE0wUjG3QLBdaK38jprI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OARjE5hCp1zQ3Lx4IZ0UIA/KRjf5k69ijMt3eQoqhO-xqDhSFBqNQtVvFUWqeitKumNd5scdjjti-Z1mJmupB4E7lTzd6gFiQNu6wndXY0QrjbqAK60B9wkH9g8U9H4kQg/d62x9mxISypDMCColydV2bUNjOTNUvb0tvZ38hRgHQo'), ('width', 260), ('height', 263)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PusZsyemomtp68PrNNGHIw/ZWPDjoOc4CxbApLagiR-hhJGJ2KpUK01PcNIiXiynrRJbaqokRDcwIgCRpvrgKNkQYIQQr4KoenOLre2JRDFq2pfPQLdiBp27SWP713rEwU/zx072o933DkXleVEvSQV_cF-41p-SBwm2igpJqHUDhU'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"The Motor Drive Analyzer is built on an 8 channel, 12-bit resolution oscilloscope platform. It acquires any signal and performs three-phase electrical and mechanical power calculations. It provides complete power section and embedded control test coverage.",https://www.teledynelecroy.com/oscilloscope/mda-8000hd-motor-drive-analyzers,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782631/Instruments/Oscilloscopes/MDA8000HD/MDA8000HD.webp,MDA8000HD,Write a Python script that uses Instrumentkit to connect to a MDA8000HD Oscilloscopes,,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
239,https://cdn.tmi.yokogawa.com/IM735301-01E.pdf,https://en.wikipedia.org/wiki/Spectrum_analyzer,"[OrderedDict([('id', 'atttq1VLeer6131dE'), ('width', 800), ('height', 467), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pDR5_CntHQXQjQAC2Kwiag/dRfp-az1_r6jiHnAg93sM_ePmzJ4S8nmNdChlb5Wt8j0hya4uvEFocTZ-SJopRwNRR3vQHfjK9w4SYa-BPo4AOOtuEpPTc0lW6xFa-HYX9g/18Tqs0_DBTVqKu_bXhh2NV6-WKdV9YOV3byUvgO4N9U'), ('filename', 'AQ6370_Front_lg.jpg'), ('size', 262250), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zW2aLaQxGIBr__miosTaFA/TBhX3Qo4U3E5lXqRmeNtkh1IeEbnNthacfS4wf5Oxse5r37mX8R8y5upf8z_0LG1GBtWFYTloXNpEzybziVx7A/-kWiF5E-hGMyrkwI6UbaRV6Tl8q_fJxqw3Emq0gTdzc'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bALgTLyCvXKXUuY4yFn4lg/KoVeRsyQ_CnWpvaODSnKogDESFqoVgmYARoI7FO_tQMKIBN46ismY0E3jC_f-FUmFVujK3pXmrIf1zu8CwJvdQ/IADod_8Czmbqal8TKc6Lk7lns4BfBtHgJGrLnTkE3G8'), ('width', 800), ('height', 467)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/4D3JlL0MmkXM0MIKvT7zzw/GT6LC1cp-GVcEl6_2aFtB5FK_iNE-jEtK1uKEUVrSw5l4f28AT1Vim6kMXFCXt0JKDVK9io-9oePOSc-ZS-tyg/I2B1jgm6pYhXcu-1m2RJkYV6XiFZOrWbHJicb_AG-6o'), ('width', 3000), ('height', 3000)]))]))])]",318.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125993/Instruments/Vendor%20Logos/Yokogawa.png,The AQ6370 is Yokogawa's high speed and high performance Optical Spectrum Analyzer for characterization of optical communications system and optical components. Thirteen built-in optical viewer analysis functions and seven trace calculations for popular applications can be utilized with a simple function key. ,https://tmi.yokogawa.com/ca/solutions/discontinued/aq6370-optical-spectrum-analyzer/,Yokogawa 6370,634.0,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals.,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa6370.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa6370,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/91EkiaJqR32pXT_9j2ikkA/EA8IX6bgJJ5AWHxSJn_XsjdpYAbFM-YDdqUbrZWF93R43aeTp5aElLydj7HEdEh8wo2jzLCFOTdCKUYUpJSqs1zbr_NokqlVS5aCZUEOXdQ/4kbrVwXBbGOLMD1hKLvO7wdukSK2boAdCxBHEMhRvXw'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mLKN3BYMkiZUdn2rlRmVtw/cw3TDV5BlW5jr47wsWYGUsjqEQZbKDvc2mw_Lv9aXzgXtFoYC1bkplw5NhTSdUeNveYCSzsYG9fK-1b24lGzfQ/umhRd2RrT6tf47pL7QQ-NfYCvL9z9J5dB71Th5o0jzE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/a3VAY9DVGC-aEBfsilZ3xw/8a9ejY3MgpFLh3YMiQ-k86blOpOc7VPmtTlcvVeTvXbTwq9ckonmesZx3cT_rNdybRDFFOAT9g5kdq8SOraK_Q/uf6rR_lz7JMeO4cE-hHB-59T8gCRIwI7dhqfDVgASSo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EXvJLqLv0Q1zEcaZ4OYDWw/W05CyYIR7E-TtqueHjX1znSLYTjKMcUW9Z2jdHtLIXhVcPktYi-xnoq2dtrhqqf6FOnJ9gLxlUF3R1y-zUaZzw/5MptEU6yLCcaC2jBAtxU_UfVh58yJurgp_UIp0qIdX8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782639/Instruments/Spectrum%20Analyzers/AQ6370/AQ6370.jpg,AQ6370,Write a Python script that uses Instrumentkit to connect to a AQ6370 Spectrum Analyzers,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Yokogawa 6370 optical spectrum analyzer.
""""""

# IMPORTS #####################################################################


from enum import IntEnum, Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import OpticalSpectrumAnalyzer
from instruments.abstract_instruments.comm import SocketCommunicator
from instruments.util_fns import (
    enum_property,
    unitful_property,
    unitless_property,
    bounded_unitful_property,
    ProxyList,
    string_property,
)


# CLASSES #####################################################################


class Yokogawa6370(OpticalSpectrumAnalyzer):

    """"""
    The Yokogawa 6370 is a optical spectrum analyzer.
    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa6370.open_visa('TCPIP0:192.168.0.35')
    >>> inst.start_wl = 1030e-9 * u.m
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if isinstance(self._file, SocketCommunicator):
            self.terminator = ""\r\n""  # TCP IP connection terminator

        # Set data Format to binary
        self.sendcmd("":FORMat:DATA REAL,64"")  # TODO: Find out where we want this

    # INNER CLASSES #

    class Channel(OpticalSpectrumAnalyzer.Channel):

        """"""
        Class representing the channels on the Yokogawa 6370.
        This class inherits from `OpticalSpectrumAnalyzer.Channel`.
        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa6370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._name = idx

        # METHODS #

        def _data(self, axis, limits=None, bin_format=True):
            """"""Get data of `axis`.

            :param axis: Axis to get the data of, ""X"" or ""Y""
            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            if limits is None:
                cmd = f"":TRAC:{axis}? {self._name}""
            elif isinstance(limits, (tuple, list)) and len(limits) == 2:
                cmd = f"":TRAC:{axis}? {self._name},{limits[0]+1},{limits[1]+1}""
            else:
                raise ValueError(""limits has to be a list or tuple with two members"")
            self._parent.sendcmd(cmd)
            data = self._parent.binblockread(data_width=8, fmt=""<d"")
            self._parent._file.read_raw(1)  # pylint: disable=protected-access
            return data

        def data(self, limits=None, bin_format=True):
            """"""
            Return the trace's level data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""Y"", limits=limits, bin_format=bin_format)

        def wavelength(self, limits=None, bin_format=True):
            """"""
            Return the trace's wavelength data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""X"", limits=limits, bin_format=bin_format)

    # ENUMS #

    class SweepModes(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 6370
        """"""

        SINGLE = 1
        REPEAT = 2
        AUTO = 3

    class Traces(Enum):
        """"""
        Enum containing valid Traces for the Yokogawa 6370
        """"""

        A = ""TRA""
        B = ""TRB""
        C = ""TRC""
        D = ""TRD""
        E = ""TRE""
        F = ""TRF""
        G = ""TRG""

    # PROPERTIES #

    # General

    id = string_property(
        ""*IDN"",
        doc=""""""
            Get the identification of the device.
            Output: 'Manufacturer,Product,SerialNumber,FirmwareVersion'
            Sample: 'YOKOGAWA,AQ6370D,90Y403996,02.08'
            """""",
        readonly=True,
    )

    status = unitless_property(
        ""*STB"",
        doc=""""""The status byte of the device.
        Bit 7: Summary bit of operation status
        Bit 5: Summary bit of standard event status register
        Bit 4: “1” if the output buffer contains data
        Bit 3: Summary bit of questionable status
        """""",
        readonly=True,
    )

    operation_event = unitless_property(
        "":status:operation:event"",
        doc=""""""
            All changes after the last readout. Readout clears the operation_event
            Bit 4: Autosweep
            Bit 3: Calibration/Alignment
            Bit 2: Copy/File
            Bit 1: Program
            Bit 0: Sweep finished.
        """""",
        readonly=True,
    )

    @property
    def channel(self):
        """"""
        Gets the specific channel object.
        This channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> osa = ik.yokogawa.Yokogawa6370.open_gpibusb('/dev/ttyUSB0')
        >>> dat = osa.channel[""A""].data # Gets the data of channel 0

        :rtype: `list`[`~Yokogawa6370.Channel`]
        """"""
        return ProxyList(self, Yokogawa6370.Channel, Yokogawa6370.Traces)

    # Sweep

    start_wl, start_wl_min, start_wl_max = bounded_unitful_property(
        "":SENS:WAV:STAR"",
        u.meter,
        doc=""""""
        The start wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    stop_wl, stop_wl_min, stop_wl_max = bounded_unitful_property(
        "":SENS:WAV:STOP"",
        u.meter,
        doc=""""""
        The stop wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    bandwidth = unitful_property(
        "":SENS:BAND:RES"",
        u.meter,
        doc=""""""
        The bandwidth in m.
        """""",
    )

    span = unitful_property(
        "":SENS:WAV:SPAN"",
        u.meter,
        doc=""""""
        A floating point property that controls the wavelength span in m.
        """""",
    )

    center_wl = unitful_property(
        "":SENS:WAV:CENT"",
        u.meter,
        doc=""""""
         A floating point property that controls the center wavelength m.
        """""",
    )

    points = unitless_property(
        "":SENS:SWE:POIN"",
        doc=""""""
        An integer property that controls the number of points in a trace.
        """""",
    )

    sweep_mode = enum_property(
        "":INIT:SMOD"",
        SweepModes,
        input_decoration=int,
        doc=""""""
        A property to control the Sweep Mode as one of Yokogawa6370.SweepMode.
        Effective only after a self.start_sweep()."""""",
    )

    # Analysis

    # Traces

    active_trace = enum_property(
        "":TRAC:ACTIVE"",
        Traces,
        doc=""""""
        The active trace of the OSA of enum Yokogawa6370.Traces. Determines the
        result of Yokogawa6370.data() and Yokogawa6370.wavelength()."""""",
    )

    # METHODS #

    def data(self, limits=None):
        """"""
        Function to query the active Trace data of the OSA.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].data(limits=limits)

    def wavelength(self, limits=None):
        """"""
        Query the wavelength axis of the active trace.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].wavelength(limits=limits)

    def analysis(self):
        """"""Get the analysis data.""""""
        return [float(x) for x in self.query("":CALC:DATA?"").split("","")]

    def start_sweep(self):
        """"""
        Triggering function for the Yokogawa 6370.
        After changing the sweep mode, the device needs to be triggered before
        it will update.
        """"""
        self.sendcmd(""*CLS;:init"")

    def abort(self):
        """"""Abort a running sweep or calibration etc.""""""
        self.sendcmd("":ABORT"")

    def clear(self):
        """"""Clear status registers.""""""
        self.sendcmd(""*CLS"")
"
245,https://www.thinksrs.com/downloads/pdfs/catalog/DS345c.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attdOv77MX1TYKshq'), ('width', 2688), ('height', 1517), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IaIQ0dWcilCUDqQaiTMGSw/Fjo5wDdlv4YxHoN4uifJyWvJxAFiqx4osRkXg0FC0czSJGNrybrcAFn6du_9-rnV_WM5KfXHmCvZU5HQahYnSiqCiBrWAAA4c9dyuXTTG0A/SSTbtjol1mVKApR9LVQMQO8ItUcBu2id9UU7Y86Y4Pc'), ('filename', 'DS345_Main2.jpg'), ('size', 572471), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EUBtalIt482zCFLPsDOV7g/3SQxZ3ZoOoW9VpREA5CiMMhV8szai5yuDUk5xRt0jIPjavgjmWJonvbjP0J2p80LHUJoqzEIQw31DizZexRnBA/z5JTzdYDTNoEBiBdLGzEd-K6Q7xf6SkToFbe5e8uOzY'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/t3eVt8bYjN-_pkrLEn_-Pg/E53uhz7UT61swyIoeP3u-k963PiCoaFzxyGcr3WyH4nLcWOamOqipnsIotJ_UV-cvY1TxMgSH1JzxSu19hrNHA/iAvaN4ggY2aZC7cHF4ReKFBO0ftTLMhTLjovpGZDQMg'), ('width', 907), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2esc1wnQqs4SAqOYdfrVoA/mwR2nVpVd-zrxX0wRCGsbqhdwBfpsejGON8TDq8D5maq-33t7t4fDZYOgMwjZkRwU5pCkmkzCImHZFmBzo8AqQ/djy_GRrhSWagoK2TYqOoASA3pvna5bHPmAAwaylUGZc'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"The DS345 Function Generator is a full-featured 30 MHz synthesized function generator that uses an innovative Direct Digital Synthesis (DDS) architecture. It generates many standard waveforms with excellent frequency resolution (1 µHz), and has versatile modulation capabilities including AM, FM, Burst, PM and frequency sweeps. It also generates arbitrary waveforms with a fast 40 Msample/s update rate.",https://www.thinksrs.com/products/DS345.htm,SRS 345,493.0,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs345.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs345-function-generator,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782645/Instruments/Function%20Generators/DS345/DS345.jpg,DS345,Write a Python script that uses Instrumentkit to connect to a DS345 Function Generators,1595.0,,,,"#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )
"
248,https://cdn.teledynelecroy.com/files/pdf/labmaster-10zi-a-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attreLJUz1eRfLnKT'), ('width', 392), ('height', 301), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/SBgwEHyJbDer2GoE7MioEQ/C65ALL0ub2tBtFu-yVfSmjxYR9NJrqe8A6ZR1hoY6oKN4iPWeJggndFBCCPCFrO8WcBcEBfdQxTWr0lGvPOzSzFuzSgWd4mPPbVThiWjAVo/iBFiljh0FJgmY45w9s9aUFjIhm_z9udsNO9KhIXJRxI'), ('filename', 'cross-sync-p3.webp'), ('size', 19634), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IMrOzYhSgfKc2Shu8zCWSg/v4QdEKJYQWXZPqvNva_gpxsE_UKTjP-tQMkhDRufZdnZHtQuOse6jq-NP2ksNO-uHPLXpgB07aOUmWzp59oANTnhAuXRThp6Xc84i64_TOk/BqPhf7zV73K1LWw09uo4VOWFXfwpzFDa9LmH5d4L-1g'), ('width', 47), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZZG955PIY6BIghbwXrA5fg/DfJUoDSfqqmYqesQN2G10YArRZsNJUYwhS3VYD3HmNaWuJZUmnWQRAgyo7M_8gbTVCFP8BcQcsCH67uvjStMwvRqZ_6f-zWqJAxm0PNqYSo/ARkGDMJS7Hru0Fp0pT6UunT4eQ8xnYllmBdCCh-r8sw'), ('width', 392), ('height', 301)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/el5m1dKJqfaXDLj6JalFfg/k7bqTcDEOD9_c3b0n86rtNe1HugRqT9hT5EsG1pkFtG5mNuWlLBtpuLthJGJOPggzWoq7TtUpujqaAGpfY7f7gLfGorwzKAjRAs3CxW9lhg/VBsBMary6WiXQgJI9cRV4F4DTbgAOhASOygBbwt0k2k'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"The LabMaster 10 Zi is the world's highest-performance modular oscilloscope - it breaks channel count barriers and provides more ""bandwidth density"". The modular design provides the simplest upgrade path in bandwidth and channel count, with one acquisition module providing four channels at 36 GHz or two channels at 65 GHz, with capability for up to 20 acquisition modules",https://www.teledynelecroy.com/oscilloscope/labmaster-10-zi-a-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782647/Instruments/Oscilloscopes/LabMaster-10-Zi-A/LabMaster-10-Zi-A.webp,LabMaster 10 Zi-A,Write a Python script that uses Instrumentkit to connect to a LabMaster 10 Zi-A Oscilloscopes,,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
258,https://www.thorlabs.com/_sd.cfm?fileName=ETN051885-D02.pdf&partNumber=KIM001,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ikmeULh0xPXQ3S2OP7niPQ/4FFgBZ0zDcnT_uQ7Er5g-yifKXK4KUdNTFOyj2Ne5P_V6QjNEr_ROoDly8axC8Rv9Cl9DgbLYMtJeL8jk_msul6l-lsAJldryb_M7691g9Q/e80FgngEatgR471d9aT2qmyRrHJbjGAwwf3MAz-g3RY'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FBgUwDsb1bj8han4Myz-mg/_MRQC4MHlgzafX_YM-FqcgWfxFDB0Ta8FhbI441-QovJtrd-8_4L4WeHlhpjo1nPPm3W4PMz-gUDvMSm_wSPKQ/vi21FV8lnE4PdtGB17SHPH-hQbVBmxqi3ghKPagZ87U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nSe386AzoppYVSR1Ix0j9g/ZJqu2XJLlsCueaTUh3ARMglC2OeMfd-xGJtdm-FYr4gLkHOJJXcpXco2gco_e_eVZ2TrrFj1Hh5_Ajd29BR0_w/qdG0NiZ--pnhxfTv9djuoRhREnsuj6Nlr6goL9ho_ZI'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/irf7zNlom7ANLOcab_z-Fw/mdKCFY4dPmn5tzMMC68j3sCBP74maUIU9SdzB7oEmnOLWxuCypVbp33OwiLztEmL-1gBtLnzqDu7QSE-irKJzw/ZrwKvdsySuPhEZo7TbjXpmpGWDMZ-d8agu2Yn7ZzAIk'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,This single-channel piezo inertia controller provides a voltage output for a single piezo inertia stage or actuator. The top panel features a spring-loaded scroll wheel for driving the stage or actuator as well as selecting menu options.,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,APTPiezoInertiaActuator,598.0,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782656/Instruments/Positional%20Controller/KIM001/KIM001.jpg,KIM001,Write a Python script that uses Instrumentkit to connect to a KIM001 Positional Controller,835.34,,,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs APT Controller.
""""""

# IMPORTS #####################################################################


import re
import struct
import logging
import codecs
import warnings

from instruments.thorlabs import _abstract, _packets, _cmds
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################

# pylint: disable=too-many-lines


class ThorLabsAPT(_abstract.ThorLabsInstrument):

    """"""
    Generic ThorLabs APT hardware device controller. Communicates using the
    ThorLabs APT communications protocol, whose documentation is found in the
    thorlabs source folder.
    """"""

    class APTChannel:

        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.
        """"""

        def __init__(self, apt, idx_chan):
            self._apt = apt
            # APT is 1-based, but we want the Python representation to be
            # 0-based.
            self._idx_chan = idx_chan + 1

        @property
        def enabled(self):
            """"""
            Gets/sets the enabled status for the specified APT channel

            :type: `bool`

            :raises TypeError: If controller is not supported
            """"""
            if self._apt.model_number[0:3] == ""KIM"":
                raise TypeError(
                    ""For KIM controllers, use the ""
                    ""`enabled_single` function to enable ""
                    ""one axis. For KIM101 controllers, ""
                    ""multiple axes can be enabled using ""
                    ""the `enabled_multi` function from the ""
                    ""controller level.""
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_REQ_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOD_GET_CHANENABLESTATE
            )
            return not bool(resp.parameters[1] - 1)

        @enabled.setter
        def enabled(self, newval):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_SET_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x01 if newval else 0x02,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

    _channel_type = APTChannel

    def __init__(self, filelike):
        super().__init__(filelike)
        self._dest = 0x50  # Generic USB device; make this configurable later.

        # Provide defaults in case an exception occurs below.
        self._serial_number = None
        self._model_number = None
        self._hw_type = None
        self._fw_version = None
        self._notes = """"
        self._hw_version = None
        self._mod_state = None
        self._n_channels = 0
        self._channel = ()

        # Perform a HW_REQ_INFO to figure out the model number, serial number,
        # etc.
        try:
            req_packet = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.HW_REQ_INFO,
                param1=0x00,
                param2=0x00,
                dest=self._dest,
                source=0x01,
                data=None,
            )
            hw_info = self.querypacket(
                req_packet,
                expect=_cmds.ThorLabsCommands.HW_GET_INFO,
                expect_data_len=84,
            )

            self._serial_number = codecs.encode(hw_info.data[0:4], ""hex"").decode(
                ""ascii""
            )
            self._model_number = (
                hw_info.data[4:12].decode(""ascii"").replace(""\x00"", """").strip()
            )

            hw_type_int = struct.unpack(""<H"", hw_info.data[12:14])[0]
            if hw_type_int == 45:
                self._hw_type = ""Multi-channel controller motherboard""
            elif hw_type_int == 44:
                self._hw_type = ""Brushless DC controller""
            else:
                self._hw_type = f""Unknown type: {hw_type_int}""

            # Note that the fourth byte is padding, so we strip out the first
            # three bytes and format them.
            # pylint: disable=invalid-format-index
            self._fw_version = ""{0[0]:x}.{0[1]:x}.{0[2]:x}"".format(hw_info.data[14:18])
            self._notes = (
                hw_info.data[18:66].replace(b""\x00"", b"""").decode(""ascii"").strip()
            )

            self._hw_version = struct.unpack(""<H"", hw_info.data[78:80])[0]
            self._mod_state = struct.unpack(""<H"", hw_info.data[80:82])[0]
            self._n_channels = struct.unpack(""<H"", hw_info.data[82:84])[0]
        except OSError as e:
            logger.error(""Exception occured while fetching hardware info: %s"", e)

        # Create a tuple of channels of length _n_channel_type
        if self._n_channels > 0:
            self._channel = tuple(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels)
            )

    @property
    def serial_number(self):
        """"""
        Gets the serial number for the APT controller

        :type: `str`
        """"""
        return self._serial_number

    @property
    def model_number(self):
        """"""
        Gets the model number for the APT controller

        :type: `str`
        """"""
        return self._model_number

    @property
    def name(self):
        """"""
        Gets the name of the APT controller. This is a human readable string
        containing the model, serial number, hardware version, and firmware
        version.

        :type: `str`
        """"""
        return (
            ""ThorLabs APT Instrument model {model}, serial {serial} ""
            ""(HW version {hw_ver}, FW version {fw_ver})"".format(
                hw_ver=self._hw_version,
                serial=self.serial_number,
                fw_ver=self._fw_version,
                model=self.model_number,
            )
        )

    @property
    def channel(self):
        """"""
        Gets the list of channel objects attached to the APT controller.

        A specific channel object can then be accessed like one would access
        a list.

        :type: `tuple` of `APTChannel`
        """"""
        return self._channel

    @property
    def n_channels(self):
        """"""
        Gets/sets the number of channels attached to the APT controller

        :type: `int`
        """"""
        return self._n_channels

    @n_channels.setter
    def n_channels(self, nch):
        # Change the number of channels so as not to modify those instances
        # already existing:
        # If we add more channels, append them to the list,
        # If we remove channels, remove them from the end of the list.
        if nch > self._n_channels:
            self._channel = list(self._channel) + list(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels, nch)
            )
        elif nch < self._n_channels:
            self._channel = self._channel[:nch]
        self._n_channels = nch

    def identify(self):
        """"""
        Causes a light on the APT instrument to blink, so that it can be
        identified.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.MOD_IDENTIFY,
            param1=0x00,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        self.sendpacket(pkt)

    @property
    def destination(self):
        """"""
        Gets the destination for the APT controller

        :type: `int`
        """"""
        return self._dest


class APTPiezoDevice(ThorLabsAPT):

    """"""
    Generic ThorLabs APT piezo device, superclass of more specific piezo
    devices.
    """"""

    class PiezoDeviceChannel(ThorLabsAPT.APTChannel):
        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.

        This class represents piezo stage channels.
        """"""

        # PIEZO COMMANDS #

        @property
        def max_travel(self):
            """"""
            Gets the maximum travel for the specified piezo channel.

            :type: `~pint.Quantity`
            :units: Nanometers
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_MAXTRAVEL,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(pkt, expect_data_len=4)

            # Not all APT piezo devices support querying the maximum travel
            # distance. Those that do not simply ignore the PZ_REQ_MAXTRAVEL
            # packet, so that the response is empty.
            if resp is None:
                return NotImplemented

            # chan, int_maxtrav
            _, int_maxtrav = struct.unpack(""<HH"", resp.data)
            return int_maxtrav * u.Quantity(100, ""nm"")

    @property
    def led_intensity(self):
        """"""
        Gets/sets the output intensity of the LED display.

        :type: `float` between 0 and 1.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_REQ_TPZ_DISPSETTINGS,
            param1=0x01,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        resp = self.querypacket(pkt, expect_data_len=2)

        # Not all APT piezo devices support querying the LED intenstiy
        # distance, e.g., TIM, KIM. Those that do not simply ignore the
        # PZ_REQ_TPZ_DISPSETTINGS packet, so that the response is empty.
        # Setting will be ignored as well.
        if resp is None:
            return NotImplemented
        else:
            return float(struct.unpack(""<H"", resp.data)[0]) / 255

    @led_intensity.setter
    def led_intensity(self, intensity):
        # pylint: disable=round-builtin
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_SET_TPZ_DISPSETTINGS,
            param1=None,
            param2=None,
            dest=self._dest,
            source=0x01,
            data=struct.pack(""<H"", int(round(255 * intensity))),
        )
        self.sendpacket(pkt)

    _channel_type = PiezoDeviceChannel


class APTPiezoInertiaActuator(APTPiezoDevice):

    """"""Represent a Thorlabs APT piezo inertia actuator.

    Currently only the KIM piezo inertia actuator is implemented.
    Some routines will work with the TIM actuator as well. Routines
    that are specific for the KIM101 controller will raise a TypeError
    if not implemented for this controller. Unfortunately, handling all
    these controller specific functions is fairly messy, but necessary.

    Example for a KIM101 controller:
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> # call the controller
        >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # set first channel to enabled
        >>> ch = kim.channel[0]
        >>> ch.enabled_single = True
        >>> # define and set drive parameters
        >>> max_volts = u.Quantity(110, u.V)
        >>> step_rate = u.Quantity(1000, 1/u.s)
        >>> acceleration = u.Quantity(10000, 1/u.s**2)
        >>> ch.drive_op_parameters = [max_volts, step_rate, acceleration]
        >>> # aboslute move to 1000 steps
        >>> ch.move_abs(1000)
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PROPERTIES #

        @property
        def drive_op_parameters(self):
            """"""Get / Set various drive parameters for move motion.

            Defines the speed and acceleration of moves initiated in
            the following ways:
            - by clicking in the position display
            - via the top panel controls when ‘Go To Position’ mode is
            selected (in the Set_TIM_JogParameters (09) or
            Set_KCubeMMIParams (15) sub‐messages).
            - via software using the MoveVelocity, MoveAbsoluteStepsEx
            or MoveRelativeStepsEx methods.

            :setter: The setter must be be given as a list of 3
                entries. The three entries are:
                -  Maximum Voltage:
                The maximum piezo drive voltage, in the range 85V
                to 125V. Unitful, if no unit given, V are assumed.
                - Step Rate:
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the drive parameters, unitful.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # change the step rate to 2000 /s
                >>> drive_params = ch.drive_op_parameters
                >>> drive_params[1] = 2000
                >>> ch.drive_op_parameters = drive_params
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x07,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=14
            )

            # unpack
            ret_val = struct.unpack(""<HHHll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4]]

            # set units and formats
            ret_val = [
                u.Quantity(int(ret_val[0]), u.V),
                u.Quantity(int(ret_val[1]), 1 / u.s),
                u.Quantity(int(ret_val[2]), 1 / u.s**2),
            ]
            return ret_val

        @drive_op_parameters.setter
        def drive_op_parameters(self, params):
            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 3:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 3."")

            # ensure units
            volt = int(assume_units(params[0], u.V).to(u.V).magnitude)
            rate = int(assume_units(params[1], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[2], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if volt < 85 or volt > 125:
                raise ValueError(
                    ""The voltage ({} V) is out of range. It must ""
                    ""be between 85 V and 125 V."".format(volt)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )

            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHHll"", 0x07, self._idx_chan, volt, rate, accl),
            )
            self._apt.sendpacket(pkt)

        @property
        def enabled_single(self):
            """"""Get / Set single axis enabled.

            .. note:: Enabling multi channels for KIM101 is defined in
            the controller class.

            :return: Axis status enabled.
            :rtype: bool

            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # enable channel 0
                >>> ch.enabled_single = True
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise (
                    ""This command is only valid with KIM001 and ""
                    ""KIM101 controllers. Your controller is a {}."".format(
                        self._apt.model_number
                    )
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2B,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
            )

            ret_val = struct.unpack(""<HH"", resp.data)[1] == self._idx_chan

            return ret_val

        @enabled_single.setter
        def enabled_single(self, newval):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            param = self._idx_chan if newval else 0x00
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", 0x2B, param),
            )
            self._apt.sendpacket(pkt)

        @property
        def jog_parameters(self):
            """"""Get / Set the jog parameters.

            Define the speed and acceleration of moves initiated in the
            following ways:
            - By clicking the jog buttons on the GUI panel
            - By moving the joystick on the unit when ‘Jog Mode’ is
            selected.
            - via software using the MoveJog method.

            It differs from the normal motor jog message in that there
            are two jog step sizes, one for forward and one for reverse.
            The reason for this is that due to the inherent nature of
            the PIA actuators going further in one direction as
            compared with another this will allow the user to
            potentially make adjustments to get fore and aft movement
            the same or similar.

            :setter: The setter must be be given as a list of 5
                entries. The three entries are:
                - Jog Mode (1 for continuus, i.e., until stop command
                is issued, or 2 jog by the number of steps defined)
                - Jog Step Size Forward: Range 1 - 2000
                - Jog Step Size Backward: Range 1 - 2000
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Jog Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the jog parameters.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.
            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> mode = 2  # only move by set step size
                >>> step = 100  # step size
                >>> rate = u.Quantity(1000, 1/u.s)  # step rate
                >>> # if no quantity given, SI units assumed
                >>> accl = 10000
                >>> ch.jog_parameters = [mode, step, step, rate, accl]
                >>> ch.jog_parameters
                [2, 100, 100, array(1000) * 1/s, array(10000) * 1/s**2]
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2D,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=22
            )

            # unpack response
            ret_val = struct.unpack(""<HHHllll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4], ret_val[5], ret_val[6]]

            # assign the appropriate units, forms
            ret_val = [
                int(ret_val[0]),
                int(ret_val[1]),
                int(ret_val[2]),
                u.Quantity(int(ret_val[3]), 1 / u.s),
                u.Quantity(int(ret_val[4]), 1 / u.s**2),
            ]

            return ret_val

        @jog_parameters.setter
        def jog_parameters(self, params):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 5:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 5."")

            # ensure units
            mode = int(params[0])
            steps_fwd = int(params[1])
            steps_bkw = int(params[2])
            rate = int(assume_units(params[3], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[4], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if mode != 1 and mode != 2:
                raise ValueError(
                    ""The mode ({}) must be either set to 1 ""
                    ""(continuus) or 2 (steps)."".format(mode)
                )
            if steps_fwd < 1 or steps_fwd > 2000:
                raise ValueError(
                    ""The steps forward ({}) are out of range. It ""
                    ""must be between 1 and 2,000."".format(steps_fwd)
                )
            if steps_bkw < 1 or steps_bkw > 2000:
                raise ValueError(
                    ""The steps backward ({}) are out of range. ""
                    ""It must be between 1 and 2,000."".format(steps_bkw)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )
            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHllll"",
                    0x2D,
                    self._idx_chan,
                    mode,
                    steps_fwd,
                    steps_bkw,
                    rate,
                    accl,
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def position_count(self):
            """"""Get/Set the position count of a given channel.

            :setter pos: Position (steps) of axis.
            :type pos: int

            :return: Position (steps) of axis.
            :rtype: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set position count to zero
                >>> ch.position_count = 0
                >>> ch.position_count
                0
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x05,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=12
            )

            ret_val = int(struct.unpack(""<HHll"", resp.data)[2])

            return ret_val

        @position_count.setter
        def position_count(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHll"", 0x05, self._idx_chan, pos, 0x00),
            )
            self._apt.sendpacket(pkt)

        # METHODS #

        def move_abs(self, pos):
            """"""
            Moves the axis to a position specified as the number of
            steps away from the zero position.

            To set the moving parameters, use the setter for
            `drive_op_parameters`.

            :param pos: Position to move to, in steps.
            :type pos: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # move to 314 steps
                >>> ch.move_abs(314)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_ABSOLUTE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

        def move_jog(self, direction=""fwd""):
            """"""
            Jogs the axis in forward or backward direction by the number
            of steps that are stored in the controller.

            To set the moving parameters, use the setter for
            `jog_parameters`.

            :param str direction: Direction of jog. 'fwd' for forward,
                'rev' for backward. 'fwd' if invalid argument given

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> params = ch.jog_parameters
                >>> params[0] = 2  # move by number of steps
                >>> params[1] = 100  # step size forward
                >>> params[2] = 200  # step size reverse
                >>> ch.jog_parameters = params  # set parameters
                >>> # jog forward (default)
                >>> ch.move_jog()
                >>> # jog reverse
                >>> ch.move_jog('rev')
            """"""
            if direction == ""rev"":
                param2 = 0x02
            else:
                param2 = 0x01

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=param2,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        def move_jog_stop(self):
            """"""Stops the current motor movement.

            Stop a jog command. The regular motor move stop command does
            not work for jogging. This command somehow does...

            .. note:: This information is quite empirical. It would
                only be really needed if jogging parameters are set to
                continuous. The safer method is to set the step range.
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel

    # PROPERTIES #

    @property
    def enabled_multi(self):
        """"""Enable / Query mulitple channel mode.

        For KIM101 controller, where multiple axes can be selected
        simultaneously (i. e., for a mirror mount).

        :setter mode: Channel pair to be activated.
            0:  All channels deactivated
            1:  First channel pair activated (channel 0 & 1)
            2:  Second channel pair activated (channel 2 & 3)
        :type mode: int

        :return: The selected mode:
            0 - multi-channel selection disabled
            1 - Channel 0 & 1 enabled
            2 - Channel 2 & 3 enabled
        :rtype: int

        :raises ValueError: No valid channel pair selected
        :raises TypeError: Invalid controller for this command.

        Example:
            >>> import instruments as ik
            >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
            >>> # activate the first two channels
            >>> kim.enabled_multi = 1
            >>> # read back
            >>> kim.enabled_multi
            1
        """"""
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
            param1=0x2B,
            param2=0x00,
            dest=self.destination,
            source=0x01,
            data=None,
        )

        resp = self.querypacket(
            pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
        )

        ret_val = int(struct.unpack(""<HH"", resp.data)[1])

        if ret_val == 5:
            return 1
        elif ret_val == 6:
            return 2
        else:
            return 0

    @enabled_multi.setter
    def enabled_multi(self, mode):
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        if mode == 0:
            param = 0x00
        elif mode == 1:
            param = 0x05
        elif mode == 2:
            param = 0x06
        else:
            raise ValueError(
                ""Please select a valid mode: 0 - all ""
                ""disabled, 1 - Channel 1 & 2 enabled, ""
                ""2 - Channel 3 & 4 enabled.""
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
            param1=None,
            param2=None,
            dest=self.destination,
            source=0x01,
            data=struct.pack(""<HH"", 0x2B, param),
        )

        self.sendpacket(pkt)


class APTPiezoStage(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT piezo stage
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PIEZO COMMANDS #

        @property
        def position_control_closed(self):
            """"""
            Gets the status if the position control is closed or not.

            `True` means that the position control is closed, `False` otherwise

            :type: `bool`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_POSCONTROLMODE
            )
            return bool((resp.parameters[1] - 1) & 1)

        def change_position_control_mode(self, closed, smooth=True):
            """"""
            Changes the position control mode of the piezo channel

            :param bool closed: `True` for closed, `False` for open
            :param bool smooth: `True` for smooth, `False` for otherwise.
                Default is `True`.
            """"""
            mode = 1 + (int(closed) | int(smooth) << 1)
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=mode,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        @property
        def output_position(self):
            """"""
            Gets/sets the output position for the piezo channel.

            :type: `str`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_OUTPUTPOS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_OUTPUTPOS, expect_data_len=4
            )
            # chan, pos
            _, pos = struct.unpack(""<HH"", resp.data)
            return pos

        @output_position.setter
        def output_position(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_OUTPUTPOS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel


class APTStrainGaugeReader(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT strain gauge reader.

    .. warning:: This is not currently implemented
    """"""

    class StrainGaugeChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single strain gauge channel attached to a
        `APTStrainGaugeReader` on the Thorlabs APT controller.

        .. warning:: This is not currently implemented
        """"""

    _channel_type = StrainGaugeChannel


class APTMotorController(ThorLabsAPT):

    """"""
    Class representing a Thorlabs APT motor controller.

    .. note:: A motor model must be selected in order to use unitful
        distances.

    Example:
        >>> import instruments as ik
        >>> import instruments.units as u

        >>> # load the controller, a KDC101 cube
        >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # assign a channel to `ch`
        >>> ch = kdc.channel[0]
        >>> # select the stage that is connected to the controller
        >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

        >>> # home the stage
        >>> ch.go_home()
        >>> # move to 52 degrees absolute position
        >>> ch.move(u.Quantity(52, u.deg))
        >>> # move 10 degrees back from current position
        >>> ch.move(u.Quantity(-10, u.deg), absolute=False)
    """"""

    class MotorChannel(ThorLabsAPT.APTChannel):

        """"""
        Class representing a single motor attached to a Thorlabs APT motor
        controller (`APTMotorController`).
        """"""

        # INSTANCE VARIABLES #

        _motor_model = None

        #: Sets the scale between the encoder counts and physical units
        #: for the position, velocity and acceleration parameters of this
        #: channel. By default, set to dimensionless, indicating that the proper
        #: scale is not known.
        #:
        #: In keeping with the APT protocol documentation, the scale factor
        #: is multiplied by the physical quantity to get the encoder count,
        #: such that scale factors should have units similar to microsteps/mm,
        #: in the example of a linear motor.
        #:
        #: Encoder counts are represented by the quantities package unit
        #: ""ct"", which is considered dimensionally equivalent to dimensionless.
        #: Finally, note that the ""/s"" and ""/s**2"" are not included in scale
        #: factors, so as to produce quantities of dimension ""ct/s"" and
        #: ""ct/s**2""
        #: from dimensionful input.
        #:
        #: For more details, see the APT protocol documentation.
        scale_factors = (u.Quantity(1, ""dimensionless""),) * 3

        _motion_timeout = u.Quantity(10, ""second"")

        __SCALE_FACTORS_BY_MODEL = {
            # TODO: add other tables here.
            re.compile(""TST001|BSC00.|BSC10.|MST601""): {
                # Note that for these drivers, the scale factors are identical
                # for position, velcoity and acceleration. This is not true for
                # all drivers!
                ""DRV001"": (u.Quantity(51200, ""count/mm""),) * 3,
                ""DRV013"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV014"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV113"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""DRV114"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""FW103"": (u.Quantity(25600 / 360, ""count/deg""),) * 3,
                ""NR360"": (u.Quantity(25600 / 5.4546, ""count/deg""),) * 3,
            },
            re.compile(""TDC001|KDC101""): {
                ""MTS25-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                ""MTS50-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                # TODO: Z8xx and Z6xx models. Need to add regex support to motor models, too.
                ""PRM1-Z8"": (
                    u.Quantity(1919.64, ""count/deg""),
                    u.Quantity(42941.66, u.sec / u.deg),
                    u.Quantity(14.66, u.sec**2 / u.deg),
                ),
            },
        }

        __STATUS_BIT_MASK = {
            ""CW_HARD_LIM"": 0x00000001,
            ""CCW_HARD_LIM"": 0x00000002,
            ""CW_SOFT_LIM"": 0x00000004,
            ""CCW_SOFT_LIM"": 0x00000008,
            ""CW_MOVE_IN_MOTION"": 0x00000010,
            ""CCW_MOVE_IN_MOTION"": 0x00000020,
            ""CW_JOG_IN_MOTION"": 0x00000040,
            ""CCW_JOG_IN_MOTION"": 0x00000080,
            ""MOTOR_CONNECTED"": 0x00000100,
            ""HOMING_IN_MOTION"": 0x00000200,
            ""HOMING_COMPLETE"": 0x00000400,
            ""INTERLOCK_STATE"": 0x00001000,
        }

        # IK-SPECIFIC PROPERTIES #
        # These properties don't correspond to any particular functionality
        # of the underlying device, but control how we interact with it.

        @property
        def motion_timeout(self):
            """"""
            Gets/sets the motor channel motion timeout.

            :units: Seconds
            :type: `~pint.Quantity`
            """"""
            return self._motion_timeout

        @motion_timeout.setter
        def motion_timeout(self, newval):
            self._motion_timeout = assume_units(newval, u.second)

        # UNIT CONVERSION METHODS #

        def _set_scale(self, motor_model):
            """"""
            Sets the scale factors for this motor channel, based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel.

            :param str motor_model: Name of the model of the attached motor,
                as indicated in the APT protocol documentation (page 14, v9).
            """"""
            for driver_re, motor_dict in self.__SCALE_FACTORS_BY_MODEL.items():
                if driver_re.match(self._apt.model_number) is not None:
                    if motor_model in motor_dict:
                        self.scale_factors = motor_dict[motor_model]
                        return
                    else:
                        break
            # If we've made it down here, emit a warning that we didn't find the
            # model.
            logger.warning(
                ""Scale factors for controller %s and motor %s are "" ""unknown"",
                self._apt.model_number,
                motor_model,
            )

        # We copy the docstring below, so it's OK for this method
        # to not have a docstring of its own.
        # pylint: disable=missing-docstring
        def set_scale(self, motor_model):
            warnings.warn(
                ""The set_scale method has been deprecated in favor ""
                ""of the motor_model property."",
                DeprecationWarning,
            )
            return self._set_scale(motor_model)

        set_scale.__doc__ = _set_scale.__doc__

        @property
        def motor_model(self):
            """"""
            Gets or sets the model name of the attached motor.
            Note that the scale factors for this motor channel are based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel, such that setting a new motor model will update
            the scale factors accordingly.

            :type: `str` or `None`
            """"""
            return self._motor_model

        @motor_model.setter
        def motor_model(self, newval):
            self._set_scale(newval)
            self._motor_model = newval

        # MOTOR COMMANDS #

        @property
        def backlash_correction(self):
            """"""Get / set backlash correctionf or given stage.

            If no units are given, ``u.counts`` are assumed. If you have
            the stage defined (see example below), unitful values can be
            used for setting the backlash correction, e.g., ``u.mm`` or
            ``u.deg``.

            :return: Unitful quantity of backlash correction.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> ch.backlash_correction = 4 * u.deg  # set it to 4 degrees
                >>> ch.backlash_correction  # read it back
                <Quantity(4, 'degree')>
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_GENMOVEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_GENMOVEPARAMS,
                expect_data_len=6,
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @backlash_correction.setter
        def backlash_correction(self, pos):
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )
            # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_GENMOVEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )
            self._apt.sendpacket(pkt)

        @property
        def home_parameters(self):
            """"""Get the home parameters for the motor channel.

            Parameters are stage specific and not all parameters can be set
            for every stage. For example, the MLS203 stage only allows the
            homing velocity to be changed.

            .. note:: When setting the quantity, pass `None` to values
                that you want to leave unchanged (see example below).

            .. note:: After changing the offset, the stage must be homed
                in order to show the new offset in its values.

            :return: Home Direction (1: forward/positive, 2 reverse/negative),
                Limit Switch (1: hardware reverse, 4: hardware forward),
                Home Velocity,
                Offset distance
            :rtype: Tuple[int, int, u.Quantity, u.Quantity]


            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> # set offset distance to 4 degrees, leave other values
                >>> ch.home_parameters = None, None, None, 4 * u.deg
                >>> ch.home_parameters  # read it back
                (2, 1, <Quantity(9.99, 'degree / second')>, <Quantity(3.99, 'degree')>)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_HOMEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_HOMEPARAMS,
                expect_data_len=14,
            )
            # chan, home_dir, limit_switch, velocity, ,offset_dist
            _, home_dir, lim_sw, vel, offset = struct.unpack(""<HHHll"", response.data)
            return (
                int(home_dir),
                int(lim_sw),
                u.Quantity(vel) / self.scale_factors[1],
                u.Quantity(offset, ""counts"") / self.scale_factors[0],
            )

        @home_parameters.setter
        def home_parameters(self, values):
            if len(values) != 4:
                raise ValueError(
                    ""Home parameters muust be set with four values: ""
                    ""Home direction, limit switch settings, velocity, and offset. ""
                    ""For settings you want to leave untouched, pass `None`.""
                )

            # replace values that are `None`
            if None in values:
                set_params = self.home_parameters
                values = [x if x is not None else y for x, y in zip(values, set_params)]

            home_dir, lim_sw, velocity, offset = values
            if isinstance(velocity, u.Quantity):
                velocity = (velocity * self.scale_factors[1]).to_reduced_units()
                if velocity.dimensionless:
                    velocity = int(velocity.magnitude)
                else:
                    raise ValueError(
                        ""Provided units for velocity are not compatible ""
                        ""with current motor scale factor.""
                    )
            if isinstance(offset, u.Quantity):
                if offset.units == u.counts:
                    offset = int(offset.magnitude)
                else:
                    scaled_vel = offset * self.scale_factors[0]
                    try:
                        offset = int(scaled_vel.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units for offset are not compatible ""
                            ""with current motor scale factor.""
                        )

                # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_HOMEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHll"",
                    self._idx_chan,
                    int(home_dir),
                    int(lim_sw),
                    int(velocity),
                    int(offset),
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def status_bits(self):
            """"""
            Gets the status bits for the specified motor channel.

            .. note:: This command, as currently implemented, is only
                available for certain devices and will result in an
                ``OSError`` otherwise. Devices that work according to the
                manual are: TSC001, KSC101, BSC10x, BSC20x, LTS150, LTS300,
                MLJ050, MLJ150, TIM101, KIM101.

            :type: `dict`
            """"""
            # NOTE: the difference between MOT_REQ_STATUSUPDATE and
            # MOT_REQ_DCSTATUSUPDATE confuses me
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_STATUSUPDATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            # The documentation claims there are 14 data bytes, but it seems
            # there are sometimes some extra random ones...
            # fixme: wrong expected datatype? MOT_GET_STATUSUPDATE expected
            resp_data = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER,
                expect_data_len=14,
            ).data[:14]
            # ch_ident, position, enc_count, status_bits
            _, _, _, status_bits = struct.unpack(""<HLLL"", resp_data)

            status_dict = {
                key: (status_bits & bit_mask > 0)
                for key, bit_mask in self.__STATUS_BIT_MASK.items()
            }

            return status_dict

        @property
        def position(self):
            """"""
            Gets the current position of the specified motor channel

            :type: `~pint.Quantity`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_POSCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @property
        def position_encoder(self):
            """"""
            Gets the position of the encoder of the specified motor channel

            :type: `~pint.Quantity`
            :units: Encoder ``counts``
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_ENCCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_ENCCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"")

        def go_home(self):
            """"""
            Instructs the specified motor channel to return to its home
            position
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_HOME,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_HOMED,
                timeout=self.motion_timeout,
            )

        def move(self, pos, absolute=True):
            """"""
            Instructs the specified motor channel to move to a specific
            location. The provided position can be either an absolute or
            relative position.

            :param pos: The position to move to. Provided value will be
                converted to encoder counts.
            :type pos: `~pint.Quantity`
            :units pos: As specified, or assumed to of units encoder counts

            :param bool absolute: Specify if the position is a relative or
                absolute position. ``True`` means absolute, while ``False``
                is for a relative move.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> # select the stage that is connected to the controller
                >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

                >>> # move to 32 degrees absolute position
                >>> ch.move(u.Quantity(32, u.deg))

                >>> # move 10 degrees forward from current position
                >>> ch.move(u.Quantity(10, u.deg), absolute=False)
            """"""
            # Handle units as follows:
            # 1. Treat raw numbers as encoder counts.
            # 2. If units are provided (as a Quantity), check if they're encoder
            #    counts. If they aren't, apply scale factor.
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )

            # Now that we have our position as an integer number of encoder
            # counts, we're good to move.
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_ABSOLUTE
                if absolute
                else _cmds.ThorLabsCommands.MOT_MOVE_RELATIVE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )

            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_COMPLETED,
                timeout=self.motion_timeout,
                expect_data_len=14,
            )

    _channel_type = MotorChannel

    # CONTROLLER PROPERTIES AND METHODS #
"
260,https://www.thorlabs.com/_sd.cfm?fileName=12597-D02.pdf&partNumber=TC200,https://www.omega.ca/en/resources/temperature-controllers,"[OrderedDict([('id', 'attcuzwqvuj6cXzvc'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/g99QLydjD5THCFVFlM0uBA/bQg7O2hREw1lGQukxg3cyHYvFBqt6KTEvTERX6WiaD2q-4Auj1LL5gNSy5SKIKThRHEdw6Pr7o3BbszZJX3PLBzvwLjaWlOxHBN-JkiKLBA/P4qDobos_l4R-YqBHwFETnVZMBwxfuQy3Bfz1745VKQ'), ('filename', '12597-xl.jpg'), ('size', 35659), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/u3FIRVsSXmZSxPzOpVGl2Q/oG9u45a_OID90aWjeWXN6l1zid0Ql-l5KnuK70VcFqbwmhdtztUnTEnTOWTk8X-op8OEg1NyPMVd57wW4T6tWQ/3bBqQY7aGMzobIswHSNKHccPGbpem9HbPtka-18P9w4'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jHGRWQ9S0feXswwc5Drrag/64r3mKtrOfPL6i_31jypyLVPL6foPtLT1iX6bnb3BG9TCZz9j8KO8L3p41twnRyytvpY3XIQP9FjbiuiV-fTiw/9j6SiTD84v_cbokx4KrvlGM3wLU3tfKwfkA0SxckGKo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/gCcLqlmGQTE6ssIqD3QMPw/QNRJh1-utqsmnSyO44UlshLjlH57CsuIydgeZ05kiNCE3DTH-IicO0qV1EUXXCB1dDZsHI3rW7-vj9TELSOl-Q/3Yq-TNFncbaVfmQeHaFsNeFwHo2eeOcqHWvRCOwSDYo'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The TC200 Temperature Controller is a bench top controller intended for use with resistive heating elements
rated up to 18 Watts. This general purpose instrument can drive various types of heaters, including foil and
resistive coil types. It accepts feedback from either positive or negative temperature coefficient thermistors, has
programmable P, I, and D gains, and will display the temperature in °C, °F, or K. In addition, it can be
programmed for up to five sequential temperature settings along with associated ramp and hold times for each
level. A user-programmable maximum temperature limit provides protection to the device being heated, and a
user-programmable power limit protects the heating element from being over driven. ",https://www.thorlabs.com/thorproduct.cfm?partnumber=TC200,TC 200,598.0,['Temperature Controllers'],"As the name implies, a temperature controller is an instrument used to control temperatures, mainly without extensive operator involvement. A controller in a temperature control system will accept a temperature sensor such as a thermocouple or RTD as input and compare the actual temperature to the desired control temperature, or setpoint. It will then provide an output to a control element.

Digital temperature controllers are used in a variety of applications, ranging from industrial processes to consumer products. For example, industrial applications such as HVAC systems, food processing, and chemical processing often require precise temperature control in order to ensure quality and safety. On the other hand, consumer products such as refrigerators, air conditioners, and water heaters also rely on temperature controllers to maintain a comfortable environment.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/tc200.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#tc200-temperature-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782658/Instruments/Temperature%20Controllers/TC200/TC200.jpg,TC200,Write a Python script that uses Instrumentkit to connect to a TC200 Temperature Controllers,,,True,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs TC200 temperature controller.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum, Enum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import (
    convert_temperature,
    enum_property,
    unitful_property,
    int_property,
)

# CLASSES #####################################################################


class TC200(Instrument):

    """"""
    The TC200 is is a controller for the voltage across a heating element.
    It can also read in the temperature off of a thermistor and implements
    a PID control to keep the temperature at a set value.

    The user manual can be found here:
    http://www.thorlabs.com/thorcat/12500/TC200-Manual.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.prompt = ""> ""

    def _ack_expected(self, msg=""""):
        return msg

    # ENUMS #

    class Mode(IntEnum):

        """"""
        Enum containing valid output modes of the TC200.
        """"""

        normal = 0
        cycle = 1

    class Sensor(Enum):

        """"""
        Enum containing valid temperature sensor types for the TC200.
        """"""

        ptc100 = ""ptc100""
        ptc1000 = ""ptc1000""
        th10k = ""th10k""
        ntc10k = ""ntc10k""

    # PROPERTIES #

    def name(self):
        """"""
        Gets the name and version number of the device

        :return: the name string of the device
        :rtype: str
        """"""
        response = self.query(""*idn?"")
        return response

    @property
    def mode(self):
        """"""
        Gets/sets the output mode of the TC200

        :type: `TC200.Mode`
        """"""
        response = self.status
        response_code = (int(response) >> 1) % 2
        return TC200.Mode(response_code)

    @mode.setter
    def mode(self, newval):
        if not isinstance(newval, TC200.Mode):
            raise TypeError(
                ""Mode setting must be a `TC200.Mode` value, ""
                ""got {} instead."".format(type(newval))
            )
        out_query = f""mode={newval.name}""
        # there is an issue with the TC200; it responds with a spurious
        # Command Error on mode=normal. Thus, the sendcmd() method cannot
        # be used.
        if newval == TC200.Mode.normal:
            self.prompt = ""Command error CMD_ARG_RANGE_ERR\n\r> ""
            self.sendcmd(out_query)
            self.prompt = ""> ""
        else:
            self.sendcmd(out_query)

    @property
    def enable(self):
        """"""
        Gets/sets the heater enable status.

        If output enable is on (`True`), there is a voltage on the output.

        :type: `bool`
        """"""
        response = self.status
        return True if int(response) % 2 == 1 else False

    @enable.setter
    def enable(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(
                ""TC200 enable property must be specified with a "" ""boolean.""
            )
        # the ""ens"" command is a toggle, we need to track two different cases,
        # when it should be on and it is off, and when it is off and
        # should be on

        # if no sensor is attached, the unit will respond with an error.
        # There is no current error handling in the way that thorlabs
        # responds with errors
        if newval and not self.enable:
            response1 = self._file.query(""ens"")
            while response1 != "">"":
                response1 = self._file.read(1)
            self._file.read(1)

        elif not newval and self.enable:
            response1 = self._file.query(""ens"")
            while response1 != "">"":
                response1 = self._file.read(1)
            self._file.read(1)

    @property
    def status(self):
        """"""
        Gets the the status code of the TC200

        :rtype: `int`
        """"""
        _ = self._file.query(""stat?"")
        response = self.read(5)
        return int(response.split("" "")[0])

    temperature = unitful_property(
        ""tact"",
        units=u.degC,
        readonly=True,
        input_decoration=lambda x: x.replace("" C"", """")
        .replace("" F"", """")
        .replace("" K"", """"),
        doc=""""""
        Gets the actual temperature of the sensor

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units degrees C.
        :type: `~pint.Quantity` or `int`
        :return: the temperature (in degrees C)
        :rtype: `~pint.Quantity`
        """""",
    )

    max_temperature = unitful_property(
        ""tmax"",
        units=u.degC,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(u.Quantity(20, u.degC), u.Quantity(205, u.degC)),
        doc=""""""
        Gets/sets the maximum temperature

        :return: the maximum temperature (in deg C)
        :units: As specified or assumed to be degree Celsius. Returns with
            units degC.
        :rtype: `~pint.Quantity`
        """""",
    )

    @property
    def temperature_set(self):
        """"""
        Gets/sets the actual temperature of the sensor

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units degrees C.
        :type: `~pint.Quantity` or `int`
        :return: the temperature (in degrees C)
        :rtype: `~pint.Quantity`
        """"""
        response = (
            self.query(""tset?"")
            .replace("" Celsius"", """")
            .replace("" C"", """")
            .replace("" F"", """")
            .replace("" K"", """")
        )
        return u.Quantity(float(response), u.degC)

    @temperature_set.setter
    def temperature_set(self, newval):
        # the set temperature is always in celsius
        newval = convert_temperature(newval, u.degC)
        if newval < u.Quantity(20.0, u.degC) or newval > self.max_temperature:
            raise ValueError(""Temperature set is out of range."")
        out_query = f""tset={newval.magnitude}""
        self.sendcmd(out_query)

    @property
    def p(self):
        """"""
        Gets/sets the p-gain. Valid numbers are [1,250].

        :return: the p-gain (in nnn)
        :rtype: `int`
        """"""
        return self.pid[0]

    @p.setter
    def p(self, newval):
        if newval not in range(1, 251):
            raise ValueError(""P-value not in [1, 250]"")
        self.sendcmd(f""pgain={newval}"")

    @property
    def i(self):
        """"""
        Gets/sets the i-gain. Valid numbers are [1,250]

        :return: the i-gain (in nnn)
        :rtype: `int`
        """"""
        return self.pid[1]

    @i.setter
    def i(self, newval):
        if newval not in range(0, 251):
            raise ValueError(""I-value not in [0, 250]"")
        self.sendcmd(f""igain={newval}"")

    @property
    def d(self):
        """"""
        Gets/sets the d-gain. Valid numbers are [0, 250]

        :return: the d-gain (in nnn)
        :type: `int`
        """"""
        return self.pid[2]

    @d.setter
    def d(self, newval):
        if newval not in range(0, 251):
            raise ValueError(""D-value not in [0, 250]"")
        self.sendcmd(f""dgain={newval}"")

    @property
    def pid(self):
        """"""
        Gets/sets all three PID values at the same time. See `TC200.p`,
        `TC200.i`, and `TC200.d` for individual restrictions.

        If `None` is specified then the corresponding PID value is not changed.

        :return: List of integers of PID values. In order [P, I, D].
        :type: `list` or `tuple`
        :rtype: `list`
        """"""
        return list(map(int, self.query(""pid?"").split()))

    @pid.setter
    def pid(self, newval):
        if not isinstance(newval, (list, tuple)):
            raise TypeError(""Setting PID must be specified as a list or tuple"")
        if newval[0] is not None:
            self.p = newval[0]
        if newval[1] is not None:
            self.i = newval[1]
        if newval[2] is not None:
            self.d = newval[2]

    @property
    def degrees(self):
        """"""
        Gets/sets the units of the temperature measurement.

        :return: The temperature units (degC/F/K) the TC200 is measuring in
        :type: `~pint.Unit`
        """"""
        response = self.status
        if (response >> 4) % 2 and (response >> 5) % 2:
            return u.degC
        elif (response >> 5) % 2:
            return u.degK

        return u.degF

    @degrees.setter
    def degrees(self, newval):
        if newval == u.degC:
            self.sendcmd(""unit=c"")
        elif newval == u.degF:
            self.sendcmd(""unit=f"")
        elif newval == u.degK:
            self.sendcmd(""unit=k"")
        else:
            raise TypeError(""Invalid temperature type"")

    sensor = enum_property(
        ""sns"",
        Sensor,
        input_decoration=lambda x: x.split("","")[0].split(""="")[1].strip().lower(),
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the current thermistor type. Used for converting resistances
        to temperatures.

        :return: The thermistor type
        :type: `TC200.Sensor`
        """""",
    )

    beta = int_property(
        ""beta"",
        valid_set=range(2000, 6001),
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the beta value of the thermistor curve.

        Value within [2000, 6000]

        :return: the gain (in nnn)
        :type: `int`
        """""",
    )

    max_power = unitful_property(
        ""pmax"",
        units=u.W,
        format_code=""{:.1f}"",
        set_fmt=""{}={}"",
        valid_range=(0.1 * u.W, 18.0 * u.W),
        doc=""""""
        Gets/sets the maximum power

        :return: The maximum power
        :units: Watts (linear units)
        :type: `~pint.Quantity`
        """""",
    )
"
263,https://cdn.teledynelecroy.com/files/pdf/hdo4000a-oscilloscopes-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attFW6vjF1JLHmN7h'), ('width', 260), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x5T9cGb9xEOt5jxbaeViwA/TvfCYbbDVzl6ONW-qUrD3TtoFwDv1nRAjCyu5nHczB4TXzYW9AD87qkTv0voXl1sYHBs2B_ltSLEgY718qFWycrfa7_sVrNgogSq2awfpQA/7vc6D3ovfPUcdRN1yQN5RUCofIII1Vd5nQEXdzUGHPI'), ('filename', 'hdo4000a-00.webp'), ('size', 18318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xD5Dp0ZBqJ01p3_34ILYTg/R1ILX7jubf9bP_rPeuHCRvGUiZbb3l6kIcNZ0FgHCgpLQQ1LOTR9gIVR1LTg4bKA2pjX66q2_kBiSlAbuN8hA8DAP7WqnGQXRhhPcceEokc/jHIEQJIVMHj_SqR3n_IliXiKkeXg5aSlpVEpQ3__I2Q'), ('width', 37), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HftOjTYbcj1reVMdVGoR_Q/4DcvlxAvgCLT2MsSY5iJDaR7TnhwDcAzoLfvj8FU1cXOBzVoD5cS38tYv2PVtF48JyE7jLd-C0-JHnsKlKlqGg45QCpRx8Qhbg0gO3oOkUI/VHweVj9itNgvFcS-6jKYCv80JccbbbsBVsw4IbwmI0Q'), ('width', 260), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/E6bFZzOXEO2s0QLF0fKHyw/npfErchODfGnO9iKRH9FLM44_CZmNOcYBuOR2F3YFyWmttP_jW2Asa8s6P88UBdU4cjO6cckhlVPbfMlgJsCjtpHEX2umR6ge8KF5yIg5Qk/w4Huc1OdKBpfvZhsw-vaAoXhfcxQ48t7HaPHx2drLFs'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"HDO4000A oscilloscopes have 4 analog input channels, 12-bit resolution using Teledyne LeCroy’s HD4096 high definition technology, up to 1 GHz of bandwidth and a compact form factor with a large 12.1” multi-touch display. They are ideal for debug and troubleshooting of power electronics designs, digital power management or power integrity analysis, automotive electronics systems, and deeply embedded or mechatronic designs.",https://www.teledynelecroy.com/oscilloscope/hdo4000a-high-definition-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782661/Instruments/Oscilloscopes/HDO4000A/HDO4000A.webp,HDO4000A,Write a Python script that uses Instrumentkit to connect to a HDO4000A Oscilloscopes,,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
266,,"https://www.sciencedirect.com/topics/engineering/motor-controller#:~:text=Motor%20controllers-,Motor%20controllers%20are%20devices%20which%20regulate%20the%20operation%20of%20an,operation%20of%20the%20prime%20mover.","[OrderedDict([('id', 'attQbpWUn3oumhgod'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0it7UZq0_3Q9Ii5QMi0lfA/o0lEs1SlTN1vxjJ_-zZYy83GfKZsquoSQeyOv0tdCUyyLk2fLU4VRFTNRJY4y5rDkaWsqPVLJDoqnskmWoPWhXGrq3cY9YvNFtdGjfX9c0Y/NE7Z4yqPazxaHAXoRcuByQRglosmEIaqlQ3FVOMZP2U'), ('filename', 'AG-UC2.jpeg'), ('size', 87230), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xhBx01TEZEts8VnX4oS1OQ/lpvSenR3SQe-r5goegI3zWerbUOhqHw7n4SIufuX98s2FRrS0K2lccV5LYvoXF61UAA9OBSmirmTkp6A-7xkNQ/8zyfinUMvZJHsE721SK1WhOzyDcrMZdXC-9xLoVbY7o'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/b05Rr8uIZdSmRSy8xV9DDw/ws2WlTagw7QyV9f5crm0QZq1tix4WOcFGI1GcaFLKV25fjmjWUsP3Tlj-i4vHdYhpJFJ3dIfByLANhst1xqL7Q/x6pyOw5ruZpZU06rOeHaQzCAfXZwjQUELpuFsDsc7pk'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/QbsbQ70_nlOJpnPSfw0ffg/ke83MsnqDQPIFoUUvjXsW0uNfV_qYYRvJINp0fto6yhl3ffDZjwI-ePgfRZPqmES9xBiQoZe-ljI4T3VURvTwA/Tx3bEgh7V0rncTVPj1WALyON5MkovDzgZvxKnUvHXkE'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,"The AG-UC2 Agilis™ Controller provides USB computer control for two Agilis axes. The AG-UC2 controller features two sets of push buttons for each Agilis axis; one set for step size settings, and the other set for precise low speed adjustments and fast coarse motion. Power is supplied through the USB port and if not available, the USB-CH power supply can independently power the Agilis controller. USB hubs may also be used for power and communication, but must provide the required 5 V supply, e.g. must feature an external power supply.",https://www.newport.com/p/AG-UC2,Aguc 2,380.0,['Motor Controller'],"Motor controllers are devices which regulate the operation of an electric motor. In artificial lift applications, motor controllers generally refer to those devices used in conjunction with switchboards or VFDs to control the operation of the prime mover.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html,Instrumentkit,https://github.com/instrumentkit/InstrumentKit/blob/main/doc/source/apiref/newport.rst,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782662/Instruments/Motor%20Controller/AG-UC2/AG-UC2.jpg,AG-UC2,Write a Python script that uses Instrumentkit to connect to a AG-UC2 Motor Controller,,,,,
272,,,,2819.0,"Columbus, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125974/Instruments/Vendor%20Logos/Mettler_Toledo.png,"Instrument class to communicate with Mettler Toledo balances using the MT-SICS Standared Interface Command Set.

",https://www.mt.com/ca/en/home/library/user-manuals/laboratory-weighing/RM-MT-SICS-MS-ML-ME.html,Mtsics,368.0,['Miscellaneous'],Miscellaneous,"Mettler Toledo (NYSE: MTD) is a multinational manufacturer of scales and analytical instruments. It is the largest provider of weighing instruments for use in laboratory, industrial, and food retailing applications. The company also provides various analytical instruments, process analytics instruments, and end-of-line inspection systems. The company operates worldwide with 70% of net sales, derived in equal parts, from Europe and from the Americas. Asian business is included in the remaining 30%.[2] Mettler Toledo is headquartered in Switzerland and incorporated in the United States.[4]
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/mettler_toledo/mt_sics.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/mettler_toledo.html?highlight=mettler%20toeldo#instruments.mettler_toledo.MTSICS,Mettler Toledo,"[OrderedDict([('id', 'att9xokawODTifrvQ'), ('width', 610), ('height', 343), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ilmp4W1s9rCC5q5dgOOmCA/VP8vxhxKr-t46WMdXVhHV-RvKxX3D1IlgYOrVtxR8205u1lrbb2U1GZdm2gAaqdtNxKGmJWh2JUfVI249kOIhQmAlX1mUCxaKf5nGsjPiBXYMzmizZPV24msb07sNIeysAFeOAzeKG2YY3J6jXHDnQ/INSlm-trM8cVzpg0nkHJ3aqC1M2bp6JtiWCrLz2Uv7M'), ('filename', 'Mettler-Toledo-AG-SIC-Pharma-2010-2014.jpg'), ('size', 13614), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eJ9Vm51gjiDBPo1BkYlm9A/iMohkuZpNyyTmOKlTPs673sM-q082kzPZAzwW3dnpDZrwtwU_Y99A7yo3ewP5tDGabNbsGFOHCGESK1VM4KPDA/h7T6iZF5GHvPxBKRF56pJuDsN8WU9-ixGJs6oMnzdM8'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/c3ab-S0S4Nf9_hnRhRK8pw/KfmLzo7nxEGNGHOrVKfBDtbBgeakXhFhVyT_c-rbHSEncEXbfHT-4p8K1-dNe0lhKSc-KzH2pBP73X5OpXqRZA/DYwm6bLfTinvkkf4VKHakbiU9kKoG3MOpLEhNUQ6J80'), ('width', 610), ('height', 343)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cnYg3tff9LFdOiD0c3njwA/0B6mi_AkmrSleniek2NfcGAM6Uuuvftzs3Kx6nHWFsZv-IBGIS_Cv2BNgXHjygaaQmpW5fv3gN3UkqYGB7MhJA/4n4DqPyRsm6Np0oIF1FMdac1mexGugCMRkNKdl_A0kM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.mt.com/ca/en/home.html,,MT Standard Interface Communication Software,Write a Python script that uses Instrumentkit to connect to a MT Standard Interface Communication Software Miscellaneous,,,,,"#!/usr/bin/env python
""""""
Provides support for the Mettler Toledo balances via Standard Interface Command Set.
""""""

from enum import Enum
import warnings

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units


class MTSICS(Instrument):
    """"""
    Instrument class to communicate with Mettler Toledo balances using the MT-SICS
    Standared Interface Command Set.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
    >>> inst.weight
    <Quantity(120.2, 'gram')>
    """"""

    class WeightMode(Enum):
        """"""
        Enum class to select the weight mode.
        """"""

        stable = False
        immediately = True

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r\n""
        self._weight_mode = MTSICS.WeightMode.stable

    def clear_tare(self):
        """"""
        Clear the tare value.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.clear_tare()
        """"""
        _ = self.query(""TAC"")

    def reset(self):
        """"""
        Reset the balance.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.reset()
        """"""
        _ = self.query(""@"")

    def tare(self, immediately=None):
        """"""
        Tare the balance.

        The mode is dependent on the weight mode, however, can be overwritten with
        the keyword `immediately`.

        :param bool immediately: Tare immediately if True, otherwise wait for stable
            weight.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.tare()
        """"""
        if immediately is None:
            immediately = self.weight_mode.value
        msg = ""TI"" if immediately else ""T""
        _ = self.query(msg)

    def zero(self, immediately=None):
        """"""
        Zero the balance after stable weight is obtained.

        Terminates processes such as zero, tare, calibration and testing etc.
        If the device is in standby mode, it is turned on. This function sets the
        currently read and the tare value to zero.

        The mode is dependent on the weight mode, however, can be overwritten with
        the keyword `immediately`.

        :param bool immediately: Zero immediately if True, otherwise wait for stable
            weight.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.zero()
        """"""
        if immediately is None:
            immediately = self.weight_mode.value
        msg = ""ZI"" if immediately else ""Z""
        _ = self.query(msg)

    def query(self, cmd, size=-1):
        """"""
        Query the instrument for a response.

        Error checking is performed on the response.

        :param str cmd: The command to send to the instrument.
        :param int size: Number of bytes to read from the instrument.

        :return: The response from the instrument.
        :rtype: str

        :raises: UserWarning if the balance is in dynamic mode.
        """"""
        self.sendcmd(cmd)

        rval = self.read(size)
        rval = rval.split()

        # error checking
        self._general_error_checking(rval[0])
        self._cmd_error_checking(rval[1])

        # raise warning if balance in dynamic mode
        if rval[1] == ""D"":
            warnings.warn(""Balance in dynamic mode."", UserWarning)

        return rval[2:]

    def _cmd_error_checking(self, value):
        """"""
        Check for errors in the query response.

        :param value: Command specific error code.
        :return: None

        :raises: OSError if an error in the command occurred.
        """"""
        if value == ""I"":
            raise OSError(""Internal error (e.g. balance not ready yet)."")
        elif value == ""L"":
            raise OSError(""Logical error (e.g. parameter not allowed)."")
        elif value == ""+"":
            raise OSError(
                ""Weigh module or balance is in overload range""
                ""(weighing range exceeded).""
            )
        elif value == ""-"":
            raise OSError(
                ""Weigh module or balance is in underload range""
                ""(e.g. weighing pan is not in place).""
            )

    def _general_error_checking(self, value):
        """"""
        Check for general errors in the query response.

        :param value:  General error code.

        :return: None

        :raises: OSError if a general error occurred.
        """"""
        if value == ""ES"":
            raise OSError(""Syntax Error."")
        elif value == ""ET"":
            raise OSError(""Transmission Error."")
        elif value == ""EL"":
            raise OSError(""Logical Error."")

    @property
    def mt_sics(self):
        """"""
        Get MT-SICS level and MT-SICS versions.

        :return: Level, Version Level 0, Version Level 1, Version Level 2,
            Version Level 3

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.mt_sics
        ['1', '1.0', '1.0', '1.0']
        """"""
        retval = [it.replace('""', """") for it in self.query(""I1"")]
        return retval

    @property
    def mt_sics_commands(self):
        """"""
        Get MT-SICS commands.

        Please refer to manual for information on the commands. Not all of these
        commands are currently implemented in this class!

        :return: List of all implemented MT-SICS levels and commands
        :rtype: list

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> in inst.mt_sics_commands
        [[""0"", ""I0""], [""1"", ""D""]]
        """"""
        timeout = self.timeout
        self.timeout = u.Quantity(0.1, u.s)

        retlist = []
        self.sendcmd(""I0"")
        while True:
            try:
                lst = self.read().split()
                if lst == []:  # data stream was empty
                    break
                retlist.append(lst)
            except OSError:  # communication timed out
                break
        self.timeout = timeout
        av_cmds = [[it[2], it[3].replace('""', """")] for it in retlist]
        return av_cmds

    @property
    def name(self):
        """"""Get / Set balance name.

        A maximum of 20 characters can be entered.

        :raises ValueError: If name is longer than 20 characters.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.name = ""My Balance""
        >>> inst.name
        'My Balance'
        """"""
        retval = "" "".join(self.query(""I10""))
        return retval.replace('""', """")

    @name.setter
    def name(self, value):
        if len(value) > 20:
            raise ValueError(""Name must be 20 characters or less."")
        _ = self.query(f'I10 ""{value}""')

    @property
    def serial_number(self):
        """"""
        Get the serial number of the balance.

        :return: The serial number of the balance.
        :rtype: str

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.serial_number
        '123456789'
        """"""
        return self.query(""I4"")[0].replace('""', """")

    @property
    def tare_value(self):
        """"""Get / set the tare value.

        If no unit is given, grams are assumed.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.tare_value = 1.0
        >>> inst.tare_value
        <Quantity(1.0, 'gram')>
        """"""
        retval = self.query(""TA"")
        return u.Quantity(float(retval[0]), retval[1])

    @tare_value.setter
    def tare_value(self, value):
        value = assume_units(value, u.gram)
        value = value.to(u.gram)
        _ = self.query(f""TA {value.magnitude} g"")

    @property
    def weight(self):
        """"""
        Get the weight.

        If you want to get the immediate (maybe unstable) weight, plese set the
        weight mode accordingly.

        :return: Weight
        :rtype: u.Quantity

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.weight
        <Quantity(1.0, 'gram')>
        """"""
        msg = ""SI"" if self.weight_mode.value else ""S""
        retval = self.query(msg)
        return u.Quantity(float(retval[0]), retval[1])

    @property
    def weight_mode(self):
        """"""Get/set the weight mode.

        By default, it starts in ``MTSICS.WeightMode.stable``.

        :return: Weight mode
        :rtype: MTSICS.WeightMode

        :raises TypeError: Weight mode is not of type ``MTSICS.WeightMode``

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.mettler_toledo.MTSICS.open_serial('/dev/ttyUSB0', 9600)
        >>> inst.weight_mode = inst.WeightMode.immediately
        >>> inst.weight_mode
        <Weight.immediately>
        """"""
        return self._weight_mode

    @weight_mode.setter
    def weight_mode(self, value):
        if not isinstance(value, MTSICS.WeightMode):
            raise TypeError(""Weight mode must be of type `MTSICS.WeightMode"")
        self._weight_mode = value
"
273,https://www.optixs.cz/data/ke-stazeni/475_dsp_gaussmeter-d879.pdf,https://en.wikipedia.org/wiki/Magnetometer,"[OrderedDict([('id', 'attN0SqMNqnS9oS5O'), ('width', 500), ('height', 271), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IAXSP7fPquFgR9e9bZBD2w/aLGzG8lwLAk-i---PFuH070ARV1ICc_JThbeHaeaoKb8yDunJRFQEwbKD3_UXEbAZlk2Lw3pRLdvDVUHnSEPXg/_Hpny11IOiAeT1Rkb2TuTwkNRX1Hv9mxEr0WHCr2jGc'), ('filename', '475.png'), ('size', 146533), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/M3E6d79Ii7MOLYSWtrTGtQ/gHIdfrkdvC-v3ZZ0MP2tyzyMDKsLF5duY1KyY6s_oPVHXjXjmPYHspWcOcs_cp7vY19RwSTJI3x5F79nrdKL1w/VwXs_wJUCTqgeS9GcQaMWPGsD8nwTIef4cAORsOOM5s'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bC_Q13Yj43EdClbShgBqJg/zbedeEBpEgoYiXTpBXynHWCmANPEWZ0wvVVdAZ-ExlLmEW2RmpO_RSVjNipdzobjWvo23gO4lQUKv37u8roGJQ/bQPIVRg5gJX9X_IeL61yOReuGq6tV58yqsy61VKnIjM'), ('width', 500), ('height', 271)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IDpjF_UyiRiO6EGuVqaoqg/TBR2dvS4TxJB9PxiIe98KnIjMw3nMc3Vc3m6zhMDpOdeTI8qZ-ffdGc37TnwgSOWC4x41s4gbhQCfIPYLPLTkw/2fn2WauPBIxp1Q8TsNQayvuAID2o8oj0WUrEH6QZTqg'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"Lake Shore combined the technical advantages of digital signal processing with over a decade of experience in precision magnetic field measurements to produce the first commercial digital signal processor (DSP) based Hall effect gaussmeter, the Model 475. DSP technology creates a solid foundation for accurate, stable, and repeatable field measurement while simultaneously enabling the gaussmeter to offer an unequaled set of useful measurement features. The Model 475 is intended for the most demanding DC and AC applications. In many cases, it provides the functionality of two or more instruments in a field measurement system.",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-475-dsp-gaussmeter,Lakeshore 475,348.0,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore475.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore475-gaussmeter,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782669/Instruments/Power%20Meters/Lakeshore-475/Lakeshore-475.png,Lakeshore 475,Write a Python script that uses Instrumentkit to connect to a Lakeshore 475 Power Meters,4454.0,,,,"#!/usr/bin/env python
""""""
Provides support for the Lakeshore 475 Gaussmeter.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units, bool_property

# CONSTANTS ###################################################################

LAKESHORE_FIELD_UNITS = {1: u.gauss, 2: u.tesla, 3: u.oersted, 4: u.amp / u.meter}

LAKESHORE_TEMP_UNITS = {1: u.celsius, 2: u.kelvin}

LAKESHORE_FIELD_UNITS_INV = {v: k for k, v in LAKESHORE_FIELD_UNITS.items()}
LAKESHORE_TEMP_UNITS_INV = {v: k for k, v in LAKESHORE_TEMP_UNITS.items()}

# CLASSES #####################################################################


class Lakeshore475(SCPIInstrument):

    """"""
    The Lakeshore475 is a DSP Gaussmeter with field ranges from 35mG to 350kG.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> gm = ik.lakeshore.Lakeshore475.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(gm.field)
    >>> gm.field_units = u.tesla
    >>> gm.field_setpoint = 0.05 * u.tesla
    """"""

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Lakeshore 475
        """"""

        dc = 1
        rms = 2
        peak = 3

    class Filter(IntEnum):
        """"""
        Enum containing valid filter modes for the Lakeshore 475
        """"""

        wide = 1
        narrow = 2
        lowpass = 3

    class PeakMode(IntEnum):
        """"""
        Enum containing valid peak modes for the Lakeshore 475
        """"""

        periodic = 1
        pulse = 2

    class PeakDisplay(IntEnum):
        """"""
        Enum containing valid peak displays for the Lakeshore 475
        """"""

        positive = 1
        negative = 2
        both = 3

    # PROPERTIES ##

    @property
    def field(self):
        """"""
        Read field from connected probe.

        :type: `~pint.Quantity`
        """"""
        return float(self.query(""RDGFIELD?"")) * self.field_units

    @property
    def field_units(self):
        """"""
        Gets/sets the units of the Gaussmeter.

        Acceptable units are Gauss, Tesla, Oersted, and Amp/meter.

        :type: `~pint.Unit`
        """"""
        value = int(self.query(""UNIT?""))
        return LAKESHORE_FIELD_UNITS[value]

    @field_units.setter
    def field_units(self, newval):
        if isinstance(newval, u.Unit):
            if newval in LAKESHORE_FIELD_UNITS_INV:
                self.sendcmd(f""UNIT {LAKESHORE_FIELD_UNITS_INV[newval]}"")
            else:
                raise ValueError(""Not an acceptable Python quantities object"")
        else:
            raise TypeError(""Field units must be a Python quantity"")

    @property
    def temp_units(self):
        """"""
        Gets/sets the temperature units of the Gaussmeter.

        Acceptable units are celcius and kelvin.

        :type: `~pint.Unit`
        """"""
        value = int(self.query(""TUNIT?""))
        return LAKESHORE_TEMP_UNITS[value]

    @temp_units.setter
    def temp_units(self, newval):
        if isinstance(newval, u.Unit):
            if newval in LAKESHORE_TEMP_UNITS_INV:
                self.sendcmd(f""TUNIT {LAKESHORE_TEMP_UNITS_INV[newval]}"")
            else:
                raise TypeError(""Not an acceptable Python quantities object"")
        else:
            raise TypeError(""Temperature units must be a Python quantity"")

    @property
    def field_setpoint(self):
        """"""
        Gets/sets the final setpoint of the field control ramp.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units Gauss.
        :type: `~pint.Quantity` with units Gauss
        """"""
        value = self.query(""CSETP?"").strip()
        units = self.field_units
        return float(value) * units

    @field_setpoint.setter
    def field_setpoint(self, newval):
        expected_units = self.field_units
        newval = assume_units(newval, u.gauss)

        if newval.units != expected_units:
            raise ValueError(
                f""Field setpoint must be specified in the same units ""
                f""that the field units are currently set to. Attempts units of ""
                f""{newval.units}, currently expecting {expected_units}.""
            )

        self.sendcmd(f""CSETP {newval.magnitude}"")

    @property
    def field_control_params(self):
        """"""
        Gets/sets the parameters associated with the field control ramp.
        These are (in this order) the P, I, ramp rate, and control slope limit.

        :type: `tuple` of 2 `float` and 2 `~pint.Quantity`
        """"""
        params = self.query(""CPARAM?"").strip().split("","")
        params = [float(x) for x in params]
        params[2] = params[2] * self.field_units / u.minute
        params[3] = params[3] * u.volt / u.minute
        return tuple(params)

    @field_control_params.setter
    def field_control_params(self, newval):
        if not isinstance(newval, tuple):
            raise TypeError(""Field control parameters must be specified as "" "" a tuple"")
        p, i, ramp_rate, control_slope_lim = newval

        expected_units = self.field_units / u.minute

        ramp_rate = assume_units(ramp_rate, expected_units)
        if ramp_rate.units != expected_units:
            raise ValueError(
                f""Field control params ramp rate must be specified in the same units ""
                f""that the field units are currently set to, per minute. Attempts units of ""
                f""{ramp_rate.units}, currently expecting {expected_units}.""
            )
        ramp_rate = float(ramp_rate.magnitude)

        unit = u.volt / u.minute
        control_slope_lim = float(
            assume_units(control_slope_lim, unit).to(unit).magnitude
        )

        self.sendcmd(f""CPARAM {p},{i},{ramp_rate},{control_slope_lim}"")

    @property
    def p_value(self):
        """"""
        Gets/sets the P value for the field control ramp.

        :type: `float`
        """"""
        return self.field_control_params[0]

    @p_value.setter
    def p_value(self, newval):
        newval = float(newval)
        values = list(self.field_control_params)
        values[0] = newval
        self.field_control_params = tuple(values)

    @property
    def i_value(self):
        """"""
        Gets/sets the I value for the field control ramp.

        :type: `float`
        """"""
        return self.field_control_params[1]

    @i_value.setter
    def i_value(self, newval):
        newval = float(newval)
        values = list(self.field_control_params)
        values[1] = newval
        self.field_control_params = tuple(values)

    @property
    def ramp_rate(self):
        """"""
        Gets/sets the ramp rate value for the field control ramp.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of current field units / minute.
        :type: `~pint.Quantity`
        """"""
        return self.field_control_params[2]

    @ramp_rate.setter
    def ramp_rate(self, newval):
        unit = self.field_units / u.minute
        newval = float(assume_units(newval, unit).to(unit).magnitude)
        values = list(self.field_control_params)
        values[2] = newval
        self.field_control_params = tuple(values)

    @property
    def control_slope_limit(self):
        """"""
        Gets/sets the I value for the field control ramp.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units volt / minute.
        :type: `~pint.Quantity`
        """"""
        return self.field_control_params[3]

    @control_slope_limit.setter
    def control_slope_limit(self, newval):
        unit = u.volt / u.minute
        newval = float(assume_units(newval, unit).to(unit).magnitude)
        values = list(self.field_control_params)
        values[3] = newval
        self.field_control_params = tuple(values)

    control_mode = bool_property(
        command=""CMODE"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""
        Gets/sets the control mode setting. False corresponds to the field
        control ramp being disables, while True enables the closed loop PI
        field control.

        :type: `bool`
        """""",
    )

    # METHODS ##

    # pylint: disable=too-many-arguments
    def change_measurement_mode(
        self, mode, resolution, filter_type, peak_mode, peak_disp
    ):
        """"""
        Change the measurement mode of the Gaussmeter.

        :param mode: The desired measurement mode.
        :type mode: `Lakeshore475.Mode`

        :param `int` resolution: Digit resolution of the measured field. One of
            `{3|4|5}`.

        :param filter_type: Specify the signal filter
            used by the instrument. Available types include wide band, narrow
            band, and low pass.
        :type filter_type: `Lakeshore475.Filter`

        :param peak_mode: Peak measurement mode to be
            used.
        :type peak_mode: `Lakeshore475.PeakMode`

        :param peak_disp: Peak display mode to be
            used.
        :type peak_disp: `Lakeshore475.PeakDisplay`
        """"""
        if not isinstance(mode, Lakeshore475.Mode):
            raise TypeError(
                ""Mode setting must be a ""
                ""`Lakeshore475.Mode` value, got {} ""
                ""instead."".format(type(mode))
            )
        if not isinstance(resolution, int):
            raise TypeError('Parameter ""resolution"" must be an integer.')
        if not isinstance(filter_type, Lakeshore475.Filter):
            raise TypeError(
                ""Filter type setting must be a ""
                ""`Lakeshore475.Filter` value, got {} ""
                ""instead."".format(type(filter_type))
            )
        if not isinstance(peak_mode, Lakeshore475.PeakMode):
            raise TypeError(
                ""Peak measurement type setting must be a ""
                ""`Lakeshore475.PeakMode` value, got {} ""
                ""instead."".format(type(peak_mode))
            )
        if not isinstance(peak_disp, Lakeshore475.PeakDisplay):
            raise TypeError(
                ""Peak display type setting must be a ""
                ""`Lakeshore475.PeakDisplay` value, got {} ""
                ""instead."".format(type(peak_disp))
            )

        mode = mode.value
        filter_type = filter_type.value
        peak_mode = peak_mode.value
        peak_disp = peak_disp.value

        # Parse the resolution
        if resolution in range(3, 6):
            resolution -= 2
        else:
            raise ValueError(""Only 3,4,5 are valid resolutions."")

        self.sendcmd(
            ""RDGMODE {},{},{},{},{}"".format(
                mode, resolution, filter_type, peak_mode, peak_disp
            )
        )
"
282,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,https://en.wikipedia.org/wiki/Current_source,"[OrderedDict([('id', 'att31UsbWkgLLw6lz'), ('width', 799), ('height', 416), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AchQe6MkobpPjk-cvwbjvg/VZyBtLNDYLXdeeqkinu6-mX_MSeh5w-2pvBkMgaxXS_0ac8mRV6BY27vVEwiNDS7H0aaIatzrrkPqvuXOy41I4q401oVdcJmgusyz-p8Abs/HWTsDXxl4KCAtCU-NQMXmuPMhqk64ZBjyWLZCJ238B0'), ('filename', 'Keithley_6220.jpg'), ('size', 79670), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/P3AFY-oQeO8yMm-Z-m6skg/Je48PNrNmM0dXQB1_uvWcF_IJDRkuTgcBhhTQugVIiGunNilgD2avU_x0e_IHd3c2bjGHNEhxW7hWtyQ6SDTeg/S5MG_9wDNUFyh-IG1CZn5NtYvj-slSoRiLEyIjkt_Jg'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ctgL_neU9_59KKJN0Y11qw/ZEZqS-v572PfXbR1Zd5i5RdJXhIyBnt4_lP98c0lidzcYdMiePdFJ66x4ezisncxl4HbQKtQ_JJ74ZcmGXQ3Yg/l01Vm21HxMiUCXUmOhQm56qzsxJpKGdIQBXc-ZxFyLY'), ('width', 799), ('height', 416)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/c18Zr1v5aVHTy8sN5M_n5g/bPXS4aQBrOI6y7PECV9-FJHFmmoGz7SXbsxdZt70nJ50vtp5PEiQrJNta9MX-myTEhemV1OVbXEQTZ0UMETmQw/64CIRsSp7jR3yzxjxVI3I5_KN7pIPHPeTi_2nrsI7xo'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/series-6200,Keithley 6220,240.0,['Power Supplies'],"A current source is an electronic circuit that delivers or absorbs an electric current which is independent of the voltage across it.

A current source is the dual of a voltage source. The term current sink is sometimes used for sources fed from a negative voltage supply. Figure 1 shows the schematic symbol for an ideal current source driving a resistive load. There are two types. An independent current source (or sink) delivers a constant current. A dependent current source delivers a current which is proportional to some other voltage or current in the circuit.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.pyli,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,Keithley,"[OrderedDict([('id', 'attqJ7B2tvK8wDFSb'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-kMGuDSPvSsZxUvZUKfkEg/DxJFhwGQlYpsiFafzzpG5O9FndG6ubQUs5v8GdW0v6ycoEZhXzmm7PhJrIsbel3qBLUjBjXuW-PekP1zByxu9a8gxQAVx3EPwIiJHuO1Xfmv9Y76X80NdMFjTCjp2lu3XBrQXTQRxbD8MbJ222IiGQ/cInvk79fqGTdaSpiewQV_xGn8pm32P5hI-sCzvORLOY'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ECLZSAG8gZdH6s2WQB9eXg/qSMRSKp-_vNjy9KLxk5c-YWlIE7qUYHs35-UWKhyuNhixnjDnlqveYEd6GmZXBnWBDHx4WDrkSQbNsc1MiCIMg/UmakXLjrg7HSAUAxyWoiK2REeRj6RMykKrm1OLEaibo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WQdQst9AwmKbOEj3AOETSw/9XS6uiBEqi3-63RzEWK2L8m_X18YoD3ObN9iz6DymP78vXQrF1RBoobAbSFoaG83m-3qzDzkD3gKL6K-dzSGPg/kYzMH0mJbjtjhTBt3o3xBbs82Vi5xUDRpGkgJatWwzo'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/O4s8gPb7juh3-eRMwDqgKA/9m6ZkmQ8Aw2ZiwvQGEENIgwgjtIDn2tIlahkoFlLQObqIEJP5CJqqZOm-uJlXMmOWpBXIl3V4Y0lWfnusUp1IQ/Is8NcHO48zfuV4X2CXFuUu1TAcsqC5SVk5bLEJfmAU4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782676/Instruments/Power%20Supplies/Keithley-6220/Keithley-6220.jpg,Keithley 6220,Write a Python script that uses Instrumentkit to connect to a Keithley 6220 Power Supplies,6210.0,,,,
284,,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attJFtaQgK65Azlmu'), ('width', 800), ('height', 945), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5ZD10qlwQSqblimtTmMPNg/B4ckzXGfjLwVrGKpViNJlW9nbwASg16qAim4U8bZxGK5kPD9sgdVBMqi2zbQnylMVjSS8hy9sYWBuh1dDMUllkXZE2E01G71uaZk1lwGJVo/-0GN501JYJC4Av9mnkNh9mDoCWHEZ3hR1eV1e8IGG0g'), ('filename', 'image.png'), ('size', 845732), ('type', 'image/png')])]",,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692142672/Instruments/Vendor%20Logos/FLOJOY_TEXT.png,"All SCPI Multimeters
",https://supereyes.ru/img/instructions/OWON_HDS_SCPI_manual.pdf,SCPI multimeter,135.0,['Multimeters'],SCPI Multimeter,"
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/generic_scpi/scpi_multimeter.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/generic_scpi.html#scpimultimeter-generic-multimeter-using-scpi-commands,Generic SCPI,"[OrderedDict([('id', 'attpFOvtzuWOJVOYv'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XzYr_HDntjWrgAKAkQQQ6g/v7wLsdS_iBz3S68lwDC5XaUaEmnSqzEJg3Sr08JXEloqINDFXjov0rC46nGo2pufMBVqous9RwXR816VrqNFDjnc71yyzFB5Wyh0DGWkNnM/0u-xCPNvAhB4Q9s7v434ZdW3veLXwZC_mQlmOHLLf1M'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DRpgk7F4sSAeR1s8cammFw/ov4VT_wJHKMVO6PeBJ4CMqruzbOqjQgzvr5ECDp9me1jSVAyZjBL4Zv3Ax1wL2Wbxcxst7ZA8ZQMDRoPDVrHYA/0NFOD6aqMtjNAGQGFVN4L25vJJs2zqYKdaPULjCq77c'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/S4fu3jXFLKOoaMrcz4vheA/QWNNtpA82XJImu_r69nMUU05Jenb20X4F6NReVVasDapf25-pWMR19eYDR_7qnmnnDwWHn_cCy0GSAEx3XnEcQ/2DgpECHpjvcjUT7XT9VP3BcQUMB6Dj0cu9MmtF-wfgE'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/z__R7cswxAdLN4wBlDAK8A/Y_v-Yx_wuhNZjVhhoJIZw2o4_NWbicql2UBXIMKsqc1fxKQuwcQB1-EcWsNuz6Etgpu3uUp4SlaAz0MYK0_6xQ/cpFe3XP6_oaD1RtnFcspfYaoZJGLxKjZCIyc1WoEwfg'), ('width', 3000), ('height', 3000)]))]))])]",https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782678/Instruments/Multimeters/SCPI-multimeter/SCPI-multimeter.png,SCPI multimeter,Write a Python script that uses Instrumentkit to connect to a SCPI multimeter Multimeters,,,,"Many Devices and Vendors SCPI Multimeters, And Github Project seems Coded in C++","#!/usr/bin/env python
""""""
Provides support for SCPI compliant multimeters
""""""

# IMPORTS #####################################################################


from enum import Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import Multimeter
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import assume_units, enum_property, unitful_property

# CONSTANTS ###################################################################

VALID_FRES_NAMES = [""4res"", ""4 res"", ""four res"", ""f res""]

UNITS_CAPACITANCE = [""cap""]
UNITS_VOLTAGE = [""volt:dc"", ""volt:ac"", ""diod""]
UNITS_CURRENT = [""curr:dc"", ""curr:ac""]
UNITS_RESISTANCE = [""res"", ""fres""] + VALID_FRES_NAMES
UNITS_FREQUENCY = [""freq""]
UNITS_TIME = [""per""]
UNITS_TEMPERATURE = [""temp""]

# CLASSES #####################################################################


class SCPIMultimeter(SCPIInstrument, Multimeter):

    """"""
    This class is used for communicating with generic SCPI-compliant
    multimeters.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.generic_scpi.SCPIMultimeter.open_tcpip(""192.168.1.1"")
    >>> print(inst.measure(inst.Mode.resistance))
    """"""

    # ENUMS ##

    class Mode(Enum):

        """"""
        Enum of valid measurement modes for (most) SCPI compliant multimeters
        """"""

        capacitance = ""CAP""
        continuity = ""CONT""
        current_ac = ""CURR:AC""
        current_dc = ""CURR:DC""
        diode = ""DIOD""
        frequency = ""FREQ""
        fourpt_resistance = ""FRES""
        period = ""PER""
        resistance = ""RES""
        temperature = ""TEMP""
        voltage_ac = ""VOLT:AC""
        voltage_dc = ""VOLT:DC""

    class TriggerMode(Enum):

        """"""
        Valid trigger sources for most SCPI Multimeters.

        ""Immediate"": This is a continuous trigger. This means the trigger
        signal is always present.

        ""External"": External TTL pulse on the back of the instrument. It
        is active low.

        ""Bus"": Causes the instrument to trigger when a ``*TRG`` command is
        sent by software. This means calling the trigger() function.
        """"""

        immediate = ""IMM""
        external = ""EXT""
        bus = ""BUS""

    class InputRange(Enum):

        """"""
        Valid device range parameters outside of directly specifying the range.
        """"""

        minimum = ""MIN""
        maximum = ""MAX""
        default = ""DEF""
        automatic = ""AUTO""

    class Resolution(Enum):

        """"""
        Valid measurement resolution parameters outside of directly the
        resolution.
        """"""

        minimum = ""MIN""
        maximum = ""MAX""
        default = ""DEF""

    class TriggerCount(Enum):

        """"""
        Valid trigger count parameters outside of directly the value.
        """"""

        minimum = ""MIN""
        maximum = ""MAX""
        default = ""DEF""
        infinity = ""INF""

    class SampleCount(Enum):

        """"""
        Valid sample count parameters outside of directly the value.
        """"""

        minimum = ""MIN""
        maximum = ""MAX""
        default = ""DEF""

    class SampleSource(Enum):

        """"""
        Valid sample source parameters.

        #. ""immediate"": The trigger delay time is inserted between successive
            samples. After the first measurement is completed, the instrument
            waits the time specified by the trigger delay and then performs the
            next sample.
        #. ""timer"": Successive samples start one sample interval after the
            START of the previous sample.
        """"""

        immediate = ""IMM""
        timer = ""TIM""

    # PROPERTIES ##

    # pylint: disable=unnecessary-lambda,undefined-variable
    mode = enum_property(
        command=""CONF"",
        enum=Mode,
        doc=""""""
        Gets/sets the current measurement mode for the multimeter.

        Example usage:

        >>> dmm.mode = dmm.Mode.voltage_dc

        :type: `~SCPIMultimeter.Mode`
        """""",
        input_decoration=lambda x: SCPIMultimeter._mode_parse(x),
        set_fmt=""{}:{}"",
    )

    trigger_mode = enum_property(
        command=""TRIG:SOUR"",
        enum=TriggerMode,
        doc=""""""
            Gets/sets the SCPI Multimeter trigger mode.

            Example usage:

            >>> dmm.trigger_mode = dmm.TriggerMode.external

            :type: `~SCPIMultimeter.TriggerMode`
        """""",
    )

    @property
    def input_range(self):
        """"""
        Gets/sets the device input range for the device range for the currently
        set multimeter mode.

        Example usages:

        >>> dmm.input_range = dmm.InputRange.automatic
        >>> dmm.input_range = 1 * u.millivolt

        :units: As appropriate for the current mode setting.
        :type: `~pint.Quantity`, or `~SCPIMultimeter.InputRange`
        """"""
        value = self.query(""CONF?"")
        mode = self.Mode(self._mode_parse(value))
        value = value.split("" "")[1].split("","")[0]  # Extract device range
        try:
            return float(value) * UNITS[mode]
        except ValueError:
            return self.InputRange(value.strip())

    @input_range.setter
    def input_range(self, newval):
        current = self.query(""CONF?"")
        mode = self.Mode(self._mode_parse(current))
        units = UNITS[mode]
        if isinstance(newval, self.InputRange):
            newval = newval.value
        else:
            newval = assume_units(newval, units).to(units).magnitude
        self.sendcmd(f""CONF:{mode.value} {newval}"")

    @property
    def resolution(self):
        """"""
        Gets/sets the measurement resolution for the multimeter. When
        specified as a float it is assumed that the user is providing an
        appropriate value.

        Example usage:

        >>> dmm.resolution = 3e-06
        >>> dmm.resolution = dmm.Resolution.maximum

        :type: `int`, `float` or `~SCPIMultimeter.Resolution`
        """"""
        value = self.query(""CONF?"")
        value = value.split("" "")[1].split("","")[1]  # Extract resolution
        try:
            return float(value)
        except ValueError:
            return self.Resolution(value.strip())

    @resolution.setter
    def resolution(self, newval):
        current = self.query(""CONF?"")
        mode = self.Mode(self._mode_parse(current))
        input_range = current.split("" "")[1].split("","")[0]
        if isinstance(newval, self.Resolution):
            newval = newval.value
        elif not isinstance(newval, (float, int)):
            raise TypeError(
                ""Resolution must be specified as an int, float, ""
                ""or SCPIMultimeter.Resolution value.""
            )
        self.sendcmd(f""CONF:{mode.value} {input_range},{newval}"")

    @property
    def trigger_count(self):
        """"""
        Gets/sets the number of triggers that the multimeter will accept before
        returning to an ""idle"" trigger state.

        Note that if the sample_count propery has been changed, the number
        of readings taken total will be a multiplication of sample count and
        trigger count (see property `SCPIMulimeter.sample_count`).

        If specified as a `~SCPIMultimeter.TriggerCount` value, the following
        options apply:

        #. ""minimum"": 1 trigger
        #. ""maximum"": Maximum value as per instrument manual
        #. ""default"": Instrument default as per instrument manual
        #. ""infinity"": Continuous. Typically when the buffer is filled in this
            case, the older data points are overwritten.

        Note that when using triggered measurements, it is recommended that you
        disable autorange by either explicitly disabling it or specifying your
        desired range.

        :type: `int` or `~SCPIMultimeter.TriggerCount`
        """"""
        value = self.query(""TRIG:COUN?"")
        try:
            return int(value)
        except ValueError:
            return self.TriggerCount(value.strip())

    @trigger_count.setter
    def trigger_count(self, newval):
        if isinstance(newval, self.TriggerCount):
            newval = newval.value
        elif not isinstance(newval, int):
            raise TypeError(
                ""Trigger count must be specified as an int ""
                ""or SCPIMultimeter.TriggerCount value.""
            )
        self.sendcmd(f""TRIG:COUN {newval}"")

    @property
    def sample_count(self):
        """"""
        Gets/sets the number of readings (samples) that the multimeter will
        take per trigger event.

        The time between each measurement is defined with the sample_timer
        property.

        Note that if the trigger_count propery has been changed, the number
        of readings taken total will be a multiplication of sample count and
        trigger count (see property `SCPIMulimeter.trigger_count`).

        If specified as a `~SCPIMultimeter.SampleCount` value, the following
        options apply:

        #. ""minimum"": 1 sample per trigger
        #. ""maximum"": Maximum value as per instrument manual
        #. ""default"": Instrument default as per instrument manual

        Note that when using triggered measurements, it is recommended that you
        disable autorange by either explicitly disabling it or specifying your
        desired range.

        :type: `int` or `~SCPIMultimeter.SampleCount`
        """"""
        value = self.query(""SAMP:COUN?"")
        try:
            return int(value)
        except ValueError:
            return self.SampleCount(value.strip())

    @sample_count.setter
    def sample_count(self, newval):
        if isinstance(newval, self.SampleCount):
            newval = newval.value
        elif not isinstance(newval, int):
            raise TypeError(
                ""Sample count must be specified as an int ""
                ""or SCPIMultimeter.SampleCount value.""
            )
        self.sendcmd(f""SAMP:COUN {newval}"")

    trigger_delay = unitful_property(
        command=""TRIG:DEL"",
        units=u.second,
        doc=""""""
        Gets/sets the time delay which the multimeter will use following
        receiving a trigger event before starting the measurement.

        :units: As specified, or assumed to be of units seconds otherwise.
        :type: `~pint.Quantity`
        """""",
    )

    sample_source = enum_property(
        command=""SAMP:SOUR"",
        enum=SampleSource,
        doc=""""""
        Gets/sets the multimeter sample source. This determines whether the
        trigger delay or the sample timer is used to dtermine sample timing when
        the sample count is greater than 1.

        In both cases, the first sample is taken one trigger delay time period
        after the trigger event. After that, it depends on which mode is used.

        :type: `SCPIMultimeter.SampleSource`
        """""",
    )

    sample_timer = unitful_property(
        command=""SAMP:TIM"",
        units=u.second,
        doc=""""""
        Gets/sets the sample interval when the sample counter is greater than
        one and when the sample source is set to timer (see
        `SCPIMultimeter.sample_source`).

        This command does not effect the delay between the trigger occuring and
        the start of the first sample. This trigger delay is set with the
        `~SCPIMultimeter.trigger_delay` property.

        :units: As specified, or assumed to be of units seconds otherwise.
        :type: `~pint.Quantity`
        """""",
    )

    @property
    def relative(self):
        raise NotImplementedError

    @relative.setter
    def relative(self, newval):
        raise NotImplementedError

    # METHODS ##

    def measure(self, mode=None):
        """"""
        Instruct the multimeter to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units. If no appropriate units exist,
        (for example, continuity), then return type is `float`.

        :param mode: Desired measurement mode. If set to `None`, will default
            to the current mode.
        :type mode: `~SCPIMultimeter.Mode`
        """"""
        if mode is None:
            mode = self.mode
        if not isinstance(mode, SCPIMultimeter.Mode):
            raise TypeError(
                ""Mode must be specified as a SCPIMultimeter.Mode ""
                ""value, got {} instead."".format(type(mode))
            )
        # pylint: disable=no-member
        value = float(self.query(f""MEAS:{mode.value}?""))
        return value * UNITS[mode]

    # INTERNAL FUNCTIONS ##

    @staticmethod
    def _mode_parse(val):
        """"""
        When given a string of the form

        ""VOLT +1.00000000E+01,+3.00000000E-06""

        this function will return just the first component representing the mode
        the multimeter is currently in.

        :param str val: Input string to be parsed.

        :rtype: `str`
        """"""
        val = val.split("" "")[0]
        if val == ""VOLT"":
            val = ""VOLT:DC""
        return val


# UNITS #######################################################################

UNITS = {
    SCPIMultimeter.Mode.capacitance: u.farad,
    SCPIMultimeter.Mode.voltage_dc: u.volt,
    SCPIMultimeter.Mode.voltage_ac: u.volt,
    SCPIMultimeter.Mode.diode: u.volt,
    SCPIMultimeter.Mode.current_ac: u.amp,
    SCPIMultimeter.Mode.current_dc: u.amp,
    SCPIMultimeter.Mode.resistance: u.ohm,
    SCPIMultimeter.Mode.fourpt_resistance: u.ohm,
    SCPIMultimeter.Mode.frequency: u.hertz,
    SCPIMultimeter.Mode.period: u.second,
    SCPIMultimeter.Mode.temperature: u.kelvin,
    SCPIMultimeter.Mode.continuity: 1,
}
"
289,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att8CeLFiqOpXnfXX'), ('width', 500), ('height', 313), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TBQYpBOcCmC4kjqtQa4Ekw/EGL-vL3smZN1BjfRc57xAZojGFcghiH9v7iCTZKEaAsaTTCh7EXDnrzL8dmCXYJsv9EZk5wULgwtKDhOcvFh8j63SKTrFO1AAXWyMPJ9QUY/cpOgMr0LIBiU3frgV8sEJDiGlq8n6o0vPuRWlsIvz2k'), ('filename', '1000Z.png'), ('size', 220984), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/T_ytyI6IbJs1K8QZSHsU-w/ZXGov5ZzXGJQJEKPH07hhBdjE6tKW6SU8EiIhJ8jjlMolDsncdHbtGtDl2kIIl4iMATx6y6CYmkiOvhvpeNGpA/D6zBQPbBY3EO3yvapl6pzhMShydrKaAKe30EwuiMZvQ'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/u78xRAPevpbWDfjH_n_hyw/TqHOw1yXczwJaJqLM59I6d-AJzEWpFLNAQY0lFp5ECA217Wr8klSTSesqQBhpIjtuhiRMevHoU6vyzpKu4UP-w/6EVXPoFx1GS072drUT40pMjBMpnJX-sbdv5DFMcJuis'), ('width', 500), ('height', 313)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/gZjFAf8_4CajnQd5VHfHhg/mRWAApyi9JGLGeU7jh6RCi5PUTdvGczda_8_gy8JoapCLeednqdTz83i7oqLUtl9PA4DS_aht2PvtkUfz8OVdQ/oG64pIYoenPBYtxVWzNCP6nP_WHp4i8xBdnGM8iNy-o'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125991/Instruments/Vendor%20Logos/Rigol.png,"The 1000 Series from RIGOL include the B, D, and E series oscilloscopes. The E Series are the value leader with 50-100 MHz models that include 2 channels and 1 Million points of memory. The D Series add low speed digital capture enabling basic mixed signal analysis in a economic package. The B Series provide more speed and power including our economic 4 channel, 200 MHz DS1204B model which provides 2 GSa/sec sampling. With features including FFTs, record and replay, roll mode, alternate trigger mode, and adjustable trigger sensitivity the 1000 Series is a great entry for value oscilloscope requirements.",https://www.rigolna.com/products/digital-oscilloscopes/1000/,Rigolds 1000 Series,444.0,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/rigol/rigolds1000.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/rigol.html#rigolds1000series-oscilloscope,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WUPEm7WIrDBJwf-CxTP1CQ/c45j6lGkvUXKTJfBDhArJLyD7-l_4NF2myIhZAu_8gIhIIETcLU6anPJblojjG_QFgt5ncM1EwllGfuBgAdQAL0MZTybVYrK3qDc-QHBsvCxT_giDdOe9s_5THfJ4Xcv/ARveUF1YbFTBtFvTmM2bI3iXw2wdPTc_LgGkzCSeAUM'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s5pGaAkh_ht2y4qztLoUCA/rG3zvcTrKw9dZlEDLKcJMImO3_KitIJdLu06m0oQLLI7WC8kPBYaGx57b-RG51FMI0SNEUgEeijvbXD1ZJlFzw/hN5N97eEAugvwzz6gFcgUigRVHSG_YH1gnwX1pMLfus'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1Ct-aVhil1h-KLmGHATC6A/CMFkCiaL3PfMO9OxDCv4jyW69F4RM8Q-nj5Wtvqe9JxD_uvCfjTqtU8zRmniyyGTUwg6C461m4gPDCbqSiSP5Q/4XvTtS2eH__nDziBKudzzCNB-asZCVH8VaZkdml8IQ0'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/t-r8__D9YELrQjovkfFexw/x5zQBS7IgprBqH5sdXPSTmHtrXtXxqsu60EUJtFH3TLYQZTGk0pVuC2fOK5gf4k_cxSkvO9re3bgbqy73aKPfA/mm5sO4CR8Sk0l-TOTciXwlkYOydrsKBgOIK-R9Sp9n8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782681/Instruments/Oscilloscopes/Rigol-DS1000-Series/Rigol-DS1000-Series.png,Rigol DS1000-Series,Write a Python script that uses Instrumentkit to connect to a Rigol DS1000-Series Oscilloscopes,,,,,"#!/usr/bin/env python
""""""
Provides support for Rigol DS-1000 series oscilloscopes.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import ProxyList, bool_property, enum_property

# CLASSES #####################################################################


class RigolDS1000Series(SCPIInstrument, Oscilloscope):

    """"""
    The Rigol DS1000-series is a popular budget oriented oscilloscope
    that has featured wide adoption across hobbyist circles.

    .. warning:: This instrument is not complete, and probably not even
        functional!
    """"""

    # ENUMS #

    class AcquisitionType(Enum):
        """"""
        Enum containing valid acquisition types for the Rigol DS1000
        """"""

        normal = ""NORM""
        average = ""AVER""
        peak_detect = ""PEAK""

    # INNER CLASSES #

    class DataSource(Oscilloscope.DataSource):
        """"""
        Class representing a data source (channel, math, or ref) on the
        Rigol DS1000

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `RigolDS1000Series` class.
        """"""

        @property
        def name(self):
            return self._name

        def read_waveform(self, bin_format=True):
            # TODO: add DIG, FFT.
            if self.name not in [""CHAN1"", ""CHAN2"", ""DIG"", ""MATH"", ""FFT""]:
                raise NotImplementedError(
                    ""Rigol DS1000 series does not ""
                    ""supportreading waveforms from ""
                    ""{}."".format(self.name)
                )
            self._parent.sendcmd(f"":WAV:DATA? {self.name}"")
            data = self._parent.binblockread(2)  # TODO: check width
            return data

    class Channel(DataSource, Oscilloscope.Channel):
        """"""
        Class representing a channel on the Rigol DS1000.

        This class inherits from `~RigolDS1000Series.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `RigolDS1000Series` class.
        """"""

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the Rigol DS1000
            """"""

            ac = ""AC""
            dc = ""DC""
            ground = ""GND""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # Rigols are 1-based.

            # Initialize as a data source with name CHAN{}.
            super().__init__(self._parent, f""CHAN{self._idx}"")

        def sendcmd(self, cmd):
            """"""
            Passes a command from the `Channel` class to the parent
            `RigolDS1000Series`, appending the required channel identification.

            :param str cmd: The command string to send to the instrument
            """"""
            self._parent.sendcmd(f"":CHAN{self._idx}:{cmd}"")

        def query(self, cmd):
            """"""
            Passes a command from the `Channel` class to the parent
            `RigolDS1000Series`, appending the required channel identification.

            :param str cmd: The command string to send to the instrument
            :return: The result as returned by the instrument
            :rtype: `str`
            """"""
            return self._parent.query(f"":CHAN{self._idx}:{cmd}"")

        coupling = enum_property(""COUP"", Coupling)

        bw_limit = bool_property(""BWL"", inst_true=""ON"", inst_false=""OFF"")
        display = bool_property(""DISP"", inst_true=""ON"", inst_false=""OFF"")
        invert = bool_property(""INV"", inst_true=""ON"", inst_false=""OFF"")

        # TODO: :CHAN<n>:OFFset
        # TODO: :CHAN<n>:PROBe
        # TODO: :CHAN<n>:SCALe

        filter = bool_property(""FILT"", inst_true=""ON"", inst_false=""OFF"")

        # TODO: :CHAN<n>:MEMoryDepth

        vernier = bool_property(""VERN"", inst_true=""ON"", inst_false=""OFF"")

    # PROPERTIES #

    @property
    def channel(self):
        # Rigol DS1000 series oscilloscopes all have two channels,
        # according to the documentation.
        return ProxyList(self, self.Channel, range(2))

    @property
    def math(self):
        return self.DataSource(parent=self, name=""MATH"")

    @property
    def ref(self):
        return self.DataSource(parent=self, name=""REF"")

    acquire_type = enum_property("":ACQ:TYPE"", AcquisitionType)
    # TODO: implement :ACQ:MODE. This is confusing in the documentation,
    # though.

    @property
    def acquire_averages(self):
        """"""
        Gets/sets the number of averages the oscilloscope should take per
        acquisition.

        :type: `int`
        """"""
        return int(self.query("":ACQ:AVER?""))

    @acquire_averages.setter
    def acquire_averages(self, newval):
        if newval not in [2**i for i in range(1, 9)]:
            raise ValueError(
                ""Number of averages {} not supported by instrument; ""
                ""must be a power of 2 from 2 to 256."".format(newval)
            )
        self.sendcmd(f"":ACQ:AVER {newval}"")

    # TODO: implement :ACQ:SAMP in a meaningful way. This should probably be
    #       under Channel, and needs to be unitful.
    # TODO: I don't understand :ACQ:MEMD yet.

    # METHODS ##

    def force_trigger(self):
        self.sendcmd("":FORC"")

    # TODO: consider moving the next few methods to Oscilloscope.
    def run(self):
        """"""
        Starts running the oscilloscope trigger.
        """"""
        self.sendcmd("":RUN"")

    def stop(self):
        """"""
        Stops running the oscilloscope trigger.
        """"""
        self.sendcmd("":STOP"")

    # TODO: unitful timebase!

    # FRONT-PANEL KEY EMULATION METHODS ##
    # These methods correspond one-to-one with physical keys on the front
    # (local) control panel, except for release_panel, which enables the local
    # panel and disables any remote lockouts, and for panel_locked.
    #
    # Many of the :KEY: commands are not yet implemented as methods.

    panel_locked = bool_property("":KEY:LOCK"", inst_true=""ENAB"", inst_false=""DIS"")

    def release_panel(self):
        # TODO: better name?
        # NOTE: method may be redundant with the panel_locked property.
        """"""
        Releases any lockout of the local control panel.
        """"""
        self.sendcmd("":KEY:FORC"")
"
301,,https://fr.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,"[OrderedDict([('id', 'attJFtaQgK65Azlmu'), ('width', 800), ('height', 945), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5ZD10qlwQSqblimtTmMPNg/B4ckzXGfjLwVrGKpViNJlW9nbwASg16qAim4U8bZxGK5kPD9sgdVBMqi2zbQnylMVjSS8hy9sYWBuh1dDMUllkXZE2E01G71uaZk1lwGJVo/-0GN501JYJC4Av9mnkNh9mDoCWHEZ3hR1eV1e8IGG0g'), ('filename', 'image.png'), ('size', 845732), ('type', 'image/png')])]",,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692142672/Instruments/Vendor%20Logos/FLOJOY_TEXT.png,All SCPI Instrument,,Scpi Instrument,134.0,['Miscellaneous'],SCPI Instrument,"
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/generic_scpi/scpi_instrument.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/generic_scpi.html#scpiinstrument-base-class-for-instruments-using-the-scpi-protocol,Generic SCPI,"[OrderedDict([('id', 'attpFOvtzuWOJVOYv'), ('width', 1763), ('height', 1763), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XzYr_HDntjWrgAKAkQQQ6g/v7wLsdS_iBz3S68lwDC5XaUaEmnSqzEJg3Sr08JXEloqINDFXjov0rC46nGo2pufMBVqous9RwXR816VrqNFDjnc71yyzFB5Wyh0DGWkNnM/0u-xCPNvAhB4Q9s7v434ZdW3veLXwZC_mQlmOHLLf1M'), ('filename', 'logo (1).png'), ('size', 99073), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DRpgk7F4sSAeR1s8cammFw/ov4VT_wJHKMVO6PeBJ4CMqruzbOqjQgzvr5ECDp9me1jSVAyZjBL4Zv3Ax1wL2Wbxcxst7ZA8ZQMDRoPDVrHYA/0NFOD6aqMtjNAGQGFVN4L25vJJs2zqYKdaPULjCq77c'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/S4fu3jXFLKOoaMrcz4vheA/QWNNtpA82XJImu_r69nMUU05Jenb20X4F6NReVVasDapf25-pWMR19eYDR_7qnmnnDwWHn_cCy0GSAEx3XnEcQ/2DgpECHpjvcjUT7XT9VP3BcQUMB6Dj0cu9MmtF-wfgE'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/z__R7cswxAdLN4wBlDAK8A/Y_v-Yx_wuhNZjVhhoJIZw2o4_NWbicql2UBXIMKsqc1fxKQuwcQB1-EcWsNuz6Etgpu3uUp4SlaAz0MYK0_6xQ/cpFe3XP6_oaD1RtnFcspfYaoZJGLxKjZCIyc1WoEwfg'), ('width', 3000), ('height', 3000)]))]))])]",https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,,SCPI Instrument,Write a Python script that uses Instrumentkit to connect to a SCPI Instrument Miscellaneous,,,,Generic Python Library for communication with SCPI Instruments,"#!/usr/bin/env python
""""""
Provides support for SCPI compliant instruments
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# CLASSES #####################################################################


class SCPIInstrument(Instrument):
    r""""""
    Base class for all SCPI-compliant instruments. Inherits from
    from `~instruments.Instrument`.

    This class does not implement any instrument-specific communication
    commands. What it does add is several of the generic SCPI star commands.
    This includes commands such as ``*IDN?``, ``*OPC?``, and ``*RST``.

    Example usage:

    >>> import instruments as ik
    >>> inst = ik.generic_scpi.SCPIInstrument.open_tcpip('192.168.0.2', 8888)
    >>> print(inst.name)
    """"""

    # PROPERTIES #

    @property
    def name(self):
        """"""
        The name of the connected instrument, as reported by the
        standard SCPI command ``*IDN?``.

        :rtype: `str`
        """"""
        return self.query(""*IDN?"")

    @property
    def scpi_version(self):
        """"""
        Returns the version of the SCPI protocol supported by this instrument,
        as specified by the ``SYST:VERS?`` command described in section 21.21
        of the SCPI 1999 standard.
        """"""
        return self.query(""SYST:VERS?"")

    @property
    def op_complete(self):
        """"""
        Check if all operations sent to the instrument have been completed.

        :rtype: `bool`
        """"""
        result = self.query(""*OPC?"")
        return bool(int(result))

    @property
    def power_on_status(self):
        """"""
        Gets/sets the power on status for the instrument.

        :type: `bool`
        """"""
        result = self.query(""*PSC?"")
        return bool(int(result))

    @power_on_status.setter
    def power_on_status(self, newval):
        on = [""on"", ""1"", 1, True]
        off = [""off"", ""0"", 0, False]
        if isinstance(newval, str):
            newval = newval.lower()
        if newval in on:
            self.sendcmd(""*PSC 1"")
        elif newval in off:
            self.sendcmd(""*PSC 0"")
        else:
            raise ValueError

    @property
    def self_test_ok(self):
        """"""
        Gets the results of the instrument's self test. This lets you check
        if the self test was sucessful or not.

        :rtype: `bool`
        """"""
        result = self.query(""*TST?"")
        try:
            result = int(result)
            return result == 0
        except ValueError:
            return False

    # BASIC SCPI COMMANDS ##

    def reset(self):
        """"""
        Reset instrument. On many instruments this is a factory reset and will
        revert all settings to default.
        """"""
        self.sendcmd(""*RST"")

    def clear(self):
        """"""
        Clear instrument. Consult manual for specifics related to that
        instrument.
        """"""
        self.sendcmd(""*CLS"")

    def trigger(self):
        """"""
        Send a software trigger event to the instrument. On most instruments
        this will cause some sort of hardware event to start. For example, a
        multimeter might take a measurement.

        This software trigger usually performs the same action as a hardware
        trigger to your instrument.
        """"""
        self.sendcmd(""*TRG"")

    def wait_to_continue(self):
        """"""
        Instruct the instrument to wait until it has completed all received
        commands before continuing.
        """"""
        self.sendcmd(""*WAI"")

    # SYSTEM COMMANDS ##

    @property
    def line_frequency(self):
        """"""
        Gets/sets the power line frequency setting for the instrument.

        :return: The power line frequency
        :units: Hertz
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(float(self.query(""SYST:LFR?"")), ""Hz"")

    @line_frequency.setter
    def line_frequency(self, newval):
        self.sendcmd(
            ""SYST:LFR {}"".format(assume_units(newval, ""Hz"").to(""Hz"").magnitude)
        )

    # ERROR QUEUE HANDLING ##
    # NOTE: This functionality is still quite incomplete, and could be fleshed
    #       out significantly still. One good thing would be to add handling
    #       for SCPI-defined error codes.
    #
    #       Another good use of this functionality would be to allow users to
    #       automatically check errors after each command or query.
    class ErrorCodes(IntEnum):

        """"""
        Enumeration describing error codes as defined by SCPI 1999.0.
        Error codes that are equal to 0 mod 100 are defined to be *generic*.
        """"""

        # NOTE: this class may be overriden by subclasses, since the only access
        #       to this enumeration from within SCPIInstrument is by ""self,""
        #       not by explicit name. Thus, if an instrument supports additional
        #       error codes from the SCPI base, they can be added in a natural
        #       way.
        no_error = 0

        # -100 BLOCK: COMMAND ERRORS ##
        command_error = -100
        invalid_character = -101
        syntax_error = -102
        invalid_separator = -103
        data_type_error = -104
        get_not_allowed = -105
        # -106 and -107 not specified.
        parameter_not_allowed = -108
        missing_parameter = -109
        command_header_error = -110
        header_separator_error = -111
        program_mnemonic_too_long = -112
        undefined_header = -113
        header_suffix_out_of_range = -114
        unexpected_number_of_parameters = -115
        numeric_data_error = -120
        invalid_character_in_number = -121
        exponent_too_large = -123
        too_many_digits = -124
        numeric_data_not_allowed = -128
        suffix_error = -130
        invalid_suffix = -131
        suffix_too_long = -134
        suffix_not_allowed = -138
        character_data_error = -140
        invalid_character_data = -141
        character_data_too_long = -144
        character_data_not_allowed = -148
        string_data_error = -150
        invalid_string_data = -151
        string_data_not_allowed = -158
        block_data_error = -160
        invalid_block_data = -161
        block_data_not_allowed = -168
        expression_error = -170
        invalid_expression = -171
        expression_not_allowed = -178
        macro_error = -180
        invalid_outside_macro_definition = -181
        invalid_inside_macro_definition = -183
        macro_parameter_error = -184

        # pylint: disable=fixme
        # TODO: copy over other blocks.
        # -200 BLOCK: EXECUTION ERRORS ##
        # -300 BLOCK: DEVICE-SPECIFIC ERRORS ##
        # Note that device-specific errors also include all positive numbers.
        # -400 BLOCK: QUERY ERRORS ##

        # OTHER ERRORS ##

        #: Raised when the instrument detects that it has been turned from
        #: off to on.
        power_on = -500  # Yes, SCPI 1999 defines the instrument turning on as
        # an error. Yes, this makes my brain hurt.
        user_request_event = -600
        request_control_event = -700
        operation_complete = -800

    def check_error_queue(self):
        """"""
        Checks and clears the error queue for this device, returning a list of
        :class:`SCPIInstrument.ErrorCodes` or `int` elements for each error
        reported by the connected instrument.
        """"""
        # pylint: disable=fixme
        # TODO: use SYST:ERR:ALL instead of SYST:ERR:CODE:ALL to get
        #       messages as well. Should be just a bit more parsing, but the
        #       SCPI standard isn't clear on how the pairs are represented,
        #       so it'd be helpful to have an example first.
        err_list = map(int, self.query(""SYST:ERR:CODE:ALL?"").split("",""))
        return [
            self.ErrorCodes[err] if isinstance(err, self.ErrorCodes) else err
            for err in err_list
            if err != self.ErrorCodes.no_error
        ]

    # DISPLAY COMMANDS ##

    @property
    def display_brightness(self):
        """"""
        Brightness of the display on the connected instrument, represented as
        a float ranging from 0 (dark) to 1 (full brightness).

        :type: `float`
        """"""
        return float(self.query(""DISP:BRIG?""))

    @display_brightness.setter
    def display_brightness(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display brightness must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:BRIG {newval}"")

    @property
    def display_contrast(self):
        """"""
        Contrast of the display on the connected instrument, represented as
        a float ranging from 0 (no contrast) to 1 (full contrast).

        :type: `float`
        """"""
        return float(self.query(""DISP:CONT?""))

    @display_contrast.setter
    def display_contrast(self, newval):
        if newval < 0 or newval > 1:
            raise ValueError(""Display contrast must be a number between 0"" "" and 1."")
        self.sendcmd(f""DISP:CONT {newval}"")
"
309,https://www.keysight.com/us/en/assets/7018-01144/data-sheets/5988-8544.pdf,https://www.keysight.com/us/en/products/waveform-and-function-generators.html,"[OrderedDict([('id', 'att9Bw70ALrjUCUhO'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HHyn5xG3qyrJ1XSZQ07Ygw/ZW2w7ceH1FDjyoC1WVtCdNeD3gR6ewV5LjXLhyHDDhqVjgonC5SOc0hpXKEfTkAQSE5WMBHAQtFqozMuX_Ji63Sh-Tnv5A3MKwfQVv-aTBQ/lpFZfRKNKUk0xTH7IxVnGwx62iPoSdffRWS1bUiiETc'), ('filename', 'PROD-127539-01.webp'), ('size', 12382), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Mm_-2f0JS4lKwZ9Oiqc_oA/CLpN7Wu1hVaCDMJdtk5YxraoxnD5s-hU9ORh6POHdzaPvy76T7GTsKDabLNH4cJgs5mmqdYpw4NBiQAl05zzu57fQpkUMOwYSXi9zMdpcyQ/uAaPsXIl0A_Oqz97-oQj9S5er-2WRrVS69uR_ic1KOU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1kiprzlS6iavUd1og7ayRw/6uiM76a3NvmGHfNUwjUwjitGFTgaPHGAwSYsuTcZiVIcC9VV4XLtVZXjblCl100o4yuCH5nbv_sMPT9QvofFmMvdx_bO4G8gKldfpsjpraQ/XQJl5B6cpsLfw0vk_GTS4E8i2bvdd4ynAUV5cFny85o'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KZJ_CaRHWCpRFjo-PGRu4A/rDyd9ZWAhhG1kNt829hZQNxBCdzuSox6wGveCxaCQcjC4wiW11zGUQt5n_AQy1wFme5e_uYsRFOROWEwwaOrXNAs1XvApyErhzgdO9L_aAI/HWbi5bySYb-ft2vJ_BjAK2eLwAt1JJa3JgZXNHxNsd8'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,The Keysight 33220A is a 20 MHz synthesized function generator with built-in arbitrary waveform and pulse capabilities. Itscombination of bench-top and system features makes this function generator a versatile solution for your testing requirements now and in the future.,https://www.keysight.com/us/en/support/33220A/function--arbitrary-waveform-generator-20-mhz.html,Agilent 33220 A,41.0,['RF Signal Generator'],"Function / Arbitrary Waveform Generator, 20 MHz","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/agilent/agilent33220a.html#Agilent33220a,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/agilent.html#agilent33220a-function-generator,Agilent,"[OrderedDict([('id', 'attXkc513oAf08kfb'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PBtvTjD_Dn6AWs_xdYIcTA/2OHWULPoVWDocFyrVBfrtjc84qvqGDyauRxCtYvqoMnzhxhNJBfRisSqmuSWTJdCycw4adm6vqRxD9H_b1YR9wlWLcKV0BcpGyt3xqEwwu4/HkslT_eCMBTdWKSYwOeHMJNLuNPUtL-FYL6Fv6A2CQI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pz7XSwZdabM9iMoXrb70Fw/SQTk9eOnAaQZTPnwfOUvDFr_giIytjN-HtP672HpajGnOzaXHCDcBXbQ3c-8PbSOttRpyVfCq9PagnV2tpOfVOVjsSjGRY85OQkOd2ekBqs/QYuZEE1Ha_j0GgTBIUb2nwlvYfJM8AnGAGco7I2xd6M'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F0wuzBSK3BV0o_GMHgUm2A/ewIplO_vcmQOIwnW0b0ygmLgXkM1aQsrKiEyqVJfpyiVcieo0Sy6_yytvZ2zZDFtUov3S77OFafPU17XR5oxP1LgoGRjUU5SaLNJr8PjTU8/ij-5cM93hxj23IcMSzJQND8SFNzk4-gdlqgmgDD2K3A'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DLqDl5zEIYy2d5BcgdSJPg/yDJ-es7lOmSsNUc1GBJcS3PvgYeq_86WGpb_j7DSSUJL3s-nbhoSrwyfLTVdnDBRS-H22pmn7ZEbtVluhpetKgZ4G0u4-qT66v3MoqvJRTU/J9yIeucuaY9_MrXCeHEuT3vv2y-acKD0CtuaWZvmV4w'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782698/Instruments/RF%20Signal%20Generator/Keysight-33220A/Keysight-33220A.webp,Keysight 33220A,Write a Python script that uses Instrumentkit to connect to a Keysight 33220A RF Signal Generator,,"
",True,,
332,https://www.farnell.com/datasheets/1484270.pdf,https://en.wikipedia.org/wiki/Electrometer,"[OrderedDict([('id', 'att30haLadU97rFh4'), ('width', 320), ('height', 161), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ylk56rsLkaiyypImx0Wj6Q/XD5bhB_4LJRCkfjRGywXtKOJ93PnzY0jHWeGGIiJGbVjEAf11wP7qJOPD5k_7VbtWOwLFKEkXnrcc6oDLKu02A6EKctCBC4OmaCHZx_YeQM/c1QUUeTh6QoOw-doi551Z3Qcm7pyWj8iXzbZLuvGiFo'), ('filename', '6514.webp'), ('size', 4232), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/unUCF5DMbiTdtQ5tPK_Mig/O1KYQdLXQvPHkk5ZpzR8G6WCt_bM2t_JU7h4RrSu4zj618TB2P5OzRcVDzC164QwdctNE_Mvu6CiAkv1DOksbvw0R6r-BMPQ1PdBexax4BM/zSkE3L_fIqrLgdAMGEJZ7nhwpW4XUbx2gWj5nytZVd0'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ra9tV1ImAT9seLgGxCJucQ/LARbOzUatwCuwPtgz7kN4Rk-5tsvAKGoFX9joJXDCJyq5joq5hHjin-0nsjKEKpGuzFLAdUFyYGb5vpj9qpWAtceVteSqX7vzy9yCNLMIxI/PAVvvVxhLQz-G_Di_Xrt2uuLBj2DKcxuqYvWARjIE7E'), ('width', 320), ('height', 161)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yA-q76AF8onCX7T2GV6otg/43fG3DPHqNcSi5n4dGV2AkYKJwMwCxYdsCgnyWTSinzs8jNcOIycAOTwYVl_GR1Afou2owuSEodpO_rpL6FTGqVD7_NLufVw0B30yczSjsA/sPi7MEG4W5WOKeMk0-YgWtZkMvIcPS3UPTDoXIE4XM4'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"6514 electrometer combines flexible interfacing capabilities with current sensitivity, charge measurement capabilities, resolution, and speed that are equal or superior to our earlier electrometers. The Model 6514’s built-in IEEE-488, RS-232, and digital I/O interfaces make it simple to configure fully automated, high speed systems for low-level testing. The 5½-digit Model 6514 is designed for applications that demand fast, yet precise measurements of low currents, voltages from high resistance sources, charges, or high resistances. The Model 6514’s exceptional measurement performance comes at an affordable price. While its cost is comparable with that of many high end DMMs, the Model 6514 offers far greater current sensitivity and significantly lower voltage burden (as low as 20μV) than other instruments can provide.",https://canada.newark.com/keithley/6514/electrometer-20pa-to-20ma-2v-to/dp/59K0092,Keithley 6514,218.0,['Power Meters'],"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6514.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6514-electrometer,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782717/Instruments/Power%20Meters/Keithley-6514/Keithley-6514.webp,Keithley 6514,Write a Python script that uses Instrumentkit to connect to a Keithley 6514 Power Meters,11161.7,,,,"#!/usr/bin/env python
""""""
Provides support for the Keithley 6514 electrometer
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Electrometer
from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import bool_property, enum_property

# CLASSES #####################################################################


class Keithley6514(SCPIInstrument, Electrometer):

    """"""
    The `Keithley 6514`_ is an electrometer capable of doing sensitive current,
    charge, voltage and resistance measurements.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley6514.open_gpibusb('/dev/ttyUSB0', 12)
    """"""

    # ENUMS #

    class Mode(Enum):
        """"""
        Enum containing valid measurement modes for the Keithley 6514
        """"""

        voltage = ""VOLT:DC""
        current = ""CURR:DC""
        resistance = ""RES""
        charge = ""CHAR""

    class TriggerMode(Enum):
        """"""
        Enum containing valid trigger modes for the Keithley 6514
        """"""

        immediate = ""IMM""
        tlink = ""TLINK""

    class ArmSource(Enum):
        """"""
        Enum containing valid trigger arming sources for the Keithley 6514
        """"""

        immediate = ""IMM""
        timer = ""TIM""
        bus = ""BUS""
        tlink = ""TLIN""
        stest = ""STES""
        pstest = ""PST""
        nstest = ""NST""
        manual = ""MAN""

    class ValidRange(Enum):
        """"""
        Enum containing valid measurement ranges for the Keithley 6514
        """"""

        voltage = (2, 20, 200)
        current = (
            20e-12,
            200e-12,
            2e-9,
            20e-9,
            200e-9,
            2e-6,
            20e-6,
            200e-6,
            2e-3,
            20e-3,
        )
        resistance = (2e3, 20e3, 200e3, 2e6, 20e6, 200e6, 2e9, 20e9, 200e9)
        charge = (20e-9, 200e-9, 2e-6, 20e-6)

    # CONSTANTS #

    _MODE_UNITS = {
        Mode.voltage: u.volt,
        Mode.current: u.amp,
        Mode.resistance: u.ohm,
        Mode.charge: u.coulomb,
    }

    # PRIVATE METHODS #

    def _valid_range(self, mode):
        if mode == self.Mode.voltage:
            return self.ValidRange.voltage
        elif mode == self.Mode.current:
            return self.ValidRange.current
        elif mode == self.Mode.resistance:
            return self.ValidRange.resistance
        elif mode == self.Mode.charge:
            return self.ValidRange.charge
        else:
            raise ValueError(""Invalid mode."")

    def _parse_measurement(self, ascii):
        # TODO: don't assume ASCII data format # pylint: disable=fixme
        vals = list(map(float, ascii.split("","")))
        reading = vals[0] * self.unit
        timestamp = vals[1]
        status = vals[2]
        return reading, timestamp, status

    # PROPERTIES #

    # The mode values have quotes around them for some annoying reason.
    mode = enum_property(
        ""FUNCTION"",
        Mode,
        input_decoration=lambda val: val[1:-1],
        # output_decoration=lambda val: '""{}""'.format(val),
        set_fmt='{} ""{}""',
        doc=""""""
        Gets/sets the measurement mode of the Keithley 6514.
        """""",
    )

    trigger_mode = enum_property(
        ""TRIGGER:SOURCE"",
        TriggerMode,
        doc=""""""
        Gets/sets the trigger mode of the Keithley 6514.
        """""",
    )

    arm_source = enum_property(
        ""ARM:SOURCE"",
        ArmSource,
        doc=""""""
        Gets/sets the arm source of the Keithley 6514.
        """""",
    )

    zero_check = bool_property(
        ""SYST:ZCH"",
        inst_true=""ON"",
        inst_false=""OFF"",
        doc=""""""
        Gets/sets the zero checking status of the Keithley 6514.
        """""",
    )

    zero_correct = bool_property(
        ""SYST:ZCOR"",
        inst_true=""ON"",
        inst_false=""OFF"",
        doc=""""""
        Gets/sets the zero correcting status of the Keithley 6514.
        """""",
    )

    @property
    def unit(self):
        return self._MODE_UNITS[self.mode]

    @property
    def auto_range(self):
        """"""
        Gets/sets the auto range setting

        :type: `bool`
        """"""
        # pylint: disable=no-member
        out = self.query(f""{self.mode.value}:RANGE:AUTO?"")
        return True if out == ""1"" else False

    @auto_range.setter
    def auto_range(self, newval):
        # pylint: disable=no-member
        self.sendcmd(""{}:RANGE:AUTO {}"".format(self.mode.value, ""1"" if newval else ""0""))

    @property
    def input_range(self):
        """"""
        Gets/sets the upper limit of the current range.

        :type: `~pint.Quantity`
        """"""
        # pylint: disable=no-member
        mode = self.mode
        out = self.query(f""{mode.value}:RANGE:UPPER?"")
        return float(out) * self._MODE_UNITS[mode]

    @input_range.setter
    def input_range(self, newval):
        # pylint: disable=no-member
        mode = self.mode
        val = newval.to(self._MODE_UNITS[mode]).magnitude
        if val not in self._valid_range(mode).value:
            raise ValueError(""Unexpected range limit for currently selected mode."")
        self.sendcmd(f""{mode.value}:RANGE:UPPER {val:e}"")

    # METHODS ##

    def auto_config(self, mode):
        """"""
        This command causes the device to do the following:
            - Switch to the specified mode
            - Reset all related controls to default values
            - Set trigger and arm to the 'immediate' setting
            - Set arm and trigger counts to 1
            - Set trigger delays to 0
            - Place unit in idle state
            - Disable all math calculations
            - Disable buffer operation
            - Enable autozero
        """"""
        self.sendcmd(f""CONF:{mode.value}"")

    def fetch(self):
        """"""
        Request the latest post-processed readings using the current mode.
        (So does not issue a trigger)
        Returns a tuple of the form (reading, timestamp)
        """"""
        raw = self.query(""FETC?"")
        reading, timestamp, _ = self._parse_measurement(raw)
        return reading, timestamp

    def read_measurements(self):
        """"""
        Trigger and acquire readings using the current mode.
        Returns a tuple of the form (reading, timestamp)
        """"""
        raw = self.query(""READ?"")
        reading, timestamp, _ = self._parse_measurement(raw)
        return reading, timestamp
"
334,https://www.thorlabs.com/_sd.cfm?fileName=ETN012478-D02.pdf&partNumber=MST602,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attYtJhsEvZTymA09'), ('width', 780), ('height', 508), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eXK6FQSotpk-YPIo89jUWA/vAtvqNoehq6Tm-P8b1_gRkYFM3Ly-F0D0c5SYkHZZxZVq7_hXVnuH01B0OnUFGqxYFtMrSK58VVQVIoZPLufokayYX1RaltV28XbmAvdT7o/Yojo_QNSxMl09rF5sDouBH8czYj7wKBWnYSFL6D4d_I'), ('filename', 'ETN012478-xl.jpg'), ('size', 49930), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VA4wKE9kdJEa6ELvrjrapQ/zHXzghgUMT6z0alk15uWnCt9bUUhoEXd6UqalKeruxqtJwc1HkXd50v477Rd7-6DU25wORN_CSRpmMoiAlR6Lg/FhrpAaUL72g_xW1W7TnXAu6x8FG8Vywila1Svu48HoM'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xKScIqd7FxOAR1jZ5D9scA/iBseXmNX2yazUvYBMu22Zt55G9X2jnqueuAWXkc1-8n7SqUlTAs4Pa7F8zgYC1AL4LoSACB8EVZjgV7j8wjTiA/qE2RtAgX-ziKgzLLGPgYZqFb6jTmJ4YJBD5h7RaGV_0'), ('width', 780), ('height', 508)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3e_Tb42GWjAKfvNZ4ms40w/fkEgK1E5lYJCD5BOiVhBkTonqCnRybEb6H2su-yz6SxwlrX92Bce69HLhC6T28X1g9U9BV5Cgc2puhIvTLORSg/Dn8Uu7Eqphd112OMIIfv8qI9vhA2KWu7UjSP4wJo15c'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The APT™ MST602 module is a dual-channel, high-resolution, rack-mounted stepper motor driver designed for use with the APT MMR601 Motion Control 19"" Modular Rack System. It has been designed to drive 2-phase bi-polar stepper motors up to 50 W, with or without encoder feedback, and is compatible with the full range of stepper-motor-equipped nanopositioning actuators and stages offered by Thorlabs. Alternatively, it is also compatible with any generic two-phase bi-polar motor of varying powers and varying cardinal step sizes. ",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=1186,Aptmotorcontroller,604.0,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782719/Instruments/Positional%20Controller/APT-Stepper-Motor-Control-Module/APT-Stepper-Motor-Control-Module.jpg,APT Stepper Motor Control Module,Write a Python script that uses Instrumentkit to connect to a APT Stepper Motor Control Module Positional Controller,1523.17,,,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs APT Controller.
""""""

# IMPORTS #####################################################################


import re
import struct
import logging
import codecs
import warnings

from instruments.thorlabs import _abstract, _packets, _cmds
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################

# pylint: disable=too-many-lines


class ThorLabsAPT(_abstract.ThorLabsInstrument):

    """"""
    Generic ThorLabs APT hardware device controller. Communicates using the
    ThorLabs APT communications protocol, whose documentation is found in the
    thorlabs source folder.
    """"""

    class APTChannel:

        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.
        """"""

        def __init__(self, apt, idx_chan):
            self._apt = apt
            # APT is 1-based, but we want the Python representation to be
            # 0-based.
            self._idx_chan = idx_chan + 1

        @property
        def enabled(self):
            """"""
            Gets/sets the enabled status for the specified APT channel

            :type: `bool`

            :raises TypeError: If controller is not supported
            """"""
            if self._apt.model_number[0:3] == ""KIM"":
                raise TypeError(
                    ""For KIM controllers, use the ""
                    ""`enabled_single` function to enable ""
                    ""one axis. For KIM101 controllers, ""
                    ""multiple axes can be enabled using ""
                    ""the `enabled_multi` function from the ""
                    ""controller level.""
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_REQ_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOD_GET_CHANENABLESTATE
            )
            return not bool(resp.parameters[1] - 1)

        @enabled.setter
        def enabled(self, newval):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_SET_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x01 if newval else 0x02,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

    _channel_type = APTChannel

    def __init__(self, filelike):
        super().__init__(filelike)
        self._dest = 0x50  # Generic USB device; make this configurable later.

        # Provide defaults in case an exception occurs below.
        self._serial_number = None
        self._model_number = None
        self._hw_type = None
        self._fw_version = None
        self._notes = """"
        self._hw_version = None
        self._mod_state = None
        self._n_channels = 0
        self._channel = ()

        # Perform a HW_REQ_INFO to figure out the model number, serial number,
        # etc.
        try:
            req_packet = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.HW_REQ_INFO,
                param1=0x00,
                param2=0x00,
                dest=self._dest,
                source=0x01,
                data=None,
            )
            hw_info = self.querypacket(
                req_packet,
                expect=_cmds.ThorLabsCommands.HW_GET_INFO,
                expect_data_len=84,
            )

            self._serial_number = codecs.encode(hw_info.data[0:4], ""hex"").decode(
                ""ascii""
            )
            self._model_number = (
                hw_info.data[4:12].decode(""ascii"").replace(""\x00"", """").strip()
            )

            hw_type_int = struct.unpack(""<H"", hw_info.data[12:14])[0]
            if hw_type_int == 45:
                self._hw_type = ""Multi-channel controller motherboard""
            elif hw_type_int == 44:
                self._hw_type = ""Brushless DC controller""
            else:
                self._hw_type = f""Unknown type: {hw_type_int}""

            # Note that the fourth byte is padding, so we strip out the first
            # three bytes and format them.
            # pylint: disable=invalid-format-index
            self._fw_version = ""{0[0]:x}.{0[1]:x}.{0[2]:x}"".format(hw_info.data[14:18])
            self._notes = (
                hw_info.data[18:66].replace(b""\x00"", b"""").decode(""ascii"").strip()
            )

            self._hw_version = struct.unpack(""<H"", hw_info.data[78:80])[0]
            self._mod_state = struct.unpack(""<H"", hw_info.data[80:82])[0]
            self._n_channels = struct.unpack(""<H"", hw_info.data[82:84])[0]
        except OSError as e:
            logger.error(""Exception occured while fetching hardware info: %s"", e)

        # Create a tuple of channels of length _n_channel_type
        if self._n_channels > 0:
            self._channel = tuple(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels)
            )

    @property
    def serial_number(self):
        """"""
        Gets the serial number for the APT controller

        :type: `str`
        """"""
        return self._serial_number

    @property
    def model_number(self):
        """"""
        Gets the model number for the APT controller

        :type: `str`
        """"""
        return self._model_number

    @property
    def name(self):
        """"""
        Gets the name of the APT controller. This is a human readable string
        containing the model, serial number, hardware version, and firmware
        version.

        :type: `str`
        """"""
        return (
            ""ThorLabs APT Instrument model {model}, serial {serial} ""
            ""(HW version {hw_ver}, FW version {fw_ver})"".format(
                hw_ver=self._hw_version,
                serial=self.serial_number,
                fw_ver=self._fw_version,
                model=self.model_number,
            )
        )

    @property
    def channel(self):
        """"""
        Gets the list of channel objects attached to the APT controller.

        A specific channel object can then be accessed like one would access
        a list.

        :type: `tuple` of `APTChannel`
        """"""
        return self._channel

    @property
    def n_channels(self):
        """"""
        Gets/sets the number of channels attached to the APT controller

        :type: `int`
        """"""
        return self._n_channels

    @n_channels.setter
    def n_channels(self, nch):
        # Change the number of channels so as not to modify those instances
        # already existing:
        # If we add more channels, append them to the list,
        # If we remove channels, remove them from the end of the list.
        if nch > self._n_channels:
            self._channel = list(self._channel) + list(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels, nch)
            )
        elif nch < self._n_channels:
            self._channel = self._channel[:nch]
        self._n_channels = nch

    def identify(self):
        """"""
        Causes a light on the APT instrument to blink, so that it can be
        identified.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.MOD_IDENTIFY,
            param1=0x00,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        self.sendpacket(pkt)

    @property
    def destination(self):
        """"""
        Gets the destination for the APT controller

        :type: `int`
        """"""
        return self._dest


class APTPiezoDevice(ThorLabsAPT):

    """"""
    Generic ThorLabs APT piezo device, superclass of more specific piezo
    devices.
    """"""

    class PiezoDeviceChannel(ThorLabsAPT.APTChannel):
        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.

        This class represents piezo stage channels.
        """"""

        # PIEZO COMMANDS #

        @property
        def max_travel(self):
            """"""
            Gets the maximum travel for the specified piezo channel.

            :type: `~pint.Quantity`
            :units: Nanometers
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_MAXTRAVEL,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(pkt, expect_data_len=4)

            # Not all APT piezo devices support querying the maximum travel
            # distance. Those that do not simply ignore the PZ_REQ_MAXTRAVEL
            # packet, so that the response is empty.
            if resp is None:
                return NotImplemented

            # chan, int_maxtrav
            _, int_maxtrav = struct.unpack(""<HH"", resp.data)
            return int_maxtrav * u.Quantity(100, ""nm"")

    @property
    def led_intensity(self):
        """"""
        Gets/sets the output intensity of the LED display.

        :type: `float` between 0 and 1.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_REQ_TPZ_DISPSETTINGS,
            param1=0x01,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        resp = self.querypacket(pkt, expect_data_len=2)

        # Not all APT piezo devices support querying the LED intenstiy
        # distance, e.g., TIM, KIM. Those that do not simply ignore the
        # PZ_REQ_TPZ_DISPSETTINGS packet, so that the response is empty.
        # Setting will be ignored as well.
        if resp is None:
            return NotImplemented
        else:
            return float(struct.unpack(""<H"", resp.data)[0]) / 255

    @led_intensity.setter
    def led_intensity(self, intensity):
        # pylint: disable=round-builtin
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_SET_TPZ_DISPSETTINGS,
            param1=None,
            param2=None,
            dest=self._dest,
            source=0x01,
            data=struct.pack(""<H"", int(round(255 * intensity))),
        )
        self.sendpacket(pkt)

    _channel_type = PiezoDeviceChannel


class APTPiezoInertiaActuator(APTPiezoDevice):

    """"""Represent a Thorlabs APT piezo inertia actuator.

    Currently only the KIM piezo inertia actuator is implemented.
    Some routines will work with the TIM actuator as well. Routines
    that are specific for the KIM101 controller will raise a TypeError
    if not implemented for this controller. Unfortunately, handling all
    these controller specific functions is fairly messy, but necessary.

    Example for a KIM101 controller:
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> # call the controller
        >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # set first channel to enabled
        >>> ch = kim.channel[0]
        >>> ch.enabled_single = True
        >>> # define and set drive parameters
        >>> max_volts = u.Quantity(110, u.V)
        >>> step_rate = u.Quantity(1000, 1/u.s)
        >>> acceleration = u.Quantity(10000, 1/u.s**2)
        >>> ch.drive_op_parameters = [max_volts, step_rate, acceleration]
        >>> # aboslute move to 1000 steps
        >>> ch.move_abs(1000)
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PROPERTIES #

        @property
        def drive_op_parameters(self):
            """"""Get / Set various drive parameters for move motion.

            Defines the speed and acceleration of moves initiated in
            the following ways:
            - by clicking in the position display
            - via the top panel controls when ‘Go To Position’ mode is
            selected (in the Set_TIM_JogParameters (09) or
            Set_KCubeMMIParams (15) sub‐messages).
            - via software using the MoveVelocity, MoveAbsoluteStepsEx
            or MoveRelativeStepsEx methods.

            :setter: The setter must be be given as a list of 3
                entries. The three entries are:
                -  Maximum Voltage:
                The maximum piezo drive voltage, in the range 85V
                to 125V. Unitful, if no unit given, V are assumed.
                - Step Rate:
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the drive parameters, unitful.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # change the step rate to 2000 /s
                >>> drive_params = ch.drive_op_parameters
                >>> drive_params[1] = 2000
                >>> ch.drive_op_parameters = drive_params
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x07,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=14
            )

            # unpack
            ret_val = struct.unpack(""<HHHll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4]]

            # set units and formats
            ret_val = [
                u.Quantity(int(ret_val[0]), u.V),
                u.Quantity(int(ret_val[1]), 1 / u.s),
                u.Quantity(int(ret_val[2]), 1 / u.s**2),
            ]
            return ret_val

        @drive_op_parameters.setter
        def drive_op_parameters(self, params):
            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 3:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 3."")

            # ensure units
            volt = int(assume_units(params[0], u.V).to(u.V).magnitude)
            rate = int(assume_units(params[1], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[2], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if volt < 85 or volt > 125:
                raise ValueError(
                    ""The voltage ({} V) is out of range. It must ""
                    ""be between 85 V and 125 V."".format(volt)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )

            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHHll"", 0x07, self._idx_chan, volt, rate, accl),
            )
            self._apt.sendpacket(pkt)

        @property
        def enabled_single(self):
            """"""Get / Set single axis enabled.

            .. note:: Enabling multi channels for KIM101 is defined in
            the controller class.

            :return: Axis status enabled.
            :rtype: bool

            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # enable channel 0
                >>> ch.enabled_single = True
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise (
                    ""This command is only valid with KIM001 and ""
                    ""KIM101 controllers. Your controller is a {}."".format(
                        self._apt.model_number
                    )
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2B,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
            )

            ret_val = struct.unpack(""<HH"", resp.data)[1] == self._idx_chan

            return ret_val

        @enabled_single.setter
        def enabled_single(self, newval):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            param = self._idx_chan if newval else 0x00
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", 0x2B, param),
            )
            self._apt.sendpacket(pkt)

        @property
        def jog_parameters(self):
            """"""Get / Set the jog parameters.

            Define the speed and acceleration of moves initiated in the
            following ways:
            - By clicking the jog buttons on the GUI panel
            - By moving the joystick on the unit when ‘Jog Mode’ is
            selected.
            - via software using the MoveJog method.

            It differs from the normal motor jog message in that there
            are two jog step sizes, one for forward and one for reverse.
            The reason for this is that due to the inherent nature of
            the PIA actuators going further in one direction as
            compared with another this will allow the user to
            potentially make adjustments to get fore and aft movement
            the same or similar.

            :setter: The setter must be be given as a list of 5
                entries. The three entries are:
                - Jog Mode (1 for continuus, i.e., until stop command
                is issued, or 2 jog by the number of steps defined)
                - Jog Step Size Forward: Range 1 - 2000
                - Jog Step Size Backward: Range 1 - 2000
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Jog Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the jog parameters.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.
            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> mode = 2  # only move by set step size
                >>> step = 100  # step size
                >>> rate = u.Quantity(1000, 1/u.s)  # step rate
                >>> # if no quantity given, SI units assumed
                >>> accl = 10000
                >>> ch.jog_parameters = [mode, step, step, rate, accl]
                >>> ch.jog_parameters
                [2, 100, 100, array(1000) * 1/s, array(10000) * 1/s**2]
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2D,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=22
            )

            # unpack response
            ret_val = struct.unpack(""<HHHllll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4], ret_val[5], ret_val[6]]

            # assign the appropriate units, forms
            ret_val = [
                int(ret_val[0]),
                int(ret_val[1]),
                int(ret_val[2]),
                u.Quantity(int(ret_val[3]), 1 / u.s),
                u.Quantity(int(ret_val[4]), 1 / u.s**2),
            ]

            return ret_val

        @jog_parameters.setter
        def jog_parameters(self, params):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 5:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 5."")

            # ensure units
            mode = int(params[0])
            steps_fwd = int(params[1])
            steps_bkw = int(params[2])
            rate = int(assume_units(params[3], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[4], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if mode != 1 and mode != 2:
                raise ValueError(
                    ""The mode ({}) must be either set to 1 ""
                    ""(continuus) or 2 (steps)."".format(mode)
                )
            if steps_fwd < 1 or steps_fwd > 2000:
                raise ValueError(
                    ""The steps forward ({}) are out of range. It ""
                    ""must be between 1 and 2,000."".format(steps_fwd)
                )
            if steps_bkw < 1 or steps_bkw > 2000:
                raise ValueError(
                    ""The steps backward ({}) are out of range. ""
                    ""It must be between 1 and 2,000."".format(steps_bkw)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )
            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHllll"",
                    0x2D,
                    self._idx_chan,
                    mode,
                    steps_fwd,
                    steps_bkw,
                    rate,
                    accl,
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def position_count(self):
            """"""Get/Set the position count of a given channel.

            :setter pos: Position (steps) of axis.
            :type pos: int

            :return: Position (steps) of axis.
            :rtype: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set position count to zero
                >>> ch.position_count = 0
                >>> ch.position_count
                0
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x05,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=12
            )

            ret_val = int(struct.unpack(""<HHll"", resp.data)[2])

            return ret_val

        @position_count.setter
        def position_count(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHll"", 0x05, self._idx_chan, pos, 0x00),
            )
            self._apt.sendpacket(pkt)

        # METHODS #

        def move_abs(self, pos):
            """"""
            Moves the axis to a position specified as the number of
            steps away from the zero position.

            To set the moving parameters, use the setter for
            `drive_op_parameters`.

            :param pos: Position to move to, in steps.
            :type pos: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # move to 314 steps
                >>> ch.move_abs(314)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_ABSOLUTE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

        def move_jog(self, direction=""fwd""):
            """"""
            Jogs the axis in forward or backward direction by the number
            of steps that are stored in the controller.

            To set the moving parameters, use the setter for
            `jog_parameters`.

            :param str direction: Direction of jog. 'fwd' for forward,
                'rev' for backward. 'fwd' if invalid argument given

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> params = ch.jog_parameters
                >>> params[0] = 2  # move by number of steps
                >>> params[1] = 100  # step size forward
                >>> params[2] = 200  # step size reverse
                >>> ch.jog_parameters = params  # set parameters
                >>> # jog forward (default)
                >>> ch.move_jog()
                >>> # jog reverse
                >>> ch.move_jog('rev')
            """"""
            if direction == ""rev"":
                param2 = 0x02
            else:
                param2 = 0x01

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=param2,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        def move_jog_stop(self):
            """"""Stops the current motor movement.

            Stop a jog command. The regular motor move stop command does
            not work for jogging. This command somehow does...

            .. note:: This information is quite empirical. It would
                only be really needed if jogging parameters are set to
                continuous. The safer method is to set the step range.
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel

    # PROPERTIES #

    @property
    def enabled_multi(self):
        """"""Enable / Query mulitple channel mode.

        For KIM101 controller, where multiple axes can be selected
        simultaneously (i. e., for a mirror mount).

        :setter mode: Channel pair to be activated.
            0:  All channels deactivated
            1:  First channel pair activated (channel 0 & 1)
            2:  Second channel pair activated (channel 2 & 3)
        :type mode: int

        :return: The selected mode:
            0 - multi-channel selection disabled
            1 - Channel 0 & 1 enabled
            2 - Channel 2 & 3 enabled
        :rtype: int

        :raises ValueError: No valid channel pair selected
        :raises TypeError: Invalid controller for this command.

        Example:
            >>> import instruments as ik
            >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
            >>> # activate the first two channels
            >>> kim.enabled_multi = 1
            >>> # read back
            >>> kim.enabled_multi
            1
        """"""
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
            param1=0x2B,
            param2=0x00,
            dest=self.destination,
            source=0x01,
            data=None,
        )

        resp = self.querypacket(
            pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
        )

        ret_val = int(struct.unpack(""<HH"", resp.data)[1])

        if ret_val == 5:
            return 1
        elif ret_val == 6:
            return 2
        else:
            return 0

    @enabled_multi.setter
    def enabled_multi(self, mode):
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        if mode == 0:
            param = 0x00
        elif mode == 1:
            param = 0x05
        elif mode == 2:
            param = 0x06
        else:
            raise ValueError(
                ""Please select a valid mode: 0 - all ""
                ""disabled, 1 - Channel 1 & 2 enabled, ""
                ""2 - Channel 3 & 4 enabled.""
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
            param1=None,
            param2=None,
            dest=self.destination,
            source=0x01,
            data=struct.pack(""<HH"", 0x2B, param),
        )

        self.sendpacket(pkt)


class APTPiezoStage(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT piezo stage
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PIEZO COMMANDS #

        @property
        def position_control_closed(self):
            """"""
            Gets the status if the position control is closed or not.

            `True` means that the position control is closed, `False` otherwise

            :type: `bool`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_POSCONTROLMODE
            )
            return bool((resp.parameters[1] - 1) & 1)

        def change_position_control_mode(self, closed, smooth=True):
            """"""
            Changes the position control mode of the piezo channel

            :param bool closed: `True` for closed, `False` for open
            :param bool smooth: `True` for smooth, `False` for otherwise.
                Default is `True`.
            """"""
            mode = 1 + (int(closed) | int(smooth) << 1)
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=mode,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        @property
        def output_position(self):
            """"""
            Gets/sets the output position for the piezo channel.

            :type: `str`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_OUTPUTPOS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_OUTPUTPOS, expect_data_len=4
            )
            # chan, pos
            _, pos = struct.unpack(""<HH"", resp.data)
            return pos

        @output_position.setter
        def output_position(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_OUTPUTPOS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel


class APTStrainGaugeReader(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT strain gauge reader.

    .. warning:: This is not currently implemented
    """"""

    class StrainGaugeChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single strain gauge channel attached to a
        `APTStrainGaugeReader` on the Thorlabs APT controller.

        .. warning:: This is not currently implemented
        """"""

    _channel_type = StrainGaugeChannel


class APTMotorController(ThorLabsAPT):

    """"""
    Class representing a Thorlabs APT motor controller.

    .. note:: A motor model must be selected in order to use unitful
        distances.

    Example:
        >>> import instruments as ik
        >>> import instruments.units as u

        >>> # load the controller, a KDC101 cube
        >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # assign a channel to `ch`
        >>> ch = kdc.channel[0]
        >>> # select the stage that is connected to the controller
        >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

        >>> # home the stage
        >>> ch.go_home()
        >>> # move to 52 degrees absolute position
        >>> ch.move(u.Quantity(52, u.deg))
        >>> # move 10 degrees back from current position
        >>> ch.move(u.Quantity(-10, u.deg), absolute=False)
    """"""

    class MotorChannel(ThorLabsAPT.APTChannel):

        """"""
        Class representing a single motor attached to a Thorlabs APT motor
        controller (`APTMotorController`).
        """"""

        # INSTANCE VARIABLES #

        _motor_model = None

        #: Sets the scale between the encoder counts and physical units
        #: for the position, velocity and acceleration parameters of this
        #: channel. By default, set to dimensionless, indicating that the proper
        #: scale is not known.
        #:
        #: In keeping with the APT protocol documentation, the scale factor
        #: is multiplied by the physical quantity to get the encoder count,
        #: such that scale factors should have units similar to microsteps/mm,
        #: in the example of a linear motor.
        #:
        #: Encoder counts are represented by the quantities package unit
        #: ""ct"", which is considered dimensionally equivalent to dimensionless.
        #: Finally, note that the ""/s"" and ""/s**2"" are not included in scale
        #: factors, so as to produce quantities of dimension ""ct/s"" and
        #: ""ct/s**2""
        #: from dimensionful input.
        #:
        #: For more details, see the APT protocol documentation.
        scale_factors = (u.Quantity(1, ""dimensionless""),) * 3

        _motion_timeout = u.Quantity(10, ""second"")

        __SCALE_FACTORS_BY_MODEL = {
            # TODO: add other tables here.
            re.compile(""TST001|BSC00.|BSC10.|MST601""): {
                # Note that for these drivers, the scale factors are identical
                # for position, velcoity and acceleration. This is not true for
                # all drivers!
                ""DRV001"": (u.Quantity(51200, ""count/mm""),) * 3,
                ""DRV013"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV014"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV113"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""DRV114"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""FW103"": (u.Quantity(25600 / 360, ""count/deg""),) * 3,
                ""NR360"": (u.Quantity(25600 / 5.4546, ""count/deg""),) * 3,
            },
            re.compile(""TDC001|KDC101""): {
                ""MTS25-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                ""MTS50-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                # TODO: Z8xx and Z6xx models. Need to add regex support to motor models, too.
                ""PRM1-Z8"": (
                    u.Quantity(1919.64, ""count/deg""),
                    u.Quantity(42941.66, u.sec / u.deg),
                    u.Quantity(14.66, u.sec**2 / u.deg),
                ),
            },
        }

        __STATUS_BIT_MASK = {
            ""CW_HARD_LIM"": 0x00000001,
            ""CCW_HARD_LIM"": 0x00000002,
            ""CW_SOFT_LIM"": 0x00000004,
            ""CCW_SOFT_LIM"": 0x00000008,
            ""CW_MOVE_IN_MOTION"": 0x00000010,
            ""CCW_MOVE_IN_MOTION"": 0x00000020,
            ""CW_JOG_IN_MOTION"": 0x00000040,
            ""CCW_JOG_IN_MOTION"": 0x00000080,
            ""MOTOR_CONNECTED"": 0x00000100,
            ""HOMING_IN_MOTION"": 0x00000200,
            ""HOMING_COMPLETE"": 0x00000400,
            ""INTERLOCK_STATE"": 0x00001000,
        }

        # IK-SPECIFIC PROPERTIES #
        # These properties don't correspond to any particular functionality
        # of the underlying device, but control how we interact with it.

        @property
        def motion_timeout(self):
            """"""
            Gets/sets the motor channel motion timeout.

            :units: Seconds
            :type: `~pint.Quantity`
            """"""
            return self._motion_timeout

        @motion_timeout.setter
        def motion_timeout(self, newval):
            self._motion_timeout = assume_units(newval, u.second)

        # UNIT CONVERSION METHODS #

        def _set_scale(self, motor_model):
            """"""
            Sets the scale factors for this motor channel, based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel.

            :param str motor_model: Name of the model of the attached motor,
                as indicated in the APT protocol documentation (page 14, v9).
            """"""
            for driver_re, motor_dict in self.__SCALE_FACTORS_BY_MODEL.items():
                if driver_re.match(self._apt.model_number) is not None:
                    if motor_model in motor_dict:
                        self.scale_factors = motor_dict[motor_model]
                        return
                    else:
                        break
            # If we've made it down here, emit a warning that we didn't find the
            # model.
            logger.warning(
                ""Scale factors for controller %s and motor %s are "" ""unknown"",
                self._apt.model_number,
                motor_model,
            )

        # We copy the docstring below, so it's OK for this method
        # to not have a docstring of its own.
        # pylint: disable=missing-docstring
        def set_scale(self, motor_model):
            warnings.warn(
                ""The set_scale method has been deprecated in favor ""
                ""of the motor_model property."",
                DeprecationWarning,
            )
            return self._set_scale(motor_model)

        set_scale.__doc__ = _set_scale.__doc__

        @property
        def motor_model(self):
            """"""
            Gets or sets the model name of the attached motor.
            Note that the scale factors for this motor channel are based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel, such that setting a new motor model will update
            the scale factors accordingly.

            :type: `str` or `None`
            """"""
            return self._motor_model

        @motor_model.setter
        def motor_model(self, newval):
            self._set_scale(newval)
            self._motor_model = newval

        # MOTOR COMMANDS #

        @property
        def backlash_correction(self):
            """"""Get / set backlash correctionf or given stage.

            If no units are given, ``u.counts`` are assumed. If you have
            the stage defined (see example below), unitful values can be
            used for setting the backlash correction, e.g., ``u.mm`` or
            ``u.deg``.

            :return: Unitful quantity of backlash correction.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> ch.backlash_correction = 4 * u.deg  # set it to 4 degrees
                >>> ch.backlash_correction  # read it back
                <Quantity(4, 'degree')>
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_GENMOVEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_GENMOVEPARAMS,
                expect_data_len=6,
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @backlash_correction.setter
        def backlash_correction(self, pos):
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )
            # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_GENMOVEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )
            self._apt.sendpacket(pkt)

        @property
        def home_parameters(self):
            """"""Get the home parameters for the motor channel.

            Parameters are stage specific and not all parameters can be set
            for every stage. For example, the MLS203 stage only allows the
            homing velocity to be changed.

            .. note:: When setting the quantity, pass `None` to values
                that you want to leave unchanged (see example below).

            .. note:: After changing the offset, the stage must be homed
                in order to show the new offset in its values.

            :return: Home Direction (1: forward/positive, 2 reverse/negative),
                Limit Switch (1: hardware reverse, 4: hardware forward),
                Home Velocity,
                Offset distance
            :rtype: Tuple[int, int, u.Quantity, u.Quantity]


            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> # set offset distance to 4 degrees, leave other values
                >>> ch.home_parameters = None, None, None, 4 * u.deg
                >>> ch.home_parameters  # read it back
                (2, 1, <Quantity(9.99, 'degree / second')>, <Quantity(3.99, 'degree')>)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_HOMEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_HOMEPARAMS,
                expect_data_len=14,
            )
            # chan, home_dir, limit_switch, velocity, ,offset_dist
            _, home_dir, lim_sw, vel, offset = struct.unpack(""<HHHll"", response.data)
            return (
                int(home_dir),
                int(lim_sw),
                u.Quantity(vel) / self.scale_factors[1],
                u.Quantity(offset, ""counts"") / self.scale_factors[0],
            )

        @home_parameters.setter
        def home_parameters(self, values):
            if len(values) != 4:
                raise ValueError(
                    ""Home parameters muust be set with four values: ""
                    ""Home direction, limit switch settings, velocity, and offset. ""
                    ""For settings you want to leave untouched, pass `None`.""
                )

            # replace values that are `None`
            if None in values:
                set_params = self.home_parameters
                values = [x if x is not None else y for x, y in zip(values, set_params)]

            home_dir, lim_sw, velocity, offset = values
            if isinstance(velocity, u.Quantity):
                velocity = (velocity * self.scale_factors[1]).to_reduced_units()
                if velocity.dimensionless:
                    velocity = int(velocity.magnitude)
                else:
                    raise ValueError(
                        ""Provided units for velocity are not compatible ""
                        ""with current motor scale factor.""
                    )
            if isinstance(offset, u.Quantity):
                if offset.units == u.counts:
                    offset = int(offset.magnitude)
                else:
                    scaled_vel = offset * self.scale_factors[0]
                    try:
                        offset = int(scaled_vel.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units for offset are not compatible ""
                            ""with current motor scale factor.""
                        )

                # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_HOMEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHll"",
                    self._idx_chan,
                    int(home_dir),
                    int(lim_sw),
                    int(velocity),
                    int(offset),
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def status_bits(self):
            """"""
            Gets the status bits for the specified motor channel.

            .. note:: This command, as currently implemented, is only
                available for certain devices and will result in an
                ``OSError`` otherwise. Devices that work according to the
                manual are: TSC001, KSC101, BSC10x, BSC20x, LTS150, LTS300,
                MLJ050, MLJ150, TIM101, KIM101.

            :type: `dict`
            """"""
            # NOTE: the difference between MOT_REQ_STATUSUPDATE and
            # MOT_REQ_DCSTATUSUPDATE confuses me
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_STATUSUPDATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            # The documentation claims there are 14 data bytes, but it seems
            # there are sometimes some extra random ones...
            # fixme: wrong expected datatype? MOT_GET_STATUSUPDATE expected
            resp_data = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER,
                expect_data_len=14,
            ).data[:14]
            # ch_ident, position, enc_count, status_bits
            _, _, _, status_bits = struct.unpack(""<HLLL"", resp_data)

            status_dict = {
                key: (status_bits & bit_mask > 0)
                for key, bit_mask in self.__STATUS_BIT_MASK.items()
            }

            return status_dict

        @property
        def position(self):
            """"""
            Gets the current position of the specified motor channel

            :type: `~pint.Quantity`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_POSCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @property
        def position_encoder(self):
            """"""
            Gets the position of the encoder of the specified motor channel

            :type: `~pint.Quantity`
            :units: Encoder ``counts``
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_ENCCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_ENCCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"")

        def go_home(self):
            """"""
            Instructs the specified motor channel to return to its home
            position
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_HOME,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_HOMED,
                timeout=self.motion_timeout,
            )

        def move(self, pos, absolute=True):
            """"""
            Instructs the specified motor channel to move to a specific
            location. The provided position can be either an absolute or
            relative position.

            :param pos: The position to move to. Provided value will be
                converted to encoder counts.
            :type pos: `~pint.Quantity`
            :units pos: As specified, or assumed to of units encoder counts

            :param bool absolute: Specify if the position is a relative or
                absolute position. ``True`` means absolute, while ``False``
                is for a relative move.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> # select the stage that is connected to the controller
                >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

                >>> # move to 32 degrees absolute position
                >>> ch.move(u.Quantity(32, u.deg))

                >>> # move 10 degrees forward from current position
                >>> ch.move(u.Quantity(10, u.deg), absolute=False)
            """"""
            # Handle units as follows:
            # 1. Treat raw numbers as encoder counts.
            # 2. If units are provided (as a Quantity), check if they're encoder
            #    counts. If they aren't, apply scale factor.
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )

            # Now that we have our position as an integer number of encoder
            # counts, we're good to move.
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_ABSOLUTE
                if absolute
                else _cmds.ThorLabsCommands.MOT_MOVE_RELATIVE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )

            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_COMPLETED,
                timeout=self.motion_timeout,
                expect_data_len=14,
            )

    _channel_type = MotorChannel

    # CONTROLLER PROPERTIES AND METHODS #
"
337,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attu9I3LtvUIcgvyq'), ('width', 540), ('height', 351), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/aDKmaG6fvq5MclZfdpXamg/MoXVTCOY8hFbKsp1gArOn66Bp4yG33Al1fYK7gJmDVdXs5fmEkAXXU3_ALZp3HxHr5c3xdk-sI2m3qrxTr0fQZnBpOTHWNIa4tnUx5akEus/fSXSXKF9RV2qj59YbMdE2beQsecLCuDdsb0VajHK2Bg'), ('filename', 'Tek-dpo73304.jpeg'), ('size', 55700), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TzslWZNN_dZ8oRaGThiePQ/Ym7Ql861snhhBbDQ5E_UWhm3CmqM2i44D371ABALvqmKPVdRy0yj8jHrdYChTgiPm9QJPZjZp6O4V6mmTCvx2A/PNaieJ8YkJFs9zIAo5ygux9cCqZdn5CE6AHdVt4HpMY'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pwBP6mYsZ-J_A7i4A9x2Cg/bMu0k1aTVbBJTS6r-U1Kfys45PFVnSbZ1S3hO7UedyGgLyyP5CmTiwmcomrWksAhSNkAO20HVDwRcNGl5QMTLA/0-yR_hnIJKrGYLN2sIIvL_owk_Mp_zuJs9tzvWeIheQ'), ('width', 540), ('height', 351)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pqYQrf6rGhh69GZLMr_Rgw/TA_pM3Wwr8J3n1ZmzfAlFChQkspghri5eEbs7F-5EjbHRqVEHa0Ur0lo-EwFOBpRUhqyu0xsVCcNrBgWKIcwBw/facT26ti5rnfVnbI3rwWjU0sjVSTgPgvgqfcBsaVaRg'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The MSO/DPO70000DX is one of the most advanced oscilloscopes in its class—enabling today's engineer to see signals better with minimal noise, debug signal anomalies faster and utilize measurement and analysis tools for automated compliance testing and other verifications",https://www.tek.com/en/products/oscilloscopes/dpo70000-mso70000?utm_source=Google&utm_medium=ppc&utm_term=&utm_content=Colts-and-Titans&utm_campaign=Evergreen-Tektronix-Mainstream-Scopes&_bt=623794827723&_bk=&_bm=&_bn=g&_bg=140123783248&gclid=Cj0KCQjw8NilBhDOARIsAHzpbLCFoQf1R6EyTEO3Cq_CaxeAyy1od8kPILEYzOvwRWPPA3R2dif-PQ4aAid7EALw_wcB,Tekdpo 7000,543.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tekdpo70000.html,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/tektronix/tekdpo70000.html,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782722/Instruments/Oscilloscopes/DPO7000/DPO7000.jpg,DPO7000,Write a Python script that uses Instrumentkit to connect to a DPO7000 Oscilloscopes,,,,,
341,https://www.thorlabs.com/_sd.cfm?fileName=8654-D02.pdf&partNumber=SC10,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927,"[OrderedDict([('id', 'attuCdx2mUAVBjH8G'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2czXkRzBzXSj9j3khIpOsw/84KfQdNDP5UXFF_DAnE9WhKi34TqHQB3g7kyD0D9wxJlXo1daEx8GWDWc72D4TcMS_0H6ERBzlXU0AuxmuNwKbTAn8Ev_M0w6tQw4lDjkJk/TMeykgBzdesNn3CR-Rd_3cEJHjzf3i66JhksOR46KwA'), ('filename', '2698_SC10_SGL.jpg'), ('size', 29251), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VepmEKZdzXa5yYlaQplN0A/qm_RK_Sr0MnLpn9yAnEPo_9gpCde0Q7ZHuurGWX4-KvTI5-TfAJsplLX47IChOY2xk8gWLLHAfbahkQjHIfaQg/DqGKXQjOoKkcurCd8pT8kBwfdR4njdlYaoY8eXuIy1U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Pzn-in08Va7uX23l9LPHOw/snooO3iRWYijnRGeMo66UNWt5gQPn51V6BiZEYQwjXJUekXYf-MAmfVP6PFtPzcudq2Qxa5JJA9rz53JabtRhw/fLc8DncYDuEeFWQWiWvDc2iXnMa8RjHI3XIjiFmizEo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lu9VYW3WSDpqubdcmOSy6A/EymR6IRZfuxEsdh0Py82mY9Fm-k2-pFr-57K5J7k62MXKd28F_RKAIWPOB8Crhz32A0orCXjre0mn4ol7rXJNw/IGIy3Z4NlwDEhGvdQr7ibySc3kWrcEhuadOK1Orm9bg'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The easy-to-read LCD front panel provides access to the same commands as the included LabVIEW and LabWindows software packages. In addition to simply opening or closing the shutter, a repeating sequence of open and close events with exposure times as low as 10 ms can be set up and initiated either by a front panel button, a TTL pulse (+5 V), or a computer command via RS-232. Alternatively, the shutter can be synchronized to follow the rising and falling edges of an external voltage supplied over BNC.

",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927&pn=SC10,SC 10,599.0,['Shutter Controller'],"Optical Shutters utilize a rotary, electro-mechanical actuator to provide millisecond shutter operation. During operation, these shutters remain in a closed position and then open when a pulse control signal is applied by an external controller. As long as the control voltage to the optical shutter remains high, the shutter stays open, but as soon as the voltage goes low, the shutter closes, providing inherent ""fail-safe"" operation. The frequency at which the device is opened and closed can be controlled. An optical sensor, which detects the shutter blade position in the housing, provides information that confirms the state of the optical shutter position. This makes it ideal in applications where a laser safety lockout is required.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/sc10.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782726/Instruments/Shutter%20Controller/SC10/SC10.jpg,SC10,Write a Python script that uses Instrumentkit to connect to a SC10 Shutter Controller,844.36,,,,"#!/usr/bin/python
""""""
Provides the support for the Thorlabs SC10 optical beam shutter controller.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.thorlabs.thorlabs_utils import check_cmd
from instruments.units import ureg as u
from instruments.util_fns import (
    bool_property,
    enum_property,
    int_property,
    unitful_property,
)

# CLASSES #####################################################################


class SC10(Instrument):

    """"""
    The SC10 is a shutter controller, to be used with the Thorlabs SH05 and SH1.
    The user manual can be found here:
    http://www.thorlabs.com/thorcat/8600/SC10-Manual.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.prompt = ""> ""

    def _ack_expected(self, msg=""""):
        return msg

    # ENUMS #

    class Mode(IntEnum):

        """"""
        Enum containing valid output modes of the SC10
        """"""

        manual = 1
        auto = 2
        single = 3
        repeat = 4
        external = 5

    # PROPERTIES #

    @property
    def name(self):
        """"""
        Gets the name and version number of the device.

        :return: Name and verison number of the device
        :rtype: `str`
        """"""
        return self.query(""id?"")

    @property
    def enable(self):
        """"""
        Gets/sets the shutter enable status, False for disabled, True if
        enabled

        If output enable is on (`True`), there is a voltage on the output.
        :return: Status of the switch.
        :rtype: `bool`

        :raises TypeError: Unexpected type given when trying to enable.
        """"""
        return bool(int(self.query(""ens?"")))

    @enable.setter
    def enable(self, value):
        if not isinstance(value, bool):
            raise TypeError(f""Expected bool, got type {type(value)} instead."")
        curr_status = self.enable
        if curr_status is not value:
            self.sendcmd(""ens"")

    repeat = int_property(
        ""rep"",
        valid_set=range(1, 100),
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the repeat count for repeat mode. Valid range is [1,99]
        inclusive.

        :type: `int`
        """""",
    )

    mode = enum_property(
        ""mode"",
        Mode,
        input_decoration=int,
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the output mode of the SC10

        :rtype: `SC10.Mode`
        """""",
    )

    trigger = int_property(
        ""trig"",
        valid_set=range(0, 2),
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the trigger source.

        0 for internal trigger, 1 for external trigger

        :type: `int`
        """""",
    )

    out_trigger = int_property(
        ""xto"",
        valid_set=range(0, 2),
        set_fmt=""{}={}"",
        doc=""""""
        Gets/sets the out trigger source.

        0 trigger out follows shutter output, 1 trigger out follows
        controller output

        :type: `int`
        """""",
    )

    open_time = unitful_property(
        ""open"",
        u.ms,
        format_code=""{:.0f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 999999),
        doc=""""""
        Gets/sets the amount of time that the shutter is open, in ms

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units milliseconds.
        :type: `~pint.Quantity`
        """""",
    )

    shut_time = unitful_property(
        ""shut"",
        u.ms,
        format_code=""{:.0f}"",
        set_fmt=""{}={}"",
        valid_range=(0, 999999),
        doc=""""""
        Gets/sets the amount of time that the shutter is closed, in ms

        :units: As specified (if a `~pint.Quantity`) or assumed
            to be of units milliseconds.
        :type: `~pint.Quantity`
        """""",
    )

    @property
    def baud_rate(self):
        """"""
        Gets/sets the instrument baud rate.

        Valid baud rates are 9600 and 115200.

        :type: `int`
        """"""
        response = self.query(""baud?"")
        return 115200 if int(response) else 9600

    @baud_rate.setter
    def baud_rate(self, newval):
        if newval != 9600 and newval != 115200:
            raise ValueError(""Invalid baud rate mode"")
        else:
            self.sendcmd(f""baud={0 if newval == 9600 else 1}"")

    closed = bool_property(
        ""closed"",
        inst_true=""1"",
        inst_false=""0"",
        readonly=True,
        doc=""""""
        Gets the shutter closed status.

        `True` represents the shutter is closed, and `False` for the shutter is
        open.

        :rtype: `bool`
        """""",
    )

    interlock = bool_property(
        ""interlock"",
        inst_true=""1"",
        inst_false=""0"",
        readonly=True,
        doc=""""""
        Gets the interlock tripped status.

        Returns `True` if the interlock is tripped, and `False` otherwise.

        :rtype: `bool`
        """""",
    )

    # Methods #

    def default(self):
        """"""
        Restores instrument to factory settings.

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""default"")
        return check_cmd(response)

    def save(self):
        """"""
        Stores the parameters in static memory

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""savp"")
        return check_cmd(response)

    def save_mode(self):
        """"""
        Stores output trigger mode and baud rate settings in memory.

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""save"")
        return check_cmd(response)

    def restore(self):
        """"""
        Loads the settings from memory.

        Returns 1 if successful, zero otherwise.

        :rtype: `int`
        """"""
        response = self.query(""resp"")
        return check_cmd(response)
"
344,https://www.thinksrs.com/downloads/pdfs/catalog/CTC100c.pdf,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attWJtT5pqwcUvIF4'), ('width', 3996), ('height', 2704), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IdRpZC6_nYUDyJPQ8BnWBg/KbSytbgjVl5Am0stFZqyw58Iqc-KQqq3tkS0u33gOUB0EwJ3EcyX39wk2oAHnx0YGB4SPjPbZ54ocH_Garm5tCkVI72lWsgG7YBRGjFpqko/9goIYdpkRKfF6E1-ErmthaNP6hloT7OHx26Wemi3VuQ'), ('filename', 'CTC100_Main2.jpg'), ('size', 2127759), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/To1FcZSeyW8A4NwIUnaAaA/P351XJgYADuJ1V8WtOVsZVED7GdqLZMxXrOCEvQ1ybkH2SeoC4Z7g05g37dqgPRl4EhD5RgTVIZwcXRg3albUw/foVoizhLxQk1OrkM7s6Rymjk3Ozc8SZ4atMe2x_AJsw'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-_aajAuyyY0MiawTTg4V_w/X-NSMo33jxCIfUT_K6QoS2ievvzkTi8ZoG9aXt3BI1nh5EED5bpRfeC34yg4mg5fV_AhJ3s6lmms75N6W3uYAg/hDeq0voH45otJyHs_pS5F_HtOBkktDiouIutqMIQMiM'), ('width', 757), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fb_p2CWxpRi4_j-VXj2olg/BSSmceT7oKqeoNIllo6Xsl6bNT7yrKJmg2atgyVR5dDSxrG8BBOH7gFTFnbYf1GBfzP1kREWetKQKboxnzHCWA/ReYcwZLiAidp_ZpX7CDndNdRZFp4n1B0u2OhwppIH90'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"CTC100 Cryogenic Temperature Controller—a high performance instrument that can monitor and control temperatures with millikelvin resolution.

The CTC100 Cryogenic Temperature Controller is configured to suit a wide range of research and industrial applications. The system consists of four sensor inputs, two powered and four analog voltage outputs, and up to six feedback control loops.",https://www.thinksrs.com/products/ctc100.html,Srs ctc 100,495.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsctc100.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsctc100-cryogenic-temperature-controller,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782728/Instruments/Temperature%20Controllers/CTC100/CTC100.jpg,CTC100,Write a Python script that uses Instrumentkit to connect to a CTC100 Temperature Controllers,3495.0,,,,"#!/usr/bin/env python
""""""
Provides support for the SRS CTC-100 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from contextlib import contextmanager
from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class SRSCTC100(SCPIInstrument):

    """"""
    Communicates with a Stanford Research Systems CTC-100 cryogenic temperature
    controller.
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._do_errcheck = True

    # DICTIONARIES #

    _BOOL_NAMES = {""On"": True, ""Off"": False}

    # Note that the SRS CTC-100 uses '\xb0' to represent '°'.
    _UNIT_NAMES = {
        ""\xb0C"": u.celsius,
        ""W"": u.watt,
        ""V"": u.volt,
        ""\xea"": u.ohm,
        """": u.dimensionless,
    }

    # INNER CLASSES ##

    class SensorType(Enum):
        """"""
        Enum containing valid sensor types for the SRS CTC-100
        """"""

        rtd = ""RTD""
        thermistor = ""Thermistor""
        diode = ""Diode""
        rox = ""ROX""

    class Channel:

        """"""
        Represents an input or output channel on an SRS CTC-100 cryogenic
        temperature controller.
        """"""

        def __init__(self, ctc, chan_name):
            self._ctc = ctc

            # Save the pretty name that we are given.
            self._chan_name = chan_name

            # Strip spaces from the name used in remote programming, as
            # specified on page 14 of the manual.
            self._rem_name = chan_name.replace("" "", """")

        # PRIVATE METHODS #

        def _get(self, prop_name):
            return self._ctc.query(f""{self._rem_name}.{prop_name}?"").strip()

        def _set(self, prop_name, newval):
            self._ctc.sendcmd(f'{self._rem_name}.{prop_name} = ""{newval}""')

        # DISPLAY AND PROGRAMMING #
        # These properties control how the channel is identified in scripts
        # and on the front-panel display.

        @property
        def name(self):
            """"""
            Gets/sets the name of the channel that will be used by the
            instrument to identify the channel in programming and on the
            display.

            :type: `str`
            """"""
            return self._chan_name

        @name.setter
        def name(self, newval):
            self._set(""name"", newval)
            # TODO: check for errors!
            self._chan_name = newval
            self._rem_name = newval.replace("" "", """")

        # BASICS #

        @property
        def value(self):
            """"""
            Gets the measurement value of the channel. Units depend on what
            kind of sensor and/or channel you have specified. Units can be one
            of ``celsius``, ``watt``, ``volt``, ``ohm``, or ``dimensionless``.

            :type: `~pint.Quantity`
            """"""
            # WARNING: Queries all units all the time.
            # TODO: Make an OutputChannel that subclasses this class,
            #       and add a setter for value.
            return u.Quantity(float(self._get(""value"")), self.units)

        @property
        def units(self):
            """"""
            Gets the appropriate units for the specified channel.

            Units can be one of ``celsius``, ``watt``, ``volt``, ``ohm``, or
            ``dimensionless``.

            :type: `~pint.Unit`
            """"""
            # FIXME: does not respect ""chan.d/dt"" property.
            return self._ctc.channel_units()[self._chan_name]
            # FIXME: the following line doesn't do what I'd expect, and so it's
            #        commented out.
            # return
            # self._ctc._UNIT_NAMES[self._ctc.query('{}.units?'.format(self._rem_name)).strip()]

        @property
        def sensor_type(self):
            """"""
            Gets the type of sensor attached to the specified channel.

            :type: `SRSCTC100.SensorType`
            """"""
            return self._ctc.SensorType(self._get(""sensor""))

        # STATS #
        # The following properties control and query the statistics of the
        # channel.

        @property
        def stats_enabled(self):
            """"""
            Gets/sets enabling the statistics for the specified channel.

            :type: `bool`
            """"""
            return True if self._get(""stats"") == ""On"" else False

        @stats_enabled.setter
        def stats_enabled(self, newval):
            # FIXME: replace with bool_property factory
            self._set(""stats"", ""On"" if newval else ""Off"")

        @property
        def stats_points(self):
            """"""
            Gets/sets the number of sample points to use for the channel
            statistics.

            :type: `int`
            """"""
            return int(self._get(""points""))

        @stats_points.setter
        def stats_points(self, newval):
            self._set(""points"", int(newval))

        @property
        def average(self):
            """"""
            Gets the average measurement for the specified channel as
            determined by the statistics gathering.

            :type: `~pint.Quantity`
            """"""
            return u.Quantity(float(self._get(""average"")), self.units)

        @property
        def std_dev(self):
            """"""
            Gets the standard deviation for the specified channel as determined
            by the statistics gathering.

            :type: `~pint.Quantity`
            """"""
            return u.Quantity(float(self._get(""SD"")), self.units)

        # LOGGING #

        def get_log_point(self, which=""next"", units=None):
            """"""
            Get a log data point from the instrument.

            :param str which: Which data point you want. Valid examples
                include ``first``, and ``next``. Consult the instrument
                manual for the complete list
            :param units: Units to attach to the returned data point. If left
                with the value of `None` then the instrument will be queried
                for the current units setting.
            :type units: `~pint.Unit`
            :return: The log data point with units
            :rtype: `~pint.Quantity`
            """"""
            if units is None:
                units = self.units

            point = [
                s.strip()
                for s in self._ctc.query(f""getLog.xy {self._chan_name}, {which}"").split(
                    "",""
                )
            ]
            return u.Quantity(float(point[0]), ""ms""), u.Quantity(float(point[1]), units)

        def get_log(self):
            """"""
            Gets all of the log data points currently saved in the instrument
            memory.

            :return: Tuple of all the log data points. First value is time,
                second is the measurement value.
            :rtype: If numpy is installed, tuple of 2x `~pint.Quantity`,
                each comprised of a numpy array (`numpy.dnarray`).
                Else, `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
            """"""
            # Remember the current units.
            units = self.units

            # Find out how many points there are.
            n_points = int(self._ctc.query(f""getLog.xy? {self._chan_name}""))

            # Make an empty quantity that size for the times and for the channel
            # values.
            if numpy:
                ts = u.Quantity(numpy.empty((n_points,)), u.ms)
                temps = u.Quantity(numpy.empty((n_points,)), units)
            else:
                ts = [u.Quantity(0, u.ms)] * n_points
                temps = [u.Quantity(0, units)] * n_points

            # Reset the position to the first point, then save it.
            # pylint: disable=protected-access
            with self._ctc._error_checking_disabled():
                ts[0], temps[0] = self.get_log_point(""first"", units)
                for idx in range(1, n_points):
                    ts[idx], temps[idx] = self.get_log_point(""next"", units)

            # Do an actual error check now.
            if self._ctc.error_check_toggle:
                self._ctc.errcheck()

            if not numpy:
                ts = tuple(ts)
                temps = tuple(temps)

            return ts, temps

    # PRIVATE METHODS ##

    def _channel_names(self):
        """"""
        Returns the names of valid channels, using the ``getOutput.names``
        command, as documented in the example on page 14 of the
        `CTC-100 manual`_.

        Note that ``getOutput`` also lists input channels, confusingly enough.

        .. _CTC-100 manual: http://www.thinksrs.com/downloads/PDFs/Manuals/CTC100m.pdf
        """"""
        # We need to split apart the comma-separated list and make sure that
        # no newlines or other whitespace gets carried along for the ride.
        # Note that we do NOT strip spaces here, as this is done inside
        # the Channel object. Doing things that way allows us to present
        # the actual pretty name to users, but to use the remote-programming
        # name in commands.
        # As a consequence, users of this instrument MUST use spaces
        # matching the pretty name and not the remote-programming name.
        # CG could not think of a good way around this.
        names = [name.strip() for name in self.query(""getOutput.names?"").split("","")]
        return names

    def channel_units(self):
        """"""
        Returns a dictionary from channel names to channel units, using the
        ``getOutput.units`` command. Unknown units and dimensionless quantities
        are presented the same way by the instrument, and so both are reported
        using `u.dimensionless`.

        :rtype: `dict` with channel names as keys and units as values
        """"""
        unit_strings = [
            unit_str.strip() for unit_str in self.query(""getOutput.units?"").split("","")
        ]
        return {
            chan_name: self._UNIT_NAMES[unit_str]
            for chan_name, unit_str in zip(self._channel_names(), unit_strings)
        }

    def errcheck(self):
        """"""
        Performs an error check query against the CTC100. This function does
        not return anything, but will raise an `IOError` if the error code
        received by the instrument is not zero.

        :return: Nothing
        """"""
        errs = super().query(""geterror?"").strip()
        err_code, err_descript = errs.split("","")
        err_code = int(err_code)
        if err_code == 0:
            return err_code
        else:
            raise OSError(err_descript.strip())

    @contextmanager
    def _error_checking_disabled(self):
        old = self._do_errcheck
        self._do_errcheck = False
        yield
        self._do_errcheck = old

    # PROPERTIES ##
    @property
    def channel(self):
        """"""
        Gets a specific measurement channel on the SRS CTC100. This is accessed
        like one would access a `dict`. Here you must use the actual channel
        names to address a specific channel. This is different from most
        other instruments in InstrumentKit because the CRC100 channel names
        can change by the user.

        The list of current valid channel names can be accessed by the
        `SRSCTC100._channel_names()` function.

        :type: `SRSCTC100.Channel`
        """"""
        # Note that since the names can change, we need to query channel names
        # each time. This is inefficient, but alas.
        return ProxyList(self, self.Channel, self._channel_names())

    @property
    def display_figures(self):
        """"""
        Gets/sets the number of significant figures to display. Valid range
        is 0-6 inclusive.

        :type: `int`
        """"""
        return int(self.query(""system.display.figures?""))

    @display_figures.setter
    def display_figures(self, newval):
        if newval not in range(7):
            raise ValueError(
                ""Number of display figures must be an integer ""
                ""from 0 to 6, inclusive.""
            )
        self.sendcmd(f""system.display.figures = {newval}"")

    @property
    def error_check_toggle(self):
        """"""
        Gets/sets if errors should be checked for after every command.

        :bool:
        """"""
        return self._do_errcheck

    @error_check_toggle.setter
    def error_check_toggle(self, newval):
        if not isinstance(newval, bool):
            raise TypeError
        self._do_errcheck = newval

    # OVERRIDEN METHODS #

    # We override sendcmd() and query() to do error checking after each
    # command.
    def sendcmd(self, cmd):
        super().sendcmd(cmd)
        if self._do_errcheck:
            self.errcheck()

    def query(self, cmd, size=-1):
        resp = super().query(cmd, size)
        if self._do_errcheck:
            self.errcheck()
        return resp

    # LOGGING COMMANDS #

    def clear_log(self):
        """"""
        Clears the SRS CTC100 log

        Not sure if this works.
        """"""
        self.sendcmd(""System.Log.Clear yes"")
"
347,https://www.picowatt.fi/interfacing/avs47_serial_usb/avs47_serial_usb_w_userguide.pdf,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attLoXHvdB7eWnmFg'), ('width', 2935), ('height', 1593), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-oPup4hqMwFI4JI7EDnQoA/Dyy4QTpHTXdeL_zT41JuU0DKbqfZqjj09aoyyYRP_4S0H23uvM5-f_2eI7fqWqgDdO2XpNDU5tBbaVxBTsHvh16uwxqpsuQKDhdKbRhXYi7qKwQKAej9Db9KpPdyhzy6/xFe2zWIWEim2Xk9e_FnWz-VEgObKiKSWCTGoNRmxhXc'), ('filename', 'avs48si_physical_front_panel.jpg'), ('size', 188257), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UVtcQXfSw47iWgCJ_zCLsQ/mpHTd72bNMVtEusZ9k1HowzxW9XmFxdqzai6_2eGFjXnw9figeM1UlmfF2mtXAXRLIOg3LNnFDMS9t_8xmw5PA/r0pdafhwu61ULpOAXH5Enh9ORYlWbVrg_Q6Pj3Mk41Q'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zIhTumyykKLzsj-yDj7ibg/9wwN4oEvSxOFxb6oYHuXcIJHoNU1wRcE2Z93pUp6IG5N664DGdYxUtN_S-AUpT4RT_S1HKYeRFfCPJbt_CwUiw/W2H-AFswRgmKww1hwq64DFZ2i62Qwh5m9Ut_OFIBM18'), ('width', 943), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mcINo_ORHS7O9rlMg-PCMQ/_z5ChdzjJTL9dQO5Aaiuw16eU5K5moKEzE0UuF4z-jakDU8vqwaPgr20LIP3GSDqNE71z-uUW_Ae7BkvSarEzA/Mj1D06Ws8DKH0lAHP2YcWwS5oR59cKBJrIB3v5HfJRk'), ('width', 3000), ('height', 3000)]))]))])]",5.0,Finland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125957/Instruments/Vendor%20Logos/Picowatt.png,The Picowatt AVS 47 is a resistance bridge used to measure the resistance of low-temperature sensors.,https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,Picowattavs 47,419.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","RV-Elektroniikka Oy PICOWATT is specialized in manufacturing instruments for thermometry at ultralow temperatures. Founded in February 1978, we have gathered 45 years of experience in designing and manufacturing low-noise precision
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/picowatt/picowattavs47.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,Picowatt,"[OrderedDict([('id', 'attgTI15cND1GBG9f'), ('width', 150), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rG9bJP6TbB-TOtquU8kIew/WFFU77xGc2wU5ukgEjOIl5UD11lNCNAFF59XAPgkurQzgrZriwX46uYXS1hzDeiyoKU8Mb2ZjcVdSScggHzixJ-jUOuoEtliqCC7fo4zh3w/K0AYLgdl46_Jkrt2M7VkSUaR4Ads4ZiUk7Sws02BK5k'), ('filename', 'logotext.gif'), ('size', 543), ('type', 'image/gif'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/35Nc64rf5zDAJ6dSBvyZmQ/SbJo2N08c1yT0aVfCbXcYM1avxtw37I9LdqxE9FDQ6lUSVK6Q9EhwolrB9rsI_iaVtZiDlV-r88U1eTqJMjmEg/tJ7xSaG_7O0aoZNX867zsreA2rSAVyawmqGsYegeH9w'), ('width', 108), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_k8nTvTWUy_zmyQjaMdoWA/u8ePyeROOZcmN7fe6OmvhgyHAesybch7AymtHGwWj4re-fBT9WEpnKKg6lw0oN1Hw9YvMrCM9zEoNAzJuHAhfw/h72yevFLb5xnSHaBnEufzUgSiZET5q8M0d_ChwP-oE4'), ('width', 150), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bqnV0dQCtysutaq3EHZVjA/-GaC9G8x0227E2pEk3EejUYCbGCoPrbumNjJsMlOMLdpaMutyztI6oUamByGc9HNsu5DhT0xRV9ewdyimLz3fg/695PHKQFKv9iRDgH1RvjQZUDphXRO10rB-Qcude9wbg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.picowatt.fi/index1.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782731/Instruments/Temperature%20Controllers/AVS-47/AVS-47.jpg,AVS 47,Write a Python script that uses Instrumentkit to connect to a AVS 47 Temperature Controllers,,,True,,"#!/usr/bin/env python
""""""
Provides support for the Picowatt AVS 47 resistance bridge
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import enum_property, bool_property, int_property, ProxyList

# CLASSES #####################################################################


class PicowattAVS47(SCPIInstrument):

    """"""
    The Picowatt AVS 47 is a resistance bridge used to measure the resistance
    of low-temperature sensors.

    Example usage:

    >>> import instruments as ik
    >>> bridge = ik.picowatt.PicowattAVS47.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print bridge.sensor[0].resistance
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""HDR 0"")  # Disables response headers from replies

    # INNER CLASSES #

    class Sensor:

        """"""
        Class representing a sensor on the PicowattAVS47

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `PicowattAVS47` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx  # The AVS47 is actually zero-based indexing! Wow!

        @property
        def resistance(self):
            """"""
            Gets the resistance. It first ensures that the next measurement
            reading is up to date by first sending the ""ADC"" command.

            :units: :math:`\\Omega` (ohms)
            :rtype: `~pint.Quantity`
            """"""
            # First make sure the mux is on the correct channel
            if self._parent.mux_channel != self._idx:
                self._parent.input_source = self._parent.InputSource.ground
                self._parent.mux_channel = self._idx
                self._parent.input_source = self._parent.InputSource.actual
            # Next, prep a measurement with the ADC command
            self._parent.sendcmd(""ADC"")
            return float(self._parent.query(""RES?"")) * u.ohm

    # ENUMS #

    class InputSource(IntEnum):
        """"""
        Enum containing valid input source modes for the AVS 47
        """"""

        ground = 0
        actual = 1
        reference = 2

    # PROPERTIES #

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        :rtype: `~PicowattAVS47.Sensor`

        .. seealso::
            `PicowattAVS47` for an example using this property.
        """"""
        return ProxyList(self, PicowattAVS47.Sensor, range(8))

    remote = bool_property(
        command=""REM"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""
        Gets/sets the remote mode state.

        Enabling the remote mode allows all settings to be changed by computer
        interface and locks-out the front panel.

        :type: `bool`
        """""",
    )

    input_source = enum_property(
        command=""INP"",
        enum=InputSource,
        input_decoration=int,
        doc=""""""
        Gets/sets the input source.

        :type: `PicowattAVS47.InputSource`
        """""",
    )

    mux_channel = int_property(
        command=""MUX"",
        doc=""""""
        Gets/sets the multiplexer sensor number.
        It is recommended that you ground the input before switching the
        multiplexer channel.

        Valid mux channel values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )

    excitation = int_property(
        command=""EXC"",
        doc=""""""
        Gets/sets the excitation sensor number.

        Valid excitation sensor values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )

    display = int_property(
        command=""DIS"",
        doc=""""""
        Gets/sets the sensor that is displayed on the front panel.

        Valid display sensor values are 0 through 7 (inclusive).

        :type: `int`
        """""",
        valid_set=range(8),
    )
"
348,https://www.thorlabs.com/_sd.cfm?fileName=ETN035405-D02.pdf&partNumber=LPS710E,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attM8R0YwBzGU5Fsz'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7d72tINQNGVD3PBrjSbHQQ/0Z2FZqzQ95CzVqkfdY1wycq4JBRaih-m24NRVRkUMNNeQN6-AiNWXjWJ4EfQ7M74_-8MSCe02jiou-vkhad6AhwmK7VnIcx3KJnBPgr645Q/K7c1lbnjHPEZYUg3x9LmVkA9noLIram7QRffqUZwkN0'), ('filename', 'ETN035405-xl.jpg'), ('size', 40288), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KFuSidHlHD6Uj0mw2Nmu1w/IS6zACMjIYRwAlmdVkBbgVixAhVE42KSsWlkd5tHQY7sxj04xoX6W-Htxg3Pef3_lofcPag6Kyqnt-D1WzeGdg/mjMeyy2-pjf---H0R5sQ-5IPGFsn-pfBgAfp5Que5PI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fsB7jS84FNUiNKfiiMXgkQ/t-FQ9pPVq7bjKgEvIvYTTwDWbuTBJQWPYQv2cpKp44XiVy60wfy5W_htsMiEjLwEvUIvppyhKmZVth2ThXfA0w/XkP4ginm4st8wne0w3NmS_2r0Qbc8v07IGG6arCAXu8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/t8wTa7bUZUzl3hEJFFTYlg/V_mirQLyfRKYPceXR58QDC1mO62Ez1--8UepPVmVQMUMtPrj-A2GyIAtjchBcwbhjy0pJUuKDaz8v06j-c8VCA/1yhw9I-KvK_DkBDqxPnmck52wfi5DUW6Ve7tbfXUsW8'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The LPS710E(/M) Amplified Piezo Stage provides long range, fine focus Z-axis travel for a microscope slide while maintaining a compact, low-profile footprint. It features submicron repeatability, nanometer positioning resolution, low angular error, and fast millisecond response and settling times. When used with the LPSA1(/M) microscope slide holder, the stage is ideal for imaging modalities requiring sensitive sample positioning and sectioning, such as confocal laser scanning microscopy. This stage is not compatible with trans-illumination.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=11303,Aptpiezostage,602.0,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782731/Instruments/Positional%20Controller/LPS710E-M/LPS710E-M.jpg,LPS710E/M,Write a Python script that uses Instrumentkit to connect to a LPS710E/M Positional Controller,5309.35,,,,"#!/usr/bin/env python
""""""
Provides the support for the Thorlabs APT Controller.
""""""

# IMPORTS #####################################################################


import re
import struct
import logging
import codecs
import warnings

from instruments.thorlabs import _abstract, _packets, _cmds
from instruments.units import ureg as u
from instruments.util_fns import assume_units

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################

# pylint: disable=too-many-lines


class ThorLabsAPT(_abstract.ThorLabsInstrument):

    """"""
    Generic ThorLabs APT hardware device controller. Communicates using the
    ThorLabs APT communications protocol, whose documentation is found in the
    thorlabs source folder.
    """"""

    class APTChannel:

        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.
        """"""

        def __init__(self, apt, idx_chan):
            self._apt = apt
            # APT is 1-based, but we want the Python representation to be
            # 0-based.
            self._idx_chan = idx_chan + 1

        @property
        def enabled(self):
            """"""
            Gets/sets the enabled status for the specified APT channel

            :type: `bool`

            :raises TypeError: If controller is not supported
            """"""
            if self._apt.model_number[0:3] == ""KIM"":
                raise TypeError(
                    ""For KIM controllers, use the ""
                    ""`enabled_single` function to enable ""
                    ""one axis. For KIM101 controllers, ""
                    ""multiple axes can be enabled using ""
                    ""the `enabled_multi` function from the ""
                    ""controller level.""
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_REQ_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOD_GET_CHANENABLESTATE
            )
            return not bool(resp.parameters[1] - 1)

        @enabled.setter
        def enabled(self, newval):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOD_SET_CHANENABLESTATE,
                param1=self._idx_chan,
                param2=0x01 if newval else 0x02,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

    _channel_type = APTChannel

    def __init__(self, filelike):
        super().__init__(filelike)
        self._dest = 0x50  # Generic USB device; make this configurable later.

        # Provide defaults in case an exception occurs below.
        self._serial_number = None
        self._model_number = None
        self._hw_type = None
        self._fw_version = None
        self._notes = """"
        self._hw_version = None
        self._mod_state = None
        self._n_channels = 0
        self._channel = ()

        # Perform a HW_REQ_INFO to figure out the model number, serial number,
        # etc.
        try:
            req_packet = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.HW_REQ_INFO,
                param1=0x00,
                param2=0x00,
                dest=self._dest,
                source=0x01,
                data=None,
            )
            hw_info = self.querypacket(
                req_packet,
                expect=_cmds.ThorLabsCommands.HW_GET_INFO,
                expect_data_len=84,
            )

            self._serial_number = codecs.encode(hw_info.data[0:4], ""hex"").decode(
                ""ascii""
            )
            self._model_number = (
                hw_info.data[4:12].decode(""ascii"").replace(""\x00"", """").strip()
            )

            hw_type_int = struct.unpack(""<H"", hw_info.data[12:14])[0]
            if hw_type_int == 45:
                self._hw_type = ""Multi-channel controller motherboard""
            elif hw_type_int == 44:
                self._hw_type = ""Brushless DC controller""
            else:
                self._hw_type = f""Unknown type: {hw_type_int}""

            # Note that the fourth byte is padding, so we strip out the first
            # three bytes and format them.
            # pylint: disable=invalid-format-index
            self._fw_version = ""{0[0]:x}.{0[1]:x}.{0[2]:x}"".format(hw_info.data[14:18])
            self._notes = (
                hw_info.data[18:66].replace(b""\x00"", b"""").decode(""ascii"").strip()
            )

            self._hw_version = struct.unpack(""<H"", hw_info.data[78:80])[0]
            self._mod_state = struct.unpack(""<H"", hw_info.data[80:82])[0]
            self._n_channels = struct.unpack(""<H"", hw_info.data[82:84])[0]
        except OSError as e:
            logger.error(""Exception occured while fetching hardware info: %s"", e)

        # Create a tuple of channels of length _n_channel_type
        if self._n_channels > 0:
            self._channel = tuple(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels)
            )

    @property
    def serial_number(self):
        """"""
        Gets the serial number for the APT controller

        :type: `str`
        """"""
        return self._serial_number

    @property
    def model_number(self):
        """"""
        Gets the model number for the APT controller

        :type: `str`
        """"""
        return self._model_number

    @property
    def name(self):
        """"""
        Gets the name of the APT controller. This is a human readable string
        containing the model, serial number, hardware version, and firmware
        version.

        :type: `str`
        """"""
        return (
            ""ThorLabs APT Instrument model {model}, serial {serial} ""
            ""(HW version {hw_ver}, FW version {fw_ver})"".format(
                hw_ver=self._hw_version,
                serial=self.serial_number,
                fw_ver=self._fw_version,
                model=self.model_number,
            )
        )

    @property
    def channel(self):
        """"""
        Gets the list of channel objects attached to the APT controller.

        A specific channel object can then be accessed like one would access
        a list.

        :type: `tuple` of `APTChannel`
        """"""
        return self._channel

    @property
    def n_channels(self):
        """"""
        Gets/sets the number of channels attached to the APT controller

        :type: `int`
        """"""
        return self._n_channels

    @n_channels.setter
    def n_channels(self, nch):
        # Change the number of channels so as not to modify those instances
        # already existing:
        # If we add more channels, append them to the list,
        # If we remove channels, remove them from the end of the list.
        if nch > self._n_channels:
            self._channel = list(self._channel) + list(
                self._channel_type(self, chan_idx)
                for chan_idx in range(self._n_channels, nch)
            )
        elif nch < self._n_channels:
            self._channel = self._channel[:nch]
        self._n_channels = nch

    def identify(self):
        """"""
        Causes a light on the APT instrument to blink, so that it can be
        identified.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.MOD_IDENTIFY,
            param1=0x00,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        self.sendpacket(pkt)

    @property
    def destination(self):
        """"""
        Gets the destination for the APT controller

        :type: `int`
        """"""
        return self._dest


class APTPiezoDevice(ThorLabsAPT):

    """"""
    Generic ThorLabs APT piezo device, superclass of more specific piezo
    devices.
    """"""

    class PiezoDeviceChannel(ThorLabsAPT.APTChannel):
        """"""
        Represents a channel within the hardware device. One device can have
        many channels, each labeled by an index.

        This class represents piezo stage channels.
        """"""

        # PIEZO COMMANDS #

        @property
        def max_travel(self):
            """"""
            Gets the maximum travel for the specified piezo channel.

            :type: `~pint.Quantity`
            :units: Nanometers
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_MAXTRAVEL,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(pkt, expect_data_len=4)

            # Not all APT piezo devices support querying the maximum travel
            # distance. Those that do not simply ignore the PZ_REQ_MAXTRAVEL
            # packet, so that the response is empty.
            if resp is None:
                return NotImplemented

            # chan, int_maxtrav
            _, int_maxtrav = struct.unpack(""<HH"", resp.data)
            return int_maxtrav * u.Quantity(100, ""nm"")

    @property
    def led_intensity(self):
        """"""
        Gets/sets the output intensity of the LED display.

        :type: `float` between 0 and 1.
        """"""
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_REQ_TPZ_DISPSETTINGS,
            param1=0x01,
            param2=0x00,
            dest=self._dest,
            source=0x01,
            data=None,
        )
        resp = self.querypacket(pkt, expect_data_len=2)

        # Not all APT piezo devices support querying the LED intenstiy
        # distance, e.g., TIM, KIM. Those that do not simply ignore the
        # PZ_REQ_TPZ_DISPSETTINGS packet, so that the response is empty.
        # Setting will be ignored as well.
        if resp is None:
            return NotImplemented
        else:
            return float(struct.unpack(""<H"", resp.data)[0]) / 255

    @led_intensity.setter
    def led_intensity(self, intensity):
        # pylint: disable=round-builtin
        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZ_SET_TPZ_DISPSETTINGS,
            param1=None,
            param2=None,
            dest=self._dest,
            source=0x01,
            data=struct.pack(""<H"", int(round(255 * intensity))),
        )
        self.sendpacket(pkt)

    _channel_type = PiezoDeviceChannel


class APTPiezoInertiaActuator(APTPiezoDevice):

    """"""Represent a Thorlabs APT piezo inertia actuator.

    Currently only the KIM piezo inertia actuator is implemented.
    Some routines will work with the TIM actuator as well. Routines
    that are specific for the KIM101 controller will raise a TypeError
    if not implemented for this controller. Unfortunately, handling all
    these controller specific functions is fairly messy, but necessary.

    Example for a KIM101 controller:
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> # call the controller
        >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # set first channel to enabled
        >>> ch = kim.channel[0]
        >>> ch.enabled_single = True
        >>> # define and set drive parameters
        >>> max_volts = u.Quantity(110, u.V)
        >>> step_rate = u.Quantity(1000, 1/u.s)
        >>> acceleration = u.Quantity(10000, 1/u.s**2)
        >>> ch.drive_op_parameters = [max_volts, step_rate, acceleration]
        >>> # aboslute move to 1000 steps
        >>> ch.move_abs(1000)
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PROPERTIES #

        @property
        def drive_op_parameters(self):
            """"""Get / Set various drive parameters for move motion.

            Defines the speed and acceleration of moves initiated in
            the following ways:
            - by clicking in the position display
            - via the top panel controls when ‘Go To Position’ mode is
            selected (in the Set_TIM_JogParameters (09) or
            Set_KCubeMMIParams (15) sub‐messages).
            - via software using the MoveVelocity, MoveAbsoluteStepsEx
            or MoveRelativeStepsEx methods.

            :setter: The setter must be be given as a list of 3
                entries. The three entries are:
                -  Maximum Voltage:
                The maximum piezo drive voltage, in the range 85V
                to 125V. Unitful, if no unit given, V are assumed.
                - Step Rate:
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the drive parameters, unitful.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # change the step rate to 2000 /s
                >>> drive_params = ch.drive_op_parameters
                >>> drive_params[1] = 2000
                >>> ch.drive_op_parameters = drive_params
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x07,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=14
            )

            # unpack
            ret_val = struct.unpack(""<HHHll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4]]

            # set units and formats
            ret_val = [
                u.Quantity(int(ret_val[0]), u.V),
                u.Quantity(int(ret_val[1]), 1 / u.s),
                u.Quantity(int(ret_val[2]), 1 / u.s**2),
            ]
            return ret_val

        @drive_op_parameters.setter
        def drive_op_parameters(self, params):
            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 3:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 3."")

            # ensure units
            volt = int(assume_units(params[0], u.V).to(u.V).magnitude)
            rate = int(assume_units(params[1], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[2], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if volt < 85 or volt > 125:
                raise ValueError(
                    ""The voltage ({} V) is out of range. It must ""
                    ""be between 85 V and 125 V."".format(volt)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )

            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHHll"", 0x07, self._idx_chan, volt, rate, accl),
            )
            self._apt.sendpacket(pkt)

        @property
        def enabled_single(self):
            """"""Get / Set single axis enabled.

            .. note:: Enabling multi channels for KIM101 is defined in
            the controller class.

            :return: Axis status enabled.
            :rtype: bool

            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # enable channel 0
                >>> ch.enabled_single = True
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise (
                    ""This command is only valid with KIM001 and ""
                    ""KIM101 controllers. Your controller is a {}."".format(
                        self._apt.model_number
                    )
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2B,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
            )

            ret_val = struct.unpack(""<HH"", resp.data)[1] == self._idx_chan

            return ret_val

        @enabled_single.setter
        def enabled_single(self, newval):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            param = self._idx_chan if newval else 0x00
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", 0x2B, param),
            )
            self._apt.sendpacket(pkt)

        @property
        def jog_parameters(self):
            """"""Get / Set the jog parameters.

            Define the speed and acceleration of moves initiated in the
            following ways:
            - By clicking the jog buttons on the GUI panel
            - By moving the joystick on the unit when ‘Jog Mode’ is
            selected.
            - via software using the MoveJog method.

            It differs from the normal motor jog message in that there
            are two jog step sizes, one for forward and one for reverse.
            The reason for this is that due to the inherent nature of
            the PIA actuators going further in one direction as
            compared with another this will allow the user to
            potentially make adjustments to get fore and aft movement
            the same or similar.

            :setter: The setter must be be given as a list of 5
                entries. The three entries are:
                - Jog Mode (1 for continuus, i.e., until stop command
                is issued, or 2 jog by the number of steps defined)
                - Jog Step Size Forward: Range 1 - 2000
                - Jog Step Size Backward: Range 1 - 2000
                The piezo motor moves by ramping up the drive
                voltage to the value set in the MaxVoltage parameter
                and then dropping quickly to zero, then repeating.
                One cycle is termed a step. This parameter specifies
                the velocity to move when a command is initiated.
                The step rate is specified in steps/sec, in the range 1
                to 2,000. Unitful, if no unit given, 1 / sec assumed.
                - Jog Step Acceleration:
                This parameter specifies the acceleration up to the
                step rate, in the range 1 to 100,000 cycles/sec/sec.
                Unitful, if no unit given, 1/sec**2 assumed.

            :return: List with the jog parameters.

            :raises TypeError: The setter was not a list or tuple.
            :raises ValueError: The setter was not given a tuple with
                three values.
            :raises ValueError: One of the parameters was out of range.
            :raises TypeError: Invalid controller for this command.

            Example for a KIM101 controller:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> mode = 2  # only move by set step size
                >>> step = 100  # step size
                >>> rate = u.Quantity(1000, 1/u.s)  # step rate
                >>> # if no quantity given, SI units assumed
                >>> accl = 10000
                >>> ch.jog_parameters = [mode, step, step, rate, accl]
                >>> ch.jog_parameters
                [2, 100, 100, array(1000) * 1/s, array(10000) * 1/s**2]
            """"""
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x2D,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=22
            )

            # unpack response
            ret_val = struct.unpack(""<HHHllll"", resp.data)
            ret_val = [ret_val[2], ret_val[3], ret_val[4], ret_val[5], ret_val[6]]

            # assign the appropriate units, forms
            ret_val = [
                int(ret_val[0]),
                int(ret_val[1]),
                int(ret_val[2]),
                u.Quantity(int(ret_val[3]), 1 / u.s),
                u.Quantity(int(ret_val[4]), 1 / u.s**2),
            ]

            return ret_val

        @jog_parameters.setter
        def jog_parameters(self, params):
            if self._apt.model_number[0:3] != ""KIM"":
                raise TypeError(
                    ""This command is only valid with ""
                    ""KIM001 and KIM101 controllers. Your ""
                    ""controller is a {}."".format(self._apt.model_number)
                )

            if not isinstance(params, tuple) and not isinstance(params, list):
                raise TypeError(""Parameters must be given as list or tuple."")
            if len(params) != 5:
                raise ValueError(""Parameters must be a list or tuple with "" ""length 5."")

            # ensure units
            mode = int(params[0])
            steps_fwd = int(params[1])
            steps_bkw = int(params[2])
            rate = int(assume_units(params[3], 1 / u.s).to(1 / u.s).magnitude)
            accl = int(assume_units(params[4], 1 / u.s**2).to(1 / u.s**2).magnitude)

            # check parameters
            if mode != 1 and mode != 2:
                raise ValueError(
                    ""The mode ({}) must be either set to 1 ""
                    ""(continuus) or 2 (steps)."".format(mode)
                )
            if steps_fwd < 1 or steps_fwd > 2000:
                raise ValueError(
                    ""The steps forward ({}) are out of range. It ""
                    ""must be between 1 and 2,000."".format(steps_fwd)
                )
            if steps_bkw < 1 or steps_bkw > 2000:
                raise ValueError(
                    ""The steps backward ({}) are out of range. ""
                    ""It must be between 1 and 2,000."".format(steps_bkw)
                )
            if rate < 1 or rate > 2000:
                raise ValueError(
                    ""The step rate ({} /s) is out of range. It ""
                    ""must be between 1 /s and 2,000 /s."".format(rate)
                )
            if accl < 1 or accl > 100000:
                raise ValueError(
                    ""The acceleration ({} /s/s) is out of range. ""
                    ""It must be between 1 /s/s and 100,000 /s/s."".format(accl)
                )

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHllll"",
                    0x2D,
                    self._idx_chan,
                    mode,
                    steps_fwd,
                    steps_bkw,
                    rate,
                    accl,
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def position_count(self):
            """"""Get/Set the position count of a given channel.

            :setter pos: Position (steps) of axis.
            :type pos: int

            :return: Position (steps) of axis.
            :rtype: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set position count to zero
                >>> ch.position_count = 0
                >>> ch.position_count
                0
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
                param1=0x05,
                param2=self._idx_chan,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=12
            )

            ret_val = int(struct.unpack(""<HHll"", resp.data)[2])

            return ret_val

        @position_count.setter
        def position_count(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HHll"", 0x05, self._idx_chan, pos, 0x00),
            )
            self._apt.sendpacket(pkt)

        # METHODS #

        def move_abs(self, pos):
            """"""
            Moves the axis to a position specified as the number of
            steps away from the zero position.

            To set the moving parameters, use the setter for
            `drive_op_parameters`.

            :param pos: Position to move to, in steps.
            :type pos: int

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # move to 314 steps
                >>> ch.move_abs(314)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_ABSOLUTE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

        def move_jog(self, direction=""fwd""):
            """"""
            Jogs the axis in forward or backward direction by the number
            of steps that are stored in the controller.

            To set the moving parameters, use the setter for
            `jog_parameters`.

            :param str direction: Direction of jog. 'fwd' for forward,
                'rev' for backward. 'fwd' if invalid argument given

            Example:
                >>> import instruments as ik
                >>> # call the controller
                >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # grab channel 0
                >>> ch = kim.channel[0]
                >>> # set jog parameters
                >>> params = ch.jog_parameters
                >>> params[0] = 2  # move by number of steps
                >>> params[1] = 100  # step size forward
                >>> params[2] = 200  # step size reverse
                >>> ch.jog_parameters = params  # set parameters
                >>> # jog forward (default)
                >>> ch.move_jog()
                >>> # jog reverse
                >>> ch.move_jog('rev')
            """"""
            if direction == ""rev"":
                param2 = 0x02
            else:
                param2 = 0x01

            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=param2,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        def move_jog_stop(self):
            """"""Stops the current motor movement.

            Stop a jog command. The regular motor move stop command does
            not work for jogging. This command somehow does...

            .. note:: This information is quite empirical. It would
                only be really needed if jogging parameters are set to
                continuous. The safer method is to set the step range.
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZMOT_MOVE_JOG,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )

            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel

    # PROPERTIES #

    @property
    def enabled_multi(self):
        """"""Enable / Query mulitple channel mode.

        For KIM101 controller, where multiple axes can be selected
        simultaneously (i. e., for a mirror mount).

        :setter mode: Channel pair to be activated.
            0:  All channels deactivated
            1:  First channel pair activated (channel 0 & 1)
            2:  Second channel pair activated (channel 2 & 3)
        :type mode: int

        :return: The selected mode:
            0 - multi-channel selection disabled
            1 - Channel 0 & 1 enabled
            2 - Channel 2 & 3 enabled
        :rtype: int

        :raises ValueError: No valid channel pair selected
        :raises TypeError: Invalid controller for this command.

        Example:
            >>> import instruments as ik
            >>> kim = ik.thorlabs.APTPiezoInertiaActuator.open_serial(""/dev/ttyUSB0"", baud=115200)
            >>> # activate the first two channels
            >>> kim.enabled_multi = 1
            >>> # read back
            >>> kim.enabled_multi
            1
        """"""
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_REQ_PARAMS,
            param1=0x2B,
            param2=0x00,
            dest=self.destination,
            source=0x01,
            data=None,
        )

        resp = self.querypacket(
            pkt, expect=_cmds.ThorLabsCommands.PZMOT_GET_PARAMS, expect_data_len=4
        )

        ret_val = int(struct.unpack(""<HH"", resp.data)[1])

        if ret_val == 5:
            return 1
        elif ret_val == 6:
            return 2
        else:
            return 0

    @enabled_multi.setter
    def enabled_multi(self, mode):
        if self.model_number != ""KIM101"":
            raise TypeError(
                ""This command is only valid with ""
                ""a KIM101 controller. Your ""
                ""controller is a {}."".format(self.model_number)
            )

        if mode == 0:
            param = 0x00
        elif mode == 1:
            param = 0x05
        elif mode == 2:
            param = 0x06
        else:
            raise ValueError(
                ""Please select a valid mode: 0 - all ""
                ""disabled, 1 - Channel 1 & 2 enabled, ""
                ""2 - Channel 3 & 4 enabled.""
            )

        pkt = _packets.ThorLabsPacket(
            message_id=_cmds.ThorLabsCommands.PZMOT_SET_PARAMS,
            param1=None,
            param2=None,
            dest=self.destination,
            source=0x01,
            data=struct.pack(""<HH"", 0x2B, param),
        )

        self.sendpacket(pkt)


class APTPiezoStage(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT piezo stage
    """"""

    class PiezoChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single piezo channel within a piezo stage
        on the Thorlabs APT controller.
        """"""

        # PIEZO COMMANDS #

        @property
        def position_control_closed(self):
            """"""
            Gets the status if the position control is closed or not.

            `True` means that the position control is closed, `False` otherwise

            :type: `bool`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_POSCONTROLMODE
            )
            return bool((resp.parameters[1] - 1) & 1)

        def change_position_control_mode(self, closed, smooth=True):
            """"""
            Changes the position control mode of the piezo channel

            :param bool closed: `True` for closed, `False` for open
            :param bool smooth: `True` for smooth, `False` for otherwise.
                Default is `True`.
            """"""
            mode = 1 + (int(closed) | int(smooth) << 1)
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_POSCONTROLMODE,
                param1=self._idx_chan,
                param2=mode,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            self._apt.sendpacket(pkt)

        @property
        def output_position(self):
            """"""
            Gets/sets the output position for the piezo channel.

            :type: `str`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_REQ_OUTPUTPOS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            resp = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.PZ_GET_OUTPUTPOS, expect_data_len=4
            )
            # chan, pos
            _, pos = struct.unpack(""<HH"", resp.data)
            return pos

        @output_position.setter
        def output_position(self, pos):
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.PZ_SET_OUTPUTPOS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<HH"", self._idx_chan, pos),
            )
            self._apt.sendpacket(pkt)

    _channel_type = PiezoChannel


class APTStrainGaugeReader(APTPiezoDevice):

    """"""
    Class representing a Thorlabs APT strain gauge reader.

    .. warning:: This is not currently implemented
    """"""

    class StrainGaugeChannel(APTPiezoDevice.PiezoDeviceChannel):
        """"""
        Class representing a single strain gauge channel attached to a
        `APTStrainGaugeReader` on the Thorlabs APT controller.

        .. warning:: This is not currently implemented
        """"""

    _channel_type = StrainGaugeChannel


class APTMotorController(ThorLabsAPT):

    """"""
    Class representing a Thorlabs APT motor controller.

    .. note:: A motor model must be selected in order to use unitful
        distances.

    Example:
        >>> import instruments as ik
        >>> import instruments.units as u

        >>> # load the controller, a KDC101 cube
        >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
        >>> # assign a channel to `ch`
        >>> ch = kdc.channel[0]
        >>> # select the stage that is connected to the controller
        >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

        >>> # home the stage
        >>> ch.go_home()
        >>> # move to 52 degrees absolute position
        >>> ch.move(u.Quantity(52, u.deg))
        >>> # move 10 degrees back from current position
        >>> ch.move(u.Quantity(-10, u.deg), absolute=False)
    """"""

    class MotorChannel(ThorLabsAPT.APTChannel):

        """"""
        Class representing a single motor attached to a Thorlabs APT motor
        controller (`APTMotorController`).
        """"""

        # INSTANCE VARIABLES #

        _motor_model = None

        #: Sets the scale between the encoder counts and physical units
        #: for the position, velocity and acceleration parameters of this
        #: channel. By default, set to dimensionless, indicating that the proper
        #: scale is not known.
        #:
        #: In keeping with the APT protocol documentation, the scale factor
        #: is multiplied by the physical quantity to get the encoder count,
        #: such that scale factors should have units similar to microsteps/mm,
        #: in the example of a linear motor.
        #:
        #: Encoder counts are represented by the quantities package unit
        #: ""ct"", which is considered dimensionally equivalent to dimensionless.
        #: Finally, note that the ""/s"" and ""/s**2"" are not included in scale
        #: factors, so as to produce quantities of dimension ""ct/s"" and
        #: ""ct/s**2""
        #: from dimensionful input.
        #:
        #: For more details, see the APT protocol documentation.
        scale_factors = (u.Quantity(1, ""dimensionless""),) * 3

        _motion_timeout = u.Quantity(10, ""second"")

        __SCALE_FACTORS_BY_MODEL = {
            # TODO: add other tables here.
            re.compile(""TST001|BSC00.|BSC10.|MST601""): {
                # Note that for these drivers, the scale factors are identical
                # for position, velcoity and acceleration. This is not true for
                # all drivers!
                ""DRV001"": (u.Quantity(51200, ""count/mm""),) * 3,
                ""DRV013"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV014"": (u.Quantity(25600, ""count/mm""),) * 3,
                ""DRV113"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""DRV114"": (u.Quantity(20480, ""count/mm""),) * 3,
                ""FW103"": (u.Quantity(25600 / 360, ""count/deg""),) * 3,
                ""NR360"": (u.Quantity(25600 / 5.4546, ""count/deg""),) * 3,
            },
            re.compile(""TDC001|KDC101""): {
                ""MTS25-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                ""MTS50-Z8"": (
                    1 / u.Quantity(34304, ""mm/count""),
                    NotImplemented,
                    NotImplemented,
                ),
                # TODO: Z8xx and Z6xx models. Need to add regex support to motor models, too.
                ""PRM1-Z8"": (
                    u.Quantity(1919.64, ""count/deg""),
                    u.Quantity(42941.66, u.sec / u.deg),
                    u.Quantity(14.66, u.sec**2 / u.deg),
                ),
            },
        }

        __STATUS_BIT_MASK = {
            ""CW_HARD_LIM"": 0x00000001,
            ""CCW_HARD_LIM"": 0x00000002,
            ""CW_SOFT_LIM"": 0x00000004,
            ""CCW_SOFT_LIM"": 0x00000008,
            ""CW_MOVE_IN_MOTION"": 0x00000010,
            ""CCW_MOVE_IN_MOTION"": 0x00000020,
            ""CW_JOG_IN_MOTION"": 0x00000040,
            ""CCW_JOG_IN_MOTION"": 0x00000080,
            ""MOTOR_CONNECTED"": 0x00000100,
            ""HOMING_IN_MOTION"": 0x00000200,
            ""HOMING_COMPLETE"": 0x00000400,
            ""INTERLOCK_STATE"": 0x00001000,
        }

        # IK-SPECIFIC PROPERTIES #
        # These properties don't correspond to any particular functionality
        # of the underlying device, but control how we interact with it.

        @property
        def motion_timeout(self):
            """"""
            Gets/sets the motor channel motion timeout.

            :units: Seconds
            :type: `~pint.Quantity`
            """"""
            return self._motion_timeout

        @motion_timeout.setter
        def motion_timeout(self, newval):
            self._motion_timeout = assume_units(newval, u.second)

        # UNIT CONVERSION METHODS #

        def _set_scale(self, motor_model):
            """"""
            Sets the scale factors for this motor channel, based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel.

            :param str motor_model: Name of the model of the attached motor,
                as indicated in the APT protocol documentation (page 14, v9).
            """"""
            for driver_re, motor_dict in self.__SCALE_FACTORS_BY_MODEL.items():
                if driver_re.match(self._apt.model_number) is not None:
                    if motor_model in motor_dict:
                        self.scale_factors = motor_dict[motor_model]
                        return
                    else:
                        break
            # If we've made it down here, emit a warning that we didn't find the
            # model.
            logger.warning(
                ""Scale factors for controller %s and motor %s are "" ""unknown"",
                self._apt.model_number,
                motor_model,
            )

        # We copy the docstring below, so it's OK for this method
        # to not have a docstring of its own.
        # pylint: disable=missing-docstring
        def set_scale(self, motor_model):
            warnings.warn(
                ""The set_scale method has been deprecated in favor ""
                ""of the motor_model property."",
                DeprecationWarning,
            )
            return self._set_scale(motor_model)

        set_scale.__doc__ = _set_scale.__doc__

        @property
        def motor_model(self):
            """"""
            Gets or sets the model name of the attached motor.
            Note that the scale factors for this motor channel are based on the model
            of the attached motor and the specifications of the driver of which
            this is a channel, such that setting a new motor model will update
            the scale factors accordingly.

            :type: `str` or `None`
            """"""
            return self._motor_model

        @motor_model.setter
        def motor_model(self, newval):
            self._set_scale(newval)
            self._motor_model = newval

        # MOTOR COMMANDS #

        @property
        def backlash_correction(self):
            """"""Get / set backlash correctionf or given stage.

            If no units are given, ``u.counts`` are assumed. If you have
            the stage defined (see example below), unitful values can be
            used for setting the backlash correction, e.g., ``u.mm`` or
            ``u.deg``.

            :return: Unitful quantity of backlash correction.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> ch.backlash_correction = 4 * u.deg  # set it to 4 degrees
                >>> ch.backlash_correction  # read it back
                <Quantity(4, 'degree')>
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_GENMOVEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_GENMOVEPARAMS,
                expect_data_len=6,
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @backlash_correction.setter
        def backlash_correction(self, pos):
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )
            # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_GENMOVEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )
            self._apt.sendpacket(pkt)

        @property
        def home_parameters(self):
            """"""Get the home parameters for the motor channel.

            Parameters are stage specific and not all parameters can be set
            for every stage. For example, the MLS203 stage only allows the
            homing velocity to be changed.

            .. note:: When setting the quantity, pass `None` to values
                that you want to leave unchanged (see example below).

            .. note:: After changing the offset, the stage must be homed
                in order to show the new offset in its values.

            :return: Home Direction (1: forward/positive, 2 reverse/negative),
                Limit Switch (1: hardware reverse, 4: hardware forward),
                Home Velocity,
                Offset distance
            :rtype: Tuple[int, int, u.Quantity, u.Quantity]


            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> ch.motor_model = 'PRM1-Z8'  # select rotation stage

                >>> # set offset distance to 4 degrees, leave other values
                >>> ch.home_parameters = None, None, None, 4 * u.deg
                >>> ch.home_parameters  # read it back
                (2, 1, <Quantity(9.99, 'degree / second')>, <Quantity(3.99, 'degree')>)
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_HOMEPARAMS,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_HOMEPARAMS,
                expect_data_len=14,
            )
            # chan, home_dir, limit_switch, velocity, ,offset_dist
            _, home_dir, lim_sw, vel, offset = struct.unpack(""<HHHll"", response.data)
            return (
                int(home_dir),
                int(lim_sw),
                u.Quantity(vel) / self.scale_factors[1],
                u.Quantity(offset, ""counts"") / self.scale_factors[0],
            )

        @home_parameters.setter
        def home_parameters(self, values):
            if len(values) != 4:
                raise ValueError(
                    ""Home parameters muust be set with four values: ""
                    ""Home direction, limit switch settings, velocity, and offset. ""
                    ""For settings you want to leave untouched, pass `None`.""
                )

            # replace values that are `None`
            if None in values:
                set_params = self.home_parameters
                values = [x if x is not None else y for x, y in zip(values, set_params)]

            home_dir, lim_sw, velocity, offset = values
            if isinstance(velocity, u.Quantity):
                velocity = (velocity * self.scale_factors[1]).to_reduced_units()
                if velocity.dimensionless:
                    velocity = int(velocity.magnitude)
                else:
                    raise ValueError(
                        ""Provided units for velocity are not compatible ""
                        ""with current motor scale factor.""
                    )
            if isinstance(offset, u.Quantity):
                if offset.units == u.counts:
                    offset = int(offset.magnitude)
                else:
                    scaled_vel = offset * self.scale_factors[0]
                    try:
                        offset = int(scaled_vel.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units for offset are not compatible ""
                            ""with current motor scale factor.""
                        )

                # create package to send
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_SET_HOMEPARAMS,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(
                    ""<HHHll"",
                    self._idx_chan,
                    int(home_dir),
                    int(lim_sw),
                    int(velocity),
                    int(offset),
                ),
            )
            self._apt.sendpacket(pkt)

        @property
        def status_bits(self):
            """"""
            Gets the status bits for the specified motor channel.

            .. note:: This command, as currently implemented, is only
                available for certain devices and will result in an
                ``OSError`` otherwise. Devices that work according to the
                manual are: TSC001, KSC101, BSC10x, BSC20x, LTS150, LTS300,
                MLJ050, MLJ150, TIM101, KIM101.

            :type: `dict`
            """"""
            # NOTE: the difference between MOT_REQ_STATUSUPDATE and
            # MOT_REQ_DCSTATUSUPDATE confuses me
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_STATUSUPDATE,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            # The documentation claims there are 14 data bytes, but it seems
            # there are sometimes some extra random ones...
            # fixme: wrong expected datatype? MOT_GET_STATUSUPDATE expected
            resp_data = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER,
                expect_data_len=14,
            ).data[:14]
            # ch_ident, position, enc_count, status_bits
            _, _, _, status_bits = struct.unpack(""<HLLL"", resp_data)

            status_dict = {
                key: (status_bits & bit_mask > 0)
                for key, bit_mask in self.__STATUS_BIT_MASK.items()
            }

            return status_dict

        @property
        def position(self):
            """"""
            Gets the current position of the specified motor channel

            :type: `~pint.Quantity`
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_POSCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_POSCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"") / self.scale_factors[0]

        @property
        def position_encoder(self):
            """"""
            Gets the position of the encoder of the specified motor channel

            :type: `~pint.Quantity`
            :units: Encoder ``counts``
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_REQ_ENCCOUNTER,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            response = self._apt.querypacket(
                pkt, expect=_cmds.ThorLabsCommands.MOT_GET_ENCCOUNTER, expect_data_len=6
            )
            # chan, pos
            _, pos = struct.unpack(""<Hl"", response.data)
            return u.Quantity(pos, ""counts"")

        def go_home(self):
            """"""
            Instructs the specified motor channel to return to its home
            position
            """"""
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_HOME,
                param1=self._idx_chan,
                param2=0x00,
                dest=self._apt.destination,
                source=0x01,
                data=None,
            )
            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_HOMED,
                timeout=self.motion_timeout,
            )

        def move(self, pos, absolute=True):
            """"""
            Instructs the specified motor channel to move to a specific
            location. The provided position can be either an absolute or
            relative position.

            :param pos: The position to move to. Provided value will be
                converted to encoder counts.
            :type pos: `~pint.Quantity`
            :units pos: As specified, or assumed to of units encoder counts

            :param bool absolute: Specify if the position is a relative or
                absolute position. ``True`` means absolute, while ``False``
                is for a relative move.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u

                >>> # load the controller, a KDC101 cube
                >>> kdc = ik.thorlabs.APTMotorController.open_serial(""/dev/ttyUSB0"", baud=115200)
                >>> # assign a channel to `ch`
                >>> ch = kdc.channel[0]
                >>> # select the stage that is connected to the controller
                >>> ch.motor_model = 'PRM1-Z8'  # a rotation stage

                >>> # move to 32 degrees absolute position
                >>> ch.move(u.Quantity(32, u.deg))

                >>> # move 10 degrees forward from current position
                >>> ch.move(u.Quantity(10, u.deg), absolute=False)
            """"""
            # Handle units as follows:
            # 1. Treat raw numbers as encoder counts.
            # 2. If units are provided (as a Quantity), check if they're encoder
            #    counts. If they aren't, apply scale factor.
            if not isinstance(pos, u.Quantity):
                pos_ec = int(pos)
            else:
                if pos.units == u.counts:
                    pos_ec = int(pos.magnitude)
                else:
                    scaled_pos = pos * self.scale_factors[0]
                    # Force a unit error.
                    try:
                        pos_ec = int(scaled_pos.to(u.counts).magnitude)
                    except:
                        raise ValueError(
                            ""Provided units are not compatible ""
                            ""with current motor scale factor.""
                        )

            # Now that we have our position as an integer number of encoder
            # counts, we're good to move.
            pkt = _packets.ThorLabsPacket(
                message_id=_cmds.ThorLabsCommands.MOT_MOVE_ABSOLUTE
                if absolute
                else _cmds.ThorLabsCommands.MOT_MOVE_RELATIVE,
                param1=None,
                param2=None,
                dest=self._apt.destination,
                source=0x01,
                data=struct.pack(""<Hl"", self._idx_chan, pos_ec),
            )

            _ = self._apt.querypacket(
                pkt,
                expect=_cmds.ThorLabsCommands.MOT_MOVE_COMPLETED,
                timeout=self.motion_timeout,
                expect_data_len=14,
            )

    _channel_type = MotorChannel

    # CONTROLLER PROPERTIES AND METHODS #
"
357,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attNaj1PW0Au0Ue7A'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qlt1jtptdv2bgF24g3R74Q/glIYEGTwQs21RV_t_QBDR6xz9WvGrg0ldfBXN99gVXUxHmPoZG4vyEeYPPSfkAaHrhsUKc2Ae9H9dhdoeYF8GunTaYqzJjzJvXGLikdKd0I/ToJ8NNXgpZkV92Ly6yKvYdRuLRiV4eLoohGFXU0tCsw'), ('filename', 'SR830_FP_Wide1.jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/RA1pbiRpAbvK-gncslHElQ/bVQwxBC3J3UQB-aN3YiZp--IqTlWXSVWGjAAyEw36J-LkgHSCcprYr9GtB8n_tXulTh42uTOllinWIUXD0ngzg/m5u6ABCrmc393w5zpEUNvqXVY_iC9p7NzOkMBn0xROc'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZMdHov0U9VqXejpSiPIhBA/qgQaGJHFUexcwqj9szqqcimqk8ZuavWKjgfln2jNltkSKv60yqNV0ovfpApiIbb8elSYcjNs1AkKfKQYEw43GQ/5y366OakVxsfXqxYtCoK0yGheOO_rKzE1l1wd9sZZzU'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5EKFuLPlE3iqPkJqgzwMMw/T3JqeW5oMruqPAxTiL-LjDVFlBJgloMC1s78-Ar5fzx_HXhgWSTW9l-ldU-bgq-z2TRfLM-WSZAKH579BIv_PA/xRCqMrrcaLsee5Pzv5Ni3KmdRMvdW7WepTKnskal0sI'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,https://www.thinksrs.com/products/sr810830.htm,SRS 830,497.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs830.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs830-lock-in-amplifier,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782548/Instruments/Lockin%20Amplifiers/SR-830/SR-830.jpg,SRS 830,Write a Python script that uses Instrumentkit to connect to a SRS 830 Lockin Amplifiers,4250.0,,,,"#!/usr/bin/env python
""""""
Provides support for the SRS 830 lock-in amplifier.
""""""

# IMPORTS #####################################################################


import math
import time
import warnings
from enum import Enum, IntEnum

from instruments.abstract_instruments.comm import (
    GPIBCommunicator,
    SerialCommunicator,
    LoopbackCommunicator,
)
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import (
    bool_property,
    bounded_unitful_property,
    enum_property,
    unitful_property,
)

# CONSTANTS ###################################################################

VALID_SAMPLE_RATES = [2.0**n for n in range(-4, 10)]
VALID_SAMPLE_RATES += [""trigger""]

# CLASSES #####################################################################


class SRS830(SCPIInstrument):

    """"""
    Communicates with a Stanford Research Systems 830 Lock-In Amplifier.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS830.open_gpibusb('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1000 * u.hertz # Lock-In frequency
    >>> data = srs.take_measurement(1, 10) # 1Hz sample rate, 10 samples total
    """"""

    def __init__(self, filelike, outx_mode=None):
        """"""
        Class initialization method.

        :param int outx_mode: Manually over-ride which ``OUTX`` command to send
            at startup. This is a command that needs to be sent as specified
            by the SRS830 manual. If left default, the correct ``OUTX`` command
            will be sent depending on what type of communicator self._file is.
        """"""
        super().__init__(filelike)
        if outx_mode == 1:
            self.sendcmd(""OUTX 1"")
        elif outx_mode == 2:
            self.sendcmd(""OUTX 2"")
        else:
            if isinstance(self._file, GPIBCommunicator):
                self.sendcmd(""OUTX 1"")
            elif isinstance(self._file, SerialCommunicator):
                self.sendcmd(""OUTX 2"")
            elif isinstance(self._file, LoopbackCommunicator):
                pass
            else:
                warnings.warn(
                    ""OUTX command has not been set. Instrument ""
                    ""behaviour is unknown."",
                    UserWarning,
                )

    # ENUMS #

    class FreqSource(IntEnum):

        """"""
        Enum for the SRS830 frequency source settings.
        """"""

        external = 0
        internal = 1

    class Coupling(IntEnum):

        """"""
        Enum for the SRS830 channel coupling settings.
        """"""

        ac = 0
        dc = 1

    class BufferMode(IntEnum):
        """"""
        Enum for the SRS830 buffer modes.
        """"""

        one_shot = 0
        loop = 1

    class Mode(Enum):
        """"""
        Enum containing valid modes for the SRS 830
        """"""

        x = ""x""
        y = ""y""
        r = ""r""
        theta = ""theta""
        xnoise = ""xnoise""
        ynoise = ""ynoise""
        aux1 = ""aux1""
        aux2 = ""aux2""
        aux3 = ""aux3""
        aux4 = ""aux4""
        ref = ""ref""
        ch1 = ""ch1""
        ch2 = ""ch2""
        none = ""none""

    # CONSTANTS #

    _XYR_MODE_MAP = {Mode.x: 1, Mode.y: 2, Mode.r: 3}

    # PROPERTIES #

    frequency_source = enum_property(
        ""FMOD"",
        FreqSource,
        input_decoration=int,
        doc=""""""
        Gets/sets the frequency source used. This is either an external source,
            or uses the internal reference.

        :type: `SRS830.FreqSource`
        """""",
    )

    frequency = unitful_property(
        ""FREQ"",
        u.hertz,
        valid_range=(0, None),
        doc=""""""
        Gets/sets the lock-in amplifier reference frequency.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units Hertz.
        :type: `~pint.Quantity` with units Hertz.
        """""",
    )

    phase, phase_min, phase_max = bounded_unitful_property(
        ""PHAS"",
        u.degrees,
        valid_range=(-360 * u.degrees, 730 * u.degrees),
        doc=""""""
        Gets/set the phase of the internal reference signal.

        Set value should be -360deg <= newval < +730deg.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units degrees.
        :type: `~pint.Quantity` with units degrees.
        """""",
    )

    amplitude, amplitude_min, amplitude_max = bounded_unitful_property(
        ""SLVL"",
        u.volt,
        valid_range=(0.004 * u.volt, 5 * u.volt),
        doc=""""""
        Gets/set the amplitude of the internal reference signal.

        Set value should be 0.004 <= newval <= 5.000

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units volts. Value should be specified as peak-to-peak.
        :type: `~pint.Quantity` with units volts peak-to-peak.
        """""",
    )

    input_shield_ground = bool_property(
        ""IGND"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""
        Function sets the input shield grounding to either 'float' or 'ground'.

        :type: `bool`
        """""",
    )

    coupling = enum_property(
        ""ICPL"",
        Coupling,
        input_decoration=int,
        doc=""""""
        Gets/sets the input coupling to either 'ac' or 'dc'.

        :type: `SRS830.Coupling`
        """""",
    )

    @property
    def sample_rate(self):
        r""""""
        Gets/sets the data sampling rate of the lock-in.

        Acceptable set values are :math:`2^n` where :math:`n \in \{-4...+9\}` or
        the string `trigger`.

        :type: `~pint.Quantity` with units Hertz.
        """"""
        value = int(self.query(""SRAT?""))
        if value == 14:
            return ""trigger""
        return u.Quantity(VALID_SAMPLE_RATES[value], u.Hz)

    @sample_rate.setter
    def sample_rate(self, newval):
        if isinstance(newval, str):
            newval = newval.lower()

        if newval in VALID_SAMPLE_RATES:
            self.sendcmd(f""SRAT {VALID_SAMPLE_RATES.index(newval)}"")
        else:
            raise ValueError(
                ""Valid samples rates given by {} ""
                'and ""trigger"".'.format(VALID_SAMPLE_RATES)
            )

    buffer_mode = enum_property(
        ""SEND"",
        BufferMode,
        input_decoration=int,
        doc=""""""
        Gets/sets the end of buffer mode.

        This sets the behaviour of the instrument when the data storage buffer
        is full. Setting to `one_shot` will stop acquisition, while `loop`
        will repeat from the start.

        :type: `SRS830.BufferMode`
        """""",
    )

    @property
    def num_data_points(self):
        """"""
        Gets the number of data sets in the SRS830 buffer.

        :type: `int`
        """"""
        resp = None
        i = 0
        while not resp and i < 10:
            resp = self.query(""SPTS?"").strip()
            i += 1
        if not resp:
            raise OSError(
                f""Expected integer response from instrument, got {repr(resp)}""
            )
        return int(resp)

    data_transfer = bool_property(
        ""FAST"",
        inst_true=""2"",
        inst_false=""0"",
        doc=""""""
        Gets/sets the data transfer status.

        Note that this function only makes use of 2 of the 3 data transfer modes
        supported by the SRS830. The supported modes are FAST0 and FAST2. The
        other, FAST1, is for legacy systems which this package does not support.

        :type: `bool`
        """""",
    )

    # AUTO- METHODS #

    def auto_offset(self, mode):
        """"""
        Sets a specific channel mode to auto offset. This is the same as
        pressing the auto offset key on the display.

        It sets the offset of the mode specified to zero.

        :param mode: Target mode of auto_offset function. Valid inputs are
            {X|Y|R}.
        :type mode: `~SRS830.Mode` or `str`
        """"""
        if isinstance(mode, str):
            mode = mode.lower()
            mode = SRS830.Mode[mode]

        if mode not in self._XYR_MODE_MAP:
            raise ValueError(""Specified mode not valid for this function."")

        mode = self._XYR_MODE_MAP[mode]

        self.sendcmd(f""AOFF {mode}"")

    def auto_phase(self):
        """"""
        Sets the lock-in to auto phase.
        This does the same thing as pushing the auto phase button.

        Do not send this message again without waiting the correct amount
        of time for the lock-in to finish.
        """"""
        self.sendcmd(""APHS"")

    # META-METHODS #

    def init(self, sample_rate, buffer_mode):
        r""""""
        Wrapper function to prepare the SRS830 for measurement.
        Sets both the data sampling rate and the end of buffer mode

        :param sample_rate: The desired sampling
            rate. Acceptable set values are :math:`2^n` where
            :math:`n \in \{-4...+9\}` in units Hertz or the string `trigger`.
        :type sample_rate: `~pint.Quantity` or `str`

        :param `SRS830.BufferMode` buffer_mode: This sets the behaviour of the
            instrument when the data storage buffer is full. Setting to
            `one_shot` will stop acquisition, while `loop` will repeat from
            the start.
        """"""
        self.clear_data_buffer()
        self.sample_rate = sample_rate
        self.buffer_mode = buffer_mode

    def start_data_transfer(self):
        """"""
        Wrapper function to start the actual data transfer.
        Sets the transfer mode to FAST2, and triggers the data transfer
        to start after a delay of 0.5 seconds.
        """"""
        self.data_transfer = True
        self.start_scan()

    def take_measurement(self, sample_rate, num_samples):
        """"""
        Wrapper function that allows you to easily take measurements with a
        specified sample rate and number of desired samples.

        Function will call time.sleep() for the required amount of time it will
        take the instrument to complete this sampling operation.

        Returns a list containing two items, each of which are lists containing
        the channel data. The order is [[Ch1 data], [Ch2 data]].

        :param `int` sample_rate: Set the desired sample rate of the
            measurement. See `~SRS830.sample_rate` for more information.

        :param `int` num_samples: Number of samples to take.

        :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
            or if numpy is installed, `numpy.array`[`numpy.array`, `numpy.array`]
        """"""
        if num_samples > 16383:
            raise ValueError(""Number of samples cannot exceed 16383."")

        sample_time = math.ceil(num_samples / sample_rate)

        self.init(sample_rate, SRS830.BufferMode[""one_shot""])
        self.start_data_transfer()

        time.sleep(sample_time + 0.1)

        self.pause()

        # The following should fail. We do this to force the instrument
        # to flush its internal buffers.
        # Note that this causes a redundant transmission, and should be fixed
        # in future versions.
        try:
            self.num_data_points
        except OSError:
            pass

        ch1 = self.read_data_buffer(""ch1"")
        ch2 = self.read_data_buffer(""ch2"")

        if numpy:
            return numpy.array([ch1, ch2])
        return ch1, ch2

    # OTHER METHODS #

    def set_offset_expand(self, mode, offset, expand):
        """"""
        Sets the channel offset and expand parameters.
        Offset is a percentage, and expand is given as a multiplication
        factor of 1, 10, or 100.

        :param mode: The channel mode that you wish to change the
            offset and/or the expand of. Valid modes are X, Y, and R.
        :type mode: `SRS830.Mode` or `str`

        :param float offset: Offset of the mode, given as a percent.
            offset = <-105...+105>.

        :param int expand: Expansion factor for the measurement. Valid input
            is {1|10|100}.
        """"""
        if isinstance(mode, str):
            mode = mode.lower()
            mode = SRS830.Mode[mode]

        if mode not in self._XYR_MODE_MAP:
            raise ValueError(""Specified mode not valid for this function."")

        mode = self._XYR_MODE_MAP[mode]

        if not isinstance(offset, (int, float)):
            raise TypeError(""Offset parameter must be an integer or a float."")
        if not isinstance(expand, (int, float)):
            raise TypeError(""Expand parameter must be an integer or a float."")

        if (offset > 105) or (offset < -105):
            raise ValueError(""Offset mustbe -105 <= offset <= +105."")

        valid = [1, 10, 100]
        if expand in valid:
            expand = valid.index(expand)
        else:
            raise ValueError(""Expand must be 1, 10, 100."")

        self.sendcmd(f""OEXP {mode},{int(offset)},{expand}"")

    def start_scan(self):
        """"""
        After setting the data transfer on via the dataTransfer function,
        this is used to start the scan. The scan starts after a delay of
        0.5 seconds.
        """"""
        self.sendcmd(""STRD"")

    def pause(self):
        """"""
        Has the instrument pause data capture.
        """"""
        self.sendcmd(""PAUS"")

    _data_snap_modes = {
        Mode.x: 1,
        Mode.y: 2,
        Mode.r: 3,
        Mode.theta: 4,
        Mode.aux1: 5,
        Mode.aux2: 6,
        Mode.aux3: 7,
        Mode.aux4: 8,
        Mode.ref: 9,
        Mode.ch1: 10,
        Mode.ch2: 11,
    }

    def data_snap(self, mode1, mode2):
        """"""
        Takes a snapshot of the current parameters are defined by variables
        mode1 and mode2.

        For combinations (X,Y) and (R,THETA), they are taken at the same
        instant. All other combinations are done sequentially, and may
        not represent values taken from the same timestamp.

        Returns a list of floats, arranged in the order that they are
        given in the function input parameters.

        :param mode1: Mode to take data snap for channel 1. Valid inputs are
            given by: {X|Y|R|THETA|AUX1|AUX2|AUX3|AUX4|REF|CH1|CH2}
        :type mode1: `~SRS830.Mode` or `str`
        :param mode2: Mode to take data snap for channel 2. Valid inputs are
            given by: {X|Y|R|THETA|AUX1|AUX2|AUX3|AUX4|REF|CH1|CH2}
        :type mode2: `~SRS830.Mode` or `str`

        :rtype: `list`
        """"""
        if isinstance(mode1, str):
            mode1 = mode1.lower()
            mode1 = SRS830.Mode[mode1]
        if isinstance(mode2, str):
            mode2 = mode2.lower()
            mode2 = SRS830.Mode[mode2]

        if (mode1 not in self._data_snap_modes) or (mode2 not in self._data_snap_modes):
            raise ValueError(""Specified mode not valid for this function."")

        mode1 = self._XYR_MODE_MAP[mode1]
        mode2 = self._XYR_MODE_MAP[mode2]

        if mode1 == mode2:
            raise ValueError(""Both parameters for the data snapshot are the "" ""same."")

        result = self.query(f""SNAP? {mode1},{mode2}"")
        return list(map(float, result.split("","")))

    _valid_read_data_buffer = {Mode.ch1: 1, Mode.ch2: 2}

    def read_data_buffer(self, channel):
        """"""
        Reads the entire data buffer for a specific channel.
        Transfer is done in ASCII mode. Although binary would be faster,
        this is not currently implemented.

        Returns a list of floats containing instrument's measurements.

        :param channel: Channel data buffer to read from. Valid channels are
            given by {CH1|CH2}.
        :type channel: `SRS830.Mode` or `str`

        :rtype: `tuple`[`float`, ...] or if numpy is installed, `numpy.array`
        """"""
        if isinstance(channel, str):
            channel = channel.lower()
            channel = SRS830.Mode[channel]

        if channel not in self._valid_read_data_buffer:
            raise ValueError(""Specified mode not valid for this function."")

        channel = self._valid_read_data_buffer[channel]

        N = self.num_data_points  # Retrieve number of data points stored

        # Query device for entire buffer, returning in ASCII, then
        # converting to a list of floats before returning to the
        # calling method
        data = self.query(f""TRCA?{channel},0,{N}"").strip()
        if numpy:
            return numpy.fromstring(data, sep="","")
        return tuple(map(float, data.split("","")))

    def clear_data_buffer(self):
        """"""
        Clears the data buffer of the SRS830.
        """"""
        self.sendcmd(""REST"")

    _valid_channel_display = [
        {Mode.x: 0, Mode.r: 1, Mode.xnoise: 2, Mode.aux1: 3, Mode.aux2: 4},  # channel1
        {  # channel2
            Mode.y: 0,
            Mode.theta: 1,
            Mode.ynoise: 2,
            Mode.aux3: 3,
            Mode.aux4: 4,
        },
    ]

    _valid_channel_ratio = [
        {Mode.none: 0, Mode.aux1: 1, Mode.aux2: 2},  # channel1
        {Mode.none: 0, Mode.aux3: 1, Mode.aux4: 2},  # channel2
    ]

    _valid_channel = {Mode.ch1: 1, Mode.ch2: 2}

    def set_channel_display(self, channel, display, ratio):
        """"""
        Sets the display of the two channels.
        Channel 1 can display X, R, X Noise, Aux In 1, Aux In 2
        Channel 2 can display Y, Theta, Y Noise, Aux In 3, Aux In 4

        Channel 1 can have ratio of None, Aux In 1, Aux In 2
        Channel 2 can have ratio of None, Aux In 3, Aux In 4

        :param channel: Channel you wish to set the display of. Valid input is
            one of {CH1|CH2}.
        :type channel: `~SRS830.Mode` or `str`

        :param display: Setting the channel will be changed to. Valid
            input is one of {X|Y|R|THETA|XNOISE|YNOISE|AUX1|AUX2|AUX3|AUX4}
        :type display: `~SRS830.Mode` or `str`

        :param ratio: Desired ratio setting for this channel. Valid input
            is one of {NONE|AUX1|AUX2|AUX3|AUX4}
        :type ratio: `~SRS830.Mode` or `str`
        """"""
        if isinstance(channel, str):
            channel = channel.lower()
            channel = SRS830.Mode[channel]
        if isinstance(display, str):
            display = display.lower()
            display = SRS830.Mode[display]
        if isinstance(ratio, str):
            ratio = ratio.lower()
            ratio = SRS830.Mode[ratio]

        if channel not in self._valid_channel:
            raise ValueError(""Specified channel not valid for this function."")

        channel = self._valid_channel[channel]

        if display not in self._valid_channel_display[channel - 1]:
            raise ValueError(""Specified display mode not valid for this "" ""function."")
        if ratio not in self._valid_channel_ratio[channel - 1]:
            raise ValueError(""Specified display ratio not valid for this "" ""function."")

        display = self._valid_channel_display[channel - 1][display]
        ratio = self._valid_channel_ratio[channel - 1][ratio]

        self.sendcmd(f""DDEF {channel},{display},{ratio}"")
"
358,https://www.thinksrs.com/downloads/pdfs/catalog/DG645c.pdf,https://en.wikipedia.org/wiki/Pulse_generator,"[OrderedDict([('id', 'attQqnPuoAadlGes3'), ('width', 2000), ('height', 1435), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2-z5UaJWELX9CiK5-z_wkA/IAzHFWQWP4VcZynG1J4kEY8jWgQqUmRoRUdDexuMOupG3mMA1DLzaPuSxuDpRuCmV78mjW0KLeDWPg-YoHjpYm9Ma6bdDd32UfBkEraxonM/OPdVgwcs2Tu0OfKupzaggHgT1X9yq2mILDVOwSvO4JI'), ('filename', 'DG645_Wide_Reflect.jpg'), ('size', 472623), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_L9njCeX8cV6LYD52F4zEg/epfASfM0Dm0OrqKBchnLo5_ZxUdmnkpjWJB8Xr9DVxTbioSK2i4azq4C5TLnkKn-MtQQkBVMFxP0vpaMOox5nw/8y_cgtrexMv5A0hQc2ziUZVqLDi9i_5fAsgJtaoKrbw'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zL0P_3C0-6zsWX984mcUFg/9hBCpyIv0rNpa-pXglpCAfhVxSXrS8jyJ2cyK5fhp3AN2kSBhzW03Ky4g0qfNLpNNiP9D3d-wpTv7yf80l7j8g/CCH1bMOeO0I5LeE5gKJyuddSI9Ru9gyK7LGAgbKDpO0'), ('width', 714), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zSL9pCgDjBVmySMJP7g8DA/zPmtHYbQJnxEOIWSefil7DUkdXpNJ-Ig4DnBKkQWC16CMzguFkMxWemZpIiJSmPXbeL6T-uS44SY6nhEuYG9Ng/RpxllzqD28kZ8IeJpY9_rV-4kNC5J17h9R3FiZ-6upY'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"The DG645 is a versatile digital delay/pulse generator that provides precisely defined pulses at repetition rates up to 10 MHz. The instrument offers several improvements over older designs—lower jitter, higher accuracy, faster trigger rates, and more outputs. The DG645 also has Ethernet, GPIB and RS-232 interfaces for computer or network control of the instrument.",https://www.thinksrs.com/products/dg645.html,Srs dg645,496.0,['Pulse Generator'],A pulse generator is either an electronic circuit or a piece of electronic test equipment used to generate rectangular pulses. Pulse generators are used primarily for working with digital circuits; related function generators are used primarily for analog circuits.,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsdg645.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsdg645-digital-delay-generator,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782433/Instruments/Pulse%20Generator/DG-645/DG-645.jpg,DG645,Write a Python script that uses Instrumentkit to connect to a DG645 Pulse Generator,4695.0,,,,"#!/usr/bin/env python
""""""
Provides support for the SRS DG645 digital delay generator.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments.comm import GPIBCommunicator
from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class SRSDG645(SCPIInstrument):

    """"""
    Communicates with a Stanford Research Systems DG645 digital delay generator,
    using the SCPI commands documented in the `user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRSDG645.open_gpibusb('/dev/ttyUSB0', 1)
    >>> srs.channel[""B""].delay = (srs.channel[""A""], u.Quantity(10, 'ns'))
    >>> srs.output[""AB""].level_amplitude = u.Quantity(4.0, ""V"")

    .. _user's guide: http://www.thinksrs.com/downloads/PDFs/Manuals/DG645m.pdf
    """"""

    class Channel:

        """"""
        Class representing a sensor attached to the SRS DG644.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `SRSDG644` class.
        """"""

        def __init__(self, parent, chan):
            if not isinstance(parent, SRSDG645):
                raise TypeError(""Don't do that."")

            if isinstance(chan, parent.Channels):
                self._chan = chan.value
            else:
                self._chan = chan

            self._ddg = parent

        # PROPERTIES #

        @property
        def idx(self):
            """"""
            Gets the channel identifier number as used for communication

            :return: The communication identification number for the specified
                channel
            :rtype: `int`
            """"""
            return self._chan

        @property
        def delay(self):
            """"""
            Gets/sets the delay of this channel.
            Formatted as a two-tuple of the reference and the delay time.
            For example, ``(SRSDG644.Channels.A, u.Quantity(10, ""ps""))``
            indicates a delay of 9 picoseconds from delay channel A.

            :units: Assume seconds if no units given.
            """"""
            resp = self._ddg.query(f""DLAY?{int(self._chan)}"").split("","")
            return self._ddg.Channels(int(resp[0])), u.Quantity(float(resp[1]), ""s"")

        @delay.setter
        def delay(self, newval):
            newval = (newval[0], assume_units(newval[1], u.s))
            self._ddg.sendcmd(
                ""DLAY {},{},{}"".format(
                    int(self._chan), int(newval[0].idx), newval[1].to(""s"").magnitude
                )
            )

    def __init__(self, filelike):
        super().__init__(filelike)

        # This instrument requires stripping two characters.
        if isinstance(filelike, GPIBCommunicator):
            filelike.strip = 2

    # ENUMS #

    class LevelPolarity(IntEnum):

        """"""
        Polarities for output levels.
        """"""

        positive = 1
        negative = 0

    class Outputs(IntEnum):

        """"""
        Enumeration of valid outputs from the DDG.
        """"""

        T0 = 0
        AB = 1
        CD = 2
        EF = 3
        GH = 4

    class Channels(IntEnum):

        """"""
        Enumeration of valid delay channels for the DDG.
        """"""

        T0 = 0
        T1 = 1
        A = 2
        B = 3
        C = 4
        D = 5
        E = 6
        F = 7
        G = 8
        H = 9

    class DisplayMode(IntEnum):

        """"""
        Enumeration of possible modes for the physical front-panel display.
        """"""

        trigger_rate = 0
        trigger_threshold = 1
        trigger_single_shot = 2
        trigger_line = 3
        adv_triggering_enable = 4
        trigger_holdoff = 5
        prescale_config = 6
        burst_mode = 7
        burst_delay = 8
        burst_count = 9
        burst_period = 10
        channel_delay = 11
        channel_levels = 12
        channel_polarity = 13
        burst_T0_config = 14

    class TriggerSource(IntEnum):

        """"""
        Enumeration of the different allowed trigger sources and modes.
        """"""

        internal = 0
        external_rising = 1
        external_falling = 2
        ss_external_rising = 3
        ss_external_falling = 4
        single_shot = 5
        line = 6

    # INNER CLASSES #

    class Output:

        """"""
        An output from the DDG.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = int(idx)

        @property
        def polarity(self):
            """"""
            Polarity of this output.

            :type: :class:`SRSDG645.LevelPolarity`
            """"""
            return self._parent.LevelPolarity(
                int(self._parent.query(f""LPOL? {self._idx}""))
            )

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, self._parent.LevelPolarity):
                raise TypeError(
                    ""Mode must be specified as a ""
                    ""SRSDG645.LevelPolarity value, got {} ""
                    ""instead."".format(type(newval))
                )
            self._parent.sendcmd(f""LPOL {self._idx},{int(newval.value)}"")

        @property
        def level_amplitude(self):
            """"""
            Amplitude (in voltage) of the output level for this output.

            :type: `float` or :class:`~pint.Quantity`
            :units: As specified, or :math:`\\text{V}` by default.
            """"""
            return u.Quantity(float(self._parent.query(f""LAMP? {self._idx}"")), ""V"")

        @level_amplitude.setter
        def level_amplitude(self, newval):
            newval = assume_units(newval, ""V"").magnitude
            self._parent.sendcmd(f""LAMP {self._idx},{newval}"")

        @property
        def level_offset(self):
            """"""
            Amplitude offset (in voltage) of the output level for this output.

            :type: `float` or :class:`~pint.Quantity`
            :units: As specified, or :math:`\\text{V}` by default.
            """"""
            return u.Quantity(float(self._parent.query(f""LOFF? {self._idx}"")), ""V"")

        @level_offset.setter
        def level_offset(self, newval):
            newval = assume_units(newval, ""V"").magnitude
            self._parent.sendcmd(f""LOFF {self._idx},{newval}"")

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets a specific channel object.

        The desired channel is accessed by passing an EnumValue from
        `SRSDG645.Channels`. For example, to access channel A:

        >>> import instruments as ik
        >>> inst = ik.srs.SRSDG645.open_gpibusb('/dev/ttyUSB0', 1)
        >>> inst.channel[inst.Channels.A]

        See the example in `SRSDG645` for a more complete example.

        :rtype: `SRSDG645.Channel`
        """"""
        return ProxyList(self, self.Channel, SRSDG645.Channels)

    @property
    def output(self):
        """"""
        Gets the specified output port.

        :type: :class:`SRSDG645.Output`
        """"""
        return ProxyList(self, self.Output, self.Outputs)

    @property
    def display(self):
        """"""
        Gets/sets the front-panel display mode for the connected DDG.
        The mode is a tuple of the display mode and the channel.

        :type: `tuple` of an `SRSDG645.DisplayMode` and an `SRSDG645.Channels`
        """"""
        disp_mode, chan = map(int, self.query(""DISP?"").split("",""))
        return SRSDG645.DisplayMode(disp_mode), SRSDG645.Channels(chan)

    @display.setter
    def display(self, newval):
        # TODO: check types here.
        self.sendcmd(""DISP {},{}"".format(*map(int, newval)))

    @property
    def enable_adv_triggering(self):
        """"""
        Gets/sets whether advanced triggering is enabled.

        :type: `bool`
        """"""
        return bool(int(self.query(""ADVT?"")))

    @enable_adv_triggering.setter
    def enable_adv_triggering(self, newval):
        self.sendcmd(f""ADVT {1 if newval else 0}"")

    @property
    def trigger_rate(self):
        """"""
        Gets/sets the rate of the internal trigger.

        :type: `~pint.Quantity` or `float`
        :units: As passed or Hz if not specified.
        """"""
        return u.Quantity(float(self.query(""TRAT?"")), u.Hz)

    @trigger_rate.setter
    def trigger_rate(self, newval):
        newval = assume_units(newval, u.Hz)
        self.sendcmd(f""TRAT {newval.to(u.Hz).magnitude}"")

    @property
    def trigger_source(self):
        """"""
        Gets/sets the source for the trigger.

        :type: :class:`SRSDG645.TriggerSource`
        """"""
        return SRSDG645.TriggerSource(int(self.query(""TSRC?"")))

    @trigger_source.setter
    def trigger_source(self, newval):
        self.sendcmd(f""TSRC {int(newval)}"")

    @property
    def holdoff(self):
        """"""
        Gets/sets the trigger holdoff time.

        :type: `~pint.Quantity` or `float`
        :units: As passed, or s if not specified.
        """"""
        return u.Quantity(float(self.query(""HOLD?"")), u.s)

    @holdoff.setter
    def holdoff(self, newval):
        newval = assume_units(newval, u.s)
        self.sendcmd(f""HOLD {newval.to(u.s).magnitude}"")

    @property
    def enable_burst_mode(self):
        """"""
        Gets/sets whether burst mode is enabled.

        :type: `bool`
        """"""
        return bool(int(self.query(""BURM?"")))

    @enable_burst_mode.setter
    def enable_burst_mode(self, newval):
        self.sendcmd(f""BURM {1 if newval else 0}"")

    @property
    def enable_burst_t0_first(self):
        """"""
        Gets/sets whether T0 output in burst mode is on first. If
        enabled, the T0 output is enabled for first delay cycle of the
        burst only. If disabled, the T0 output is enabled for all delay
        cycles of the burst.

        :type: `bool`
        """"""
        return bool(int(self.query(""BURT?"")))

    @enable_burst_t0_first.setter
    def enable_burst_t0_first(self, newval):
        self.sendcmd(f""BURT {1 if newval else 0}"")

    @property
    def burst_count(self):
        """"""
        Gets/sets the burst count. When burst mode is enabled, the
        DG645 outputs burst count delay cycles per trigger.
        Valid numbers for burst count are between 1 and 2**32 - 1
        """"""
        return int(self.query(""BURC?""))

    @burst_count.setter
    def burst_count(self, newval):
        self.sendcmd(f""BURC {int(newval)}"")

    @property
    def burst_period(self):
        """"""
        Gets/sets the burst period. The burst period sets the time
        between delay cycles during a burst. The burst period may
        range from 100 ns to 2000 – 10 ns in 10 ns steps.

        :units: Assume seconds if no units given.
        """"""
        return u.Quantity(float(self.query(""BURP?"")), u.s)

    @burst_period.setter
    def burst_period(self, newval):
        newval = assume_units(newval, u.sec)
        self.sendcmd(f""BURP {newval.to(u.sec).magnitude}"")

    @property
    def burst_delay(self):
        """"""
        Gets/sets the burst delay. When burst mode is enabled the DG645
        delays the first burst pulse relative to the trigger by the
        burst delay. The burst delay may range from 0 ps to < 2000 s
        with a resolution of 5 ps.

        :units: Assume seconds if no units given.
        """"""
        return u.Quantity(float(self.query(""BURD?"")), u.s)

    @burst_delay.setter
    def burst_delay(self, newval):
        newval = assume_units(newval, u.s)
        self.sendcmd(f""BURD {newval.to(u.sec).magnitude}"")
"
369,https://cdn.teledynelecroy.com/files/pdf/wavemaster-8zi-b-datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'att9dZv0ctFtBQxTK'), ('width', 665), ('height', 705), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uzNFtFtd2zYPxRypViUA_g/5-EhgykpEpOrHkvZ2cS8LJQO0MkQlV8eK1h9ECrzU9pz6x4QaJdJJYdNxDTo7hfcb4ro9y9WKWkS5o7QTusC4JS5R--mri0ko32ipLplP5E/2spYUQnmODjUjvKBGE8CGehcww6R7BaZ5aOpLWHVHQE'), ('filename', 'wavemaster8zi-b-02.png'), ('size', 436672), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IjLlIrrTGWKIgkJXHQJUqg/jNYWXv7YnM96eVqFE2RFUQ0d5jFdw95fRZmJbpYv9XrwtNR6bhCTJgeFssVJ4-_F2fIJweMcju3xTcYP3mdMrQ/fQmZpKvdHV9-Dl9CVKKLQsX9AI20x-ZNAt8pXFyoRXw'), ('width', 34), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EMn4zvKwnH74i8IFzYwdaA/TEIP6ZiJCZPVu7nvMUftuiLKgTRvfovvyMOKKL7vqVho3gByPX8bpCNuMWS9w7MxmYeqGFTFPAMmQaimme3bcQ/p5MQgh2wGr0RtUZfI7d4P9tvOqklBtuddf8mQMk17us'), ('width', 512), ('height', 543)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nHH26oxpHMK4PK-r791OSw/IuxdUedm5XFVscj7O_jvEEIgkj7SEGxfgebxwELgFUjhnJPo-H0EbJfQq_mMeFQV4i7fuslE9X6ZO8UquNvPBQ/K1vcfnUD286445ec14XabrhvsV6Ye3n6DfArx0psWHs'), ('width', 3000), ('height', 3000)]))]))])]",5458.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125958/Instruments/Vendor%20Logos/Teledyne.png,"The WaveMaster 8 Zi-B combines the performance, signal fidelity and feature set needed for today’s high-speed measurements with the ease of use of a standard benchtop oscilloscope. Featuring the highest-speed serial data triggers, the only complete multi-lane serial data analysis and eye diagram solution, and the most comprehensive set of compliance packages, the WaveMaster 8 Zi-B simplifies the most complex testing.",https://www.teledynelecroy.com/oscilloscope/wavemaster-sda-dda-8-zi-b-oscilloscopes,Maui,584.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lTWGtnGJvNoQQtGkWiTw3Q/03sz7-JmQWR0sVkmbuY2j-ixfrb2RG7ANHcuIFtbdKTGGqbb3QoXjLm2K3fuA9nhoGiszq6bJVfyQS_YF4DK6MQ-1dX-TgIl9G4yeNn9bWg/vEARAVcKOJ_dYKhtSRqJwpFhtlW2yseGraDxl3Pz7AE'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XGTaKAYVPQ1jSYpvxemxww/jBjZQ4mGYkD2iq_jVPiO7q5mHRoxCiI2q4H7AAqK-rb6xWvOBgV3i_qAoW9sF5ikQybzsqMlxACqPtgFgi43yg/HslREwTZ4L4j4tfmfIQACPPUQGIIea6QX54F3_0wfDg'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6uVeOUNJ3PU4sUWeEpYORw/bJvfupWXLvYTq_ZBL6vRb8MYAT9s1cHOdiskoIZnTleEyavPa0g_CjQeJuJww6jJg4u_nouDtRigAqhMWtgDuA/Jkk8i0xOaFdqPHponkBF83ypbYS-A1QYUPHb0WNXORk'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/peQQ9Hm26PMMfgUTiAljdg/S7reZk9wwmtCxsQUpO8E7xhu4eEkgZhTlCBgwIDYyLmla4_T1RQs2gdYkQbVnPT7e5e3ROXtGFN6GyDiAOh_HQ/0jke3kPtFJBQtxJ6cEGA06Lch6Hq4FgP7cJXFeoB2ko'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782751/Instruments/Oscilloscopes/WaveMaster---SDA--DDA-8-Zi-B/WaveMaster---SDA--DDA-8-Zi-B.png,WaveMaster/SDA/DDA 8 Zi-B,Write a Python script that uses Instrumentkit to connect to a WaveMaster/SDA/DDA 8 Zi-B Oscilloscopes,,,,,"#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )
"
377,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attyKXRy1zDMMnNf2'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/RoYub4Ud950mKFKaDjG7Ug/TzJ1Si8g00n-5qA1dPDNuSeSQsEVupFldH5ZqVHD_Og2COqEOd2yhvfizxXnlZPUjkB_iIC_vAw7qMbGvOzVhFf1_YW4didx62q9tCKFnFw/qos2lX1c-DUizyTujaGTFMCeOjy2zcmy5lZmbjBC8n0'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eyA8zqMnaL0_S-857gDZ5g/iuuWiJft5C82UXlzyebn9wFQjrfOSDHtzFnapqMkj_u5ad-9dgbVgDXZcBeat6o_kQJUquT3yoQNVh1tba4FVQ/XgSngROFNaTZ0PCiy3QdFfye3EPYVFtV9ecPzBfq3X8'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wWP_gEImQml7ATwKAjKjHA/foBbym2OwNZTCcA2xgdUiK-EBd-MABzgkwz_09KRynge2xmd9VAPvIfwBoBLHKv990wWsMNxRL2PH8ZnabEPzw/Ydla5hImH2KrzBjDtmIBd2SD60T1SrBRTULZC3_feOg'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7pi8nZFE4IZhYg_-eabpFQ/4kS8mHwYu6QZSsku-wljq4LpP794EDPuMnRzbmBWddnCY_uqczOZWqVEAWMGEs07CSMGhE8JanfQMSMPINZTWQ/E1fB_kZdhjZDdu-KMM3PdDc6QxJf_VkUogyLErKEE3I'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,,,Tektds 5 XX,551.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782757/Instruments/Oscilloscopes/TDS500-Series/TDS500-Series.jpg,TDS500 Series,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,,,True,,"#!/usr/bin/env python
#
# tektds5xx.py: Driver for the Tektronix TDS 5xx series oscilloscope.
#
# © 2014 Chris Schimp (silverchris@gmail.com)
#
# Modified from tektds224.py
# © 2013 Steven Casagrande (scasagrande@galvant.ca).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Provides support for the Tektronix DPO 500 oscilloscope series.

Originally contributed by Chris Schimp (silverchris@gmail.com) in 2014.
Based off of tektds224.py written by Steven Casagrande.
""""""

# IMPORTS #####################################################################

from datetime import datetime
from enum import Enum
from functools import reduce
import operator
import struct
import time


from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TekTDS5xx(SCPIInstrument, Oscilloscope):

    """"""
    Support for the TDS5xx series of oscilloscopes
     Implemented from:
      | TDS Family Digitizing Oscilloscopes
      | (TDS 410A, 420A, 460A, 520A, 524A, 540A, 544A,
      | 620A, 640A, 644A, 684A, 744A & 784A)
      | Tektronix Document: 070-8709-07
    """"""

    class Measurement:

        """"""
        Class representing a measurement channel on the Tektronix TDS5xx
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            self._id = idx + 1
            resp = self._tek.query(f""MEASU:MEAS{self._id}?"")
            self._data = dict(
                zip(
                    [
                        ""enabled"",
                        ""type"",
                        ""units"",
                        ""src1"",
                        ""src2"",
                        ""edge1"",
                        ""edge2"",
                        ""dir"",
                    ],
                    resp.split("";""),
                )
            )

        def read(self):
            """"""
            Gets the current measurement value of the channel, and returns a dict
            of all relevant information

            :rtype: `dict` of measurement parameters
            """"""
            if int(self._data[""enabled""]):
                resp = self._tek.query(f""MEASU:MEAS{self._id}:VAL?"")
                self._data[""value""] = float(resp)
                return self._data

            return self._data

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, or ref) on the Tektronix
        TDS 5xx.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        @property
        def name(self):
            """"""
            Gets the name of this data source, as identified over SCPI.

            :type: `str`
            """"""
            return self._name

        def read_waveform(self, bin_format=True):
            """"""
            Read waveform from the oscilloscope.
            This function is all inclusive. After reading the data from the
            oscilloscope, it unpacks the data and scales it accordingly.

            Supports both ASCII and binary waveform transfer. For 2500 data
            points, with a width of 2 bytes, transfer takes approx 2 seconds for
            binary, and 7 seconds for ASCII over Galvant Industries' GPIBUSB
            adapter.

            Function returns a tuple (x,y), where both x and y are numpy arrays.

            :param bool bin_format: If `True`, data is transfered
                in a binary format. Otherwise, data is transferred in ASCII.

            :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]
            """"""
            with self:
                if not bin_format:
                    # Set the data encoding format to ASCII
                    self._parent.sendcmd(""DAT:ENC ASCI"")
                    raw = self._parent.query(""CURVE?"")
                    raw = raw.split("","")  # Break up comma delimited string
                    if numpy:
                        raw = numpy.array(raw, dtype=float)  # Convert to numpy array
                    else:
                        raw = map(float, raw)
                else:
                    # Set encoding to signed, big-endian
                    self._parent.sendcmd(""DAT:ENC RIB"")
                    data_width = self._parent.data_width
                    self._parent.sendcmd(""CURVE?"")
                    # Read in the binary block, data width of 2 bytes
                    raw = self._parent.binblockread(data_width)

                    # pylint: disable=protected-access
                    # read line separation character
                    self._parent._file.read_raw(1)

                # Retrieve Y offset
                yoffs = float(self._parent.query(f""WFMP:{self.name}:YOF?""))
                # Retrieve Y multiply
                ymult = float(self._parent.query(f""WFMP:{self.name}:YMU?""))
                # Retrieve Y zero
                yzero = float(self._parent.query(f""WFMP:{self.name}:YZE?""))

                # Retrieve X incr
                xincr = float(self._parent.query(f""WFMP:{self.name}:XIN?""))
                # Retrieve number of data points
                ptcnt = int(self._parent.query(f""WFMP:{self.name}:NR_P?""))

                if numpy:
                    x = numpy.arange(float(ptcnt)) * float(xincr)
                    y = ((raw - yoffs) * float(ymult)) + float(yzero)
                else:
                    x = tuple(float(val) * float(xincr) for val in range(ptcnt))
                    y = tuple(((x - yoffs) * float(ymult)) + float(yzero) for x in raw)

                return x, y

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on the Tektronix TDS 5xx.

        This class inherits from `TekTDS5xx.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        def __init__(self, parent, idx):
            super().__init__(parent, f""CH{idx + 1}"")
            self._idx = idx + 1

        @property
        def coupling(self):
            """"""
            Gets/sets the coupling setting for this channel.

            :type: `TekTDS5xx.Coupling`
            """"""
            return TekTDS5xx.Coupling(self._parent.query(f""CH{self._idx}:COUPL?""))

        @coupling.setter
        def coupling(self, newval):
            if not isinstance(newval, TekTDS5xx.Coupling):
                raise TypeError(
                    ""Coupling setting must be a `TekTDS5xx.Coupling`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:COUPL {newval.value}"")

        @property
        def bandwidth(self):
            """"""
            Gets/sets the Bandwidth setting for this channel.

            :type: `TekTDS5xx.Bandwidth`
            """"""
            return TekTDS5xx.Bandwidth(self._parent.query(f""CH{self._idx}:BAND?""))

        @bandwidth.setter
        def bandwidth(self, newval):
            if not isinstance(newval, TekTDS5xx.Bandwidth):
                raise TypeError(
                    ""Bandwidth setting must be a `TekTDS5xx.Bandwidth`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:BAND {newval.value}"")

        @property
        def impedance(self):
            """"""
            Gets/sets the impedance setting for this channel.

            :type: `TekTDS5xx.Impedance`
            """"""
            return TekTDS5xx.Impedance(self._parent.query(f""CH{self._idx}:IMP?""))

        @impedance.setter
        def impedance(self, newval):
            if not isinstance(newval, TekTDS5xx.Impedance):
                raise TypeError(
                    ""Impedance setting must be a `TekTDS5xx.Impedance`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:IMP {newval.value}"")

        @property
        def probe(self):
            """"""
            Gets the connected probe value for this channel

            :type: `float`
            """"""
            return round(1 / float(self._parent.query(f""CH{self._idx}:PRO?"")), 0)

        @property
        def scale(self):
            """"""
            Gets/sets the scale setting for this channel.

            :type: `float`
            """"""
            return float(self._parent.query(f""CH{self._idx}:SCA?""))

        @scale.setter
        def scale(self, newval):
            self._parent.sendcmd(f""CH{self._idx}:SCA {newval:.3E}"")
            resp = float(self._parent.query(f""CH{self._idx}:SCA?""))
            if newval != resp:
                raise ValueError(
                    ""Tried to set CH{} Scale to {} but got {}""
                    "" instead"".format(self._idx, newval, resp)
                )

    # ENUMS ##

    class Coupling(Enum):

        """"""
        Available coupling options for input sources and trigger
        """"""

        ac = ""AC""
        dc = ""DC""
        ground = ""GND""

    class Bandwidth(Enum):

        """"""
        Bandwidth in MHz
        """"""

        Twenty = ""TWE""
        OneHundred = ""HUN""
        TwoHundred = ""TWO""
        FULL = ""FUL""

    class Impedance(Enum):

        """"""
        Available options for input source impedance
        """"""

        Fifty = ""FIF""
        OneMeg = ""MEG""

    class Edge(Enum):

        """"""
        Available Options for trigger slope
        """"""

        Rising = ""RIS""
        Falling = ""FALL""

    class Trigger(Enum):

        """"""
        Available Trigger sources
        (AUX not Available on TDS520A/TDS540A)
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        AUX = ""AUX""
        LINE = ""LINE""

    class Source(Enum):

        """"""
        Available Data sources
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        Math1 = ""MATH1""
        Math2 = ""MATH2""
        Math3 = ""MATH3""
        Ref1 = ""REF1""
        Ref2 = ""REF2""
        Ref3 = ""REF3""
        Ref4 = ""REF4""

    # PROPERTIES ##
    @property
    def measurement(self):
        """"""
        Gets a specific oscilloscope measurement object. The desired channel is
        specified like one would access a list.

        :rtype: `TekTDS5xx.Measurement`
        """"""
        return ProxyList(self, self.Measurement, range(3))

    @property
    def channel(self):
        """"""
        Gets a specific oscilloscope channel object. The desired channel is
        specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.channel[0].read_waveform()

        :rtype: `TekTDS5xx.Channel`
        """"""
        return ProxyList(self, self.Channel, range(4))

    @property
    def ref(self):
        """"""
        Gets a specific oscilloscope reference channel object. The desired
        channel is specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.ref[0].read_waveform()

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""REF{idx + 1}""),
            range(4),
        )

    @property
    def math(self):
        """"""
        Gets a data source object corresponding to the MATH channel.

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""MATH{idx + 1}""),
            range(3),
        )

    @property
    def sources(self):
        """"""
        Returns list of all active sources

        :rtype: `list`
        """"""
        active = []
        channels = list(map(int, self.query(""SEL?"").split("";"")[0:11]))
        for idx in range(0, 4):
            if channels[idx]:
                active.append(self.Channel(self, idx))
        for idx in range(4, 7):
            if channels[idx]:
                active.append(self.DataSource(self, f""MATH{idx - 3}""))
        for idx in range(7, 11):
            if channels[idx]:
                active.append(self.DataSource(self, f""REF{idx - 6}""))
        return active

    @property
    def data_source(self):
        """"""
        Gets/sets the the data source for waveform transfer.

        :type: `TekTDS5xx.Source` or `TekTDS5xx.DataSource`
        :rtype: `TekTDS5xx.DataSource`
        """"""
        name = self.query(""DAT:SOU?"")
        if name.startswith(""CH""):
            return self.Channel(self, int(name[2:]) - 1)

        return self.DataSource(self, name)

    @data_source.setter
    def data_source(self, newval):
        if isinstance(newval, self.DataSource):
            newval = TekTDS5xx.Source(newval.name)
        if not isinstance(newval, TekTDS5xx.Source):
            raise TypeError(
                ""Source setting must be a `TekTDS5xx.Source`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""DAT:SOU {newval.value}"")
        time.sleep(0.01)  # Let the instrument catch up.

    @property
    def data_width(self):
        """"""
        Gets/Sets the data width for waveform transfers

        :type: `int`
        """"""
        return int(self.query(""DATA:WIDTH?""))

    @data_width.setter
    def data_width(self, newval):
        if int(newval) not in [1, 2]:
            raise ValueError(""Only one or two byte-width is supported."")

        self.sendcmd(f""DATA:WIDTH {newval}"")

    def force_trigger(self):
        raise NotImplementedError

    @property
    def horizontal_scale(self):
        """"""
        Get/Set Horizontal Scale

        :type: `float`
        """"""
        return float(self.query(""HOR:MAI:SCA?""))

    @horizontal_scale.setter
    def horizontal_scale(self, newval):
        self.sendcmd(f""HOR:MAI:SCA {newval:.3E}"")
        resp = float(self.query(""HOR:MAI:SCA?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set Horizontal Scale to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_level(self):
        """"""
        Get/Set trigger level

        :type: `float`
        """"""
        return float(self.query(""TRIG:MAI:LEV?""))

    @trigger_level.setter
    def trigger_level(self, newval):
        self.sendcmd(f""TRIG:MAI:LEV {newval:.3E}"")
        resp = float(self.query(""TRIG:MAI:LEV?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set trigger level to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_coupling(self):
        """"""
        Get/Set trigger coupling

        :type: `TekTDS5xx.Coupling`
        """"""
        return TekTDS5xx.Coupling(self.query(""TRIG:MAI:EDGE:COUP?""))

    @trigger_coupling.setter
    def trigger_coupling(self, newval):
        if not isinstance(newval, TekTDS5xx.Coupling):
            raise TypeError(
                ""Coupling setting must be a `TekTDS5xx.Coupling`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:COUP {newval.value}"")

    @property
    def trigger_slope(self):
        """"""
        Get/Set trigger slope

        :type: `TekTDS5xx.Edge`
        """"""
        return TekTDS5xx.Edge(self.query(""TRIG:MAI:EDGE:SLO?""))

    @trigger_slope.setter
    def trigger_slope(self, newval):
        if not isinstance(newval, TekTDS5xx.Edge):
            raise TypeError(
                ""Edge setting must be a `TekTDS5xx.Edge`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SLO {newval.value}"")

    @property
    def trigger_source(self):
        """"""
        Get/Set trigger source

        :type: `TekTDS5xx.Trigger`
        """"""
        return TekTDS5xx.Trigger(self.query(""TRIG:MAI:EDGE:SOU?""))

    @trigger_source.setter
    def trigger_source(self, newval):
        if not isinstance(newval, TekTDS5xx.Trigger):
            raise TypeError(
                ""Trigger source setting must be a ""
                ""`TekTDS5xx.Trigger` value, got {} ""
                ""instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SOU {newval.value}"")

    @property
    def clock(self):
        """"""
        Get/Set oscilloscope clock

        :type: `datetime.datetime`
        """"""
        resp = self.query(""DATE?;:TIME?"")
        return datetime.strptime(resp, '""%Y-%m-%d"";""%H:%M:%S""')

    @clock.setter
    def clock(self, newval):
        if not isinstance(newval, datetime):
            raise ValueError(
                ""Expected datetime.datetime "" ""but got {} instead"".format(type(newval))
            )
        self.sendcmd(newval.strftime('DATE ""%Y-%m-%d"";:TIME ""%H:%M:%S""'))

    @property
    def display_clock(self):
        """"""
        Get/Set the visibility of clock on the display

        :type: `bool`
        """"""
        return bool(int(self.query(""DISPLAY:CLOCK?"")))

    @display_clock.setter
    def display_clock(self, newval):
        if not isinstance(newval, bool):
            raise ValueError(""Expected bool but got "" ""{} instead"".format(type(newval)))
        self.sendcmd(f""DISPLAY:CLOCK {int(newval)}"")

    def get_hardcopy(self):
        """"""
        Gets a screenshot of the display

        :rtype: `string`
        """"""
        self.sendcmd(""HARDC:PORT GPI;HARDC:LAY PORT;:HARDC:FORM BMP"")
        self.sendcmd(""HARDC START"")
        time.sleep(1)
        header = self._file.read_raw(size=54)
        # Get BMP Length  in kilobytes from DIB header, because file header is
        # bad
        length = reduce(operator.mul, struct.unpack(""<iihh"", header[18:30])) / 8
        length = int(length) + 8  # Add 8 bytes for our monochrome colour table
        data = header + self._file.read_raw(size=length)
        self._file.flush_input()  # Flush input buffer
        return data
"
383,Not Available,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'att0ooJCGULf7i5fN'), ('width', 900), ('height', 288), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FkI8XHB1qcVn-_9K0ph_yA/HiqBW52uF6ZIV8FEuWdS0My-AKe4aHB4u94pxZWm6qO1dYAmpnj45nuggahVm2AnW76__f7_9VPLJ7U-48jzvMx2tLNGtGYrV-K3rTrjzfg/Jlxd9s92mBiH32qAtu3RyeaIaMjqJCG3p0k6GO1Frsc'), ('filename', 'face_1.jpg'), ('size', 64705), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/t8lfn9MuuCgVukLg0Z93Zw/Cefp7hlVKAQbn2O_ReA83W8Mnh-Q6oT9R31ttpgPdDX80_nxySfLYafViBc78-HHnm5EzmBM9F29jnr4rwTcfA/7S4V25xV-67mv2n9dQo40q0RjJbtXGpI1rIiz8DVi-k'), ('width', 113), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/P8bxYoOajrL_jssK9qESyw/9KcT4107I4iRc639j_XLSovCNUfP1N_cDwZ2to_mrycv_oWQYkatQkdPs5s0Oud1zVqBQZohqPKmQfXa7vW8Gw/iplvg9HnSTqY-lxiogX3cM3c6YvbAkqbYngVEbxG738'), ('width', 900), ('height', 288)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/n9rGyzByUmGLGamL9jjbGA/0RE5wF4_wCINnmj3kDQ7mV7gTTp5Fwfb6mtjK4pddDRUcxmou-esoSfxgJgUawlCDhOksa70GLHrAhJIMCNVbQ/k6CkDQWtS2A_DRtSyleFrq1VUZ8rOMA3LGYkh2X6pu8'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,3456A 6 1/2 Digit Digital Multimeter,https://www.keysight.com/us/en/product/3456A/6-12-digit-digital-multimeter.html,HP 3456 A,149.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/hp/hp3456a.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/hp.html#hp3456a-digital-voltmeter,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782761/Instruments/Multimeters/Keysight-3456A/Keysight-3456A.jpg,Keysight 3456A,Write a Python script that uses Instrumentkit to connect to a Keysight 3456A Multimeters,,,True,,"#!/usr/bin/env python
#
# hp3456a.py: Driver for the HP3456a Digital Voltmeter.
#
# © 2014 Willem Dijkstra (wpd@xs4all.nl).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Driver for the HP3456a Digital Voltmeter

Originally contributed and copyright held by Willem Dijkstra (wpd@xs4all.nl)

An unrestricted license has been provided to the maintainers of the Instrument
Kit project.
""""""

# IMPORTS #####################################################################

import time
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u
from instruments.util_fns import assume_units, bool_property, enum_property

# CLASSES #####################################################################


class HP3456a(Multimeter):

    """"""The `HP3456a` is a 6 1/2 digit bench multimeter.

    It supports DCV, ACV, ACV + DCV, 2 wire Ohms, 4 wire Ohms, DCV/DCV Ratio,
    ACV/DCV Ratio, Offset compensated 2 wire Ohms and Offset compensated 4 wire
    Ohms measurements.

    Measurements can be further extended using a system math mode that allows
    for pass/fail, statistics, dB/dBm, null, scale and percentage readings.

    `HP3456a` is a HPIB / pre-448.2 instrument.
    """"""

    def __init__(self, filelike):
        """"""
        Initialise the instrument, and set the required eos, eoi needed for
        communication.
        """"""
        super().__init__(filelike)
        self.timeout = 15 * u.second
        self.terminator = ""\r""
        self.sendcmd(""HO0T4SO1"")
        self._null = False

    # ENUMS ##

    class MathMode(IntEnum):

        """"""
        Enum with the supported math modes
        """"""

        off = 0
        pass_fail = 1
        statistic = 2
        null = 3
        dbm = 4
        thermistor_f = 5
        thermistor_c = 6
        scale = 7
        percent = 8
        db = 9

    class Mode(Enum):

        """"""
        Enum containing the supported mode codes
        """"""

        #: DC voltage
        dcv = ""S0F1""
        #: AC voltage
        acv = ""S0F2""
        #: RMS of DC + AC voltage
        acvdcv = ""S0F3""
        #: 2 wire resistance
        resistance_2wire = ""S0F4""
        #: 4 wire resistance
        resistance_4wire = ""S0F5""
        #: ratio DC / DC voltage
        ratio_dcv_dcv = ""S1F1""
        #: ratio AC / DC voltage
        ratio_acv_dcv = ""S1F2""
        #: ratio (AC + DC) / DC voltage
        ratio_acvdcv_dcv = ""S1F3""
        #: offset compensated 2 wire resistance
        oc_resistence_2wire = ""S1F4""
        #: offset compensated 4 wire resistance
        oc_resistence_4wire = ""S1F5""

    class Register(Enum):

        """"""
        Enum with the register names for all `HP3456a` internal registers.
        """"""

        number_of_readings = ""N""
        number_of_digits = ""G""
        nplc = ""I""
        delay = ""D""
        mean = ""M""
        variance = ""V""
        count = ""C""
        lower = ""L""
        r = ""R""
        upper = ""U""
        y = ""Y""
        z = ""Z""

    class TriggerMode(IntEnum):

        """"""
        Enum with valid trigger modes.
        """"""

        internal = 1
        external = 2
        single = 3
        hold = 4

    class ValidRange(Enum):

        """"""
        Enum with the valid ranges for voltage, resistance, and number of
        powerline cycles to integrate over.

        """"""

        voltage = (1e-1, 1e0, 1e1, 1e2, 1e3)
        resistance = (1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9)
        nplc = (1e-1, 1e0, 1e1, 1e2)

    # PROPERTIES ##

    mode = enum_property(
        """",
        Mode,
        doc=""""""Set the measurement mode.

        :type: `HP3456a.Mode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    autozero = bool_property(
        ""Z"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the autozero mode.

        This is used to compensate for offsets in the dc
        input amplifier circuit of the multimeter. If set, the amplifier""s input
        circuit is shorted to ground prior to actual measurement in order to
        take an offset reading. This offset is then used to compensate for
        drift in the next measurement. When disabled, one offset reading
        is taken immediately and stored into memory to be used for all
        successive measurements onwards. Disabling autozero increases the
        `HP3456a`""s measurement speed, and also makes the instrument more
        suitable for high impendance measurements since no input switching is
        done."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    filter = bool_property(
        ""FL"",
        inst_true=""1"",
        inst_false=""0"",
        doc=""""""Set the analog filter mode.

        The `HP3456a` has a 3 pole active filter with
        greater than 60dB attenuation at frequencies of 50Hz and higher. The
        filter is applied between the input terminals and input amplifier. When
        in ACV or ACV+DCV functions the filter is applied to the output of the
        ac converter and input amplifier. In these modes select the filter for
        measurements below 400Hz."""""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    math_mode = enum_property(
        ""M"",
        MathMode,
        doc=""""""Set the math mode.

        The `HP3456a` has a number of different math modes that
        can change measurement output, or can provide additional
        statistics. Interaction with these modes is done via the
        `HP3456a.Register`.

        :type: `HP3456a.MathMode`
        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    trigger_mode = enum_property(
        ""T"",
        TriggerMode,
        doc=""""""Set the trigger mode.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`.

        :type: `HP3456a.TriggerMode`

        """""",
        writeonly=True,
        set_fmt=""{}{}"",
    )

    @property
    def number_of_readings(self):
        """"""Get/set the number of readings done per trigger/measurement cycle
        using `HP3456a.Register.number_of_readings`.

        :type: `float`
        :rtype: `float`

        """"""
        return self._register_read(HP3456a.Register.number_of_readings)

    @number_of_readings.setter
    def number_of_readings(self, value):
        self._register_write(HP3456a.Register.number_of_readings, value)

    @property
    def number_of_digits(self):
        """"""Get/set the number of digits used in measurements using
        `HP3456a.Register.number_of_digits`.

        Set to higher values to increase accuracy at the cost of measurement
        speed.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.number_of_digits))

    @number_of_digits.setter
    def number_of_digits(self, newval):
        newval = int(newval)
        if newval not in range(3, 7):
            raise ValueError(
                ""Valid number_of_digits are: "" ""{}"".format(list(range(3, 7)))
            )

        self._register_write(HP3456a.Register.number_of_digits, newval)

    @property
    def nplc(self):
        """"""Get/set the number of powerline cycles to integrate per measurement
        using `HP3456a.Register.nplc`.

        Setting higher values increases accuracy at the cost of a longer
        measurement time. The implicit assumption is that the input reading is
        stable over the number of powerline cycles to integrate.

        :type: `int`
        """"""
        return int(self._register_read(HP3456a.Register.nplc))

    @nplc.setter
    def nplc(self, newval):
        newval = int(newval)
        valid = HP3456a.ValidRange[""nplc""].value
        if newval in valid:
            self._register_write(HP3456a.Register.nplc, newval)
        else:
            raise ValueError(""Valid nplc settings are: "" ""{}"".format(valid))

    @property
    def delay(self):
        """"""Get/set the delay that is waited after a trigger for the input to
        settle using `HP3456a.Register.delay`.

        :type: As specified, assumed to be `~quantaties.Quantity.s` otherwise
        :rtype: `~quantaties.Quantity.s`

        """"""
        return self._register_read(HP3456a.Register.delay) * u.s

    @delay.setter
    def delay(self, value):
        delay = assume_units(value, u.s).to(u.s).magnitude
        self._register_write(HP3456a.Register.delay, delay)

    @property
    def mean(self):
        """"""
        Get the mean over `HP3456a.Register.count` measurements from
        `HP3456a.Register.mean` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.mean)

    @property
    def variance(self):
        """"""
        Get the variance over `HP3456a.Register.count` measurements from
        `HP3456a.Register.variance` when in `HP3456a.MathMode.statistic`.

        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.variance)

    @property
    def count(self):
        """"""
        Get the number of measurements taken from `HP3456a.Register.count` when
        in `HP3456a.MathMode.statistic`.

        :rtype: `int`
        """"""
        return int(self._register_read(HP3456a.Register.count))

    @property
    def lower(self):
        """"""
        Get/set the value in `HP3456a.Register.lower`, which indicates the
        lowest value measurement made while in `HP3456a.MathMode.statistic`, or
        the lowest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        """"""
        return self._register_read(HP3456a.Register.lower)

    @lower.setter
    def lower(self, value):
        self._register_write(HP3456a.Register.lower, value)

    @property
    def upper(self):
        """"""
        Get/set the value in `HP3456a.Register.upper`, which indicates the
        highest value measurement made while in `HP3456a.MathMode.statistic`,
        or the highest value preset for `HP3456a.MathMode.pass_fail`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.upper)

    @upper.setter
    def upper(self, value):
        return self._register_write(HP3456a.Register.upper, value)

    @property
    def r(self):
        """"""
        Get/set the value in `HP3456a.Register.r`, which indicates the resistor
        value used while in `HP3456a.MathMode.dbm` or the number of recalled
        readings in reading storage mode.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.r)

    @r.setter
    def r(self, value):
        self._register_write(HP3456a.Register.r, value)

    @property
    def y(self):
        """"""
        Get/set the value in `HP3456a.Register.y` to be used in calculations
        when in `HP3456a.MathMode.scale` or `HP3456a.MathMode.percent`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.y)

    @y.setter
    def y(self, value):
        self._register_write(HP3456a.Register.y, value)

    @property
    def z(self):
        """"""
        Get/set the value in `HP3456a.Register.z` to be used in calculations
        when in `HP3456a.MathMode.scale` or the first reading when in
        `HP3456a.MathMode.statistic`.

        :type: `float`
        :rtype: `float`
        """"""
        return self._register_read(HP3456a.Register.z)

    @z.setter
    def z(self, value):
        self._register_write(HP3456a.Register.z, value)

    @property
    def input_range(self):
        """"""Set the input range to be used.

        The `HP3456a` has separate ranges for `ohm` and for
        `volt`. The range value sent to the instrument depends on
        the unit set on the input range value. `auto` selects auto ranging.

        :type: `~pint.Quantity`
        """"""
        raise NotImplementedError

    @input_range.setter
    def input_range(self, value):
        if isinstance(value, str):
            if value.lower() == ""auto"":
                self.sendcmd(""R1W"")
            else:
                raise ValueError(
                    ""Only 'auto' is acceptable when specifying ""
                    ""the input range as a string.""
                )

        elif isinstance(value, u.Quantity):
            if value.units == u.volt:
                valid = HP3456a.ValidRange.voltage.value
                value = value.to(u.volt)
            elif value.units == u.ohm:
                valid = HP3456a.ValidRange.resistance.value
                value = value.to(u.ohm)
            else:
                raise ValueError(
                    ""Value {} not quantity.volt or quantity.ohm"" """".format(value)
                )

            value = float(value.magnitude)
            if value not in valid:
                raise ValueError(
                    ""Value {} outside valid ranges "" ""{}"".format(value, valid)
                )
            value = valid.index(value) + 2
            self.sendcmd(f""R{value}W"")
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                ""or the string 'auto', got {}"".format(type(value))
            )

    @property
    def relative(self):
        """"""
        Enable or disable `HP3456a.MathMode.Null` on the instrument.

        :type: `bool`
        """"""
        return self._null

    @relative.setter
    def relative(self, value):
        if value is True:
            self._null = True
            self.sendcmd(f""M{HP3456a.MathMode.null.value}"")
        elif value is False:
            self._null = False
            self.sendcmd(f""M{HP3456a.MathMode.off.value}"")
        else:
            raise TypeError(
                ""Relative setting must be specified as a bool, ""
                ""got {}"".format(type(value))
            )

    # METHODS ##

    def auto_range(self):
        """"""
        Set input range to auto. The `HP3456a` should upscale when a reading
        is at 120% and downscale when it below 11% full scale. Note that auto
        ranging can increase the measurement time.
        """"""
        self.input_range = ""auto""

    def fetch(self, mode=None):
        """"""Retrieve n measurements after the HP3456a has been instructed to
        perform a series of similar measurements. Typically the mode, range,
        nplc, analog filter, autozero is set along with the number of
        measurements to take. The series is then started at the trigger
        command.

        Example usage:

        >>> dmm.number_of_digits = 6
        >>> dmm.auto_range()
        >>> dmm.nplc = 1
        >>> dmm.mode = dmm.Mode.resistance_2wire
        >>> n = 100
        >>> dmm.number_of_readings = n
        >>> dmm.trigger()
        >>> time.sleep(n * 0.04)
        >>> v = dmm.fetch(dmm.Mode.resistance_2wire)
        >>> print len(v)
        10

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be returned.

        :type mode: `HP3456a.Mode`

        :return: A series of measurements from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            units = UNITS[mode]
        else:
            units = 1

        value = self.query("""", size=-1)
        values = [float(x) * units for x in value.split("","")]
        return values

    def measure(self, mode=None):
        """"""Instruct the HP3456a to perform a one time measurement. The
        measurement will use the current set registers for the measurement
        (number_of_readings, number_of_digits, nplc, delay, mean, lower, upper,
        y and z) and will immediately take place.

        Note that using `HP3456a.measure()` will override the `trigger_mode` to
        `HP3456a.TriggerMode.single`

        Example usage:

        >>> dmm = ik.hp.HP3456a.open_gpibusb(""/dev/ttyUSB0"", 22)
        >>> dmm.number_of_digits = 6
        >>> dmm.nplc = 1
        >>> print dmm.measure(dmm.Mode.resistance_2wire)

        :param mode: Desired measurement mode. If not specified, the previous
            set mode will be used, but no measurement unit will be
            returned.

        :type mode: `HP3456a.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`

        """"""
        if mode is not None:
            modevalue = mode.value
            units = UNITS[mode]
        else:
            modevalue = """"
            units = 1

        self.sendcmd(f""{modevalue}W1STNT3"")

        value = self.query("""", size=-1)
        return float(value) * units

    def _register_read(self, name):
        """"""
        Read a register on the HP3456a.

        :param name: The name of the register to read from
        :type name: `HP3456a.Register`
        :rtype: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        self.sendcmd(f""RE{name.value}"")
        time.sleep(0.1)
        return float(self.query("""", size=-1))

    def _register_write(self, name, value):
        """"""
        Write a register on the HP3456a.

        :param name: The name of the register to write to
        :type name: `HP3456a.Register`
        :type value: `float`
        """"""
        try:
            name = HP3456a.Register[name]
        except KeyError:
            pass
        if not isinstance(name, HP3456a.Register):
            raise TypeError(
                ""register must be specified as a ""
                ""HP3456a.Register, got {} ""
                ""instead."".format(name)
            )
        if name in [
            HP3456a.Register.mean,
            HP3456a.Register.variance,
            HP3456a.Register.count,
        ]:
            raise ValueError(f""register {name} is read only"")
        self.sendcmd(f""W{value}ST{name.value}"")
        time.sleep(0.1)

    def trigger(self):
        """"""
        Signal a single manual trigger event to the `HP3456a`.
        """"""
        self.sendcmd(""T3"")


# UNITS #######################################################################

UNITS = {
    None: 1,
    HP3456a.Mode.dcv: u.volt,
    HP3456a.Mode.acv: u.volt,
    HP3456a.Mode.acvdcv: u.volt,
    HP3456a.Mode.resistance_2wire: u.ohm,
    HP3456a.Mode.resistance_4wire: u.ohm,
    HP3456a.Mode.ratio_dcv_dcv: 1,
    HP3456a.Mode.ratio_acv_dcv: 1,
    HP3456a.Mode.ratio_acvdcv_dcv: 1,
    HP3456a.Mode.oc_resistence_2wire: u.ohm,
    HP3456a.Mode.oc_resistence_4wire: u.ohm,
}
"
388,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attDO3kJCZa3frTiz'), ('width', 472), ('height', 294), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eqdI89hi984lINaOk7erQA/FdazXRpXnVZEBUcQmCpQUQ9OqWqx0wwB7dNzpOY7KZw9FKIWVFCyqxX3320xYhJ5Fxpp79TTwEVKYiNmoCM3CqHCMMxFf14G-8j6NiOzRz0/Q_PYYZr7ei6G0wY7SusMwvb6iPo3WvyAaj_MXfelzFs'), ('filename', 'tektro_tds540_1.jpg'), ('size', 18801), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/d5ecl4c7UE87K2LANG_oXA/vgrGogSxl0cDzE3HC5n6qrCc8BiNo7Iylp_pZhc_wDApxuPFRmvHW3imXv1d7-J3W0Cqtq_tuqxiztRKJj9Qbg/AJTqWV-1hTgEoTJDiSPDcOQT-HXDa3WfIttzH0bDJ8c'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kl20K9CbzcpmP67ZKiY2Lw/PodrUpAFbg6zOMNmHatovMWNVEmPICu8GH5qdDnecH0T2axaJ7h6CquLh-OnANJ31V7YGGASr3wyz9dhyfxlQA/t5KReIF-E2wy3z_jOhw8wEiuGvoTBCXQBaECrt0eEFw'), ('width', 472), ('height', 294)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HnaHcWd0upvETlbGJRu6EQ/GAUhkrRR-BteULBrlPHecPjSP9VjcCoz-M1gycVF2B4-fQ5aA6m2Au6tAGiWBzg06yXHz47YWS2WeOWoILzXyQ/LQ6ZBy6m2lh7ndCSOv2T4uoIZXBs8zo-o81KU6PsU8Y'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,,,Tektds 5 XX,551.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,Instrumentkit,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782757/Instruments/Oscilloscopes/TDS500-Series/TDS500-Series.jpg,TDS500 Series,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,,,True,,"#!/usr/bin/env python
#
# tektds5xx.py: Driver for the Tektronix TDS 5xx series oscilloscope.
#
# © 2014 Chris Schimp (silverchris@gmail.com)
#
# Modified from tektds224.py
# © 2013 Steven Casagrande (scasagrande@galvant.ca).
#
# This file is a part of the InstrumentKit project.
# Licensed under the AGPL version 3.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
""""""
Provides support for the Tektronix DPO 500 oscilloscope series.

Originally contributed by Chris Schimp (silverchris@gmail.com) in 2014.
Based off of tektds224.py written by Steven Casagrande.
""""""

# IMPORTS #####################################################################

from datetime import datetime
from enum import Enum
from functools import reduce
import operator
import struct
import time


from instruments.abstract_instruments import Oscilloscope
from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TekTDS5xx(SCPIInstrument, Oscilloscope):

    """"""
    Support for the TDS5xx series of oscilloscopes
     Implemented from:
      | TDS Family Digitizing Oscilloscopes
      | (TDS 410A, 420A, 460A, 520A, 524A, 540A, 544A,
      | 620A, 640A, 644A, 684A, 744A & 784A)
      | Tektronix Document: 070-8709-07
    """"""

    class Measurement:

        """"""
        Class representing a measurement channel on the Tektronix TDS5xx
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            self._id = idx + 1
            resp = self._tek.query(f""MEASU:MEAS{self._id}?"")
            self._data = dict(
                zip(
                    [
                        ""enabled"",
                        ""type"",
                        ""units"",
                        ""src1"",
                        ""src2"",
                        ""edge1"",
                        ""edge2"",
                        ""dir"",
                    ],
                    resp.split("";""),
                )
            )

        def read(self):
            """"""
            Gets the current measurement value of the channel, and returns a dict
            of all relevant information

            :rtype: `dict` of measurement parameters
            """"""
            if int(self._data[""enabled""]):
                resp = self._tek.query(f""MEASU:MEAS{self._id}:VAL?"")
                self._data[""value""] = float(resp)
                return self._data

            return self._data

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, or ref) on the Tektronix
        TDS 5xx.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        @property
        def name(self):
            """"""
            Gets the name of this data source, as identified over SCPI.

            :type: `str`
            """"""
            return self._name

        def read_waveform(self, bin_format=True):
            """"""
            Read waveform from the oscilloscope.
            This function is all inclusive. After reading the data from the
            oscilloscope, it unpacks the data and scales it accordingly.

            Supports both ASCII and binary waveform transfer. For 2500 data
            points, with a width of 2 bytes, transfer takes approx 2 seconds for
            binary, and 7 seconds for ASCII over Galvant Industries' GPIBUSB
            adapter.

            Function returns a tuple (x,y), where both x and y are numpy arrays.

            :param bool bin_format: If `True`, data is transfered
                in a binary format. Otherwise, data is transferred in ASCII.

            :rtype: `tuple`[`tuple`[`float`, ...], `tuple`[`float`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]
            """"""
            with self:
                if not bin_format:
                    # Set the data encoding format to ASCII
                    self._parent.sendcmd(""DAT:ENC ASCI"")
                    raw = self._parent.query(""CURVE?"")
                    raw = raw.split("","")  # Break up comma delimited string
                    if numpy:
                        raw = numpy.array(raw, dtype=float)  # Convert to numpy array
                    else:
                        raw = map(float, raw)
                else:
                    # Set encoding to signed, big-endian
                    self._parent.sendcmd(""DAT:ENC RIB"")
                    data_width = self._parent.data_width
                    self._parent.sendcmd(""CURVE?"")
                    # Read in the binary block, data width of 2 bytes
                    raw = self._parent.binblockread(data_width)

                    # pylint: disable=protected-access
                    # read line separation character
                    self._parent._file.read_raw(1)

                # Retrieve Y offset
                yoffs = float(self._parent.query(f""WFMP:{self.name}:YOF?""))
                # Retrieve Y multiply
                ymult = float(self._parent.query(f""WFMP:{self.name}:YMU?""))
                # Retrieve Y zero
                yzero = float(self._parent.query(f""WFMP:{self.name}:YZE?""))

                # Retrieve X incr
                xincr = float(self._parent.query(f""WFMP:{self.name}:XIN?""))
                # Retrieve number of data points
                ptcnt = int(self._parent.query(f""WFMP:{self.name}:NR_P?""))

                if numpy:
                    x = numpy.arange(float(ptcnt)) * float(xincr)
                    y = ((raw - yoffs) * float(ymult)) + float(yzero)
                else:
                    x = tuple(float(val) * float(xincr) for val in range(ptcnt))
                    y = tuple(((x - yoffs) * float(ymult)) + float(yzero) for x in raw)

                return x, y

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on the Tektronix TDS 5xx.

        This class inherits from `TekTDS5xx.DataSource`.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `TekTDS5xx` class.
        """"""

        def __init__(self, parent, idx):
            super().__init__(parent, f""CH{idx + 1}"")
            self._idx = idx + 1

        @property
        def coupling(self):
            """"""
            Gets/sets the coupling setting for this channel.

            :type: `TekTDS5xx.Coupling`
            """"""
            return TekTDS5xx.Coupling(self._parent.query(f""CH{self._idx}:COUPL?""))

        @coupling.setter
        def coupling(self, newval):
            if not isinstance(newval, TekTDS5xx.Coupling):
                raise TypeError(
                    ""Coupling setting must be a `TekTDS5xx.Coupling`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:COUPL {newval.value}"")

        @property
        def bandwidth(self):
            """"""
            Gets/sets the Bandwidth setting for this channel.

            :type: `TekTDS5xx.Bandwidth`
            """"""
            return TekTDS5xx.Bandwidth(self._parent.query(f""CH{self._idx}:BAND?""))

        @bandwidth.setter
        def bandwidth(self, newval):
            if not isinstance(newval, TekTDS5xx.Bandwidth):
                raise TypeError(
                    ""Bandwidth setting must be a `TekTDS5xx.Bandwidth`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:BAND {newval.value}"")

        @property
        def impedance(self):
            """"""
            Gets/sets the impedance setting for this channel.

            :type: `TekTDS5xx.Impedance`
            """"""
            return TekTDS5xx.Impedance(self._parent.query(f""CH{self._idx}:IMP?""))

        @impedance.setter
        def impedance(self, newval):
            if not isinstance(newval, TekTDS5xx.Impedance):
                raise TypeError(
                    ""Impedance setting must be a `TekTDS5xx.Impedance`""
                    "" value, got {} instead."".format(type(newval))
                )

            self._parent.sendcmd(f""CH{self._idx}:IMP {newval.value}"")

        @property
        def probe(self):
            """"""
            Gets the connected probe value for this channel

            :type: `float`
            """"""
            return round(1 / float(self._parent.query(f""CH{self._idx}:PRO?"")), 0)

        @property
        def scale(self):
            """"""
            Gets/sets the scale setting for this channel.

            :type: `float`
            """"""
            return float(self._parent.query(f""CH{self._idx}:SCA?""))

        @scale.setter
        def scale(self, newval):
            self._parent.sendcmd(f""CH{self._idx}:SCA {newval:.3E}"")
            resp = float(self._parent.query(f""CH{self._idx}:SCA?""))
            if newval != resp:
                raise ValueError(
                    ""Tried to set CH{} Scale to {} but got {}""
                    "" instead"".format(self._idx, newval, resp)
                )

    # ENUMS ##

    class Coupling(Enum):

        """"""
        Available coupling options for input sources and trigger
        """"""

        ac = ""AC""
        dc = ""DC""
        ground = ""GND""

    class Bandwidth(Enum):

        """"""
        Bandwidth in MHz
        """"""

        Twenty = ""TWE""
        OneHundred = ""HUN""
        TwoHundred = ""TWO""
        FULL = ""FUL""

    class Impedance(Enum):

        """"""
        Available options for input source impedance
        """"""

        Fifty = ""FIF""
        OneMeg = ""MEG""

    class Edge(Enum):

        """"""
        Available Options for trigger slope
        """"""

        Rising = ""RIS""
        Falling = ""FALL""

    class Trigger(Enum):

        """"""
        Available Trigger sources
        (AUX not Available on TDS520A/TDS540A)
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        AUX = ""AUX""
        LINE = ""LINE""

    class Source(Enum):

        """"""
        Available Data sources
        """"""

        CH1 = ""CH1""
        CH2 = ""CH2""
        CH3 = ""CH3""
        CH4 = ""CH4""
        Math1 = ""MATH1""
        Math2 = ""MATH2""
        Math3 = ""MATH3""
        Ref1 = ""REF1""
        Ref2 = ""REF2""
        Ref3 = ""REF3""
        Ref4 = ""REF4""

    # PROPERTIES ##
    @property
    def measurement(self):
        """"""
        Gets a specific oscilloscope measurement object. The desired channel is
        specified like one would access a list.

        :rtype: `TekTDS5xx.Measurement`
        """"""
        return ProxyList(self, self.Measurement, range(3))

    @property
    def channel(self):
        """"""
        Gets a specific oscilloscope channel object. The desired channel is
        specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.channel[0].read_waveform()

        :rtype: `TekTDS5xx.Channel`
        """"""
        return ProxyList(self, self.Channel, range(4))

    @property
    def ref(self):
        """"""
        Gets a specific oscilloscope reference channel object. The desired
        channel is specified like one would access a list.

        For instance, this would transfer the waveform from the first channel::

        >>> tek = ik.tektronix.TekTDS5xx.open_tcpip('192.168.0.2', 8888)
        >>> [x, y] = tek.ref[0].read_waveform()

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""REF{idx + 1}""),
            range(4),
        )

    @property
    def math(self):
        """"""
        Gets a data source object corresponding to the MATH channel.

        :rtype: `TekTDS5xx.DataSource`
        """"""
        return ProxyList(
            self,
            lambda s, idx: self.DataSource(s, f""MATH{idx + 1}""),
            range(3),
        )

    @property
    def sources(self):
        """"""
        Returns list of all active sources

        :rtype: `list`
        """"""
        active = []
        channels = list(map(int, self.query(""SEL?"").split("";"")[0:11]))
        for idx in range(0, 4):
            if channels[idx]:
                active.append(self.Channel(self, idx))
        for idx in range(4, 7):
            if channels[idx]:
                active.append(self.DataSource(self, f""MATH{idx - 3}""))
        for idx in range(7, 11):
            if channels[idx]:
                active.append(self.DataSource(self, f""REF{idx - 6}""))
        return active

    @property
    def data_source(self):
        """"""
        Gets/sets the the data source for waveform transfer.

        :type: `TekTDS5xx.Source` or `TekTDS5xx.DataSource`
        :rtype: `TekTDS5xx.DataSource`
        """"""
        name = self.query(""DAT:SOU?"")
        if name.startswith(""CH""):
            return self.Channel(self, int(name[2:]) - 1)

        return self.DataSource(self, name)

    @data_source.setter
    def data_source(self, newval):
        if isinstance(newval, self.DataSource):
            newval = TekTDS5xx.Source(newval.name)
        if not isinstance(newval, TekTDS5xx.Source):
            raise TypeError(
                ""Source setting must be a `TekTDS5xx.Source`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""DAT:SOU {newval.value}"")
        time.sleep(0.01)  # Let the instrument catch up.

    @property
    def data_width(self):
        """"""
        Gets/Sets the data width for waveform transfers

        :type: `int`
        """"""
        return int(self.query(""DATA:WIDTH?""))

    @data_width.setter
    def data_width(self, newval):
        if int(newval) not in [1, 2]:
            raise ValueError(""Only one or two byte-width is supported."")

        self.sendcmd(f""DATA:WIDTH {newval}"")

    def force_trigger(self):
        raise NotImplementedError

    @property
    def horizontal_scale(self):
        """"""
        Get/Set Horizontal Scale

        :type: `float`
        """"""
        return float(self.query(""HOR:MAI:SCA?""))

    @horizontal_scale.setter
    def horizontal_scale(self, newval):
        self.sendcmd(f""HOR:MAI:SCA {newval:.3E}"")
        resp = float(self.query(""HOR:MAI:SCA?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set Horizontal Scale to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_level(self):
        """"""
        Get/Set trigger level

        :type: `float`
        """"""
        return float(self.query(""TRIG:MAI:LEV?""))

    @trigger_level.setter
    def trigger_level(self, newval):
        self.sendcmd(f""TRIG:MAI:LEV {newval:.3E}"")
        resp = float(self.query(""TRIG:MAI:LEV?""))
        if newval != resp:
            raise ValueError(
                ""Tried to set trigger level to {} but got {}""
                "" instead"".format(newval, resp)
            )

    @property
    def trigger_coupling(self):
        """"""
        Get/Set trigger coupling

        :type: `TekTDS5xx.Coupling`
        """"""
        return TekTDS5xx.Coupling(self.query(""TRIG:MAI:EDGE:COUP?""))

    @trigger_coupling.setter
    def trigger_coupling(self, newval):
        if not isinstance(newval, TekTDS5xx.Coupling):
            raise TypeError(
                ""Coupling setting must be a `TekTDS5xx.Coupling`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:COUP {newval.value}"")

    @property
    def trigger_slope(self):
        """"""
        Get/Set trigger slope

        :type: `TekTDS5xx.Edge`
        """"""
        return TekTDS5xx.Edge(self.query(""TRIG:MAI:EDGE:SLO?""))

    @trigger_slope.setter
    def trigger_slope(self, newval):
        if not isinstance(newval, TekTDS5xx.Edge):
            raise TypeError(
                ""Edge setting must be a `TekTDS5xx.Edge`""
                "" value, got {} instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SLO {newval.value}"")

    @property
    def trigger_source(self):
        """"""
        Get/Set trigger source

        :type: `TekTDS5xx.Trigger`
        """"""
        return TekTDS5xx.Trigger(self.query(""TRIG:MAI:EDGE:SOU?""))

    @trigger_source.setter
    def trigger_source(self, newval):
        if not isinstance(newval, TekTDS5xx.Trigger):
            raise TypeError(
                ""Trigger source setting must be a ""
                ""`TekTDS5xx.Trigger` value, got {} ""
                ""instead."".format(type(newval))
            )

        self.sendcmd(f""TRIG:MAI:EDGE:SOU {newval.value}"")

    @property
    def clock(self):
        """"""
        Get/Set oscilloscope clock

        :type: `datetime.datetime`
        """"""
        resp = self.query(""DATE?;:TIME?"")
        return datetime.strptime(resp, '""%Y-%m-%d"";""%H:%M:%S""')

    @clock.setter
    def clock(self, newval):
        if not isinstance(newval, datetime):
            raise ValueError(
                ""Expected datetime.datetime "" ""but got {} instead"".format(type(newval))
            )
        self.sendcmd(newval.strftime('DATE ""%Y-%m-%d"";:TIME ""%H:%M:%S""'))

    @property
    def display_clock(self):
        """"""
        Get/Set the visibility of clock on the display

        :type: `bool`
        """"""
        return bool(int(self.query(""DISPLAY:CLOCK?"")))

    @display_clock.setter
    def display_clock(self, newval):
        if not isinstance(newval, bool):
            raise ValueError(""Expected bool but got "" ""{} instead"".format(type(newval)))
        self.sendcmd(f""DISPLAY:CLOCK {int(newval)}"")

    def get_hardcopy(self):
        """"""
        Gets a screenshot of the display

        :rtype: `string`
        """"""
        self.sendcmd(""HARDC:PORT GPI;HARDC:LAY PORT;:HARDC:FORM BMP"")
        self.sendcmd(""HARDC START"")
        time.sleep(1)
        header = self._file.read_raw(size=54)
        # Get BMP Length  in kilobytes from DIB header, because file header is
        # bad
        length = reduce(operator.mul, struct.unpack(""<iihh"", header[18:30])) / 8
        length = int(length) + 8  # Add 8 bytes for our monochrome colour table
        data = header + self._file.read_raw(size=length)
        self._file.flush_input()  # Flush input buffer
        return data
"
394,https://download.tek.com/datasheet/DPO4000-Digital-Phosphor-Oscilloscope-Datasheet-48W1903210.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attZKmurDfbgmKnMC'), ('width', 620), ('height', 413), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/D_XodAFF40Szpq6PvDrRtw/tjU3kN5KNHOKSZVcCw5PCgmVYfmIZ4FIdNFcEvokX09HLIvyq73WESCjwMHnnx8_kqa0Ev3TqD0WyEBIKTWKL4rTSIZxCSzb-T80V48UnUSTcfEDQDV3dqd-DxRTUFSF/UM94zSYAxhMKiWtwa6P8nPtFAkBHR4nrmiHQV7GJkqY'), ('filename', 'Tektronix_MSO_DPO4000.jpg'), ('size', 63004), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FmjSPk7tXsBHw69OJumM7w/r4wqeoJN7W3gezZktnzMRXur7tSwMrcYb_q7HxKhPu73lsZBBFOTX86HDd34acwc7qYD18ij8BlSSMjS-h5jcQ/7oQTlJYYmaMgduxaiW2gbpK2YJek2X6xganEYIimhec'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xaqVIKVv8cF_NtTihXxGBA/hvs930thOmwaj_JAbh1cmy99C9H_oL6ss9KHjA4dLnIKJVNmALbxL5jRkoxDeuMcga6rnNBKnRr3llYuDKg3EQ/1B9vo0_y3_ZDul5UOl1jbYktjLCaUr4eSTz0T3chjJk'), ('width', 620), ('height', 413)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/91dvpFuabIBVaqiYrmWHaA/qjiZCvDhL9VgVO0PLVo2xx9n6b2f2RolkCdLGkx0f-CSXWOVr9EI66l8fQqrV52n9zeQXxNGRoHSz8pvDla-GA/Kvf0pB8w7PABCTywAmGbovy-HiNJSd3Wm7XLPOVA7qU'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The DPO4104 Digital Phosphor Oscilloscope delivers the performance you need to visualize even your most demanding signals. With a 1 GHz Bandwidth and offering a minimum of 5x oversampling on all channels and si (x)/x interpolation standard, you can be confident that even the fastest transient events will be captured and displayed accurately. The standard 10 M record length on all channels enables you to capture long windows of signal activity while maintaining fine timing resolution.",https://www.valuetronics.com/product/dpo4104-tektronix-digital-oscilloscope-used,Tekdpo 4104,549.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo4104-oscilloscope,Instrumentkit,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo4104.py,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782769/Instruments/Oscilloscopes/DPO4104/DPO4104.jpg,DPO4104,Write a Python script that uses Instrumentkit to connect to a DPO4104 Oscilloscopes,7995.0,,True,,
