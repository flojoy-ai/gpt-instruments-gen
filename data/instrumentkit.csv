,"Yearly revenue (millions, USD)",Vendor headquarters,Device Description,Device,Field 1,Vendor wikipedia or cruncbase description,Library,Vendor,Vendor logo,Vendor website,ChatGPT prompt,Category description link,Device Category,Category Description,Corrected device name,Device datasheet (PDF),Device picture,Device Description Link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Python docs link,Device Price,ChatGPT code,Obsolete,Notes,docstring
4,550.0,USA,"The PM100USB Power and Energy Meter Interface is compatible with all our C-Series photodiode, thermal, and pyroelectric sensors except for the ES408C Fast Pyroelectric Sensor. Our C-Type standard photodiode, slim photodiode, integrating sphere, and fiber sensors can collectively measure optical powers from 100 pW to 20 W. Our thermal power sensors measure optical powers from 10 µW to 200 W. Compatible C-Series pyroelectric energy sensors can measure energies from 10 µJ to 15 J and repetition rates up to 2 kHz. Note that the ES408C sensor for repetition rates up to 10 kHz, also available below, is not recommended for use with the PM100USB interface, which supports a maximum repetition rate of 3 kHz. Alternatively, other unamplified anode- or cathode-grounded photodiodes with up to 5 mA photocurrent, thermal elements with a maximum output voltage of 1 V, or energy sensors with voltage outputs from 100 mV to 100 V may be used.

This interface can be operated and powered by a PC via the mini-USB port. A readout rate of 300 samples per second allows active signal monitoring while the interface is in use.",PM 100 USB,606.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a PM100USB Power Meters,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037,['Power Meters'],These interfaces provide communication between an attached sensor and a PC or other external control unit. They are designed to be controlled via an external device or operated autonomously using the analog output; there are no controls or display screens.,PM100USB,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,"[OrderedDict([('id', 'attE3gJZRoLQpO3nR'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u9yxz2mGJwXk9-sqJ-jA-w/1kfa_6mTm5oW6Oc43Cm0iZ9UHdASNSpt1GBrUnyot5Mnz3Y0vClYN5-px_DnnZvx-N8Y9uKoQ6RhuoKFIOMOEHu7ENLiZkc5LsD3wYjch28/u5xYF5zpMeuPxAaHkfRE34l4MQCB61ySgdx5LyM6vA8'), ('filename', '8135_PM100USB_SGL.jpg'), ('size', 136075), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DMPm05o62axN-oGlsHAJRw/awYpa6kU-vzlFUHMzAel4aBtaaixEpOySDV_zVTo10jfQrd2q25yr9qNJEodfLHwMVJB9GpfbEiJAV5LyWHAzA/UpD6jT-fj1HEBRwWqgb69lm8XpyxWvaTdkhfdBADm1U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BdYfwbP9HF317VUk2iAOvA/gX_qmzcN4FYo6SIupA93Mw28Nvv2ql6dhOWBNM1GFEkMLLMsBCS-7SMsQjgSndij9TPcJY61U9iV4elm559jTg/9bH9OFVqgwrySW8OJp16C-jiPrFhcPTpRG6-NpsFddk'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RBdLXvxYWXR5TrCYpQ2H4w/Ot_TJejADKRgrnsUOk9dPTe1bjSf-OZ3aXTDTCHGEqwfEvPdzgCxYbbqZfNv73XRsd6UQcyptMGiyrrBmvM9eQ/nxIOoYJ1jjOvl3kFhSiqEH_H26yZha7s0hRgaKkJk2w'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037&pn=PM100USB,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/pm100usb.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#pm100usb-usb-power-meter,487.99,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
5,3500.0,"Irvine, California, United States","The model 8742 is a 4-axis open-loop intelligent motion controller/driver that provides a compact and low cost solution for driving New Focus open-loop Picomotors products. It is a single-box solution that can be computer controlled via USB and Ethernet communication interfaces using Newport Motion Control Language (NMCL) command set. Both interfaces are well supported via Windows DLL, sample LabVIEW™VIs, and intuitive graphical user interface (GUI) Windows application with device auto-discovery feature. Each model 8742 controller/driver can control one of four 4-pin RJ-22 single output ports for use with any single-channel Picomotor actuator at any given time. The model 8725 multi-axis adapter can be used to connect the 4-pin RJ-22 output ports on the drivers to New Focus™ Picomotor products with 6-pin RJ-11 connectors. Note: Power Supply not included",Picomotorcontroller 8742,384.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Instrumentkit,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",,https://www.newport.com/medias/sys_master/images/images/h8e/hfa/8797030088734/8742-Datasheet.pdf,"[OrderedDict([('id', 'attloDMGvxGciAsjA'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cSNToY6-xQOD_BehvV7FSw/U3Z9UPOy4ZoO4Ojw_67MtywRcu7XJMAhFTuVhbPlTEZrYxDYRCFQl7wbBjUh_sX5E2RVNXZ9z6Xc4bF2fFnzmG2QnRxV1ekpLLizaRCQgEE/YfXwkDrAxmPoXBN6tKT3F5qMQbGwPOGy_m9AC8FlxsY'), ('filename', '8742_with_RS485_400w.jpg'), ('size', 22135), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JhuIuohPRdtG2XDw-onMYw/UIROTbKAPsuFOSa0OLtH1dh9l3ynLFEwGgzk_xFC_Qy8ecq3VBaZRcP6S3EU4vnM7KkaDWhL6tFytFHgUnt9ZA/9ZAmpdUpMuEHk0vQPtrhL0LuyTAIy_wCcIe2kKLe9OQ'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lu1DSlw3UPYn3EwiDRY6gA/0ax5vtzRIXV8NfZJAAaKpoxXe9XVU_IaH8_ep1KNgIsFu5vZ90JsTtgbeOwR8cz_SojhmUwGKBGIbU3y3CWPfg/1spaZK11chAcs7dKS8yagnOB4AwuQohzr5fNClEZGiA'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XGqbqyEADMlp8LNPqM5R7w/qcQD48HhBDQnc9vcqq90cBCUda1bwsTtNhwuUwJU4Nei_5BWr8I8QJK170BptyedeP8L4Yr1P1jfkX245pyWXQ/4Pj6tM5fFwizog0onlfqFMIcEtBjr_pin3sDXY1pUfg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/p/8742,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newport_pmc8742.py,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#picomotorcontroller8742,1260.0,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
21,3500.0,"Irvine, California, United States","The ESP301-3N 3 Axis Motion Controller and Driver is the successor of the popular ESP300 motion controller. The ESP301 provides the same functionality as the ESP300 with a standard USB interface and extended front panel functions. For maximum backward compatibility, the ESP301 features the same motion commands and control algorithms and the same casing as the ESP300. The ESP301-3N drives and controls up to three axes of motion using any combination of DC or 2-phase stepper motors up to 3A per axis. This capability enables driving a large selection of Newport stages and actuators. Featuring an integrated manual front panel interface and Newport's unique ESP stage auto-detection and auto-configuration, the ESP301 provides most easy operation and excellent functionality at an affordable price.",Newportesp 301,386.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Instrumentkit,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",,https://www.newport.com/medias/sys_master/images/images/hda/h3e/9117547069470/ESP301-User-s-Manual.pdf,"[OrderedDict([('id', 'attIAGKtQzOcnhr4i'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-ojIIaVAIf2hy9A5vMuL6A/JgVM0EVf3lU36PYGTYRncupoBuCICiiDm05FBUacQfwUDqR5HAqakSt4KaKoEVkXgSzP14zYOoEfLUFCcoQL283YSY7RYf-DMIv0DB4pecAI-dUrcZBAzBGtCbeOo6JN/HaJh9jRZvG6SNmou7Cn-BLKNQ3CMJCGcBuKfBV1W4xA'), ('filename', 'MC-ESP301_06_Position_400w.jpg'), ('size', 11025), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zfN6c_DXRzFxvvrBqPanXg/rhfkmJfapfYN5Fc-dUdyVBHrKvzveGrBNCDX79eBf1mmlDgzNW1jJC38b3gPuHScQaoGgpjhXbFIl-nGjVSEpQ/mY5lL-2ymyxjphNb6N0tDR8OqMbg10oXoZtgyDsK_98'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q5uVUAagu1iFVNq_e6VAAQ/wJ1cZqipoVuYAJS7RmqdbgjbXpw-1iWS5hnQQz8VOXmhXPtTgw-U_2EhG1gfgK1TB-gxCRlECSLAhW0ipKGe_w/DL6yE5JzieeWgO0wq7W8vl68UR26Ofn_NAua78TRd34'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_I97ynkUfMwmObQuIO5rVg/iu49JWXX8_q_kN0T1D8UntrslffnKlAkOzL8eUZP956EuE-4rgMugVAHqQeoVRkUPK20gd3Cg83T-NMqPkpHTg/orcQjGO-NMosRPXRH28GSYTALuvoKGnn6zr3JHyZVcw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/p/ESP301-3N,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/newportesp301.py,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newportesp301-motor-controller,,,True,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
24,5800.0,USA,,Tektds 224,547.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS224 ,,,,TDS224,,,,,,,,,,
29,110.6,"Cleveland, Ohio, United States","The Keithley 485 Autoranging Picoammeter provides 100fA sensitivity with 4 1/2-digit resolution in a low-cost, highly sensitive, easy-to-use instrument. The 485 measures DC current on seven ranges covering 10 decades from 100fA to 2mA. The input can withstand overloads as high as 1000V (with 100kΩ limiting resistor) for flexibility in a wide range of applications in test, research, and student labs. An analog output linearly converts the incoming current to voltage for hard copy output or control loop applications.
",Keithley 485,237.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Electricity_meter,['Power Meters'],"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-485-Datasheet.pdf,"[OrderedDict([('id', 'attvUEoTPINWnGzN5'), ('width', 600), ('height', 318), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/952bEWlqCVNHmtag1pJbkw/eMZlX4ltoVWD49pYvGIuERyWrr-VDxhlQ5Z7Xt6COerj2pZAKk8EmVw8hh_AILjxa2RuEqgZwZF3XHjNGkyxmv0P2J7KlFtrBv42hK7ateI/IHD-hnEVCmj9htFecuLgbN8oRL89tCOdHlHaXbDSRp4'), ('filename', 'Keithley_485_View5.jpg'), ('size', 71051), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qwQ-LiOk8GOx-vuZTiR8eg/af7S70niKmW73pmXpD9GFVhfEXeMlB9TWKROkcZJ_2wx84prJBwOqbzyBEChdRdY15eQY2f4uVi5lqWvHEvnkQ/pgrRayXm8aV7lm5SWEspweBMYi7eQLSGbVAD7PramqE'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tMKsKSSHCnHBN7d-HJsTYQ/m1HyojAvg-49WCDQL3U3KT6QNahf-ys9V6s-WjE_0yCgAkEMNklzk6y6igULpNIlOlLv8LX8h15Pz26On59hyw/aCzWPWAFeUvmQeHG-takKOhYMUXK9xbHnIj8Ds_ezoc'), ('width', 600), ('height', 318)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5LEQh4nXpSOcvkJ1OJYzAw/5MMV1FuLBztBK_TbpHXWayVtn_EDHfcoXetY6wwlDys3nWE4AYJppji_P5CRMJBrA4kOKovEZIZzgysuWZxC9Q/u41G3RneyUzjOVSPx9sOJ93RKdDjwohqoU1IVZhVqkY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/67358-1/Keithley-485-Autoranging-Picoammeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley485.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley485-picoammeter,,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
39,110.6,"Cleveland, Ohio, United States","The two-channel Model 2182A Nanovoltmeter is optimized for making stable, low noise voltage measurements and for characterizing low resistance materials and devices reliably and repeatably. It provides higher measurement speed and significantly better noise performance than alternative low voltage measurement solutions. It offers a simplified delta mode for making resistance measurements in combination with a reversing current source, such as the Model 6220 or 6221.",Keithley 2182,250.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Voltmeter,['Power Meters'],A voltmeter is an instrument used for measuring electric potential difference between two points in an electric circuit. It is connected in parallel. It usually has a high resistance so that it takes negligible current from the circuit.,,https://download.tek.com/datasheet/2182A-15912.pdf,"[OrderedDict([('id', 'attKCSe2wix9ghzw6'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pIYh5wNHL1jBzhXTknwllg/mCaoUWPX9Qtch1qCCeS3LUUa7-8MQsZUEDqpI2EijUqRw4KMNHKhHtAl_wl0tLL_LLnRf9W1nDdLu9k292xhdw/bXK7I5tITNEd7LuIVY2rPVVz07VWCFe5IUj00k8A6hU'), ('filename', '2182.jpg'), ('size', 23819), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MtFaFRohvYjv3kvGz8vFqw/wYEa2VWsFQKmkIn1lUIa9yLAg9j1PVPsVgfKjrfyqXtOaD_03nB97hIrFTvRTrIFtqJXN_hLV_oaEiNft8tRrQ/ExWyWTyXH5PMwMr_ggwY-eqDB6hWp7JSYjWUQRZqD2A'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-Lj4qgtF0nEfVQY0lggerg/U70oon2ZzhdtEEvLx4zw9K7q2SmP7MmkpB5euYp9iyoMm-qPly7Sz07LbXy6tjNChvR5hW3uVHZrqWCznaSaBQ/PEqiADAltRzLlUYsjYlWxLKDanyD4OFyoADVyCN427s'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZzchJCzgtPXeCb2hntw4dg/LupUhcSuhr-Uzc5RPXJo7djB0xBEAYZr8nZ1MFMEtzttsDlj9qYEMjd5ZMF-u0_I-kirHhB4v_UPFEFtznB8_w/JzxF6WzizNeSNWqFfeavdaTqp9VVsxHF9Y31qc456LA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/nanovoltmeter-model-2182a,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley2182.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley2182-nano-voltmeter,7500.0,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
47,5.0,"Vista, California, United States",Qubitekk’s 2-channel Coincidence Counter provides researchers with a low-cost solution for nanosecond resolution coincidence counting. A third gating channel makes the counter suitable for use with pulsed sources.,CC1,432.0,"Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",Instrumentkit,Qubitekk,"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_fNYJEtBJV9okXsIo-8vow/vS4kLPigoJgfMmi4ZsOkgM0dD-le_4oikqQVc9TWe3KagVp5y1fbcYEhJ6mlaHqSKzf_vuEjsYNGlhclzYE23LYSgEUz4D5oOdL1-4hrjWtq7CSCYdTjNhv0UFBgZQxC/hZBNGlg2bFWGXuCw3YrDZiW4ZnhDsp6Va2K0X67f3bg'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Ybph2quaq9LjCwcez_fDQ/vQ7BOadlnCLommpydj4GNZbamMQkMLlZnzwGu8-qPxhmGsdggku8oECCbFODA_VwJzN_3yA7gzUHIN98B6s1-A/Pc2AHNi5G5qtdLtaTDAwRaSDn8WTNVWE4TSUVBgmgGY'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EeM2EkrBHOahu1BiwPu2yw/Ep7ZkJ429CVbmQh4kAF_DKMrkYk7fUujJ86Gh0XskGW3jd1WeCe0aUZy539MIPtgsv78sJ2XAtnOI8-9WXiHVQ/QyukOuVa6S4xsDMTkNWp2whkZgWOcQeG-u4vTUDJ4YQ'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rpG9gmSfNrKHatCgSBZCzQ/-GYzSYqwePXEXd_Ia-Wx5uhTSqJjj_FPIY5J5xkmsbzpa0YzaOqeFMkwADieU_jM1Rm2CCG5s5HyeFUcB0dXSg/a72MWvNqvjQYWMYE_pJ-xgv4wDusUn313a940PXLlWQ'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Coincidence Counter,https://en.wikipedia.org/wiki/Coincidence_counting_(physics),['Coincidence Counter'],"In quantum physics, coincidence counting is used in experiments testing particle non-locality and quantum entanglement. In these experiments two or more particles are created from the same initial packet of energy, inexorably linking/entangling their physical properties. Separate particle detectors measure the quantum states of each particle and send the resulting signal to a coincidence counter. In any experiment studying entanglement, the entangled particles are vastly outnumbered by non-entangled particles which are also detected; patternless noise that drowns out the entangled signal. In a two detector system, a coincidence counter alleviates this problem by only recording detection signals that strike both detectors simultaneously (or more accurately, recording only signals that arrive at both detectors and correlate to the same emission time). This ensures that the data represents only entangled particles.",,,"[OrderedDict([('id', 'attW3pZ1U5zs32JXd'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/m1DEK4Y-qSbpVrKk0O3zVw/Bxn6shL0zHB_3WMasT5VomPv1Rj7NQGXw4EWScqSRhWm8T4G-_WSp6d5w1fyK-A3ZSgDmPtgVHF4ZDoIcJAxBR4YMj7sk1qmGlsOjfeiyC8Jnjxy4FxExytjU90D6dH7/VnPmcLDsVbrWz_yf9DjBCkOIzUmcog7rGA8BCgyhtuE'), ('filename', 'QBTK006_Handheld_Coincidence_Counter.jpg'), ('size', 43231), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2GglJ7CGl74FvcaHIBSC_Q/mH7U1T4N9AkdhOlOXVqH36g10foV4a-JPeKXtg6lvFTxCJD1Os_eCW5WrHp4Jc8cKpbOqkrTYpRXNcRcFgtyEQ/vQ9FmNxnCLxrx8XkDvqQn1ddbtdED4ayhxII8pACyZA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rAOmG-wCEkxvvq_zpQvh4w/f_GEusDe4IMJ00GdzI1Jt32Xdm2nWFQbYaH7iwPNdPvNlxnkBI-XTHV_9quVlut5FmDkdnqmQoKugnmyGSztyw/nzEKG0C3wFXEbldHGlROGSlx0r6Fk3Gwv1p4AHwC5U8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JGxBZd5CLImiuwpiW9q1IA/NK-iEUVbmDnD-Kcg2ACixmuKvA4PNe-_fpbFdZo5zgk350zhkq-Rz2f_gnHv1d3kxV4P9zVQXza9dtC0MUe5xQ/XLaZDwPdzxR8LVgOoVJI0TiSIOLsCVjMG98ydXkTtWE'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/products/coincidence-counter/,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/cc1.py,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#cc1-coincidence-counter,,,,,"

Source code for instruments.qubitekk.cc1
#!/usr/bin/env python
""""""
Provides support for the Qubitekk CC1 Coincidence Counter instrument.

CC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi.scpi_instrument import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units, split_unit_str

# CLASSES #####################################################################


class CC1(SCPIInstrument):

    """"""
    The CC1 is a hand-held coincidence counter.

    It has two setting values, the dwell time and the coincidence window. The
    coincidence window determines the amount of time (in ns) that the two
    detections may be from each other and still be considered a coincidence.
    The dwell time is the amount of time that passes before the counter will
    send the clear signal.

    More information can be found at :
    http://www.qubitekk.com
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\n""
        self._channel_count = 3
        self._firmware = None
        self._ack_on = False
        self.sendcmd("":ACKN OF"")
        # a readline is required because if the firmware is prior to 2.2,
        # the cc1 will respond with 'Unknown Command'. After
        # 2.2, it will either respond by acknowledging the command (turning
        # acknowledgements off does not take place until after the current
        # exchange has been completed), or not acknowledging it (if the
        # acknowledgements are off). The try/except block is required to
        # handle the case in which acknowledgements are off.
        try:
            self.read(-1)
        except OSError:
            pass
        _ = self.firmware  # prime the firmware

        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            self._bool = (""ON"", ""OFF"")
            self._set_fmt = "":{}:{}""
            self.TriggerMode = self._TriggerModeNew

        else:
            self._bool = (""1"", ""0"")
            self._set_fmt = "":{} {}""
            self.TriggerMode = self._TriggerModeOld

    def _ack_expected(self, msg=""""):
        return (
            msg
            if self._ack_on and self.firmware[0] >= 2 and self.firmware[1] > 1
            else None
        )

    # ENUMS #

    class _TriggerModeNew(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""MODE CONT""
        start_stop = ""MODE STOP""

    class _TriggerModeOld(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""0""
        start_stop = ""1""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a channel on the Qubitekk CC1.
        """"""

        __CHANNEL_NAMES = {1: ""C1"", 2: ""C2"", 3: ""CO""}

        def __init__(self, cc1, idx):
            self._cc1 = cc1
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        # PROPERTIES #

        @property
        def count(self):
            """"""
            Gets the counts of this channel.

            :rtype: `int`
            """"""
            count = self._cc1.query(f""COUN:{self._chan}?"")
            tries = 5
            try:
                count = int(count)
            except ValueError:
                count = None
                while count is None and tries > 0:
                    # try to read again
                    try:
                        count = int(self._cc1.read(-1))
                    except ValueError:
                        count = None
                        tries -= 1

            if tries == 0:
                raise OSError(f""Could not read the count of channel "" f""{self._chan}."")

            self._count = count
            return self._count

    # PROPERTIES #

    @property
    def acknowledge(self):
        """"""
        Gets/sets the acknowledge message state. If True, the CC1 will echo
        back every command sent, then print the response (either Unable to
        comply, Unknown command or the response to a query). If False,
        the CC1 will only print the response.

        :units: None
        :type: boolean
        """"""
        return self._ack_on

    @acknowledge.setter
    def acknowledge(self, new_val):
        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            if self._ack_on and not new_val:
                self.sendcmd("":ACKN OF"")
                self._ack_on = False
            elif not self._ack_on and new_val:
                self.sendcmd("":ACKN ON"")
                self._ack_on = True
        else:
            raise NotImplementedError(
                ""Acknowledge message not implemented in "" ""this version.""
            )

    @property
    def gate(self):
        """"""
        Gets/sets the gate enable status

        :type: `bool`
        """"""
        return self.query(""GATE?"").strip() == self._bool[0]

    @gate.setter
    def gate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""GATE"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def subtract(self):
        """"""
        Gets/sets the subtract enable status

        :type: `bool`
        """"""
        return self.query(""SUBT?"").strip() == self._bool[0]

    @subtract.setter
    def subtract(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""SUBT"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode setting for the CC1. This can be set to
        ``continuous`` or ``start/stop`` modes.

        :type: `CC1.TriggerMode`
        """"""
        return self.TriggerMode(self.query(""TRIG?"").strip())

    @trigger_mode.setter
    def trigger_mode(self, newval):
        try:  # First assume newval is Enum.value
            newval = self.TriggerMode[newval]
        except KeyError:  # Check if newval is Enum.name instead
            try:
                newval = self.TriggerMode(newval)
            except ValueError:
                raise ValueError(""Enum property new value not in enum."")
        self.sendcmd(self._set_fmt.format(""TRIG"", self.TriggerMode(newval).value))

    @property
    def window(self):
        """"""
        Gets/sets the length of the coincidence window between the two signals.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units nanoseconds.
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(*split_unit_str(self.query(""WIND?""), ""ns""))

    @window.setter
    def window(self, new_val):
        new_val_mag = int(assume_units(new_val, u.ns).to(u.ns).magnitude)
        if new_val_mag < 0 or new_val_mag > 7:
            raise ValueError(""Window is out of range."")
        # window must be an integer!
        self.sendcmd(f"":WIND {new_val_mag}"")

    @property
    def delay(self):
        """"""
        Get/sets the delay value (in nanoseconds) on Channel 1.

        When setting, ``N`` may be ``0, 2, 4, 6, 8, 10, 12, or 14ns``.

        :rtype: `~pint.Quantity`
        :return: the delay value
        """"""
        return u.Quantity(*split_unit_str(self.query(""DELA?""), ""ns""))

    @delay.setter
    def delay(self, new_val):
        new_val = assume_units(new_val, u.ns).to(u.ns)
        if new_val < 0 * u.ns or new_val > 14 * u.ns:
            raise ValueError(""New delay value is out of bounds."")
        if new_val.magnitude % 2 != 0:
            raise ValueError(""New magnitude must be an even number"")
        self.sendcmd("":DELA "" + str(int(new_val.magnitude)))

    @property
    def dwell_time(self):
        """"""
        Gets/sets the length of time before a clear signal is sent to the
        counters.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units seconds.
        :type: `~pint.Quantity`
        """"""
        # the older versions of the firmware erroneously report the units of the
        # dwell time as being seconds rather than ms
        dwell_time = u.Quantity(*split_unit_str(self.query(""DWEL?""), ""s""))
        if self.firmware[0] <= 2 and self.firmware[1] <= 1:
            return dwell_time / 1000.0

        return dwell_time

    @dwell_time.setter
    def dwell_time(self, new_val):
        new_val_mag = assume_units(new_val, u.s).to(u.s).magnitude
        if new_val_mag < 0:
            raise ValueError(""Dwell time cannot be negative."")
        self.sendcmd(f"":DWEL {new_val_mag}"")

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                if self._firmware.find(""Unknown"") >= 0:
                    self._firmware = None
                else:
                    value = self._firmware.replace(""Firmware v"", """").split(""."")
                    if len(value) < 3:
                        for _ in range(3 - len(value)):
                            value.append(0)
                    value = tuple(map(int, value))
                    self._firmware = value
        return self._firmware

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> cc = ik.qubitekk.CC1.open_serial('COM8', 19200, timeout=1)
        >>> print(cc.channel[0].count)

        :rtype: `CC1.Channel`
        """"""
        return ProxyList(self, CC1.Channel, range(self._channel_count))

    # METHODS #

    def clear_counts(self):
        """"""
        Clears the current total counts on the counters.
        """"""
        self.sendcmd(""CLEA"")


"
49,3.0,USA,"HS9008B - 8 Channel, 1U RF Synthesizer - Phase Coherent","Holzworth HS 9000 
",169.0,"**Holzworth** Instrumentation is a leader in high-performance phase noise analyzers and RF/microwave synthesizers optimized for ultra-low phase noise
",Instrumentkit,Holzworth,"[OrderedDict([('id', 'attbKqwLCO8edU9zL'), ('width', 410), ('height', 116), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BViJd0kAjMT0p1I70jOndw/RbMevAba37Wk98_3s5dc99JuIDx-pQOt3GNAnX5WY8clwBtCy2ZGUnfGDBKB9tZoQpcExTifhwACt3PkZvOK6LXy9Hr_fmOiwYGmDZ-NfF0/NqEYyePbCZHC-2j9SVSNmFNDYTI2VyqCPXM5XZp5PFE'), ('filename', 'logo-Holzworth.jpg'), ('size', 8728), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EE0npAZn7fiaF1aSu4v6UA/_BHzgBqIBqnqQxztw6VT2qjl804nQ9Czeiyarrlt2tdKu00VTDA_fRYBGcc7ZWE5V-mp4eYw6_671lFHqIX2LA/_2OZ_xTf9VqVx8FQfBo877OGulaKwYsE-zpOaW3FuSE'), ('width', 127), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YuZKTBx8ryX5RiXWflddXQ/Vk0ChFf5GEJ8qm9cSqqcfO-3PhYzJVXMvCTX9etxfIpJs4S4or8RVV1HBDXOfM1B6_QeapLG6U_uZEwgwsykvg/W0jw8HlbkkvIfAOmPhhw1gG2AtA3G2GVN9otmgnOI58'), ('width', 410), ('height', 116)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GLfTreoSJpgHF-iqVwFE0g/61rLHhDTblD8LG0WfveSvs_aZ0OBIJAylPZxk-uHBpMTWN_Vzgq3qNxwHADDvT86caA8aNADD0pssauucjlBpw/0R5ODA_zH0c_m0PbfQjWwuqceTsdpa7UusVCvvgBYs8'), ('width', 3000), ('height', 3000)]))]))])]",https://holzworth.com,Write a Python script that uses Instrumentkit to connect to a HS 9008B Frequency synthesizer,https://en.wikipedia.org/wiki/Frequency_synthesizer,['Frequency synthesizer'],A frequency synthesizer is an electronic circuit that generates a range of frequencies from a single reference frequency.,HS 9008B,https://holzworth.com/Portals/0/datasheets/hs9000-series_datasheet.pdf,"[OrderedDict([('id', 'atteUTJEKY0DRYxo5'), ('width', 80), ('height', 60), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rnBsr3WB2jdrNDL70OqzIw/VsqpS2ZEP2y6XUbbLWFDIHcBdxuxhZ5QcQOaqvRpbglqtDzWsmrdANITd_XS1F4JP3BvoT_bJw1-P5CK2Ca_S3WlB1osx16Jo7W3zU7S5bA/vUtWyF4L0PC8Vyz91egQkwG10gNgcXyKKnjn8cbCjuU'), ('filename', 'hs9008b-right-face.jpg'), ('size', 2821), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lrksDNeTJ7E1iEIfptd8qA/9RZ-mRVT4OaABU5sI1FVuYilbKI79SHzm9963mOFojwWAHODXj5Sp9T8wZ0p78LJSlXmQLQfknSROcQFuJZLsQ/hh7zeTWLQ1-V_hapwJH2nZV0J7Hd6mULxzNr1Adg_4g'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r2vU6eH0fFDRYa8NUSfkZw/3VIYKpOSCUSJimY4F6V8eoZFMSrErghYNfEpe4s9e1MY-4jijWohKQuhQhUooHMS-Whc-9hon4J--wAaLACWCQ/9WPMreHM1oz1IzXCvL_EVDX1B2GrqqHh_5_grh9Qwko'), ('width', 80), ('height', 60)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Sb7dSmt8iH9WdYgJc3txpg/Sd94xU9me-V_6ewZmU9xr_mMSQ4Jw2KkPVwRxCGB65zEAYCxTuI5AIiz8gOI3d_wX__eOAPkN1HGo4DSwww20A/0WjSej6on6f_76u7Lcb8KyEIP8zO2_ALB9JAyU_j0kc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.testforce.com/products/additional-products/accessories/hs9008b.html,https://qcodes.github.io/Qcodes_contrib_drivers/_modules/qcodes_contrib_drivers/drivers/Holzworth/HS9008B.html,,6700.0,,,,
50,3500.0,"Irvine, California, United States",,Newporterror,382.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Instrumentkit,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} ,,,,,,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/errors.py,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#newporterror,,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
61,318.0,Japan,"The 7651 is a general-purpose DC source developed on YOKOGAWA's state-of-the-art DC standard technology. The dual multiplying D/A converter has enabled the compatibility of high-speed response and high resolution. The 7651 also provides high accuracy and stability. In addition to the source function (current supply), the sink function (current absorption) is also available, so the 7651 can be used as not only DC voltage/current source but also high-precision electronic load. Further, a series of powerful functions to meet the system use such as the programming function up to 50 steps, the IC memory card capable of storing 7 patterns of programs, and GP-IB interface are provided as standard. This 7651 can be used for a wide range of fields from R & D to production line, service and maintenance.",Yokogawa 7651,640.0,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",Instrumentkit,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UaAsDYNLAOdUQ4cG-gVBw/NTY986xzNYwKbonHbWwWC4LeHEHqycOQeXYwRbRUCHdcuhOKGAvrvBoatXQsD5bpSMp051hQO8G6Z1_BiSG1VC6MM2RwFw-JgfT3HK4pXZo/cdsfM51bauCXQpD2o4jMtv4J_4Pc6fMk_dJlEKX20e0'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0FZ2eqXGORQw7KhD8ggQhA/54nn9VVUA8rLZTUqpQNJJRRABVqmHyYpr39PgVnaWermrd9uQk4oKjA-U_ElbfbtDYyDeyOy0wUoLtc2W5106g/xl6wqD05nzCPSKrDuCKrzZgEG0XSnoQSadmaYKdpFJM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HaEWyRlZBthPGsYttIxnHQ/Dg6dnKGNXLv3Mh6hmw3-ew1Frbuj6oI01Vn3HH6YZCGh51cSS68iCmPrXpZJPdTo-4wfWlWjjSEU4Ca-zmtRlQ/eXk6rUTl5KsnGehm3vQUBE5QCuNLX-D5bbpf0_IxIrM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IbzTBl4xKhTim-kj9IZJWw/jqTaszS54GnOhLIRvMV0S3ODA6kF-CfXSMb2hQnB7aSuYMsMIsRnYenR7US3v50OI9A0DzAtFvhKHusA-qJEaw/o46lbBXBsIcuUNQKSTjhxI0hmLRfL48B90X8oBZ96jI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ",,https://cdn.tmi.yokogawa.com/IM7651-01E.is.pdf,"[OrderedDict([('id', 'attI6RnDjug8zxuhg'), ('width', 800), ('height', 502), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9NCyMaa88_Zc-eKVBGsEJA/7K_8XnPnZ4nlXQOTXBfO5tcLwKg4weFgGFlPfkF4nY2gpx-qf9KVxJ4xXZJRxYzzy4Rj9-fW7QSd7hNMepygMvdzl2kDcTUC0bo3pSFl7Jk/9uTLBg3pduNXNrHzYgf-GUYxzLLj8beVHHK1Ripp89A'), ('filename', '7651_lg.jpg'), ('size', 302628), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Hadpql77qCDc0U_vp2P0BQ/tWtoIs4b4tyA3TqbCfAQNKPXfIAcxREFKjza-DSYU9vlflQSFjQxkzQO4025n_GANJINdduFyP0W-GPRFKQuKQ/UHdlXDvM63pBfal_OC8-KquexzqNgS-BJrXbDiv_byA'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cMCW8Uoqit6sCsPeOqEq6g/a3gGR6xNaQdu8p2Z_gQ6EHyt3xF8wW22_kAgS0dpn1VUrF00FcRKL_LfXuBKJ7qlR4FH84FKzsSDKenk0VYbhg/Fn9wK56mnP0VuqYLI8BpB0Vztw069sLZkrUbhV-WCzU'), ('width', 800), ('height', 502)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/09YTAvxlYUTYot8Brf-p3g/vR6NxMthAi5TPYEtVTKS7vsERzM--4-VuRAsZIi3PQ8feybG4DgCZmiZ3IyN8tW6XdN15YO1-NhLkPYqyKhcEg/klHCEwq7_cib3750_Okqc4zGa25sMUuBSJXBm-0tdLw'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/discontinued/7651-programmable-dc-source/,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa7651.py,https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa7651,,,True,,"

Source code for instruments.yokogawa.yokogawa6370
#!/usr/bin/env python
""""""
Provides support for the Yokogawa 6370 optical spectrum analyzer.
""""""

# IMPORTS #####################################################################


from enum import IntEnum, Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import OpticalSpectrumAnalyzer
from instruments.abstract_instruments.comm import SocketCommunicator
from instruments.util_fns import (
    enum_property,
    unitful_property,
    unitless_property,
    bounded_unitful_property,
    ProxyList,
    string_property,
)


# CLASSES #####################################################################


class Yokogawa6370(OpticalSpectrumAnalyzer):

    """"""
    The Yokogawa 6370 is a optical spectrum analyzer.
    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa6370.open_visa('TCPIP0:192.168.0.35')
    >>> inst.start_wl = 1030e-9 * u.m
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if isinstance(self._file, SocketCommunicator):
            self.terminator = ""\r\n""  # TCP IP connection terminator

        # Set data Format to binary
        self.sendcmd("":FORMat:DATA REAL,64"")  # TODO: Find out where we want this

    # INNER CLASSES #

    class Channel(OpticalSpectrumAnalyzer.Channel):

        """"""
        Class representing the channels on the Yokogawa 6370.
        This class inherits from `OpticalSpectrumAnalyzer.Channel`.
        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa6370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._name = idx

        # METHODS #

        def _data(self, axis, limits=None, bin_format=True):
            """"""Get data of `axis`.

            :param axis: Axis to get the data of, ""X"" or ""Y""
            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            if limits is None:
                cmd = f"":TRAC:{axis}? {self._name}""
            elif isinstance(limits, (tuple, list)) and len(limits) == 2:
                cmd = f"":TRAC:{axis}? {self._name},{limits[0]+1},{limits[1]+1}""
            else:
                raise ValueError(""limits has to be a list or tuple with two members"")
            self._parent.sendcmd(cmd)
            data = self._parent.binblockread(data_width=8, fmt=""<d"")
            self._parent._file.read_raw(1)  # pylint: disable=protected-access
            return data

        def data(self, limits=None, bin_format=True):
            """"""
            Return the trace's level data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""Y"", limits=limits, bin_format=bin_format)

        def wavelength(self, limits=None, bin_format=True):
            """"""
            Return the trace's wavelength data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""X"", limits=limits, bin_format=bin_format)

    # ENUMS #

    class SweepModes(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 6370
        """"""

        SINGLE = 1
        REPEAT = 2
        AUTO = 3

    class Traces(Enum):
        """"""
        Enum containing valid Traces for the Yokogawa 6370
        """"""

        A = ""TRA""
        B = ""TRB""
        C = ""TRC""
        D = ""TRD""
        E = ""TRE""
        F = ""TRF""
        G = ""TRG""

    # PROPERTIES #

    # General

    id = string_property(
        ""*IDN"",
        doc=""""""
            Get the identification of the device.
            Output: 'Manufacturer,Product,SerialNumber,FirmwareVersion'
            Sample: 'YOKOGAWA,AQ6370D,90Y403996,02.08'
            """""",
        readonly=True,
    )

    status = unitless_property(
        ""*STB"",
        doc=""""""The status byte of the device.
        Bit 7: Summary bit of operation status
        Bit 5: Summary bit of standard event status register
        Bit 4: “1” if the output buffer contains data
        Bit 3: Summary bit of questionable status
        """""",
        readonly=True,
    )

    operation_event = unitless_property(
        "":status:operation:event"",
        doc=""""""
            All changes after the last readout. Readout clears the operation_event
            Bit 4: Autosweep
            Bit 3: Calibration/Alignment
            Bit 2: Copy/File
            Bit 1: Program
            Bit 0: Sweep finished.
        """""",
        readonly=True,
    )

    @property
    def channel(self):
        """"""
        Gets the specific channel object.
        This channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> osa = ik.yokogawa.Yokogawa6370.open_gpibusb('/dev/ttyUSB0')
        >>> dat = osa.channel[""A""].data # Gets the data of channel 0

        :rtype: `list`[`~Yokogawa6370.Channel`]
        """"""
        return ProxyList(self, Yokogawa6370.Channel, Yokogawa6370.Traces)

    # Sweep

    start_wl, start_wl_min, start_wl_max = bounded_unitful_property(
        "":SENS:WAV:STAR"",
        u.meter,
        doc=""""""
        The start wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    stop_wl, stop_wl_min, stop_wl_max = bounded_unitful_property(
        "":SENS:WAV:STOP"",
        u.meter,
        doc=""""""
        The stop wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    bandwidth = unitful_property(
        "":SENS:BAND:RES"",
        u.meter,
        doc=""""""
        The bandwidth in m.
        """""",
    )

    span = unitful_property(
        "":SENS:WAV:SPAN"",
        u.meter,
        doc=""""""
        A floating point property that controls the wavelength span in m.
        """""",
    )

    center_wl = unitful_property(
        "":SENS:WAV:CENT"",
        u.meter,
        doc=""""""
         A floating point property that controls the center wavelength m.
        """""",
    )

    points = unitless_property(
        "":SENS:SWE:POIN"",
        doc=""""""
        An integer property that controls the number of points in a trace.
        """""",
    )

    sweep_mode = enum_property(
        "":INIT:SMOD"",
        SweepModes,
        input_decoration=int,
        doc=""""""
        A property to control the Sweep Mode as one of Yokogawa6370.SweepMode.
        Effective only after a self.start_sweep()."""""",
    )

    # Analysis

    # Traces

    active_trace = enum_property(
        "":TRAC:ACTIVE"",
        Traces,
        doc=""""""
        The active trace of the OSA of enum Yokogawa6370.Traces. Determines the
        result of Yokogawa6370.data() and Yokogawa6370.wavelength()."""""",
    )

    # METHODS #

    def data(self, limits=None):
        """"""
        Function to query the active Trace data of the OSA.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].data(limits=limits)

    def wavelength(self, limits=None):
        """"""
        Query the wavelength axis of the active trace.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].wavelength(limits=limits)

    def analysis(self):
        """"""Get the analysis data.""""""
        return [float(x) for x in self.query("":CALC:DATA?"").split("","")]

    def start_sweep(self):
        """"""
        Triggering function for the Yokogawa 6370.
        After changing the sweep mode, the device needs to be triggered before
        it will update.
        """"""
        self.sendcmd(""*CLS;:init"")

    def abort(self):
        """"""Abort a running sweep or calibration etc.""""""
        self.sendcmd("":ABORT"")

    def clear(self):
        """"""Clear status registers.""""""
        self.sendcmd(""*CLS"")


"
77,110.6,"Cleveland, Ohio, United States","The Keithley 580 Micro-ohmmeter combines high accuracy, resolution, and sensitivity with three special capabilities that make micro-ohm measurements easier and more versatile than ever. When measuring contact and connector resistances, it is important not to puncture oxides and films that may have formed. The Model 580 ensures this dry-circuit condition by clamping the open-circuit test voltage to 20mV on the 200m, 2, and 20 ranges when the 20mV MAX button is pressed.

The Keithley 580 can test more devices by enabling both test current polarity and waveform (DC or pulsed) to be selected. When using pulsed test current, the Model 580 automatically compensates for thermoelectric EMFs. Tests on inductive devices are best performed using DC test current, as this avoids the effects of time constants on pulsed current resistance measurements. For temperature-sensitive components, a single trigger mode of operation minimizes power delivered to the device.",Keithley 580,234.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Ohmmeter,['Power Meters'],An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law.,,https://www.testequipmenthq.com/datasheets/KEITHLEY-580-Datasheet.pdf,"[OrderedDict([('id', 'attqllbRtWoi3InUL'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YeeB99QuwzEKF_cb2-T8Ow/aisB-vv49OHjTBG-_on57JbwlcWzVMjNOxMjJFe-fyQZbethGesI4lSvv96FLdz_IWqpbI9CbMb7dJr5vD1XvQ/tGoX8a9qBvFuVmsyGQoFmJpbQK_oxOtPeq1-wHZIP4U'), ('filename', '580.jpg'), ('size', 8047), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TD1w1sj7D4geRllY7DRStg/42frZYLhuArBcdLEMYDW5aiX1CWwtwAze310BVCKZ8C2obKVkYM91AMbcFMnVZid0JC-JIDWIPm1xHzsHJJdig/GphyKpVu9G5v4BKta_QyczpkFzd_Oar_bYjaGyanShI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Tt0cmThnEvvs7fGM2aV9iw/Gsevm0mgJ28jpkEjD9uhv_u8RcwRijbH7OfMrPRL44Omz0wc5ej-O0Xr_nThcixJKWDA8zOYuyZAn2duPrSywg/l7tAtzW9o5gHqL-d5c6QaLuQeOLcBNr9zcUxu56HVgQ'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ESLks8CZeheuJIGzODj1XQ/5dD8MhTORQ1Pp22etQQeYHW0ot1zoDoXVhGJHNoGdyMctpFQzBoUhEJ3cFZBRGiFrutMGPjuhw2aOSLCFfQYaA/g--4ruM6X5ytB1SeO2YmaIb47l27QUguFGSfngZg-R0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.valuetronics.com/product/580-keithley-micro-ohmmeter-used,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley580.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley580-microohm-meter,3295.0,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
79,5800.0,USA,"The AWG2005 offers 20 MS/s and 64 k deep memory. As with the entire AWG2000 Series, the graphical user interface allows on-screen viewing of waveform editing, simplifying ""what if"" test scenarios by allowing the easy creation of composite signals. The standard AWG2005 configuration provides two independent 10 V outputs or a third and fourth 10 V output (Option 02) each with 12-Bits vertical resolution. Option 04 adds TTL digital levels with (2) 12-Bit, 100 MS/s ports and combines with the marker outputs to provide a total of 28-Bits wide. The built-in sweep generator (Option 05) provides even more flexibility by offering linear and logarithmic swept frequencies, but even more significantly the AWG2005 has user definable sweep capability. This allows creation of digitally modulated signals at IF frequencies. The built-in frequency domain (FFT) editor (Option 09) is a perfect addition for customers performing proprietary or standard I & Q modulation simulations, filter design or in circuit testing of physical layer. Real time waveform sequencing extends the effective record length output to over a billion points! The AWG2005 easily simulates signals where moderate point definition and long records are required for simulating complex waveform conditions. Direct waveform transfer capability makes the AWG2005 the perfect complement to selected Tektronix oscilloscopes.",Tekawg 2000,555.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a AWG2005 RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG2005,https://download.tek.com/datasheet/76W_10020_2_1.pdf,"[OrderedDict([('id', 'attqkHYzPkKkFIskn'), ('width', 800), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ChFUOOgIt4UXDhJsxHTwnQ/LOaDQA80Rs7xcECj113yPa__t5zkQ74TFsYwWzxOkigmns-uFwqgTwpZj1-dvXwVnzBdPhS8EsqkFhh-ibtVCmqa8CVhEEWjUwrilcfZy2TqPo6Qy1zIPFg-kphcrYTy/sDG7Iz1Uydf394UTR3PiHNl5CEymPUtPv1PVPTuK1wk'), ('filename', 'Alltest-Tektronix-AWG2005-23811.jpg'), ('size', 84919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bTeiex35E2XB-6r0rW_WEg/K1hs_p1ez5R0KOqwMWlcA6k6y7OIoO_IyMrh_YSBp_VzRx8WZLUt1fM0m0AWqqgOLxX_lOj-50tNGnbjGhn8ig/KBuWqEIvuA6jS1BUGjX8dxjEdUxATzbEfnTzKYM_1lk'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Uw7xpblAe4_gJhUieZ2eOA/PCMSm7jBRil-nIgnWP4nWVlDQ6dmut0V51IBVCuhQ9gNH8wwoNt2a9JVvkuxzc_KScIe_UgjLE6s9dUHhkEY0w/vs1Oez6XrVaN4WVizFOF_y-eCGI2m5q7AF9cI25F23c'), ('width', 800), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/axV0Ntz7_bU6Xyys2TU9gA/CwqTuhv_Xi-HS4p341rQbv4DRO7WD-FpQ5yb5ixkU9pcLa6ZQr1gEmt9VMKaD8pYid1PxbEl6RbJbRcUsDvhwQ/lgxuy39KK-mloIhrcBXzdz50yPhQe5TovxGLiWvLjS0'), ('width', 3000), ('height', 3000)]))]))])]",https://alltest.net/categories/products/AWG2005-Tektronix,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekawg2000.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekawg2000-arbitrary-wave-generator,495.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
97,75.0,Germany,"TOPTICA’s TopMode lasers operate as easily as a HeNe, but also offer higher power and the choice of wavelength. The TopMode series sets records in terms of power, coherence and wavelength stability. The proprietary CoHerence-Advanced Regulation Method (CHARM) provides an active stabilization of the lasers’ coherence and ensures continuous single-frequency operation. TopMode and CHARM means nothing less than reliable 24/7 operation.",Topmode,626.0,"TOPTICA Photonics is a manufacturer of [lasers](https://en.wikipedia.org/wiki/Laser) for quantum technologies, biophotonics and material inspection
",Instrumentkit,Toptica,"[OrderedDict([('id', 'attdPu3r6YQ3XuoNe'), ('width', 469), ('height', 107), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mWHgA4oi1FvYJqyZ8prvcg/ab6Vc1q_KDv4EAJjFJu_f_ktpmfgnhSu-3vQRFm_Zc-SiTLTIE3ZdEW36rwLwA5F2joKRHJ7pkMPHbByRT9kI02DFPAylcb3QkRIr6z7UJs/RJw39hAWhzt-NvBCfndI38tTdbfWr62Hr3tNipIC9RU'), ('filename', 'download.png'), ('size', 4105), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6x7K5pk6uOw9bsJabP_ZAw/nLrk3rksEqL6rGQ7pgnMbnCS2pDNUmswJcQJu0ce5CVrmueAlZgjnraYNZlzBWUmwUlYN2uKdu8bLj3rRg346A/tZ5Ihy0FMk_e896KBi8fTr8V-W6UTJMzPgKUelY1MVQ'), ('width', 158), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Sep7micXa-kZc1ZG03CqHQ/Y-tdVUC-Z_8ugLYE_Iz04EsQeQTYL5JD_No6LuDyhBnxV5-ZI-sWJuI5w5p9vUZzFISz1Qzvb6KPyYKOoPpq0w/X-IlFSN1lqfPsROtBh_o0YLcvZegBtnSwYq45b3JZ0g'), ('width', 469), ('height', 107)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/snWR4CX2YFVtZ2SHj54ztQ/K9H0u9OKDjypS_b3q0GZwzTkXZutZUvtF3p-Vtt-_CBP0sTd7mvjpuAlpdjIy5osTQ8gW6zqvcuiWUtAlnO2dQ/HIzbtECsnM2f8fSVCa0X17ptzkkhPxTdtQ08_FuU-sA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/,Write a Python script that uses Instrumentkit to connect to a TopMode Lasers,https://en.wikipedia.org/wiki/Laser_diode,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction",TopMode,https://www.toptica.com/fileadmin/Editors_English/11_brochures_datasheets/01_brochures/toptica_BR_TopMode.pdf,"[OrderedDict([('id', 'attySc0bj6E4RhJ6k'), ('width', 1200), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6PX1L8_fgkmDeiKnUwMinw/KCXuMkxK7uUy8qrE9rxz9Sto-vx-8BvNZtyod1_f68NCXI0mZhE4Q6dDRleyGVarWrqSSY_D-DQtUOBhJ6Xr6JydIe846f3dXs5tf3bmedluYInGjxlJ0cmtbG4llTud/HKdTERarECCwzOm1i3adXyLHu-Hs1H09CbKO6w0vMaE'), ('filename', 'toptica_topmode_3x_1200x350_w.jpg'), ('size', 83757), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uIscRocJ0mILVdF3miJCYg/qkzdL2XjujEtXq1gIxeJipE5wEJ-Ryt6moIdNJ4pxOiAgjTeTUcdRphyDPCV3Ij-jZ7GGuHAqtabY61jvLoPHA/0tlg37lXAGU-sIH-8HpCU83eA1Wk5-agZbVRIck6kL4'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nrLRqKKw_SLNqsit08u6sA/zgxxratDd6ghCX7ATzd9jMMN_QO5-k_3xd2r5mxZVGUIU_z5Iw5dm7gMLjzd10vTYBzza31X0oNLWRZxdoqwfw/TxDl4UJgt4XbzZL72V1WCt_7wcp8G0oa1ceGe2XiyF8'), ('width', 1200), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PHvjDCCwBQuaSggoaLGdEw/AdoYefvr2gKgmxF5vfVgxLvE5QDBB0SaFQ410Qm8j_xD1gcnNZyZG4auazBKfQ4R94u1NKZ1PajS2InjgbB3Ow/ICBcQG2bLTSKuVjLle3ROxTHiRzdGUY9Tq0G0bOPWgc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/products/single-frequency-lasers/topmode,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/toptica/topmode.py,https://instrumentkit.readthedocs.io/en/latest/apiref/toptica.html,,,,,"

Source code for instruments.toptica.topmode
#!/usr/bin/env python
""""""
Provides the support for the Toptica Topmode diode laser.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.toptica.toptica_utils import convert_toptica_boolean as ctbool
from instruments.toptica.toptica_utils import convert_toptica_datetime as ctdate
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class TopMode(Instrument):

    """"""
    Communicates with a `Toptica Topmode`_ instrument.

    The TopMode is a diode laser with active stabilization, produced by Toptica.

    Example usage:

    >>> import instruments as ik
    >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
    >>> print(tm.laser[0].wavelength)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.prompt = ""> ""
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if ""reboot"" in msg:
            return [msg, ""reboot process started.""]
        elif ""start-correction"" in msg:
            return [msg, ""()""]

        return msg

    # ENUMS #

    class CharmStatus(IntEnum):

        """"""
        Enum containing valid charm statuses for the lasers
        """"""

        un_initialized = 0
        in_progress = 1
        success = 2
        failure = 3

    # INNER CLASSES #

    class Laser:

        """"""
        Class representing a laser on the Toptica Topmode.

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `Topmode` class.
        """"""

        def __init__(self, parent, idx):
            self.parent = parent
            self.name = f""laser{idx + 1}""

        # PROPERTIES #

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the laser

            :return: The serial number of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":serial-number"")

        @property
        def model(self):
            """"""
            Gets the model type of the laser

            :return: The model of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":model"")

        @property
        def wavelength(self):
            """"""
            Gets the wavelength of the laser

            :return: The wavelength of the specified laser
            :units: Nanometers (nm)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":wavelength"")) * u.nm

        @property
        def production_date(self):
            """"""
            Gets the production date of the laser

            :return: The production date of the specified laser
            :type: `str`
            """"""
            return self.parent.reference(self.name + "":production-date"")

        @property
        def enable(self):
            """"""
            Gets/sets the enable/disable status of the laser. Value of `True`
            is for enabled, and `False` for disabled.

            :return: Enable status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":emission""))

        @enable.setter
        def enable(self, newval):
            if not isinstance(newval, bool):
                raise TypeError(
                    ""Emission status must be a boolean, got: "" ""{}"".format(type(newval))
                )
            if not self.is_connected:
                raise RuntimeError(
                    ""Laser was not recognized by charm "" ""controller. Is it plugged in?""
                )
            self.parent.set(self.name + "":enable-emission"", newval)

        @property
        def is_connected(self):
            """"""
            Check whether a laser is connected.

            :return: Whether the controller successfully connected to a laser
            :type: `bool`
            """"""
            if self.serial_number == ""unknown"":
                return False
            return True

        @property
        def on_time(self):
            """"""
            Gets the 'on time' value for the laser

            :return: The 'on time' value for the specified laser
            :units: Seconds (s)
            :type: `~pint.Quantity`
            """"""
            return float(self.parent.reference(self.name + "":ontime"")) * u.s

        @property
        def charm_status(self):
            """"""
            Gets the 'charm status' of the laser

            :return: The 'charm status' of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 7) % 2 == 1

        @property
        def temperature_control_status(self):
            """"""
            Gets the temperature control status of the laser

            :return: The temperature control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 5) % 2 == 1

        @property
        def current_control_status(self):
            """"""
            Gets the current control status of the laser

            :return: The current control status of the specified laser
            :type: `bool`
            """"""
            response = int(self.parent.reference(self.name + "":health""))
            return (response >> 6) % 2 == 1

        @property
        def tec_status(self):
            """"""
            Gets the TEC status of the laser

            :return: The TEC status of the specified laser
            :type: `bool`
            """"""
            return ctbool(self.parent.reference(self.name + "":tec:ready""))

        @property
        def intensity(self):
            """"""
            Gets the intensity of the laser. This property is unitless.

            :return: the intensity of the specified laser
            :units: Unitless
            :type: `float`
            """"""
            return float(self.parent.reference(self.name + "":intensity""))

        @property
        def mode_hop(self):
            """"""
            Gets whether the laser has mode-hopped

            :return: Mode-hop status of the specified laser
            :type: `bool`
            """"""
            response = self.parent.reference(self.name + "":charm:reg:mh-occurred"")
            return ctbool(response)

        @property
        def lock_start(self):
            """"""
            Gets the date and time of the start of mode-locking

            :return: The datetime of start of mode-locking for specified laser
            :type: `datetime`
            """"""
            # if mode locking has not started yet, the device will respond with
            # an empty date string. This causes a problem with ctdate.
            _corr_stat = self.correction_status
            if (
                _corr_stat == TopMode.CharmStatus.un_initialized
                or _corr_stat == TopMode.CharmStatus.failure
            ):
                raise RuntimeError(""Laser has not yet successfully locked"")

            response = self.parent.reference(self.name + "":charm:reg:started"")
            return ctdate(response)

        @property
        def first_mode_hop_time(self):
            """"""
            Gets the date and time of the first mode hop

            :return: The datetime of the first mode hop for the specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:first-mh"")

            return ctdate(response)

        @property
        def latest_mode_hop_time(self):
            """"""
            Gets the date and time of the latest mode hop

            :return: The datetime of the latest mode hop for the
                specified laser
            :type: `datetime`
            """"""
            # if the mode has not hopped, the device will respond with an empty
            # date string. This causes a problem with ctdate.
            if not self.mode_hop:
                raise RuntimeError(""Mode hop not detected"")
            response = self.parent.reference(self.name + "":charm:reg:latest-mh"")
            return ctdate(response)

        @property
        def correction_status(self):
            """"""
            Gets the correction status of the laser

            :return: The correction status of the specified laser
            :type: `~TopMode.CharmStatus`
            """"""
            value = self.parent.reference(self.name + "":charm:correction-status"")
            return TopMode.CharmStatus(int(value))

        # METHODS #

        def correction(self):
            """"""
            Run the correction against the specified laser
            """"""
            if self.correction_status == TopMode.CharmStatus.un_initialized:
                self.parent.execute(self.name + "":charm:start-correction-initial"")
            else:
                self.parent.execute(self.name + "":charm:start-correction"")

    # TOPMODE CONTROL LANGUAGE #

    def execute(self, command):
        """"""
        Sends an execute command to the Topmode. This is used to automatically
        append (exec ' + command + ) to your command.

        :param str command: The command to be executed.
        """"""
        self.sendcmd(""(exec '"" + command + "")"")

    def set(self, param, value):
        """"""
        Sends a param-set command to the Topmode. This is used to automatically
        handle appending ""param-set!"" and the rest of the param-set message
        structure to your message.

        :param str param: Parameter that will be set
        :param value: Value that the parameter will be set to
        :type value: `str`, `tuple`, `list`, or `bool`
        """"""

        if isinstance(value, str):
            self.query(f'(param-set! \'{param} ""{value}"")')
        elif isinstance(value, (tuple, list)):
            self.query(""(param-set! '{} '({}))"".format(param, "" "".join(value)))
        elif isinstance(value, bool):
            value = ""t"" if value else ""f""
            self.query(f""(param-set! '{param} #{value})"")

    def reference(self, param):
        """"""
        Sends a reference commands to the Topmode. This is effectively a query
        request. It will append the required (param-ref ' + param + ).

        :param str param: Parameter that should be queried
        :return: Response to the reference request
        :rtype: `str`
        """"""
        response = self.query(f""(param-ref '{param})"").replace('""', """")
        return response

    def display(self, param):
        """"""
        Sends a display command to the Topmode.

        :param str param: Parameter that will be sent with a display request
        :return: Response to the display request
        """"""
        return self.query(f""(param-disp '{param})"")

    # PROPERTIES #

    @property
    def laser(self):
        """"""
        Gets a specific Topmode laser object. The desired laser is
        specified like one would access a list.

        For example, the following would print the wavelength from laser 1:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> tm = ik.toptica.TopMode.open_serial('/dev/ttyUSB0', 115200)
        >>> print(tm.laser[0].wavelength)

        :rtype: `~TopMode.Laser`
        """"""
        return ProxyList(self, self.Laser, range(2))

    @property
    def enable(self):
        """"""
        is the laser lasing?
        :return:
        """"""
        return ctbool(self.reference(""emission""))

    @enable.setter
    def enable(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(
                ""Emission status must be a boolean, "" ""got: {}"".format(type(newval))
            )
        self.set(""enable-emission"", newval)

    @property
    def locked(self):
        """"""
        Gets the key switch lock status

        :return: `True` if key switch is locked, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""front-key-locked""))

    @property
    def interlock(self):
        """"""
        Gets the interlock switch open state

        :return: `True` if interlock switch is open, `False` otherwise
        :type: `bool`
        """"""
        return ctbool(self.reference(""interlock-open""))

    @property
    def firmware(self):
        """"""
        Gets the firmware version of the charm controller

        :return: The firmware version of the charm controller
        :type: `tuple`
        """"""
        firmware = tuple(map(int, self.reference(""fw-ver"").split(""."")))
        return firmware

    @property
    def fpga_status(self):
        """"""
        Gets the FPGA health status

        :return: `False` if there has been a failure for the FPGA,
            `True` otherwise
        :type: `bool`
        """"""
        response = self.reference(""system-health"")
        if response.find(""#f"") >= 0:
            return False
        response = int(response)
        return False if response % 2 else True

    @property
    def serial_number(self):
        """"""
        Gets the serial number of the charm controller

        :return: The serial number of the charm controller
        :type: `str`
        """"""
        return self.reference(""serial-number"")

    @property
    def temperature_status(self):
        """"""
        Gets the temperature controller board health status

        :return: `False` if there has been a failure for the temperature
            controller board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 1) % 2 else True

    @property
    def current_status(self):
        """"""
        Gets the current controller board health status

        :return: `False` if there has been a failure for the current controller
            board, `True` otherwise
        :type: `bool`
        """"""
        response = int(self.reference(""system-health""))
        return False if (response >> 2) % 2 else True

    # METHODS #

    def reboot(self):
        """"""
        Reboots the system (note that the serial connect might have to be
        re-opened after this)
        """"""
        self.execute(""reboot-system"")


"
103,5800.0,USA,,Tektds 5 XX,551.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS520/TDS540 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS520/TDS540,https://xdevs.com/doc/Tektronix/TDS520/TEKTRONIX_Company_Ad_TDS520_w_Datasheet.pdf,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,450.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
105,5800.0,USA,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",Tekdpo 70000,548.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a DPO70000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",DPO70000,https://download.tek.com/document/55W-22447-9.pdf,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BZUCWIp3bGVS1QbZ69tILA/xlS7IOyu-hPw4hvbbEXxBjSMVtB-RyDDGTK8psI9gdiFm1ilDvG3lTJsTq5Xv8GM02yxIC9sHPq3uMr-H_cykFtDCxpQVZNaNcjS1PLDLsWl6L-5w4ztHLvHpZ44fiRwDYQlFGu4YJPlXBrwN3cGxg/EaV_SXGrD10R-lcDJZN1FKwd9XkjD5w4P-6YpijokGo'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GrDCvfgZka7Y7bRICTHHLA/TPy7CHCZe2b1EdHnoBoeViiHwr-akRrcPvAmJXN82B1-cbHDRxMq4DPOltKLqkOUbxWUCOfbYS738ZonY3vF59hZ5Zg8OBUrG0A6Hx1V78U/kepNPbg0x0S656JwazSNKnePVG0UrHqK6BspcsPJFo8'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HfRw6OUo3quQsk4IIMd_gQ/gJHLLzutGMhG_6rYylbAmWFi-1fxXKwVcbLqeJbRmUqNooRcUPFRNjyMqfIWRowlq0ABZnagcVfELSSWJLSu9_nHIQIjQCQwQz7MKO_pxsc/nrZsZsyHkgPsSesXVpegxEArjDr6A6CNeFsSdJalp0Y'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L8UILIYUmpKBuyt46bwRyg/wKLcKR8c6L2SyBlxuZy3Zn1jxkzKHM66SF84u5Hkaj26Q1igORZskxeMFl3snGZ_coOKfQNGvDJuMycpnn16BAEFjo7883LBJ1dBTC3dB9Q/SS2rGiw0bjerpaHbpVKTYQ2ak6rmuoUDDpSl4cSRhbI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo70000.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo70000-oscilloscope,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
106,21.4,"Westerville, Ohio, USA","The Model 370 AC resistance bridge is designed for precise, accurate, low noise, low excitation power AC resistance measurements. Its primary application is the measurement of resistive materials in cryogenic environments from 20 mK to 1 K. Fully integrated, the Model 370 includes features to reduce and control noise at every step of the resistance measurement process. A unique, patented, matched impedance current source and active common mode reduction circuitry minimize noise and self-heating errors. With up to 16 channels, IEEE-488 and serial interfaces, and closed loop temperature control, the Model 370 offers seamless integration with existing cryogenic systems and is the most complete package on the market today. Used with Lake Shore calibrated subkelvin resistance temperature sensors, it not only measures and displays, but also controls temperature for dilution refrigerators and other cryogenic systems.",Lakeshore 370,347.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Instrumentkit,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Ohmmeter,['Power Meters'],An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law,,http://www.cryotrade.ru/uploads/documents/temperature/LakeShore370.pdf,"[OrderedDict([('id', 'atto87LIsOZVAKm9z'), ('width', 505), ('height', 157), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kuG8VDy8h4CkvY4bxXt23A/CvDiexkITxwoq5qdubxvbT4imInAWApg04SIwgZg1QmKTdWH-b9e6ibqjFfz-IbKYruiX7dbs8SaT9jNaQ9A3Q/jcOSk1eXBSuM_6A6pbSc6On-lc71SLasBJ4P4FQnX_o'), ('filename', '370.png'), ('size', 99490), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YmFyiOxbufVBztsgfZFgYw/OprppIh2ptF9nx-oS-WjWNvw-JzxvVPLsTK28SdqlC4Ysh91I07FbkvBpKj_yHzEIyVYhlfGgBy5jrPe2OdPTw/O_x82xrCgzuuXhuux-lBuKcRSINdx7OCiOAKEcdXKwI'), ('width', 116), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/p1t7bQ5rTxiY4yKNsRpe1A/Kd-rKlq5HqLbafo_i9cA9rScFyGaPP1UyHKujFFKQAv8nHJqOn3I0E-X7It9PpdNC31OR3wnOz7Dz5mg9FNnbg/ZMyvT9bB8j2Rz7EA4f7m492EMGkf7fGJikTs2OPAsyg'), ('width', 505), ('height', 157)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uMrP5e7q100G9_xyCoNqjg/Ys200-nKOJZGxToe4FkXfVuFrJpFFL_yVeWo4dwL0INqooBO2AzMCXHY6AHHiweXNqE4_HPsACcwGRynmwhunw/KJWGysu19BdmejJZAiu0jc3vzPLkxFOyB5WxwurVqJU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-370-ac-resistance-bridge-,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore370.py,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore370-ac-resistance-bridge,,,True,,"

Source code for instruments.lakeshore.lakeshore340
#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))


"
120,5458.6,USA,"WaveRunner 9000 oscilloscopes have the industry's widest and deepest collection of tools, making it unbelievably powerful and MAUI with OneTouch makes measurement setup insanely easy, providing faster time to insight.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveRunner 9000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveRunner 9000,https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,"[OrderedDict([('id', 'attO8NgzXv6EBjVdD'), ('width', 1000), ('height', 929), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fvGIUh6JfaGwDOjy9nLVEA/Nid8bWfGiEEi3eXbpZNLB-uCUpSo8XdPbOXd61p0yb1jcezybwFxYRc_nDQM84fSCaW0L2oQG5aNiNHOQculUk9aEYzFk3fzM15xYiDBbtY/7SxCdVqarrns1EBqYJ-0ZzsN5P-LeUuDF5j4lGQN650'), ('filename', 'wr9000-hero.webp'), ('size', 138832), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/x6Mu-gwhCIIvXhPZRH5TjQ/TbiE4zGCsFjvtfZs7f0nu3HwoDk74DIkjSFpx11K1YzQ96PJI0tm236TV_SnOmEoVGzCysj0dRP6ICuIYmyotK5YFlkr_pxOUBEZG2vcJ7Q/uzsS1WnWtzfc3rFLDS6H1SO6w1uEDeVH148SxtaF4ho'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kn1rQL4MFEBEY9u82cvVbg/o4wuLsCSUGJL1AawUck2aiGVmJ1sHsXGnwvW3W4MLR64kM7nobF5ZkVk3DKaJcXggpc-POKckWIypkhf3Ife1CePTbmjBg6BToCcIsRaLC0/t0R4xxSPwjspafQ0SxoG7pLSe3MTIt8FrwXJeYBPNWs'), ('width', 551), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NPwRZ2t8n3zCE5JDEbktsw/Lgb9Jk-oQqwoAk6v5R2TQyw42DwHu3LTp9X47DOsINbN6xFz1_tQYLuO9pHwLtn0e_X4HQlDsqr16b283zRkfCGFwU-U4RwnmEufnMJERWs/RR9gBZYbeIQzYPM7lprdqbNwB6j4Oqwc_3xvtxabeEo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/waverunner-9000-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,16800.0,,,price from here: https://cdn.teledynelecroy.com/files/pdf/waverunner9000-datasheet.pdf,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
122,5800.0,USA,The Tektronix TDS224 is a portable four-channel digital scope with 1 GS/s sampling rate and 100 MHz bandwidth.,Tektds 224,552.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS224 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS224,https://www.testequipmenthq.com/datasheets/TEKTRONIX-TDS224-Datasheet.pdf,"[OrderedDict([('id', 'attogh5LFg8s7lsw4'), ('width', 798), ('height', 566), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Xuz-OEqqsrWWKLFdTOfDSg/aHHPKIQn9J6_qZc-oaEkApEPIo18f7TBuQHwDl4P0QkKb_hx3kXadsn696rIFX3w8uMFzugKCqceLTo6uSW6k3FGCj_9DGdfioi-IZmhsJI/6vWoxwOxA_iw08HqRleejHox5WwL3qoB0jO71zg0gl0'), ('filename', 'TDS224.jpg'), ('size', 323986), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0CCtfZJNCzfiFi0VWWEH-A/YXn0VvTQURR3I6mY09gYbQWgA1KCwgwN0uyD7KMGtylqLN_dHdK5_TAKPO0aoCqO0damjwIMIGrLvQ0DaSHRzw/SWoB8XcjSPEFA-JCQHzQ2EBXBFMSpVTNCVrURQiXvMw'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YQHnUMd2rXs1EJjpIZaayQ/-EZ6jmFRbhVHFbXb28ZwcjK-72I1DmMBpMGj-i_BtzWd5-2Q2hR-zuwLtfYeCBei-idIYbEODvAXTOlQdL9sjg/2jqDqUeayHuruTrDiH6nVmRWBclWPIVmCaul3XwugJ4'), ('width', 722), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_jv6ZPAw64ha-3FX0dtZ3Q/0g1SlbPxqroiknYSLrAxfhdh-hcDFmhwQZlILtNlC8FgfYE_4_I63GoeaQe_8QRHDSCQynNUstO9nRg2bBYKtQ/6_2REHfl2SK-4EH0DAJS4nOH9Zwllm0B_JPEAlAUtpQ'), ('width', 3000), ('height', 3000)]))]))])]",https://w140.com/tekwiki/wiki/TDS224,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds224.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds224-oscilloscope,650.0,,True,price from the following: https://bmisurplus.com/product/tektronix-tds-224-100-mhz-4-channel-oscilloscope/,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
143,3500.0,"Irvine, California, United States",Agilis™ Piezo Motion Controllers provide convenient and compact fine positioning control of the Agilis family of piezo motion stages and mounts.,Agilis,390.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Instrumentkit,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",,https://www.newport.com/mam/celum/celum_assets/np/resources/Agilis_Piezo_Motor_Driven_Components_User_Manual.pdf?1,"[OrderedDict([('id', 'attwW1zLjGpXPjApa'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/o9ve3VcXzWpfJR8wM7WaTA/u7AtpymCREeWJH-GoGXbXDM809HWmJZlODqHWuBhXvJwwji6LUkpB3b2ruyyjmYT6BlftGs1l8HQ4O-m_OIXQIlPzVtK-lv0-0envrRY2aM/9vG8oPMmfxGD1OBGBkg0h3g82KOc2HjkmViyf8KQhlw'), ('filename', 'AG-UC8_400w (1).jpg'), ('size', 15942), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aB2KE12v_urHBPIj54LzMQ/Es-FtUzHNo5Ygocn1DEbqX4XqMN_17bh7NwfjQDJ0KUiMpVkDxJkT_L_6ge3Puc99T5xq4v_7fasGRlSGGc3Yw/A6SPgspn08x7Tqtr2BnJSB9-OhRmhRGL28OxDa9-d7Y'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OS-qsB5kd6-3xOqjOVk2YA/u8GO6iF1KazOUokE5iOlLupdnCkDxePu2_vvl25fZQpwoDcxZhEfUK2aUDjJvyosWV5f7qrHFiSdE4rAEuhgIQ/eqkWe8J3RlnMDXiZvQUvPvNyJajo0OSn1mWr5feUukI'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Lg22v2NpiclQ4B8VDEJ5DQ/k3yB7y3TzRq0sHEM_0PNNxIhK01NHqO5HXsAxOe9drVDPNVlYwsI6a6l2TEWoLanhVq70OWkguPfRvgl1bcDxQ/MLfUvJCQZR0QmgasnfVt-6CmQX3WpO4WBdJUZal_Z7Q'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/f/agilis-piezo-motion-controllers,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/newport/agilis.py,https://instrumentkit.readthedocs.io/en/latest/apiref/newport.html#agilis-piezo-motor-controller,1022.0,,,,"

Source code for instruments.newport.agilis
#!/usr/bin/env python
""""""
Provides support for the Newport Agilis Controller AG-UC2 only (currently).

Agilis controllers are piezo driven motors that do not have support for units.
All units used in this document are given as steps.

Currently I only have a AG-PR100 rotation stage available for testing. This
device does not contain a limit switch and certain routines are therefore
completely untested! These are labeled in their respective docstring with:
    `UNTESTED: SEE COMMENT ON TOP`

The governing document for the commands and implementation is:

Agilis Series, Piezo Motor Driven Components, User's Manual, v2.2.x,
by Newport, especially chapter 4.7: ""ASCII Command Set""
Document number from footer: EDH0224En5022 — 10/12

Routines not implemented at all:
- Measure current position (MA command):
  This routine interrupts the communication and
  restarts it afterwards. It can, according to the documentation, take up to
  2 minutes to complete. It is furthermore only available on stages with limit
  switches. I currently do not have the capability to implement this therefore.
- Absolute Move (PA command):
  Exactly the same reason as for MA command.
""""""

# IMPORTS #####################################################################

import time

from enum import IntEnum

from instruments.abstract_instruments import Instrument
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class AGUC2(Instrument):

    """"""
    Handles the communication with the AGUC2 controller using the serial
    connection.

    Example usage:

    >>> import instruments as ik
    >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)

    This loads a controller into the instance `agl`. The two axis are
    called 'X' (axis 1) and 'Y' (axis 2). Controller commands and settings
    can be executed as following, as examples:

    Reset the controller:

    >>> agl.reset_controller()

    Print the firmware version:

    >>> print(agl.firmware_version)

    Individual axes can be controlled and queried as following:

    Relative move by 1000 steps:

    >>> agl.axis[""X""].move_relative(1000)

    Activate jogging in mode 3:

    >>> agl.axis[""X""].jog(3)

    Jogging will continue until the axis is stopped

    >>> agl.axis[""X""].stop()

    Query the step amplitude, then set the postive one to +10 and the
    negative one to -20

    >>> print(agl.axis[""X""].step_amplitude)
    >>> agl.axis[""X""].step_amplitude = 10
    >>> agl.axis[""X""].step_amplitude = -20
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)

        # Instrument requires '\r\n' line termination
        self.terminator = ""\r\n""

        # Some local variables
        self._remote_mode = False
        self._sleep_time = 0.25

    class Axis:

        """"""
        Class representing one axis attached to a Controller. This will likely
        work with the AG-UC8 controller as well.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by a Controller class
        """"""

        def __init__(self, cont, ax):
            if not isinstance(cont, AGUC2):
                raise TypeError(""Don't do that."")

            # set axis integer
            if isinstance(ax, AGUC2.Axes):
                self._ax = ax.value
            else:
                self._ax = ax

            # set controller
            self._cont = cont

        # PROPERTIES #

        @property
        def axis_status(self):
            """"""
            Returns the status of the current axis.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TS"")
            if resp.find(""TS"") == -1:
                return ""Status code query failed.""

            resp = int(resp.replace(str(int(self._ax)) + ""TS"", """"))
            status_message = agilis_status_message(resp)
            return status_message

        @property
        def jog(self):
            """"""
            Start jog motion / get jog mode
            Defined jog steps are defined with `step_amplitude` function (default
            16). If a jog mode is supplied, the jog motion is started. Otherwise
            the current jog mode is queried. Valid jog modes are:

            -4 — Negative direction, 666 steps/s at defined step amplitude.
            -3 — Negative direction, 1700 steps/s at max. step amplitude.
            -2 — Negative direction, 100 step/s at max. step amplitude.
            -1 — Negative direction, 5 steps/s at defined step amplitude.
             0 — No move, go to READY state.
             1 — Positive direction, 5 steps/s at defined step amplitude.
             2 — Positive direction, 100 steps/s at max. step amplitude.
             3 — Positive direction, 1700 steps/s at max. step amplitude.
             4 — Positive direction, 666 steps/s at defined step amplitude.

            :return: Jog motion set
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} JA?"")
            return int(resp.split(""JA"")[1])

        @jog.setter
        def jog(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} JA {mode}"")

        @property
        def number_of_steps(self):
            """"""
            Returns the number of accumulated steps in forward direction minus
            the number of steps in backward direction since powering the
            controller or since the last ZP (zero position) command, whatever
            was last.

            Note:
            The step size of the Agilis devices are not 100% repeatable and
            vary between forward and backward direction. Furthermore, the step
            size can be modified using the SU command. Consequently, the TP
            command provides only limited information about the actual position
            of the device. In particular, an Agilis device can be at very
            different positions even though a TP command may return the same
            result.

            :return: Number of steps
            :rtype: int
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} TP"")
            return int(resp.split(""TP"")[1])

        @property
        def move_relative(self):
            """"""
            Moves the axis by nn steps / Queries the status of the axis.
            Steps must be given a number that can be converted to a signed integer
            between -2,147,483,648 and 2,147,483,647.
            If queried, command returns the current target position. At least this
            is the expected behaviour, never worked with the rotation stage.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} PR?"")
            return int(resp.split(""PR"")[1])

        @move_relative.setter
        def move_relative(self, steps):
            steps = int(steps)
            if steps < -2147483648 or steps > 2147483647:
                raise ValueError(
                    ""Number of steps are out of range. They must be ""
                    ""between -2,147,483,648 and 2,147,483,647""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} PR {steps}"")

        @property
        def move_to_limit(self):
            """"""
            UNTESTED: SEE COMMENT ON TOP

            The  command functions properly only with devices that feature a
            limit switch like models AG-LS25, AG-M050L and AG-M100L.

            Starts a jog motion at a defined speed to the limit and stops
            automatically when the limit is activated. See `jog` command for
            details on available modes.

            Returns the distance of the current position to the limit in
            1/1000th of the total travel.
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} MA?"")
            return int(resp.split(""MA"")[1])

        @move_to_limit.setter
        def move_to_limit(self, mode):
            mode = int(mode)
            if mode < -4 or mode > 4:
                raise ValueError(""Jog mode out of range. Must be between -4 and "" ""4."")

            self._cont.ag_sendcmd(f""{int(self._ax)} MA {mode}"")

        @property
        def step_amplitude(self):
            """"""
            Sets / Gets the step_amplitude.

            Sets the step amplitude (step size) in positive and / or negative
            direction. If the parameter is positive, it will set the step
            amplitude in the forward direction. If the parameter is negative,
            it will set the step amplitude in the backward direction. You can also
            provide a tuple or list of two values (one positive, one negative),
            which will set both values.
            Valid values are between -50 and 50, except for 0.

            :return: Tuple of first negative, then positive step amplitude
                response.
            :rtype: (`int`, `int`)
            """"""
            resp_neg = self._cont.ag_query(f""{int(self._ax)} SU-?"")
            resp_pos = self._cont.ag_query(f""{int(self._ax)} SU+?"")
            return int(resp_neg.split(""SU"")[1]), int(resp_pos.split(""SU"")[1])

        @step_amplitude.setter
        def step_amplitude(self, nns):
            if not isinstance(nns, tuple) and not isinstance(nns, list):
                nns = [nns]

            # check all values for validity
            for nn in nns:
                nn = int(nn)
                if nn < -50 or nn > 50 or nn == 0:
                    raise ValueError(
                        ""Step amplitude {} outside the valid range. ""
                        ""It must be between -50 and -1 or between ""
                        ""1 and 50."".format(nn)
                    )

            for nn in nns:
                self._cont.ag_sendcmd(f""{int(self._ax)} SU {int(nn)}"")

        @property
        def step_delay(self):
            """"""
            Sets/gets the step delay of stepping mode. The delay applies for both
            positive and negative directions. The delay is programmed as multiple
            of 10µs. For example, a delay of 40 is equivalent to
            40 x 10 µs = 400 µs. The maximum value of the parameter is equal to a
            delay of 2 seconds between pulses. By default, after reset, the value
            is 0.
            Setter: value must be integer between 0 and 200000 included

            :return: Step delay
            :rtype: `int`
            """"""
            resp = self._cont.ag_query(f""{int(self._ax)} DL?"")
            return int(resp.split(""DL"")[1])

        @step_delay.setter
        def step_delay(self, nn):
            nn = int(nn)
            if nn < 0 or nn > 200000:
                raise ValueError(
                    ""Step delay is out of range. It must be between "" ""0 and 200000.""
                )

            self._cont.ag_sendcmd(f""{int(self._ax)} DL {nn}"")

        # MODES #

        def am_i_still(self, max_retries=5):
            """"""
            Function to test if an axis stands still. It queries the status of
            the given axis and returns True (if axis is still) or False if it is
            moving.
            The reason this routine is implemented is because the status messages
            can time out. If a timeout occurs, this routine will retry the query
            until `max_retries` is reached. If query is still not successful, an
            IOError will be raised.

            :param int max_retries: Maximum number of retries

            :return: True if the axis is still, False if the axis is moving
            :rtype: bool
            """"""
            retries = 0

            while retries < max_retries:
                status = self.axis_status
                if status == agilis_status_message(0):
                    return True
                elif (
                    status == agilis_status_message(1)
                    or status == agilis_status_message(2)
                    or status == agilis_status_message(3)
                ):
                    return False
                else:
                    retries += 1

            raise OSError(
                ""The function `am_i_still` ran out of maximum retries. ""
                ""Could not query the status of the axis.""
            )

        def stop(self):
            """"""
            Stops the axis. This is useful to interrupt a jogging motion.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ST"")

        def zero_position(self):
            """"""
            Resets the step counter to zero. See `number_of_steps` for details.
            """"""
            self._cont.ag_sendcmd(f""{int(self._ax)} ZP"")

    # ENUMS #

    class Axes(IntEnum):
        """"""
        Enumeration of valid delay channels for the AG-UC2 controller.
        """"""

        X = 1
        Y = 2

    # INNER CLASSES #

    # PROPERTIES #

    @property
    def axis(self):
        """"""
        Gets a specific axis object.

        The desired axis is accessed by passing an EnumValue from
        `~AGUC2.Channels`. For example, to access the X axis (axis 1):

        >>> import instruments as ik
        >>> agl = ik.newport.AGUC2.open_serial(port='COM5', baud=921600)
        >>> agl.axis[""X""].move_relative(1000)

        See example in `AGUC2` for a more details

        :rtype: `AGUC2.Axis`
        """"""
        self.enable_remote_mode = True
        return ProxyList(self, self.Axis, AGUC2.Axes)

    @property
    def enable_remote_mode(self):
        """"""
        Gets / sets the status of remote mode.
        """"""
        return self._remote_mode

    @enable_remote_mode.setter
    def enable_remote_mode(self, newval):
        if newval and not self._remote_mode:
            self._remote_mode = True
            self.ag_sendcmd(""MR"")
        elif not newval and self._remote_mode:
            self._remote_mode = False
            self.ag_sendcmd(""ML"")

    @property
    def error_previous_command(self):
        """"""
        Retrieves the error of the previous command and translates it into a
        string. The string is returned
        """"""
        resp = self.ag_query(""TE"")

        if resp.find(""TE"") == -1:
            return ""Error code query failed.""

        resp = int(resp.replace(""TE"", """"))
        error_message = agilis_error_message(resp)
        return error_message

    @property
    def firmware_version(self):
        """"""
        Returns the firmware version of the controller
        """"""
        resp = self.ag_query(""VE"")
        return resp

    @property
    def limit_status(self):
        """"""
        PARTLY UNTESTED: SEE COMMENT ABOVE

        Returns the limit switch status of the controller. Possible returns
        are:
        - PH0: No limit switch is active
        - PH1: Limit switch of axis #1 (X) is active,
               limit switch of axis #2 (Y)  is not active
        - PH2: Limit switch of axis #2 (Y) is active,
               limit switch of axis #1 (X) is not active
        - PH3: Limit switches of axis #1 (X) and axis #2 (Y) are active

        If device has no limit switch, this routine always returns PH0
        """"""
        self.enable_remote_mode = True
        resp = self.ag_query(""PH"")
        return resp

    @property
    def sleep_time(self):
        """"""
        The device often times out. Therefore a sleep time can be set. The
        routine will wait for this amount (in seconds) every time after a
        command or a query are sent.
        Setting the sleep time: Give time in seconds
        If queried: Returns the sleep time in seconds as a float
        """"""
        return self._sleep_time

    @sleep_time.setter
    def sleep_time(self, t):
        if t < 0:
            raise ValueError(""Sleep time must be >= 0."")

        self._sleep_time = float(t)

    # MODES #

    def reset_controller(self):
        """"""
        Resets the controller. All temporary settings are reset to the default
        value. Controller is put into local model.
        """"""
        self._remote_mode = False
        self.ag_sendcmd(""RS"")

    # SEND COMMAND AND QUERY ROUTINES AGILIS STYLE #

    def ag_sendcmd(self, cmd):
        """"""
        Sends the command, then sleeps
        """"""
        self.sendcmd(cmd)
        time.sleep(self._sleep_time)

    def ag_query(self, cmd, size=-1):
        """"""
        This runs the query command. However, the query command often times
        out for this device. The response of all queries are always strings.
        If timeout occurs, the response will be:
        ""Query timed out.""
        """"""
        try:
            resp = self.query(cmd, size=size)
        except OSError:
            resp = ""Query timed out.""

        # sleep
        time.sleep(self._sleep_time)

        return resp


def agilis_error_message(error_code):
    """"""
    Returns a string with th error message for a given Agilis error code.

    :param int error_code: error code as an integer

    :return: error message
    :rtype: string
    """"""
    if not isinstance(error_code, int):
        return ""Error code is not an integer.""

    error_dict = {
        0: ""No error"",
        -1: ""Unknown command"",
        -2: ""Axis out of range (must be 1 or 2, or must not be specified)"",
        -3: ""Wrong format for parameter nn (or must not be specified)"",
        -4: ""Parameter nn out of range"",
        -5: ""Not allowed in local mode"",
        -6: ""Not allowed in current state"",
    }

    if error_code in error_dict.keys():
        return error_dict[error_code]
    else:
        return ""An unknown error occurred.""


def agilis_status_message(status_code):
    """"""
    Returns a string with the status message for a given Agilis status
    code.

    :param int status_code: status code as returned

    :return: status message
    :rtype: string
    """"""
    if not isinstance(status_code, int):
        return ""Status code is not an integer.""

    status_dict = {
        0: ""Ready (not moving)."",
        1: ""Stepping (currently executing a `move_relative` command)."",
        2: ""Jogging (currently executing a `jog` command with command""
        ""parameter different than 0)."",
        3: ""Moving to limit (currently executing `measure_current_position`, ""
        ""`move_to_limit`, or `move_absolute` command)."",
    }

    if status_code in status_dict.keys():
        return status_dict[status_code]
    else:
        return ""An unknown status occurred.""


"
155,5458.6,USA,"Providing 12 bits all the time, a bigger display, smaller footprint, and more capability, the HDO6000B captures every detail.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a HDO6000B Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",HDO6000B,https://cdn.teledynelecroy.com/files/pdf/hdo6000b-datasheet.pdf,"[OrderedDict([('id', 'attj3CSnSBkmM2yoT'), ('width', 800), ('height', 552), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZkjUIFnDArFJpqQSNyfW6A/qM3wzCf_ihK8BdmMjbhunt8GpYorF_vOH2MZNWxGGDC0BByCEqudTePKGxLo3mn8qHO_KONOmFrWcBEkVTXSkBRCQt7dDoCQMwWMaKF-ZZM/bY2zLqnaxrfB3kA_oEazOomu8XhnKyYLFDqvO7guc3Q'), ('filename', 'hdo6000b09.webp'), ('size', 69476), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/X-wiLoKxcBRZfxcgTPTpjA/ooCXs3IRnoAXANjD_UCspcXxOa11IMp9YNM3uipBWWMYrjc9CpVZu0XofaV5ZzhISPzcxlf0COGL3J0fWRQuQma5oXzuB2RTzTIW-F7tChs/9wqACDL5HNdb8n6fSzkzBFn1HcMVP-cUMcq-qJQLqx4'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Snb_eANVWMCr-fcIjz-bzQ/rjegj5jgf4Pk6Eh5FY68hGGekD7XsYBG8qzUK-_uiZOgH0vuBljqRA-VtMMkz8H9Dymv7pNUqDzV8PPpdcr6W-1hxOSIDdxaBh3Za4dMkFw/sY5Visx4ZLQrzavZn874zRhDwW9JwvoWWomOWt9LNYM'), ('width', 742), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/o1eCfW64J3ABG9ftu4qZAA/f-YvPkohTMcS9Nksuqpp6CftiIbkhvGwhUSs7ZhsnD6E11S84LmPgFdRmKTTZWHPx7-3_CV9PFO58HteqoGouseAPP_cEKYwFAaEpuEogNM/A72kxX6xUDRFAby9IkTFmJ4VqadKqanp3skX6evtKgk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/hdo6000b-high-definition-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,16990.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
157,5458.6,USA,"Providing 12 bits all the time, more channels than any other oscilloscope, and long memory without tradeoffs – the WaveRunner 8000HD 8 channel oscilloscope captures every detail.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveRunner 8000HD Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveRunner 8000HD,https://cdn.teledynelecroy.com/files/pdf/waverunner-8000hd-datasheet.pdf,"[OrderedDict([('id', 'att2AevkrfFPeXyJ8'), ('width', 648), ('height', 475), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zRnpp5vV-xZ9xXWSN3Umxg/2jeNu0n5bQb8-16vYamwDyGvLvv2jbmqCgjXGZoXR9obj3iqjHjSSdkJQuXhmBP38KJnDE8maw1Ztb_Vy3xwL-ZCJxy8ucVv0MCL02x3CHI/4BcYqHhcUHfbpvAJYDFFXeHwHyAoN5xBkZ3hnFn7LSk'), ('filename', 'wr8000-1.webp'), ('size', 62720), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hWbKMbgOFHAFtaIgZtLF7A/2dpFnVYwu_mc0OBxaj3JvaV3C3Ci4ZnlQtHPwDk1b685jUfeklnCgwYWWY0LvjrD8ZpsLlFxAV9sRA6kt-R0WBZszUILpbOypaUiZkqA4sA/YK2khDR5yXNCWs2ZswfQqDGYQDeFfbP3sL4hd-CvRm8'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XsW-pEr9iQCpOAgt1NID1w/NJ_CVHmhMAS2HI7iHuOiJIl-rDB2RebXXbN1S-UDG2nOfimim-_MDwn73KV3_kAeC5uOGqqjcwkT04qOVSMIGvgYZummWzzfLbIVFSH-PmM/pDKkSEeb8oVFyxEFUNt22KcoJXp8XF3n-bvh64Lt6fQ'), ('width', 648), ('height', 475)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kqcfdpOtdY_f0Y3f6Q04Ow/OcVLigyEkbpIeHmAGhoHo6kankUP1w4lgLjFBV0kC2dcIbjC60K4r_5WrJTZL65SW8UfXlr7nZk94Oe3jYWi3RxiwB_Y2VQil7gcufNDEQg/p0_-Yf6-_lbKxt-SGQSeJzQ0q6-Xdo-gvG7nDbvpcc0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/waverunner-8000hd-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,28625.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
171,5800.0,USA,"The TDS510A Digital Oscilloscope is a full-featured, cost-effective, versatile oscilloscope which meets the measurement requirements for general-purpose research and design. Its industry-preferred graphical user interface makes it easy to learn and efficient to use. The TDS510A advanced trigger capability allows the user to trigger and view signals in a wide variety of simple as well as complex design and analysis settings. With four channels, 50 K points per channel record length, and powerful waveform acquisition modes, the TDS510A can satisfy most complex design, debug, and analysis requirements.",Tektds 5 XX,551.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS510A Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS510A,https://www.instrumex.de/datasheet/TDS510A.pdf,"[OrderedDict([('id', 'attxkUJsDPlUzetik'), ('width', 944), ('height', 708), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tGpjQV-hAw3nvptqF7Glvg/x5TsTrYG0bht6ad7bg5U0-g0kLrkLDgp-X4H2zQigS2I8tOGxHvEg7aFRa4K_dd65kCi_nGdvG3hIPRywqlkQBm0EyN9fq7OY2u3Ae1olF0/MHcNbdqGRc41V9uZScmgovjCuBeUimEnPcom5DgMYHM'), ('filename', 'TDS510A.jpeg.webp'), ('size', 31982), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/A9ZGbFJOFHV-kT1Bvr2Mog/oySPosq2qp4Xm_UKxWzTCm8L8hG7rt0sRKdHw4q7Vp--VFtmkH80zKAP_9numGAFFeOWxaE_nt7U_DrRQG36lxjNzsv6q4YdRivYfnmiwyo/QJ2qKuYBUMANWuRs5W1SJPVe3zANH-ItNyD7X0Bc1zg'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gt2ErjxcxKvMtqgKDilUEQ/lzUHtQn2SNgtYiKj7Z78lW4K3R4kutC9EAemM5MlWtpBievWJrqgjGAiqAPTVBxa9J1q2bhpvSOB90SC33VSfVMCTI8td2Hs4DGNTvuOQYc/qfftiMWhkPfWKTwn8sJtTUqo7WhRgvb8TE-c5P_U-zA'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tVuwotn8RVxq99tSrCVziQ/2w7C1j6evDZCbhatIiAbI7HxaINAOF-qGc13F-JEip3LMLC_vzQXsrzlPYm5F1F5vAwPwP1EIyqxjAVrlfCZEHLiPqtSORl0osdhebXy2fs/Slr1OSbV_cwBhxIomBQavoYGBH-UHCsu9_XayDlpsIQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/tds510a,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,1030.0,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
179,110.6,"Cleveland, Ohio, United States","The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High DC power supply sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",Keithley 6220,233.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Electricity_meter,['Power Meters'],"An electricity meter, electric meter, electrical meter, energy meter, or kilowatt-hour meter is a device that measures the amount of electric energy consumed by a residence, a business, or an electrically powered device.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,"[OrderedDict([('id', 'attdoiRLK6g3JNoW5'), ('width', 320), ('height', 138), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Muf-Dl6c-l8yCxEJvGZIAQ/FlGsP3w0U3GEJ5GgUzDet6JdhB2VFxv7CA2_EkBXRRTmk1LjflEgVVVxSoS4T9ghAPfCNLX64bNmR8NLRRp1FKkr0bdrIhoG3d8oS304BMQ/W6BhnT5g842D8XgC0CAmRJmjcABZT2GtzDkVFtISHnA'), ('filename', '6220.webp'), ('size', 4548), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u0tTTVokTHazyIyzSEby8A/xHhh9dgG4UJGJYpIbY310hNQs_qwI9N2pkSrHdF8kFpU8f5tYTEp59_iqd27wntf6qzZEksFs5Pcjbv7lAby4SGaVf920-yBihmVq0lQiuI/iW3hc3dw6zMAKMYB2bR-xICvgEe-rgUnf3cxE0Pd8iM'), ('width', 83), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iRolOhomjciHM3LxhHI14Q/pipFe02E7D5JXxHvjkDB3UZnLZvaScDrFlojArkYZduNqjEDW5iBJbrFreJnUROOnBMbBBmWEQVG9BImdhVT3g-RsPoAOEsHGq8ScF0-HcQ/frnMNIL4-NCE_jHcTSG99qwzxM4R9M_5OU5qtxVo7Pw'), ('width', 320), ('height', 138)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Zpiz3WU6kZdqaC9dW9gi3Q/6BF7ulojm5tACCgNOzs-24w9ETculPGGRoxVG5XK0IFi08mqPgJEoPoL_SfS9HcKfiXPnfVtjNM8FObr9zoFPQScyOAIbwTA7f5cfUV0NoM/vHeInJEIP3IPtKDv4GbSMbmnGYke8X3xYIBV9sUcZ0o'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/6220/source-meter-dc-current-11w/dp/43K0016,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,8631.9,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
184,5458.6,USA,"WavePro HD High-Definition oscilloscopes employ unique Teledyne LeCroy HD4096 technology to achieve 12-bit resolution at up to 8 GHz bandwidth, for the lowest noise and unmatched signal fidelity. Up to 5 Gpt of highly responsive acquisition memory gives more visibility into system behavior, and the exceptional analysis toolbox enables deep insight.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WavePro HD Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WavePro HD,https://cdn.teledynelecroy.com/files/pdf/waveprohd-datasheet.pdf,"[OrderedDict([('id', 'att4IDQeQoh37ZEzt'), ('width', 940), ('height', 627), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Pipv9O8kEz53fcLd4O7XGw/U3ntEQcK9o3T6gQ-6ngZbXv9K6Fe61j_jz8dXs7Ge0gjETsUHo9LL-zY3XX6VziujKD1TtPOJqe7lhvPUryqWxcqDGVPHOAhgtBhdD_LGdM/RJy7rnqBaZwd-kZxZnzNX3fjDG6zVbrL8QgzOlTiQTE'), ('filename', 'wphd-04.png'), ('size', 406177), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mAgC7o6fLRQVqobKx_EHzQ/HlT0eOAvnQ2W8Z3vwMPEYayyMFzG14GB7F7QIL2ZUJsHRv2YhNZwRcOG5raQwa1igIeneyV3nGJ5OQHk-KHWiQ/9oL1wMaUB11I6VWDz0ab6vub4RUWiZP-D-bdqfukC54'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kQnu5iLnyoQPBkgSvEtp1w/9sreZwqcBFS8JorcoZAALVs6QlU4Vp-tspLOw2d6zquI_vZKuuwSkoqftucIsHD0k5Nv3aStrO-2JGj25eEZEw/eFCW9_DzL9Y8Nuk5CinMwL-PkeowFoAZuT8jHNIHp5s'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/F_2AwHw8-AZ_c5Wg43SwGg/_LybrvdZd9nrGnWkGWRtmJOUPJ-u303tHEockGRM9xXSN9vQ2iFc9iCDxhC32V6ynbMWbXdRM2VgzrULGHEmoQ/cZ-G2chcnM24e7XfiejrVhKNc7lA_hnWf3hh28mWCAI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavepro-hd-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,31000.0,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
186,5420.0,USA,"E3631A 80W Triple Output Power Supply, 6V, 5A & ±25V, 1A",HPE 3631 A,156.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Instrumentkit,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Instrumentkit to connect to a Keysight E3631A Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,Keysight E3631A,https://www.keysight.com/us/en/assets/7018-06785/data-sheets/5968-9726.pdf,"[OrderedDict([('id', 'attSpS8B1W8Re8bpU'), ('width', 582), ('height', 431), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6nvdj0u3uCOjNEHM5osq3A/XSKZL2OdvACjPyn508FQ0m31-YWqfEkyqmEe9EIeCeXXjBZmsLTRIAbNxxYznbm6C0lgPGWjl0DHzEbgWdCJHlMuWWGZhx1s78YdfawuT8o/J1d78E_mMaM7TQmtv0BPABCyu42j78yhQRjGU5DqFwg'), ('filename', 'E3631.png'), ('size', 222345), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pVGPpV4IeTzNnQcrH0mIGA/TilfWLTwmvVcEAHI5arIrbInSUsZTBOURNMgMPUWPhASO-RloUy7oQ3ET-C8WPDldnwwnqIIU_2DVelcrufbVA/DHEPu69PQGhSFIBZXGqi3O-U8FDEAn7uUMq170RI51I'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_ZeZcXEWsneHQDZ-vVDkrQ/O0Ze4GgjmHzkX6JDqd_JhbEF_AYifVlv_WkPAoW1b7IJ4IciBIoFFo7S0LLT7G0SmY_CwDGvbyulB9ZabQHGlQ/HcgFen9rA3WJ2KEIrpeLS4znbb766fxelf9bgIl1Occ'), ('width', 582), ('height', 431)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VkFGXT4c_tMz9lyQAR-56w/AKVkboAVU7X0AZYollT6q9m89O_6K8jaF7GVOLzSLs_OH4rIEncmMnNRbTes8egt3gD4Ix-C7JSx0h-9hXv9IA/muuymUmAtx02GSqfAyFl2aDqBda3UORnsElU_rEv-j8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E3631A/80w-triple-output-power-supply-6v-5a--25v-1a.html,https://github.com/psmd-iberutaru/Keysight-E3631A-Python/blob/master/Keysight_E3631A.py,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/hp/hpe3631a.html,2300.0,,,,
189,5458.6,USA,"The WaveSurfer 510 combines the MAUI with OneTouch user interface with powerful waveform processing, in addition to advanced math, measurement, and debug tools, to quickly analyze and find the root cause of problems. The 12.1” touch-screen display of the WaveSurfer 510 is the largest in its class and makes viewing waveform abnormalities fast and easy.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 510 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveSurfer 510,"https://res.cloudinary.com/iwh/image/upload/q_auto,g_center/assets/1/26/wavesurfer510-ds-24mar17-prelim.pdf","[OrderedDict([('id', 'attoBSvdaeYOq105z'), ('width', 1024), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/slLDJAM6JAAMaq9MppQDmA/FgyODuazdRGigjX71Lu5FgaH5p9-0XLr8LZpxCi3z9sHFcch75K85vSxN23QLIx9Weztpul3QmoF5_bNa3xxwnll0LFefBGr3Eq-EiIVC_nZ8jQ00puXhm_JZipmPKv-/AXpYW8Ro0XnPgySxDBt5Vt538IkxX1gUM5-iS5_Eat0'), ('filename', 'LeCroy_WaveSurfer-510_img2.jpg'), ('size', 73189), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xeeD7fcKSxRRyjOT_XCzvQ/mm1171UVjOt0paC4BZ5N7MC_rJ1H9Q01A3muoN0pnz5or780vTESmAQcSwlIyahAwR5Ux4VmeFoLiClg-eh1IQ/VY7knnq01x1ROyLUYYTHKL1Oa2eIMjl6a3TNWnlC6ao'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OS6P8-wN_A67bAA0R3rj9A/HhRrVyhmYS55qnIjGlsigYsuaxk9mumXp8B38O2711c9KUAHV_udIIyhfGMnd6jukmvKMC36QhCvi1hbtSU9LQ/YUJ4jq_8LKd8h8p_drPT-B7w1Ln04_TUgYJ8qd8OzR0'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9GiqiFywqY_nfXInd1gMtg/98rg_8lQVrgNccz_209NtDL4eP6mINXaJr4mnvxENelM_BBEJ4vJO0ipP6mIoEdlBVgZhVjooWEi80cpECqRmA/B0CYjKDIOSwATkyoo2Ers67UhsAtLJ4DXuqPsBuX6RU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tequipment.net/LeCroy/WaveSurfer-510/Digital-Oscilloscopes/,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,13553.0,,True,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
191,550.0,USA,"The LCC25 is a liquid crystal controller compatible with all Thorlabs LC Variable
Retarders. The LCC25 will drive most nematic liquid crystal devices. The liquid crystal
device is connected to the BNC voltage output port. The amplitude of the output voltage,
adjusted by the front panel knob, and external signal, and a computer via a USB interface,
controls the retardance of the LC device.",LCC 25,607.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a LCC25 Power Supplies,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=14074,['Power Supplies'],"A part of Thorlabs' growing line of high-end, compact controllers and is designed to drive many of Thorlabs' liquid crystal variable retarders, polarization rotators, and cells",LCC25,https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,"[OrderedDict([('id', 'attmlcDNsJInQeJ3u'), ('width', 840), ('height', 340), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Qf6WnFZ1O_MW5KbTLxm7yg/aofzJyjXaV3ltbnK13Rk84WlJuo7WaM7RA3n6d2kw55v6hmOpK2wQMexWcPDQ-nytDAMM9ugU4NoTZbmxWLjQ82SZu8_QPxW5G5a1vJ__AQphtWBdzzHIn7gJLPHGS7G/9LZs7yz_u_iY08aKlG7yw2_Joan1yslq9bAMOgvltj4'), ('filename', '14071_LCCVoltageCtrl_1.jpg'), ('size', 96350), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yjCx0xjkdUK6-C0dJSsw3A/TwGUwI3a_cl5iaQwMx1HZAYOubGSU8AfZGkZIGdMOXEzmN8C9cTRSG8Mksdaq-XT4ehHP9S7lf-DQLraoYU3XQ/0D5xbrrMrEAurRCJFbDqrhSysNtIIIVfzXQagS6bO4Q'), ('width', 89), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/smNepjTZdK6zsis7KgXZDQ/zoHY-QUc4K-RLco63xTPJbX4-PBkJOJqahqAi-VyAfTkcfigm9hLbM012PmP1l9PFr2p1EcQ3Xxtb-uURR12Aw/pqfpmaGbz0GiK5fhZevVNCUN3CJ_Y_2-sNriyl_zANk'), ('width', 840), ('height', 340)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JlEsbxnd1v2QzZsMgyjKpw/uDpUcHunI91L-pAQFHWyUrNXr3WL6wQyyDUI7TJGudsbHpqY9B9Lo-BUH_v4KnfhFU_5vSz_uwMiORXbLBaslg/nS8kZoYcvWUVw5RLaqipEcBjo-iKEwBYYAF-Ztqjluw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/_sd.cfm?fileName=18828-D02.pdf&partNumber=LCC25,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/lcc25.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#lcc25-liquid-crystal-controller,1512.85,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
193,5.0,"Vista, California, United States",,MC1,433.0,"Qubitekk provides reliable products for generating, preparing, distributing, detecting, correlating and storing photonic qubits. The hardware that is needed to strengthen American leadership in quantum computing, communications, and sensing solutions is being developed and manufactured in San Diego County, CA.
",Instrumentkit,Qubitekk,"[OrderedDict([('id', 'attkNSzS2HQFvTpYT'), ('width', 600), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_fNYJEtBJV9okXsIo-8vow/vS4kLPigoJgfMmi4ZsOkgM0dD-le_4oikqQVc9TWe3KagVp5y1fbcYEhJ6mlaHqSKzf_vuEjsYNGlhclzYE23LYSgEUz4D5oOdL1-4hrjWtq7CSCYdTjNhv0UFBgZQxC/hZBNGlg2bFWGXuCw3YrDZiW4ZnhDsp6Va2K0X67f3bg'), ('filename', 'qubitekk_logo_rgb_web1600-600x159.png'), ('size', 23948), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Ybph2quaq9LjCwcez_fDQ/vQ7BOadlnCLommpydj4GNZbamMQkMLlZnzwGu8-qPxhmGsdggku8oECCbFODA_VwJzN_3yA7gzUHIN98B6s1-A/Pc2AHNi5G5qtdLtaTDAwRaSDn8WTNVWE4TSUVBgmgGY'), ('width', 136), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EeM2EkrBHOahu1BiwPu2yw/Ep7ZkJ429CVbmQh4kAF_DKMrkYk7fUujJ86Gh0XskGW3jd1WeCe0aUZy539MIPtgsv78sJ2XAtnOI8-9WXiHVQ/QyukOuVa6S4xsDMTkNWp2whkZgWOcQeG-u4vTUDJ4YQ'), ('width', 600), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rpG9gmSfNrKHatCgSBZCzQ/-GYzSYqwePXEXd_Ia-Wx5uhTSqJjj_FPIY5J5xkmsbzpa0YzaOqeFMkwADieU_jM1Rm2CCG5s5HyeFUcB0dXSg/a72MWvNqvjQYWMYE_pJ-xgv4wDusUn313a940PXLlWQ'), ('width', 3000), ('height', 3000)]))]))])]",https://qubitekk.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",,,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/qubitekk/mc1.py,https://instrumentkit.readthedocs.io/en/latest/apiref/qubitekk.html#mc1-motor-controller,,,,,"

Source code for instruments.qubitekk.cc1
#!/usr/bin/env python
""""""
Provides support for the Qubitekk CC1 Coincidence Counter instrument.

CC1 Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi.scpi_instrument import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units, split_unit_str

# CLASSES #####################################################################


class CC1(SCPIInstrument):

    """"""
    The CC1 is a hand-held coincidence counter.

    It has two setting values, the dwell time and the coincidence window. The
    coincidence window determines the amount of time (in ns) that the two
    detections may be from each other and still be considered a coincidence.
    The dwell time is the amount of time that passes before the counter will
    send the clear signal.

    More information can be found at :
    http://www.qubitekk.com
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\n""
        self._channel_count = 3
        self._firmware = None
        self._ack_on = False
        self.sendcmd("":ACKN OF"")
        # a readline is required because if the firmware is prior to 2.2,
        # the cc1 will respond with 'Unknown Command'. After
        # 2.2, it will either respond by acknowledging the command (turning
        # acknowledgements off does not take place until after the current
        # exchange has been completed), or not acknowledging it (if the
        # acknowledgements are off). The try/except block is required to
        # handle the case in which acknowledgements are off.
        try:
            self.read(-1)
        except OSError:
            pass
        _ = self.firmware  # prime the firmware

        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            self._bool = (""ON"", ""OFF"")
            self._set_fmt = "":{}:{}""
            self.TriggerMode = self._TriggerModeNew

        else:
            self._bool = (""1"", ""0"")
            self._set_fmt = "":{} {}""
            self.TriggerMode = self._TriggerModeOld

    def _ack_expected(self, msg=""""):
        return (
            msg
            if self._ack_on and self.firmware[0] >= 2 and self.firmware[1] > 1
            else None
        )

    # ENUMS #

    class _TriggerModeNew(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""MODE CONT""
        start_stop = ""MODE STOP""

    class _TriggerModeOld(Enum):
        """"""
        Enum containing valid trigger modes for the CC1
        """"""

        continuous = ""0""
        start_stop = ""1""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a channel on the Qubitekk CC1.
        """"""

        __CHANNEL_NAMES = {1: ""C1"", 2: ""C2"", 3: ""CO""}

        def __init__(self, cc1, idx):
            self._cc1 = cc1
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        # PROPERTIES #

        @property
        def count(self):
            """"""
            Gets the counts of this channel.

            :rtype: `int`
            """"""
            count = self._cc1.query(f""COUN:{self._chan}?"")
            tries = 5
            try:
                count = int(count)
            except ValueError:
                count = None
                while count is None and tries > 0:
                    # try to read again
                    try:
                        count = int(self._cc1.read(-1))
                    except ValueError:
                        count = None
                        tries -= 1

            if tries == 0:
                raise OSError(f""Could not read the count of channel "" f""{self._chan}."")

            self._count = count
            return self._count

    # PROPERTIES #

    @property
    def acknowledge(self):
        """"""
        Gets/sets the acknowledge message state. If True, the CC1 will echo
        back every command sent, then print the response (either Unable to
        comply, Unknown command or the response to a query). If False,
        the CC1 will only print the response.

        :units: None
        :type: boolean
        """"""
        return self._ack_on

    @acknowledge.setter
    def acknowledge(self, new_val):
        if self.firmware[0] >= 2 and self.firmware[1] > 1:
            if self._ack_on and not new_val:
                self.sendcmd("":ACKN OF"")
                self._ack_on = False
            elif not self._ack_on and new_val:
                self.sendcmd("":ACKN ON"")
                self._ack_on = True
        else:
            raise NotImplementedError(
                ""Acknowledge message not implemented in "" ""this version.""
            )

    @property
    def gate(self):
        """"""
        Gets/sets the gate enable status

        :type: `bool`
        """"""
        return self.query(""GATE?"").strip() == self._bool[0]

    @gate.setter
    def gate(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""GATE"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def subtract(self):
        """"""
        Gets/sets the subtract enable status

        :type: `bool`
        """"""
        return self.query(""SUBT?"").strip() == self._bool[0]

    @subtract.setter
    def subtract(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Bool properties must be specified with a "" ""boolean value"")
        self.sendcmd(
            self._set_fmt.format(""SUBT"", self._bool[0] if newval else self._bool[1])
        )

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode setting for the CC1. This can be set to
        ``continuous`` or ``start/stop`` modes.

        :type: `CC1.TriggerMode`
        """"""
        return self.TriggerMode(self.query(""TRIG?"").strip())

    @trigger_mode.setter
    def trigger_mode(self, newval):
        try:  # First assume newval is Enum.value
            newval = self.TriggerMode[newval]
        except KeyError:  # Check if newval is Enum.name instead
            try:
                newval = self.TriggerMode(newval)
            except ValueError:
                raise ValueError(""Enum property new value not in enum."")
        self.sendcmd(self._set_fmt.format(""TRIG"", self.TriggerMode(newval).value))

    @property
    def window(self):
        """"""
        Gets/sets the length of the coincidence window between the two signals.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units nanoseconds.
        :type: `~pint.Quantity`
        """"""
        return u.Quantity(*split_unit_str(self.query(""WIND?""), ""ns""))

    @window.setter
    def window(self, new_val):
        new_val_mag = int(assume_units(new_val, u.ns).to(u.ns).magnitude)
        if new_val_mag < 0 or new_val_mag > 7:
            raise ValueError(""Window is out of range."")
        # window must be an integer!
        self.sendcmd(f"":WIND {new_val_mag}"")

    @property
    def delay(self):
        """"""
        Get/sets the delay value (in nanoseconds) on Channel 1.

        When setting, ``N`` may be ``0, 2, 4, 6, 8, 10, 12, or 14ns``.

        :rtype: `~pint.Quantity`
        :return: the delay value
        """"""
        return u.Quantity(*split_unit_str(self.query(""DELA?""), ""ns""))

    @delay.setter
    def delay(self, new_val):
        new_val = assume_units(new_val, u.ns).to(u.ns)
        if new_val < 0 * u.ns or new_val > 14 * u.ns:
            raise ValueError(""New delay value is out of bounds."")
        if new_val.magnitude % 2 != 0:
            raise ValueError(""New magnitude must be an even number"")
        self.sendcmd("":DELA "" + str(int(new_val.magnitude)))

    @property
    def dwell_time(self):
        """"""
        Gets/sets the length of time before a clear signal is sent to the
        counters.

        :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units seconds.
        :type: `~pint.Quantity`
        """"""
        # the older versions of the firmware erroneously report the units of the
        # dwell time as being seconds rather than ms
        dwell_time = u.Quantity(*split_unit_str(self.query(""DWEL?""), ""s""))
        if self.firmware[0] <= 2 and self.firmware[1] <= 1:
            return dwell_time / 1000.0

        return dwell_time

    @dwell_time.setter
    def dwell_time(self, new_val):
        new_val_mag = assume_units(new_val, u.s).to(u.s).magnitude
        if new_val_mag < 0:
            raise ValueError(""Dwell time cannot be negative."")
        self.sendcmd(f"":DWEL {new_val_mag}"")

    @property
    def firmware(self):
        """"""
        Gets the firmware version

        :rtype: `tuple`(Major:`int`, Minor:`int`, Patch`int`)
        """"""
        # the firmware is assumed not to change while the device is active
        # firmware is stored locally as it will be gotten often
        # pylint: disable=no-member
        if self._firmware is None:
            while self._firmware is None:
                self._firmware = self.query(""FIRM?"")
                if self._firmware.find(""Unknown"") >= 0:
                    self._firmware = None
                else:
                    value = self._firmware.replace(""Firmware v"", """").split(""."")
                    if len(value) < 3:
                        for _ in range(3 - len(value)):
                            value.append(0)
                    value = tuple(map(int, value))
                    self._firmware = value
        return self._firmware

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> cc = ik.qubitekk.CC1.open_serial('COM8', 19200, timeout=1)
        >>> print(cc.channel[0].count)

        :rtype: `CC1.Channel`
        """"""
        return ProxyList(self, CC1.Channel, range(self._channel_count))

    # METHODS #

    def clear_counts(self):
        """"""
        Clears the current total counts on the counters.
        """"""
        self.sendcmd(""CLEA"")


"
197,110.6,"Cleveland, Ohio, United States","The Keithley 195A Digital Multimeter is a fully programmable instrument with a 5.5 digit resolution. In standard configuration, the Model 195A is capable of DC voltage measurements between 100nV and 1000V on six ranges, 2-terminal and 4-terminal resistance measurements between 100µO and 20MO on seven ranges. The instrument is designed to work with platinum RTD probes, a factor which contributes to high accuracy.",Keithley 195,210.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a {Device name} Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",,http://chrisgrossman.com/manuals/keithley/KEITHLEY-195A-Datasheet.pdf,"[OrderedDict([('id', 'attY6gK1wdeglTdjY'), ('width', 600), ('height', 373), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NAvXWWe3NUyRU4axBLs0RA/8PHNDJ428p-hzr1tSTUo6mIgmYG_VXrM36NGv2ao2XdqlHy9i9r6TtRpUb_sQmY5_aJknmpRrJWDKNPJTtne1A/mBDOQyDvrqALRD68l0blRmS2xtp1wjnX9CRoXd19vG4'), ('filename', '195.jpg'), ('size', 28452), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LmQo3WLrhUa_ocsLSPvSDQ/cXb69hQSYAGE_wsjMnId2miH-hR3sZs_4V4wRlMwEmQjtznXWNMFln1RnaHk8TfxIylH32z-710U0i2TMQ-zww/r6gMwyotqzzNUlPnEp7bRBWZLUnREzhnbvhWQ97lGkQ'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t4N0_NdmDYT7CTafY8xTqw/py9s9x1Ae7EnLE7C5DCd-T5GwgFFZj-x3FYohmiSv9AapZ_oJihoazBZYCRFiQmjrE8DawD5xZzH-m1a-Oy38A/RTRGPB87WaelLMRlX5HG9fmEcpKVYwezRgYOSxOi1_s'), ('width', 600), ('height', 373)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EjV0Xix9LJmn72Q3BcmG1Q/8vEvrrIlgRDt1vkRkPwOLjC7nahDByQuEuBXSyaXDZnzP28FuACXke4F4gOu5BCvgZJaeS0_rgJQwXtiw28VWQ/8dYRiZE06k66vwALStV1HRrSbys_G5OXMtXP5F-24mk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/78005-3/Keithley-195A-Digital-Multimeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley195.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley195-digital-multimeter,,,,,"

Source code for instruments.keithley.keithley195
#!/usr/bin/env python
""""""
Driver for the Keithley 195 digital multimeter
""""""

# IMPORTS #####################################################################


import time
import struct
from enum import Enum, IntEnum

from instruments.abstract_instruments import Multimeter
from instruments.units import ureg as u

# CLASSES #####################################################################


class Keithley195(Multimeter):

    """"""
    The Keithley 195 is a 5 1/2 digit auto-ranging digital multimeter. You can
    find the full specifications list in the `Keithley 195 user's guide`_.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
    >>> print dmm.measure(dmm.Mode.resistance)

    .. _Keithley 195 user's guide: http://www.keithley.com/data?asset=803
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.sendcmd(""YX"")  # Removes the termination CRLF
        self.sendcmd(""G1DX"")  # Disable returning prefix and suffix

    # ENUMS ##

    class Mode(IntEnum):
        """"""
        Enum containing valid measurement modes for the Keithley 195
        """"""

        voltage_dc = 0
        voltage_ac = 1
        resistance = 2
        current_dc = 3
        current_ac = 4

    class TriggerMode(IntEnum):
        """"""
        Enum containing valid trigger modes for the Keithley 195
        """"""

        talk_continuous = 0
        talk_one_shot = 1
        get_continuous = 2
        get_one_shot = 3
        x_continuous = 4
        x_one_shot = 5
        ext_continuous = 6
        ext_one_shot = 7

    class ValidRange(Enum):
        """"""
        Enum containing valid range settings for the Keithley 195
        """"""

        voltage_dc = (20e-3, 200e-3, 2, 20, 200, 1000)
        voltage_ac = (20e-3, 200e-3, 2, 20, 200, 700)
        current_dc = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)
        current_ac = (20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2, 2)
        resistance = (20, 200, 2000, 20e3, 200e3, 2e6, 20e6)

    # PROPERTIES #

    @property
    def mode(self):
        """"""
        Gets/sets the measurement mode for the Keithley 195. The base model
        only has DC voltage and resistance measurements. In order to use AC
        voltage, DC current, and AC current measurements your unit must be
        equiped with option 1950.

        Example use:

        >>> import instruments as ik
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> dmm.mode = dmm.Mode.resistance

        :type: `Keithley195.Mode`
        """"""
        return self.parse_status_word(self.get_status_word())[""mode""]

    @mode.setter
    def mode(self, newval):
        if isinstance(newval, str):
            newval = self.Mode[newval]
        if not isinstance(newval, Keithley195.Mode):
            raise TypeError(
                ""Mode must be specified as a Keithley195.Mode ""
                ""value, got {} instead."".format(newval)
            )
        self.sendcmd(f""F{newval.value}DX"")

    @property
    def trigger_mode(self):
        """"""
        Gets/sets the trigger mode of the Keithley 195.

        There are two different trigger settings for four different sources.
        This means there are eight different settings for the trigger mode.

        The two types are continuous and one-shot. Continuous has the instrument
        continuously sample the resistance. One-shot performs a single
        resistance measurement.

        The three trigger sources are on talk, on GET, and on ""X"". On talk
        refers to addressing the instrument to talk over GPIB. On GET is when
        the instrument receives the GPIB command byte for ""group execute
        trigger"". On ""X"" is when one sends the ASCII character ""X"" to the
        instrument. This character is used as a general execute to confirm
        commands send to the instrument. In InstrumentKit, ""X"" is sent after
        each command so it is not suggested that one uses on ""X"" triggering.
        Last, is external triggering. This is the port on the rear of the
        instrument. Refer to the manual for electrical characteristics of this
        port.

        :type: `Keithley195.TriggerMode`
        """"""
        return self.parse_status_word(self.get_status_word())[""trigger""]

    @trigger_mode.setter
    def trigger_mode(self, newval):
        if isinstance(newval, str):
            newval = Keithley195.TriggerMode[newval]
        if not isinstance(newval, Keithley195.TriggerMode):
            raise TypeError(
                ""Drive must be specified as a ""
                ""Keithley195.TriggerMode, got {} ""
                ""instead."".format(newval)
            )
        self.sendcmd(f""T{newval.value}X"")

    @property
    def relative(self):
        """"""
        Gets/sets the zero command (relative measurement) mode of the
        Keithley 195.

        As stated in the manual: The zero mode serves as a means for a baseline
        suppression. When the correct zero command is send over the bus, the
        instrument will enter the zero mode, as indicated by the front panel
        ZERO indicator light. All reading displayed or send over the bus while
        zero is enabled are the difference between the stored baseline adn the
        actual voltage level. For example, if a 100mV baseline is stored, 100mV
        will be subtracted from all subsequent readings as long as the zero mode
        is enabled. The value of the stored baseline can be as little as a few
        microvolts or as large as the selected range will permit.

        See the manual for more information.

        :type: `bool`
        """"""
        return self.parse_status_word(self.get_status_word())[""relative""]

    @relative.setter
    def relative(self, newval):
        if not isinstance(newval, bool):
            raise TypeError(""Relative mode must be a boolean."")
        self.sendcmd(f""Z{int(newval)}DX"")

    @property
    def input_range(self):
        """"""
        Gets/sets the range of the Keithley 195 input terminals. The valid range
        settings depends on the current mode of the instrument. They are listed
        as follows:

        #) voltage_dc = ``(20e-3, 200e-3, 2, 20, 200, 1000)``

        #) voltage_ac = ``(20e-3, 200e-3, 2, 20, 200, 700)``

        #) current_dc = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) current_ac = ``(20e-6, 200e-6, 2e-3, 20e-3, 200e-3, 2)``

        #) resistance = ``(20, 200, 2000, 20e3, 200e3, 2e6, 20e6)``

        All modes will also accept the string ``auto`` which will set the 195
        into auto ranging mode.

        :rtype: `~pint.Quantity` or `str`
        """"""
        index = self.parse_status_word(self.get_status_word())[""range""]
        if index == 0:
            return ""auto""

        mode = self.mode
        value = Keithley195.ValidRange[mode.name].value[index - 1]
        units = UNITS2[mode]
        return value * units

    @input_range.setter
    def input_range(self, newval):
        if isinstance(newval, str):
            if newval.lower() == ""auto"":
                self.sendcmd(""R0DX"")
                return
            else:
                raise ValueError(
                    'Only ""auto"" is acceptable when specifying '
                    ""the input range as a string.""
                )
        if isinstance(newval, u.Quantity):
            newval = float(newval.magnitude)

        mode = self.mode
        valid = Keithley195.ValidRange[mode.name].value
        if isinstance(newval, (float, int)):
            if newval in valid:
                newval = valid.index(newval) + 1
            else:
                raise ValueError(
                    ""Valid range settings for mode {} "" ""are: {}"".format(mode, valid)
                )
        else:
            raise TypeError(
                ""Range setting must be specified as a float, int, ""
                'or the string ""auto"", got {}'.format(type(newval))
            )
        self.sendcmd(f""R{newval}DX"")

    # METHODS #

    def measure(self, mode=None):
        """"""
        Instruct the Keithley 195 to perform a one time measurement. The
        instrument will use default parameters for the requested measurement.
        The measurement will immediately take place, and the results are
        directly sent to the instrument's output buffer.

        Method returns a Python quantity consisting of a numpy array with the
        instrument value and appropriate units.

        With the 195, it is HIGHLY recommended that you seperately set the
        mode and let the instrument settle into the new mode. This can sometimes
        take longer than the 2 second delay added in this method. In our testing
        the 2 seconds seems to be sufficient but we offer no guarentee.

        Example usage:

        >>> import instruments as ik
        >>> import instruments.units as u
        >>> dmm = ik.keithley.Keithley195.open_gpibusb('/dev/ttyUSB0', 12)
        >>> print(dmm.measure(dmm.Mode.resistance))

        :param mode: Desired measurement mode. This must always be specified
            in order to provide the correct return units.
        :type mode: `Keithley195.Mode`

        :return: A measurement from the multimeter.
        :rtype: `~pint.Quantity`
        """"""
        if mode is not None:
            current_mode = self.mode
            if mode != current_mode:
                self.mode = mode
                time.sleep(2)  # Gives the instrument a moment to settle
        else:
            mode = self.mode
        value = self.query("""")
        return float(value) * UNITS2[mode]

    def get_status_word(self):
        """"""
        Retreive the status word from the instrument. This contains information
        regarding the various settings of the instrument.

        The function `~Keithley195.parse_status_word` is designed to parse
        the return string from this function.

        :return: String containing setting information of the instrument
        :rtype: `str`
        """"""
        self.sendcmd(""U0DX"")
        return self._file.read_raw()

    @staticmethod
    def parse_status_word(statusword):  # pylint: disable=too-many-locals
        """"""
        Parse the status word returned by the function
        `~Keithley195.get_status_word`.

        Returns a `dict` with the following keys:
        ``{trigger,mode,range,eoi,buffer,rate,srqmode,relative,delay,multiplex,
        selftest,dataformat,datacontrol,filter,terminator}``

        :param statusword: Byte string to be unpacked and parsed
        :type: `str`

        :return: A parsed version of the status word as a Python dictionary
        :rtype: `dict`
        """"""
        if statusword[:3] != b""195"":
            raise ValueError(
                ""Status word starts with wrong prefix, expected ""
                ""195, got {}"".format(statusword)
            )

        (
            trigger,
            function,
            input_range,
            eoi,
            buf,
            rate,
            srqmode,
            relative,
            delay,
            multiplex,
            selftest,
            data_fmt,
            data_ctrl,
            filter_mode,
            terminator,
        ) = struct.unpack(""@4c2s3c2s5c2s"", statusword[4:])

        return {
            ""trigger"": Keithley195.TriggerMode(int(trigger)),
            ""mode"": Keithley195.Mode(int(function)),
            ""range"": int(input_range),
            ""eoi"": (eoi == b""1""),
            ""buffer"": buf,
            ""rate"": rate,
            ""srqmode"": srqmode,
            ""relative"": (relative == b""1""),
            ""delay"": delay,
            ""multiplex"": (multiplex == b""1""),
            ""selftest"": selftest,
            ""dataformat"": data_fmt,
            ""datacontrol"": data_ctrl,
            ""filter"": filter_mode,
            ""terminator"": terminator,
        }

    def trigger(self):
        """"""
        Tell the Keithley 195 to execute all commands that it has received.

        Do note that this is different from the standard SCPI ``*TRG`` command
        (which is not supported by the 195 anyways).
        """"""
        self.sendcmd(""X"")

    def auto_range(self):
        """"""
        Turn on auto range for the Keithley 195.

        This is the same as calling ``Keithley195.input_range = 'auto'``
        """"""
        self.input_range = ""auto""


# UNITS #######################################################################

UNITS = {
    ""DCV"": u.volt,
    ""ACV"": u.volt,
    ""ACA"": u.amp,
    ""DCA"": u.amp,
    ""OHM"": u.ohm,
}

UNITS2 = {
    Keithley195.Mode.voltage_dc: u.volt,
    Keithley195.Mode.voltage_ac: u.volt,
    Keithley195.Mode.current_dc: u.amp,
    Keithley195.Mode.current_ac: u.amp,
    Keithley195.Mode.resistance: u.ohm,
}


"
198,550.0,USA,"This four-channel controller features four SMC outputs to drive piezo inertia devices. The channels can be controlled independently or simultaneously in pairs using the dual-axis joystick on the controller's top panel. The controller can be configured to operate up to four PD series piezo inertia stages, up to four PIA series piezo inertia actuators, or up to two PIM series piezo inertia optic mounts; one KIM101 can only concurrently drive devices that use the same ""Select Stage"" configuration in the controller's menu options",APTPiezoInertiaActuator,597.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a KIM101 Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",KIM101,https://www.thorlabs.com/_sd.cfm?fileName=ETN040053-D02.pdf&partNumber=KIM101,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e5p2hIiYq4ygH4khmRIKLw/ZD4x5niolV8v29Dg1BYA-yIAs0hCdhtK_Rt5ZIHfAIuHRFX2_6VzXjF0CQsRqnXJDkX1r0oKBH3Wy0sY1y0CzRykIef8ZtiFib9H9nL7WIs/Y4YGi6k1iLrvGxezkKsgc2Lr7us2Nt5IH6yrFXNaGsA'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LH9VOO1-QWVbqSBlfCpdHg/ZILQv8IWyiXuEv8vrDPHObsUKwNl3eEHI11HMPaRv5STaU5Jl14gvqOT7Q85Rjv1ugzEj0Byxabt2BK1rfpcrA/INmcYoOiFdwKFqV2QZl_yjUTWkIyaytdbo99VtoEiZU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LwLdxZbFTKez2J1i3QOgzQ/LQ2ErEJRe1xEPEbfMLfw6LdMUa4lHxdXURUjwrpUJNkObvQy6yh4QEiTKon_RB1--YzbzdVJLnLlVWvy6Q-yag/r0UaUVgJi43ScfRiYbsjtv0P36zI3YLRjKJtRdl0dOw'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cfYFq7TTLm2n-rwxiPFEw/quBDi89yhEJfDV6GuiePn1tRu4LIjZBCiBP1MztDFl7g2r2AXMxxmdZPrj58koXoNdYNaU--ztNiVI9GmYBDGQ/CA45yKB31zOaGOkYL-kwh9Bf6o6DeYfTmgVXuwTsbWM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,1183.98,,,,"

Source code for instruments.thorlabs.pm100usb
#!/usr/bin/env python
""""""
Provides the support for the Thorlabs PM100USB power meter.
""""""

# IMPORTS #####################################################################


import logging
from collections import defaultdict, namedtuple

from enum import Enum, IntEnum

from instruments.units import ureg as u

from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property

# LOGGING #####################################################################

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# CLASSES #####################################################################


class PM100USB(SCPIInstrument):

    """"""
    Instrument class for the `ThorLabs PM100USB`_ power meter.
    Note that as this is an SCPI-compliant instrument, the properties and
    methods of :class:`~instruments.generic_scpi.SCPIInstrument` may be used
    as well.

    .. _ThorLabs PM100USB: http://www.thorlabs.com/thorproduct.cfm?partnumber=PM100USB
    """"""

    # ENUMS #

    class SensorFlags(IntEnum):
        """"""
        Enum containing valid sensor flags for the PM100USB
        """"""

        is_power_sensor = 1
        is_energy_sensor = 2
        response_settable = 16
        wavelength_settable = 32
        tau_settable = 64
        has_temperature_sensor = 256

    class MeasurementConfiguration(Enum):
        """"""
        Enum containing valid measurement modes for the PM100USB
        """"""

        current = ""CURR""
        power = ""POW""
        voltage = ""VOLT""
        energy = ""ENER""
        frequency = ""FREQ""
        power_density = ""PDEN""
        energy_density = ""EDEN""
        resistance = ""RES""
        temperature = ""TEMP""

    # We will cheat and also represent things by a named tuple over bools.
    # TODO: make a flagtuple into a new type in util_fns, copying this out
    #       as a starting point.
    _SensorFlags = namedtuple(
        ""SensorFlags"",
        [flag.name for flag in SensorFlags],  # pylint: disable=not-an-iterable
    )

    # INNER CLASSES #

    class Sensor:
        """"""
        Class representing a sensor on the ThorLabs PM100USB

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `PM100USB` class.
        """"""

        def __init__(self, parent):
            self._parent = parent

            # Pull details about the sensor from SYST:SENSOR:IDN?
            sensor_idn = parent.query(""SYST:SENSOR:IDN?"")
            (
                self._name,
                self._serial_number,
                self._calibration_message,
                self._sensor_type,
                self._sensor_subtype,
                self._flags,
            ) = sensor_idn.split("","")

            # Normalize things to enums as appropriate.
            # We want flags to be a named tuple over bools.
            # pylint: disable=protected-access
            self._flags = parent._SensorFlags(
                **{
                    e.name: bool(e & int(self._flags))
                    for e in PM100USB.SensorFlags  # pylint: disable=not-an-iterable
                }
            )

        @property
        def name(self):
            """"""
            Gets the name associated with the sensor channel

            :type: `str`
            """"""
            return self._name

        @property
        def serial_number(self):
            """"""
            Gets the serial number of the sensor channel

            :type: `str`
            """"""
            return self._serial_number

        @property
        def calibration_message(self):
            """"""
            Gets the calibration message of the sensor channel

            :type: `str`
            """"""
            return self._calibration_message

        @property
        def type(self):
            """"""
            Gets the sensor type of the sensor channel

            :type: `str`
            """"""
            return self._sensor_type, self._sensor_subtype

        @property
        def flags(self):
            """"""
            Gets any sensor flags set on the sensor channel

            :type: `collections.namedtuple`
            """"""
            return self._flags

    # PRIVATE ATTRIBUTES #

    _cache_units = False

    # UNIT CACHING #

    @property
    def cache_units(self):
        """"""
        If enabled, then units are not checked every time a measurement is
        made, reducing by half the number of round-trips to the device.

        .. warning::

            Setting this to `True` may cause incorrect values to be returned,
            if any commands are sent to the device either by its local panel,
            or by software other than InstrumentKit.

        :type: `bool`
        """"""
        return bool(self._cache_units)

    @cache_units.setter
    def cache_units(self, newval):
        self._cache_units = (
            self._READ_UNITS[self.measurement_configuration] if newval else False
        )

    # SENSOR PROPERTIES #

    @property
    def sensor(self):
        """"""
        Returns information about the currently connected sensor.

        :type: :class:`PM100USB.Sensor`
        """"""
        return self.Sensor(self)

    # SENSING CONFIGURATION PROPERTIES #

    # TODO: make a setting of this refresh cache_units.
    measurement_configuration = enum_property(
        ""CONF"",
        MeasurementConfiguration,
        doc=""""""
        Returns the current measurement configuration.

        :rtype: :class:`PM100USB.MeasurementConfiguration`
        """""",
    )

    @property
    def averaging_count(self):
        """"""
        Integer specifying how many samples to collect and average over for
        each measurement, with each sample taking approximately 3 ms.
        """"""
        return int(self.query(""SENS:AVER:COUN?""))

    @averaging_count.setter
    def averaging_count(self, newval):
        if newval < 1:
            raise ValueError(""Must count at least one time."")
        self.sendcmd(f""SENS:AVER:COUN {newval}"")

    # METHODS ##

    _READ_UNITS = defaultdict(lambda: u.dimensionless)
    _READ_UNITS.update(
        {
            MeasurementConfiguration.power: u.W,
            MeasurementConfiguration.current: u.A,
            MeasurementConfiguration.frequency: u.Hz,
            MeasurementConfiguration.voltage: u.V,
        }
    )

    def read(self, size=-1, encoding=""utf-8""):
        """"""
        Reads a measurement from this instrument, according to its current
        configuration mode.

        :param int size: Number of bytes to read from the instrument. Default
            of ``-1`` reads until a termination character is found.

        :units: As specified by :attr:`~PM100USB.measurement_configuration`.
        :rtype: :class:`~pint.Quantity`
        """"""
        # Get the current configuration to find out the units we need to
        # attach.
        units = (
            self._READ_UNITS[self.measurement_configuration]
            if not self._cache_units
            else self._cache_units
        )
        return float(self.query(""READ?"", size)) * units


"
208,367.3,"Abingdon, United Kingdom","Oxford Intelligent Temperature Controller ITC 502. Oxford Instruments ITC502 Intelligent Temperature Controller (Model 611-968) is a three term controller. It has the capability of monitoring up to three thermometers at the same time, and supplying heat to control the temperature of one part of the cryostat. The sensor interface can be configured to suit a wide range of thermometers (typically within the temperature range of 0.25 to 500 K).",Oxford itc 503,400.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Instrumentkit,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Instrumentkit to connect to a ITC 503 Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",ITC 503,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ITC503.pdf,"[OrderedDict([('id', 'attrty3FFFzJUtuMr'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RH3YRUSS9ERKB8q-jM70aQ/qdNMc_mch5YZQ4h02mTEBgGaw6E81uSvan8vTptJXgIbCKJwhsoF8NrkLBYj4Wmun2sy6MP0OioOfJOGpaxiK8j_wnkT9pSvBAskdmtFyng/IENsL28l3pancpHu_l1atefBNH5C9XCnUu-dzLU7EAE'), ('filename', 's-l1600.jpg'), ('size', 266225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GW89RwgwO4pvasVvfcf5Tg/2FgsDvXMJ9jsbLNsqeY5pC-M4MaKMHplsqmyn5WkEzo6TeevaiH6O6Gq08yqQ_R367tG_aW8Vv5jrG855zY34g/6G1UKUqTtQrjoqtXWvKMmMWOdPioPNTa0-ffh16u74U'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bDnIMvdXj3XkU8eawHAxZQ/6IRsy_lzyBdtznDuD708zr-hvWhqp0FCBWUihAxKb0LZHCLGY9y7pfHm0JuUKTsley79QMBoovDnuTQBEuPl8Q/jZHsIJKMxbK37KV6tIcQYdUvPtp4KKW-RUeL2fHSv3Y'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PBo8E1H8YsHxrFvWdJb1LQ/rsn_O1SZ5J4CHu9uErNvVQdV22KI_4gFRnmQZUoxUSmtimRRYGXLeOD0qRVUyq0zEbko5T0dTRD56BJBfvamvQ/8e3O9oHD1FCA4aL7-qeaQmWxfrPWV16VP8KR6aHN1tg'), ('width', 3000), ('height', 3000)]))]))])]",https://picclick.com/Oxford-Intelligent-Temperature-Controller-ITC-502-132299188022.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/oxford/oxforditc503.py,https://instrumentkit.readthedocs.io/en/latest/apiref/oxford.html#oxforditc503-temperature-controller,2150.0,,,,"

Source code for instruments.oxford.oxforditc503
#!/usr/bin/env python
""""""
Provides support for the Oxford ITC 503 temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.abstract_instruments import Instrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class OxfordITC503(Instrument):

    """"""
    The Oxford ITC503 is a multi-sensor temperature controller.

    Example usage::

    >>> import instruments as ik
    >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(itc.sensor[0].temperature)
    >>> print(itc.sensor[1].temperature)
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self.terminator = ""\r""
        self.sendcmd(""C3"")  # Enable remote commands

    # INNER CLASSES #

    class Sensor:

        """"""
        Class representing a probe sensor on the Oxford ITC 503.

        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `OxfordITC503` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES #

        @property
        def temperature(self):
            """"""
            Read the temperature of the attached probe to the specified channel.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = float(self._parent.query(f""R{self._idx}"")[1:])
            return u.Quantity(value, u.kelvin)

    # PROPERTIES #

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> itc = ik.oxford.OxfordITC503.open_gpibusb('/dev/ttyUSB0', 1)
        >>> print(itc.sensor[0].temperature)

        :type: `OxfordITC503.Sensor`
        """"""
        return ProxyList(self, OxfordITC503.Sensor, range(3))


"
214,7.0,Taiwan,"Temperature controller, TC-038D, goes along with different ovens (OV-30D, OV-50D, WG OVENs) with extreme temperature tunability up to 200 deg
",TC-038D,146.0,"**HC Photonics** (HCP) provides crystal ovens and controllers to well manage the temperature of nonlinear crystals, especially PPLN and PPLT. 
",Instrumentkit,HCP,"[OrderedDict([('id', 'att0HIJANIUaKbEnj'), ('width', 969), ('height', 327), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DdXf_qritrrchXIl2exoxg/7PYmUtN2mEXDKdFVKRsASroW3YRDamhh5RldEOj6IKIUwSKui-Q5dhbHdqp4pFKQNrt9MvDGogkXBpz0xhXM09tXprruKiCLq4PaQpb4uUXESKpRPaN08YtcJ1VT7Sj4/M3_LxZ4C7MMIn6siunAXx7HWZu-h3Oe6kTegvAB7wUk'), ('filename', '88959ca5c0458434_HCP Logo_web 1.jpg'), ('size', 71666), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Kps_eaW9Nyziy1wQ0rw-Ow/3uUt80DbWpa8wLMM2-WR9eXaTic9vpPcwn4E3aAhxggoPevS5RISdA8FibjwONaHEqdiXqnKlj7RhU5kRPRvQA/PIpQLKi-gZDqFcpNltF7m8ko8gfHVfHJe_LxJcw9BJQ'), ('width', 107), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iLvFYCoSHs9eBAUpMSQzcw/ab9sjplcOa7bEnbZGWXWPYJEdL57Y_XYX9SmfvSOvC9MSTbU4FzGNPp8IhODZDYCKbvGb2DcZPhUH1SlhClyhg/SUxR0LMBWZOPcUSm5Jc9i1TyGZg9zylECvAWXGb_BJ0'), ('width', 969), ('height', 327)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/O6Bv7JLjnX6JpltlbcUBXQ/jcBTP5_y6SMmVXh6z1d2Xtz8fSITWMyrXRQ2kSsmZZP30p8DZN_2FT4jWNtGF3D42WrFlMfNb6h6x8k18jxAbw/FIu38YPMcgGhf_sXRfjXFNR0YtZ_Ulu2E4M1wfOd_BY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.hcphotonics.com,Write a Python script that uses Instrumentkit to connect to a TC-038D Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",TC-038D,https://drive.google.com/file/d/1dvlmTTycCDXEis8rC74uM3bgh-szW-_n/view?usp=sharing,"[OrderedDict([('id', 'attrSHmyzn2qlEPy2'), ('width', 1200), ('height', 564), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/krpachuxIpvI5XSb-zDKtA/VDn1zBWxN9LHyZkNG6KblwxLhAAnd3p-nWve5n8May8hJ63TFzSoYx5NwjIzyDzmu4-TpAffxJ0YReZkwBmlQEm3_EBQfSoJMN6LQhl8muM/vGYHLQlUYfRLyjM_7bjP20RSlAzBthNnc2ElR1lie00'), ('filename', 'TC038D.webp'), ('size', 40894), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SPrxqrUhXTf0HO9pF9lHrw/wYlVfJV0pB6cHqHJxQZLpE5W0Zaoun8s5aTTw_n4Mz4ff5WabNHWQVljWu-i6D2A5HQ9ulC0sGUpYQel7lXWAbCApU5wmUwVJt13p9M8joY/6b57OiAnkhXAlC7vAQpsPnn4g_7P9OyU0u89NY1gd24'), ('width', 77), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AIODsOBtTgYdPZohYVMkzw/dOQIkpVt3i7nfkcettVEWfmquywNxTAIlmmReeC2wFTiuRe4uG1-4DbjYiqDXI0VO9E0k2pTxvohIzQCN_Ml59RSk5Q5FMpSakFpLU4IVx0/Id8CuQckiwmXHCjOztVqwZ_ALUzimbwNdATuaZymhYM'), ('width', 1089), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vqSTq5D_cHo64vuLjcPJlA/qjNMQv_lCnLmucFEnEXi5X3De6BbUVn4O5aMOypH1clomdVJD01GE2-K5TgcGiGNAYcsWwUdfTPqB5rC7zBgGNKGo77LMy_RcytO4vJwN0k/W4mbv7UhKxh2gNBY0eL24QkBDIX7BhpJWPYdxxuIw8I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.hcphotonics.com/accessories,,https://pypi.org/project/PyMeasure/,,,,Nothing on Github Yet,
217,5800.0,USA,,Tektds 5 XX,546.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS5XX ,,,,TDS5XX,,,,,,,,,,
218,5458.6,USA,"The WaveSurfer 3000z has a 10.1"" capacitive touch display, the longest memory, and the deepest toolbox – all at an affordable price.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 3000z Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveSurfer 3000z,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-3000z-oscilloscope-datasheet.pdf,"[OrderedDict([('id', 'attVTXwZRFz6jxMyZ'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sIRD9cA6i_6xbkQYpcmqYg/Xfc9lycH8Fh08ALBz4kuxJrWetumFAjPuFBaKyGZbSg8VWYVZ5Jbx9Qwx5208cHsrfBaw3CN-qprQ0EIQzYXV2tJ2Wkvqcb2D9LkkQ74t5E/MsFbSMiisdCGBOTmU05GkGQvQITtWwy-KqtLDUNoLMA'), ('filename', 'WAVESURFER-3014Z_DSL.jpg'), ('size', 31613), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aea5UaIsbIYetvinEGLEyQ/Hp6-e3vpv25m3ug0cVib1huhthvaS9DQZXiK3jkFSlYyYdib2eRc1KKMoGInERkkv-sjiaadZaP4o1bdHf9RRQ/U0TJDn2mwPMwtNd7m_oIUfmlnlAotTVc9HoaPKtAfvI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FJi9iMwMn_xzK7RtkcgOIw/uDuiO3l_H1pDLk_N0JNXqdECfxIo6R2OapnWmSWp3TCQk664s6O96ZR4u408A2UByVgWgrugvU0YymM7Vh_E3g/IHEjdKLQLUL7xr0PKcF-ugqbhUkvkf8eyV963ZUVmoM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DP6eZWCQIxsqp38Onn9MCA/CutqUtBpktIpDCpRuMox2UU4BmMZYp3MA3H6532PUP1RKgCg4mngPNLBsUAJJlh_7F-BJhPM9v2BGyAa63b1HQ/4pco9L1FOKaH34hpQsLr0Abk8Jz1atxxSinCq9eucMo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavesurfer-3000z-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,5780.0,,,Price from this website: https://www.globaltestsupply.com/online/teledyne-lecroy-wavesurfer-3000z-oscilloscopes,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
222,5458.6,USA,"WaveSurfer 4000HD extends Teledyne LeCroy’s leadership in High Definition Oscilloscopes with a bright, 12.1” touch screen display, performance without compromise, and price points that fit your budget.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveSurfer 4000HD Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveSurfer 4000HD,https://cdn.teledynelecroy.com/files/pdf/wavesurfer-4000hd-datasheet.pdf,"[OrderedDict([('id', 'attSL7iJBGpDPbEEX'), ('width', 740), ('height', 667), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/73251z2o0D9hA57mrjM7VA/6HtvPP9YPAi8mWIyr4OG246pvvOpK_gaZp-TwyZ91DM2VDPrV4QfYUxzr2jIbGZyNshumFQyVt1R2G1LjIyLM1BFPpYVNcJfRuSxUnl2xLI/7FEXona8QJly3XLlThAByc2-1y26BVMND0gu_5SiTr4'), ('filename', 'ws4000hd-img-1.2.webp'), ('size', 68826), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UK74ML7_y7GVHlhJ3uOY5g/sccpJqucWIkzrymov1g1pKfDuSUGHocQA0GuhLSAmiwgeEgGlpt5ao8Lca_P8tHmUzxBlpFHlSoWI2YhqU-2EP8gY-WYogfqaKowsdsnSkE/-k4a_PNECXGz2R3RTv7YCL7hkGl91Sr3fEJNo6NNXTw'), ('width', 40), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PlC4MA1WH0TjU1XcSkJQkg/76Pt4z6zOLbMPeqZ6zVawF1-LRzs7VxEFruTw91aBkPJPXUvywXNn717YJpBKCWPs2CCC5Rgx43M7gf5Sa2jNgp_YIR-oK05oWDY7_DLvlU/ioFz3Q7VZ1GthwPbvjxlRicjH219tw6877eYuu6DxPw'), ('width', 568), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9jDRC5hTTrZvIHmXvZ2znQ/iMGT0gwdKAAp_TZtWJjmPG9fH9n20qVUkjsaVa1zsPAsTlEUUWCoI0r0KHRUy2nU4N_42TmOU0s3E28U2OoofTDyqBnMUjU9kyTE2M-zWKM/02HBtQ9hoH9DRefdZl3dJvWLQcLahNbL0ybCsnmBS9M'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavesurfer-4000hd-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,8850.0,,,price from here: https://www.globaltestsupply.com/,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
248,295.0,Singapore,FJ Series - 120W regulated high voltage AC-DC power supplies with outputs from 0 - 1kVDC to 0 - 60kVDC,"XP GlassMan FJ

",141.0,"Looking for the leading manufacturer of AC-DC **power** supplies, DC-DC converters, high voltage, RF & custom **power** products? Discover our extensive range.

",Instrumentkit,Glassman,"[OrderedDict([('id', 'attQ9jak9WrU3JbmU'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t-vzuRrm4s6gH4r4j25lUQ/n_QwKkWE0Plk3ZT1V9gBChggySkEkgS0ViiOZZ5nm5BrDpwy2x9A5X8l5BaN9nFsy8Z_lhat6Sfg_zCHbH4xs8XRxckvQIdaEgo99_a2j8Q/PyuNqtzZmRmARz2OCXUVXt8u12atpkd0Tv6krqsdSRo'), ('filename', 'XP_Power.png'), ('size', 5633), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TBlKnBtACUHvmyv9HRbY-g/6JDibChcqCEEGUPz3g0afRJwxW-J5_4fOc3zV5-Nd3pqwEO9aqSLcksmR6_fSWZkc_VUyF1uX_xNWzmn-r2QdA/VB2enfdVlwwM5yKOsNwOEHw8HghGkJRuK820QxByBrA'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/slQeQHiBITwZQbaoFlT8Pg/SO0YSi3uWsQ3-nW12pMps-vGHLVlOxcIZghApty-DtB7sbrzJ9YTwB3OlnaKb_H9ZdKAWA7fskS1kS1iVqtdsg/UDCpGmAyEvF7RInnPY5JGLePsPfokL7XJESUHvlGBic'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GcpBReOwgBy6AyezYSldyQ/JCg6pxKHZSV5DbdiI1dqnBoN3B6RgRcIZxamCQVJ_pt05JuX5iR2SseR-AV83knD8VDZdFMghPNudERLdm25lw/QPVvO73SpcJO1Xjr835f6EHHsDBVk_wMILWn-Kjsii8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.xppower.com,Write a Python script that uses Instrumentkit to connect to a FJ Series Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,FJ Series,https://www.xppower.com/portals/0/pdfs/SF_FJ.pdf,"[OrderedDict([('id', 'attkmac7fxPBBo0P7'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/b6JXdBSQD0P0V6b9Er44nA/ciQ107VxEym22CoAApliCB9IkuxVLwFy1JVjhwLq-viljCGxRMGubj4MUMDp0THmnBvr3PwdzJJhUrGDBP3GYlN78GOGfq_Rd1QPICf0Kh4/OIbgVKj425lC2_YB7DBdDForpEzTDEtBFlZjhz7dbyY'), ('filename', 'FJ_prod_lrg.webp'), ('size', 34698), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QNM7XBO2kqZyPyfz5ti9kg/eBGIcyA7uHVURToqGCytyaDur1ZT5ywm_EnvPiVioF6ZmthNm2cbXA-dVA3eRFipNoEazDtiDEHovO9N1YvHqVnW-xcot2wRooBAK5AWDE8/mFd8MHsdJN6y7GH0AM8245PTApruIBDRp3_siCEOLYo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Xmjv6MG7TNRg7okOSBs3Aw/NTl_fR_FpxnNQwsi2PNpRDl145nxmP9dZ3Df09W4hRA8KGiY7pfPeGDHTPQt_4T5kfymm_DEhn1yYFIJceZHa6vjnUPCilx0w6bjzxfeL_Q/4tVfKiikqrkKgaHNXRQ999xsScZq2SwtsXL9_a63yyk'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/phY1qj0x-AwyTjpPMPdT5w/w9llzK9ocpSOdRpwsd9rYpUdHWIH8_JwCumtcaPEM4VKUkXT7SzDrF4jPTTKtokhXmkGVes4teDag9xqpXus-sVNcxaC2pbEj4KewH7BL2w/0Nirs5PZI7U0jGOKb9azy3xIUYP3wGFMm-nUF1WJe8A'), ('width', 3000), ('height', 3000)]))]))])]",https://www.xppower.com/product/FJ-Series,https://github.com/avancra/HvControllerGUI/blob/master/HvController.py,,,,,Python Package for a Series of Products,
249,,,"MHS-5200A series instruments using large scale integrated circuits andhigh-speed FPGA MCU microprocessor, the internal circuit to take surface mounttechnology has greatly enhanced the instrument's noise immunity and service life.Display interface using LC1602 LCD display is divided into two lines, the top lineshows the current frequency, the following line displays additional parameters orfunction variable and flexible use of flip key setting, greatly enhances the operability.",MHS 5200 A,370.0,"Could not find

",Instrumentkit,Minghe,,,Write a Python script that uses Instrumentkit to connect to a {Device name} Function Generators,https://en.wikipedia.org/wiki/Function_generator#Function_generator,['Function Generators'],"A function generator is electronic test equipment that generates standard waveforms, such as sine, square, ramp, or sawtooth waves, to a device under test (DUT).",,,"[OrderedDict([('id', 'atthHXPfbt5sZJn0O'), ('width', 560), ('height', 560), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/X-vHqNGQHHqe3VpEPlOphg/82xU60Z6I6hqpuqYb5BxSR7Mg8ojL_jz8GEt5IuvEapbXAFPWfXwYfGyhy3KrQcTz_Xkm2pkof5L0m9QaYL47Q/Yo47oBedIb93UsrwAQpl6DVgKbid6ZBOhzy0SorSPA4'), ('filename', 'raw.jpg'), ('size', 92012), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VuRUXIFk3yWgk4C6uvh9Tg/gSle3k0RI0e34QWnMyufBKK9c5xZcTj71l7hcL0uGwW_J2bXa3w_lXbLFZlYr37Gm1-GzxMbuI-MEdVzyb5Czw/ICOMkjrlN0MozuIaQN_amhkTithNMNT7d8pgQCaMlP4'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/75tVuhN0jaQjCvBXKnIqrg/2Eknvwk0eYDaddpEUIX0avJBUtWtchboY_0lES27nlBTByiC3lB24CdphOwhZnKPprx89_eIUcZVIpmWsZMCng/PUhbFD38atZqqnjwW6mgFVdW5kSDz0r93OB0NWRy0Rc'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ecGjuk6g7cnw5LwZxSFjpA/dk31M-dYEO60oDKV0FhHzNF2qoNelel63ctqAcKcMOhW6WgjxLirrG_1XQqXdG7kJVwVNOyk2T5fWmHffisvPA/mf-iLFMAr2e0OzHyqxMGj9qG7kX_bC-1hVHzymCoJZw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.manualslib.com/manual/1302069/Minghe-Instruments-Mhs-5200a-Series.html?page=3#manual,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/minghe/mhs5200a.py,https://instrumentkit.readthedocs.io/en/latest/apiref/minghe.html,,,True,,"

Source code for instruments.minghe.mhs5200a
#!/usr/bin/env python
""""""
Provides the support for the MingHe low-cost function generator.

Class originally contributed by Catherine Holloway.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import FunctionGenerator
from instruments.units import ureg as u
from instruments.util_fns import ProxyList, assume_units

# CLASSES #####################################################################


class MHS5200(FunctionGenerator):
    """"""
    The MHS5200 is a low-cost, 2 channel function generator.

    There is no user manual, but Al Williams has reverse-engineered the
    communications protocol:
    https://github.com/wd5gnr/mhs5200a/blob/master/MHS5200AProtocol.pdf
    """"""

    def __init__(self, filelike):
        super().__init__(filelike)
        self._channel_count = 2
        self.terminator = ""\r\n""

    def _ack_expected(self, msg=""""):
        if msg.find("":r"") == 0:
            return None
        # most commands res
        return ""ok""

    # INNER CLASSES #

    class Channel(FunctionGenerator.Channel):
        """"""
        Class representing a channel on the MHS52000.
        """"""

        # pylint: disable=protected-access

        __CHANNEL_NAMES = {1: ""1"", 2: ""2""}

        def __init__(self, mhs, idx):
            self._mhs = mhs
            super().__init__(parent=mhs, name=idx)
            # Use zero-based indexing for the external API, but one-based
            # for talking to the instrument.
            self._idx = idx + 1
            self._chan = self.__CHANNEL_NAMES[self._idx]
            self._count = 0

        def _get_amplitude_(self):
            query = f"":r{self._chan}a""
            response = self._mhs.query(query)
            return float(response.replace(query, """")) / 100.0, self._mhs.VoltageMode.rms

        def _set_amplitude_(self, magnitude, units):
            if (
                units == self._mhs.VoltageMode.peak_to_peak
                or units == self._mhs.VoltageMode.rms
            ):
                magnitude = assume_units(magnitude, ""V"").to(u.V).magnitude
            elif units == self._mhs.VoltageMode.dBm:
                raise NotImplementedError(""Decibel units are not supported."")
            magnitude *= 100
            query = f"":s{self._chan}a{int(magnitude)}""
            self._mhs.sendcmd(query)

        @property
        def duty_cycle(self):
            """"""
            Gets/Sets the duty cycle of this channel.

            :units: A fraction
            :type: `float`
            """"""
            query = f"":r{self._chan}d""
            response = self._mhs.query(query)
            duty = float(response.replace(query, """")) / 10.0
            return duty

        @duty_cycle.setter
        def duty_cycle(self, new_val):
            query = f"":s{self._chan}d{int(100.0 * new_val)}""
            self._mhs.sendcmd(query)

        @property
        def enable(self):
            """"""
            Gets/Sets the enable state of this channel.

            :type: `bool`
            """"""
            query = f"":r{self._chan}b""
            return int(self._mhs.query(query).replace(query, """").replace(""\r"", """"))

        @enable.setter
        def enable(self, newval):
            query = f"":s{self._chan}b{int(newval)}""
            self._mhs.sendcmd(query)

        @property
        def frequency(self):
            """"""
            Gets/Sets the frequency of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of units hertz.
            :type: `~pint.Quantity`
            """"""
            query = f"":r{self._chan}f""
            response = self._mhs.query(query)
            freq = float(response.replace(query, """")) * u.Hz
            return freq / 100.0

        @frequency.setter
        def frequency(self, new_val):
            new_val = assume_units(new_val, u.Hz).to(u.Hz).magnitude * 100.0
            query = f"":s{self._chan}f{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def offset(self):
            """"""
            Gets/Sets the offset of this channel.

            The fraction of the duty cycle to offset the function by.

            :type: `float`
            """"""
            # need to convert
            query = f"":r{self._chan}o""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) / 100.0 - 1.20

        @offset.setter
        def offset(self, new_val):
            new_val = int(new_val * 100) + 120
            query = f"":s{self._chan}o{new_val}""
            self._mhs.sendcmd(query)

        @property
        def phase(self):
            """"""
            Gets/Sets the phase of this channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
            of degrees.
            :type: `~pint.Quantity`
            """"""
            # need to convert
            query = f"":r{self._chan}p""
            response = self._mhs.query(query)
            return int(response.replace(query, """")) * u.deg

        @phase.setter
        def phase(self, new_val):
            new_val = assume_units(new_val, u.deg).to(""deg"").magnitude
            query = f"":s{self._chan}p{int(new_val)}""
            self._mhs.sendcmd(query)

        @property
        def function(self):
            """"""
            Gets/Sets the wave type of this channel.

            :type: `MHS5200.Function`
            """"""
            query = f"":r{self._chan}w""
            response = self._mhs.query(query).replace(query, """")
            return self._mhs.Function(int(response))

        @function.setter
        def function(self, new_val):
            query = f"":s{self._chan}w{self._mhs.Function(new_val).value}""
            self._mhs.sendcmd(query)

    class Function(Enum):
        """"""
        Enum containing valid wave modes for
        """"""

        sine = 0
        square = 1
        triangular = 2
        sawtooth_up = 3
        sawtooth_down = 4

    @property
    def channel(self):
        """"""
        Gets a specific channel object. The desired channel is specified like
        one would access a list.

        For instance, this would print the counts of the first channel::

        >>> import instruments as ik
        >>> mhs = ik.minghe.MHS5200.open_serial(vid=1027, pid=24577,
        baud=19200, timeout=1)
        >>> print(mhs.channel[0].frequency)

        :rtype: `list`[`MHS5200.Channel`]
        """"""
        return ProxyList(self, MHS5200.Channel, range(self._channel_count))

    @property
    def serial_number(self):
        """"""
        Get the serial number, as an int

        :rtype: int
        """"""
        query = "":r0c""
        response = self.query(query)
        response = response.replace(query, """").replace(""\r"", """")
        return response

    def _get_amplitude_(self):
        raise NotImplementedError()

    def _set_amplitude_(self, magnitude, units):
        raise NotImplementedError()


"
253,21.4,"Westerville, Ohio, USA","The Model 340 cryogenic temperature controller is our most advanced temperature controller and offers unsurpassed resolution, accuracy, and stability for temperature measurement and control applications to as low as 100 mK. Operating with diodes, platinum RTDs, and negative temperature coefficient (NTC) resistor sensors, the Model 340 is expandable to ten sensor inputs or to operate with thermocouple or capacitance sensors. It has two control loops, with the first loop powered to 100 W.",Lakeshore 340,350.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Instrumentkit,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Instrumentkit to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_340_l.pdf?sfvrsn=ad773cdf_1,"[OrderedDict([('id', 'atthNL1cSca5MCqeq'), ('width', 505), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EUgqGQdHaLcTZ2dkxzHaCg/R-asMrK2UnxSitBiOfkcBHbkxGrXf6Cs3lJ33uh-Uzf_EEtBuYt7QDS0iLvfufGTMKSW_7MxBK6JuMDzWEsCMw/TGT1oZQfpaS970o1cMrE248AowSRCPFMBAlZBDzQ0bg'), ('filename', '340.png'), ('size', 89525), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0bAOe6gCQttAiKMibz588Q/G97URtiS-ut6B-wD2vQt4EIUUzZOUsj7-73QXdNzuki8vVP4G9niY2tKNiSaZ4Kuue4zlEnBiY0ydMEsIP4uWg/Lu7O6pEv6Z4ohiWIFOjhBSoPcud1RNKTm-qaPfQeXn0'), ('width', 114), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XdEF3sYQjmz5ZdtR3wwzbA/klmTMeQLgH3rWo06798sjrM2WcxFndEheJZDj14d0Ugz9BdxE1CebzctVg8pWsyBeOjHpznXLsgXfKZjq2LCvQ/uvTmG1WtkR4kAPhWN1gaYlMZzJHecmtmfcgyBl1yiw8'), ('width', 505), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ky8x9iYFa23-1ANvI_Z95w/UPj4UhMCUZlYcsQhKLQG-8AlX6chrJknxWDk_iPA8921GCU8eafpUdUAt9e9LBuvXV0ZyviiX1vr53XkDcrQrQ/OJ2UQ8J34X-BmNhIjBgXhSAzWeWkWWJA1I7P6LV21-0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-340-cryogenic-temperature-controller,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore340.py,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore340-cryogenic-temperature-controller,,,True,,"

Source code for instruments.lakeshore.lakeshore340
#!/usr/bin/env python
""""""
Provides support for the Lakeshore 340 cryogenic temperature controller.
""""""

# IMPORTS #####################################################################

from instruments.generic_scpi import SCPIInstrument
from instruments.units import ureg as u
from instruments.util_fns import ProxyList

# CLASSES #####################################################################


class Lakeshore340(SCPIInstrument):

    """"""
    The Lakeshore340 is a multi-sensor cryogenic temperature controller.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.lakeshore.Lakeshore340.open_gpibusb('/dev/ttyUSB0', 1)
    >>> print(inst.sensor[0].temperature)
    >>> print(inst.sensor[1].temperature)
    """"""

    # INNER CLASSES ##

    class Sensor:

        """"""
        Class representing a sensor attached to the Lakeshore 340.

        .. warning:: This class should NOT be manually created by the user. It is
            designed to be initialized by the `Lakeshore340` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1

        # PROPERTIES ##

        @property
        def temperature(self):
            """"""
            Gets the temperature of the specified sensor.

            :units: Kelvin
            :type: `~pint.Quantity`
            """"""
            value = self._parent.query(f""KRDG?{self._idx}"")
            return u.Quantity(float(value), u.kelvin)

    # PROPERTIES ##

    @property
    def sensor(self):
        """"""
        Gets a specific sensor object. The desired sensor is specified like
        one would access a list.

        For instance, this would query the temperature of the first sensor::

        >>> bridge = Lakeshore340.open_serial(""COM5"")
        >>> print(bridge.sensor[0].temperature)

        The Lakeshore 340 supports up to 2 sensors (index 0-1).

        :rtype: `~Lakeshore340.Sensor`
        """"""
        return ProxyList(self, Lakeshore340.Sensor, range(2))


"
254,5458.6,USA,"The Motor Drive Analyzer is built on an 8 channel, 12-bit resolution oscilloscope platform. It acquires any signal and performs three-phase electrical and mechanical power calculations. It provides complete power section and embedded control test coverage.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a MDA8000HD Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",MDA8000HD,https://cdn.teledynelecroy.com/files/pdf/mda8000hd-datasheet.pdf,"[OrderedDict([('id', 'att8urLApvEdo7Bqk'), ('width', 260), ('height', 263), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_RwxfuRHTd23dmV47oOC0A/oSpT-QlgnXT7hJoFSPorH8ZCBfnmhe6DGoPe0UvgeUJDyOTBZ-Q7_qrRI-A3QWL31HIkhEn2xmia6GCb9psTPXuD9A4uJIUcE4mi3MCzUr4/7s5rKMXXPGoWZ-BVVfHEQgY563OuQB2RuR7u28N5oEI'), ('filename', 'mda8000hd-title.webp'), ('size', 25102), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uwZaUyWcTvm1gMJaYtxEXw/BaKIY4rfSxUlu5FxpjaKFC0kxBoShk98PduNE45Ke5qNQUZepNXida-AJp8bhRO-7Pelcii1O6p1vIM4MqeHJxWW7YgnQ3v3aAVkatR5xJ4/HTHP2Apo-4wONreiGt2V1oz6ydsxatNvcpE8RAc0JNQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l43oJiZCu9EUhVsBruAaXw/HztWVQ4c9VvFExF3rTO4x1WF_1VQrJ8sXKrWyvLLc3KwLMRsFRCsqo0JDtFIuZiGZqasu80HAQBoc5eWXCIp4hvwcV-CoJ6RXBA4PnbnPTg/nTMREu_X4tMRzy_GeJ_epQ1Bm4xUl4ruajLz_WOP0jE'), ('width', 260), ('height', 263)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Y0XHHbOn77fAWcABlKe1uw/9IvCfwAM1ECEkpUHUzSiJZykU18bh1LqaLPZhui1DboCxGI8O0Qpyz7TCLxPDd9TlMT72nAyHTdVAFziqANDon4XS4uI3u_tJkUNjuULT8Y/YM0sZEj1zuBdNdhgMcicjsYLI9XVK9SHvkDnd1V5vGQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/mda-8000hd-motor-drive-analyzers,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,,,,,
265,318.0,Japan,The AQ6370 is Yokogawa's high speed and high performance Optical Spectrum Analyzer for characterization of optical communications system and optical components. Thirteen built-in optical viewer analysis functions and seven trace calculations for popular applications can be utilized with a simple function key. ,Yokogawa 6370,634.0,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",Instrumentkit,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UaAsDYNLAOdUQ4cG-gVBw/NTY986xzNYwKbonHbWwWC4LeHEHqycOQeXYwRbRUCHdcuhOKGAvrvBoatXQsD5bpSMp051hQO8G6Z1_BiSG1VC6MM2RwFw-JgfT3HK4pXZo/cdsfM51bauCXQpD2o4jMtv4J_4Pc6fMk_dJlEKX20e0'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0FZ2eqXGORQw7KhD8ggQhA/54nn9VVUA8rLZTUqpQNJJRRABVqmHyYpr39PgVnaWermrd9uQk4oKjA-U_ElbfbtDYyDeyOy0wUoLtc2W5106g/xl6wqD05nzCPSKrDuCKrzZgEG0XSnoQSadmaYKdpFJM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HaEWyRlZBthPGsYttIxnHQ/Dg6dnKGNXLv3Mh6hmw3-ew1Frbuj6oI01Vn3HH6YZCGh51cSS68iCmPrXpZJPdTo-4wfWlWjjSEU4Ca-zmtRlQ/eXk6rUTl5KsnGehm3vQUBE5QCuNLX-D5bbpf0_IxIrM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IbzTBl4xKhTim-kj9IZJWw/jqTaszS54GnOhLIRvMV0S3ODA6kF-CfXSMb2hQnB7aSuYMsMIsRnYenR7US3v50OI9A0DzAtFvhKHusA-qJEaw/o46lbBXBsIcuUNQKSTjhxI0hmLRfL48B90X8oBZ96jI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,Write a Python script that uses Instrumentkit to connect to a AQ6370 Spectrum Analyzers,https://en.wikipedia.org/wiki/Spectrum_analyzer,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals.,AQ6370,https://cdn.tmi.yokogawa.com/IM735301-01E.pdf,"[OrderedDict([('id', 'atttq1VLeer6131dE'), ('width', 800), ('height', 467), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9haX8ld336Pdx6KAbvtqpw/1Uxhlry36WgpoFgP-6P77eMnqxOcx9fNngELIzOmAb7ONQ_TWltNgg5Ptw_UAwzNib0IeV0Ro3wKDNOMFu7nFNNCCql0DUxKNzx7o5qxvuw/yh1z9m91y1P01xQnZcgvsJZC9E0Wl-js-uIjIk2Rs3Q'), ('filename', 'AQ6370_Front_lg.jpg'), ('size', 262250), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/c2hGo2K7rLECKuN9xG1iOQ/bYewhk_5Arfh90lL8pFP8m17N0en7T16cyzXsrYdMHqZze9-ABrSOWywpUQm-ax6SHSksX7yico6np8WvIWK2Q/YyS7gz42AUM2vTHKJPhvzmhAzOIbyNO9i3f3ez4KC70'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/17m7cmFk2sHvWDF_4e-zbA/2gbmV_95UP4R7DfNBDaxdPWGy8UGVN1tJdBzkwYJMfjZ-ecDA-OAsRPjmvlzXmkLfkhb_2NKdpcQIYtBbcROXQ/ZxLM27zrFJhrqqsEpxzrKOwRzgZ0INBpZEAAgn0_zQU'), ('width', 800), ('height', 467)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UwWNNjLwmVn4qymfUQvgkg/6B0D2NKJ0hb1VLbd2qoVH-_rFsymMP90xySuOuqBYEYpdfoVH_DJUCALdGmX4ZxV4E5Cpgkk2p_J0xcb8CMAZQ/DJNMFZzDNmZ_ujd3vmeL2wLS8MVn9WS9k5n9ePlzZg8'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/discontinued/aq6370-optical-spectrum-analyzer/,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/yokogawa/yokogawa6370.py,https://instrumentkit.readthedocs.io/en/latest/apiref/yokogawa.html#instruments.yokogawa.Yokogawa6370,,,True,,"

Source code for instruments.yokogawa.yokogawa6370
#!/usr/bin/env python
""""""
Provides support for the Yokogawa 6370 optical spectrum analyzer.
""""""

# IMPORTS #####################################################################


from enum import IntEnum, Enum

from instruments.units import ureg as u

from instruments.abstract_instruments import OpticalSpectrumAnalyzer
from instruments.abstract_instruments.comm import SocketCommunicator
from instruments.util_fns import (
    enum_property,
    unitful_property,
    unitless_property,
    bounded_unitful_property,
    ProxyList,
    string_property,
)


# CLASSES #####################################################################


class Yokogawa6370(OpticalSpectrumAnalyzer):

    """"""
    The Yokogawa 6370 is a optical spectrum analyzer.
    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> inst = ik.yokogawa.Yokogawa6370.open_visa('TCPIP0:192.168.0.35')
    >>> inst.start_wl = 1030e-9 * u.m
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if isinstance(self._file, SocketCommunicator):
            self.terminator = ""\r\n""  # TCP IP connection terminator

        # Set data Format to binary
        self.sendcmd("":FORMat:DATA REAL,64"")  # TODO: Find out where we want this

    # INNER CLASSES #

    class Channel(OpticalSpectrumAnalyzer.Channel):

        """"""
        Class representing the channels on the Yokogawa 6370.
        This class inherits from `OpticalSpectrumAnalyzer.Channel`.
        .. warning:: This class should NOT be manually created by the user. It
            is designed to be initialized by the `Yokogawa6370` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._name = idx

        # METHODS #

        def _data(self, axis, limits=None, bin_format=True):
            """"""Get data of `axis`.

            :param axis: Axis to get the data of, ""X"" or ""Y""
            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            if limits is None:
                cmd = f"":TRAC:{axis}? {self._name}""
            elif isinstance(limits, (tuple, list)) and len(limits) == 2:
                cmd = f"":TRAC:{axis}? {self._name},{limits[0]+1},{limits[1]+1}""
            else:
                raise ValueError(""limits has to be a list or tuple with two members"")
            self._parent.sendcmd(cmd)
            data = self._parent.binblockread(data_width=8, fmt=""<d"")
            self._parent._file.read_raw(1)  # pylint: disable=protected-access
            return data

        def data(self, limits=None, bin_format=True):
            """"""
            Return the trace's level data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""Y"", limits=limits, bin_format=bin_format)

        def wavelength(self, limits=None, bin_format=True):
            """"""
            Return the trace's wavelength data.

            :param limits: Range of samples to transfer as a tuple of min and
                max value, e.g. (5, 100) transfers data from the fifth to the
                100th sample. The possible values are from 0 to 50000.
            """"""
            return self._data(""X"", limits=limits, bin_format=bin_format)

    # ENUMS #

    class SweepModes(IntEnum):
        """"""
        Enum containing valid output modes for the Yokogawa 6370
        """"""

        SINGLE = 1
        REPEAT = 2
        AUTO = 3

    class Traces(Enum):
        """"""
        Enum containing valid Traces for the Yokogawa 6370
        """"""

        A = ""TRA""
        B = ""TRB""
        C = ""TRC""
        D = ""TRD""
        E = ""TRE""
        F = ""TRF""
        G = ""TRG""

    # PROPERTIES #

    # General

    id = string_property(
        ""*IDN"",
        doc=""""""
            Get the identification of the device.
            Output: 'Manufacturer,Product,SerialNumber,FirmwareVersion'
            Sample: 'YOKOGAWA,AQ6370D,90Y403996,02.08'
            """""",
        readonly=True,
    )

    status = unitless_property(
        ""*STB"",
        doc=""""""The status byte of the device.
        Bit 7: Summary bit of operation status
        Bit 5: Summary bit of standard event status register
        Bit 4: “1” if the output buffer contains data
        Bit 3: Summary bit of questionable status
        """""",
        readonly=True,
    )

    operation_event = unitless_property(
        "":status:operation:event"",
        doc=""""""
            All changes after the last readout. Readout clears the operation_event
            Bit 4: Autosweep
            Bit 3: Calibration/Alignment
            Bit 2: Copy/File
            Bit 1: Program
            Bit 0: Sweep finished.
        """""",
        readonly=True,
    )

    @property
    def channel(self):
        """"""
        Gets the specific channel object.
        This channel is accessed as a list in the following manner::

        >>> import instruments as ik
        >>> osa = ik.yokogawa.Yokogawa6370.open_gpibusb('/dev/ttyUSB0')
        >>> dat = osa.channel[""A""].data # Gets the data of channel 0

        :rtype: `list`[`~Yokogawa6370.Channel`]
        """"""
        return ProxyList(self, Yokogawa6370.Channel, Yokogawa6370.Traces)

    # Sweep

    start_wl, start_wl_min, start_wl_max = bounded_unitful_property(
        "":SENS:WAV:STAR"",
        u.meter,
        doc=""""""
        The start wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    stop_wl, stop_wl_min, stop_wl_max = bounded_unitful_property(
        "":SENS:WAV:STOP"",
        u.meter,
        doc=""""""
        The stop wavelength in m.
        """""",
        valid_range=(600e-9, 1700e-9),
    )

    bandwidth = unitful_property(
        "":SENS:BAND:RES"",
        u.meter,
        doc=""""""
        The bandwidth in m.
        """""",
    )

    span = unitful_property(
        "":SENS:WAV:SPAN"",
        u.meter,
        doc=""""""
        A floating point property that controls the wavelength span in m.
        """""",
    )

    center_wl = unitful_property(
        "":SENS:WAV:CENT"",
        u.meter,
        doc=""""""
         A floating point property that controls the center wavelength m.
        """""",
    )

    points = unitless_property(
        "":SENS:SWE:POIN"",
        doc=""""""
        An integer property that controls the number of points in a trace.
        """""",
    )

    sweep_mode = enum_property(
        "":INIT:SMOD"",
        SweepModes,
        input_decoration=int,
        doc=""""""
        A property to control the Sweep Mode as one of Yokogawa6370.SweepMode.
        Effective only after a self.start_sweep()."""""",
    )

    # Analysis

    # Traces

    active_trace = enum_property(
        "":TRAC:ACTIVE"",
        Traces,
        doc=""""""
        The active trace of the OSA of enum Yokogawa6370.Traces. Determines the
        result of Yokogawa6370.data() and Yokogawa6370.wavelength()."""""",
    )

    # METHODS #

    def data(self, limits=None):
        """"""
        Function to query the active Trace data of the OSA.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].data(limits=limits)

    def wavelength(self, limits=None):
        """"""
        Query the wavelength axis of the active trace.

        :param limits: Range of samples to transfer as a tuple of min and
            max value, e.g. (5, 100) transfers data from the fifth to the
            100th sample. The possible values are from 0 to 50000.
        """"""
        return self.channel[self.active_trace].wavelength(limits=limits)

    def analysis(self):
        """"""Get the analysis data.""""""
        return [float(x) for x in self.query("":CALC:DATA?"").split("","")]

    def start_sweep(self):
        """"""
        Triggering function for the Yokogawa 6370.
        After changing the sweep mode, the device needs to be triggered before
        it will update.
        """"""
        self.sendcmd(""*CLS;:init"")

    def abort(self):
        """"""Abort a running sweep or calibration etc.""""""
        self.sendcmd("":ABORT"")

    def clear(self):
        """"""Clear status registers.""""""
        self.sendcmd(""*CLS"")


"
271,24.9,"Sunnyvale, California","The DS345 Function Generator is a full-featured 30 MHz synthesized function generator that uses an innovative Direct Digital Synthesis (DDS) architecture. It generates many standard waveforms with excellent frequency resolution (1 µHz), and has versatile modulation capabilities including AM, FM, Burst, PM and frequency sweeps. It also generates arbitrary waveforms with a fast 40 Msample/s update rate.",SRS 345,493.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Instrumentkit,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Instrumentkit to connect to a DS345 Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.",DS345,https://www.thinksrs.com/downloads/pdfs/catalog/DS345c.pdf,"[OrderedDict([('id', 'attdOv77MX1TYKshq'), ('width', 2688), ('height', 1517), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XH2rM183UNH-IRqzNAR6Jw/eD_B1Xv9n7DLkGNAwTvzlYkpTX_vnzCco0rRTV5V6bU5Oenv48iI1WAFHwwreKOkiNodaoz10yQmizcViIYHny__R6bSlyMyNY7GfWNSCxU/GRkZOblJPlZ-Fjp9Ea3LDcuX-EqzK_mMrS9P9w9VJhs'), ('filename', 'DS345_Main2.jpg'), ('size', 572471), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LyRymhpmQ9hbPUz7b1zOyw/Wj2XPRQBZ2Icql-U3-4umhhwCe90mBIBuOOZAqgBdfpG7nR2tHcHYZpU5zAK5FQx1lqCdyyECNS8XNpC-wAPSg/OFS15Lie80wbE0dWCvtObm8b7ljNXSc8wRjQI8ewY7g'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dV1F2R84nCe3aXJZpvG_Cg/-5Jm0evSmISuoRRQeTHzwAHGqNes_9ODH58u1y78RFV0Y1ZWJGezd2QfZtGGHmzSSnvbQbXv7EJuu47JJBgD7A/dKL_9MneiXElFg3mPIM4LC9OBCNF5csyFHdMItVozDw'), ('width', 907), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e-zWIncs243-TwY48W9T8A/IEaoE_mNMcFD9EpnMi7gxKdZ1fw4kfMg__fy8PYLPNNL6ahvZ6Suxp4NGxW25aElOOBRDZ4rn8nIkbM3pE4oMA/gNltVT9O6jGq7LFinfUgD_0BjUVLfSxWOaRloISOEos'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/DS345.htm,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs345.py,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs345-function-generator,1595.0,,,,"

Source code for instruments.srs.srs345
#!/usr/bin/env python
""""""
Provides support for the SRS 345 function generator.
""""""

# IMPORTS #####################################################################


from enum import IntEnum

from instruments.units import ureg as u

from instruments.abstract_instruments import FunctionGenerator
from instruments.generic_scpi import SCPIInstrument
from instruments.util_fns import enum_property, unitful_property

# CLASSES #####################################################################


class SRS345(SCPIInstrument, FunctionGenerator):

    """"""
    The SRS DS345 is a 30MHz function generator.

    Example usage:

    >>> import instruments as ik
    >>> import instruments.units as u
    >>> srs = ik.srs.SRS345.open_gpib('/dev/ttyUSB0', 1)
    >>> srs.frequency = 1 * u.MHz
    >>> print(srs.offset)
    >>> srs.function = srs.Function.triangle
    """"""

    # FIXME: need to add OUTX 1 here, but doing so seems to cause a syntax
    #        error on the instrument.

    # CONSTANTS #

    _UNIT_MNEMONICS = {
        FunctionGenerator.VoltageMode.peak_to_peak: ""VP"",
        FunctionGenerator.VoltageMode.rms: ""VR"",
        FunctionGenerator.VoltageMode.dBm: ""DB"",
    }

    _MNEMONIC_UNITS = {mnem: unit for unit, mnem in _UNIT_MNEMONICS.items()}

    # FunctionGenerator CONTRACT #

    def _get_amplitude_(self):
        resp = self.query(""AMPL?"").strip()

        return (float(resp[:-2]), self._MNEMONIC_UNITS[resp[-2:]])

    def _set_amplitude_(self, magnitude, units):
        self.sendcmd(f""AMPL {magnitude}{self._UNIT_MNEMONICS[units]}"")

    # ENUMS ##

    class Function(IntEnum):
        """"""
        Enum containing valid output function modes for the SRS 345
        """"""

        sinusoid = 0
        square = 1
        triangle = 2
        ramp = 3
        noise = 4
        arbitrary = 5

    # PROPERTIES ##

    frequency = unitful_property(
        command=""FREQ"",
        units=u.Hz,
        doc=""""""
        Gets/sets the output frequency.

        :units: As specified, or assumed to be :math:`\\text{Hz}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    function = enum_property(
        command=""FUNC"",
        enum=Function,
        input_decoration=int,
        doc=""""""
        Gets/sets the output function of the function generator.

        :type: `~SRS345.Function`
        """""",
    )

    offset = unitful_property(
        command=""OFFS"",
        units=u.volt,
        doc=""""""
        Gets/sets the offset voltage for the output waveform.

        :units: As specified, or assumed to be :math:`\\text{V}` otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )

    phase = unitful_property(
        command=""PHSE"",
        units=u.degree,
        doc=""""""
        Gets/sets the phase for the output waveform.

        :units: As specified, or assumed to be degrees (:math:`{}^{\\circ}`)
            otherwise.
        :type: `float` or `~pint.Quantity`
        """""",
    )


"
274,5458.6,USA,"The LabMaster 10 Zi is the world's highest-performance modular oscilloscope - it breaks channel count barriers and provides more ""bandwidth density"". The modular design provides the simplest upgrade path in bandwidth and channel count, with one acquisition module providing four channels at 36 GHz or two channels at 65 GHz, with capability for up to 20 acquisition modules",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a LabMaster 10 Zi-A Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",LabMaster 10 Zi-A,https://cdn.teledynelecroy.com/files/pdf/labmaster-10zi-a-datasheet.pdf,"[OrderedDict([('id', 'attreLJUz1eRfLnKT'), ('width', 392), ('height', 301), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TZAOHDsOt6rNfO5i_QMTEA/uz8_tmQXJ66HC32cU3VF1JWEH9wYeZ19mGbLlNBduAXy6GbXF-obDKyneYyQd1Cg9cxeDx3FzxJ0mubbGvYkOJXnqs0A5Mp7phiyiP6PTRQ/Zm0LDPZvq6qmp3Gj4yTkUayHjGRvrr93WrLtRtDyyk8'), ('filename', 'cross-sync-p3.webp'), ('size', 19634), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1PRbyVP0HTrb-AwPM_oCKQ/xrbBz6Qs1soRQhtm56-bWheo35nzuw6pJsbDx0qtiLTP_KoOQfDkAiIc4FDLfIGTuMjDzPp3gQ_jGPJStrKT7S62Ve5aqu7c4rf8tkLPqac/t5CU5bULWD1q4LY8HMlmwXPWpQbb6KqMnMdLxIuAPsY'), ('width', 47), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6-u4WcsnL88bLV6vSLMg3w/juPNbuPW1LI4FrYjrf5liJVzyaRCo4B9kI-W7RO8FuCcWAxqVyNO1XSfkmh9SnlNaRh-ap0zMsFMyl6A748CAYtDvywQ7r48PlDDnneEseQ/Edp8znUvDgur2zuv9C3G-vJsrYmWYjXrGDIkwk1gLkc'), ('width', 392), ('height', 301)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ev9CouGrk_OsBbe5Mqbffg/9z54sA7k1j00ZKcggPJ7vUzUm9g_IhkzR6tnRJyXa4NWOASMLjDifbzImu0u2PGGn-7pXa3mXrJ4_giI5O_kt5002JUBV0b6BSXR2bb4bgM/f78rwgQwHYRUrIXy6uOLgPD_flZrYvaI5sbscmY4Ijg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/labmaster-10-zi-a-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,,,,,
285,550.0,USA,This single-channel piezo inertia controller provides a voltage output for a single piezo inertia stage or actuator. The top panel features a spring-loaded scroll wheel for driving the stage or actuator as well as selecting menu options.,APTPiezoInertiaActuator,598.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a KIM001 Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",KIM001,https://www.thorlabs.com/_sd.cfm?fileName=ETN051885-D02.pdf&partNumber=KIM001,"[OrderedDict([('id', 'attSHQegTJmQMrjYW'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e5p2hIiYq4ygH4khmRIKLw/ZD4x5niolV8v29Dg1BYA-yIAs0hCdhtK_Rt5ZIHfAIuHRFX2_6VzXjF0CQsRqnXJDkX1r0oKBH3Wy0sY1y0CzRykIef8ZtiFib9H9nL7WIs/Y4YGi6k1iLrvGxezkKsgc2Lr7us2Nt5IH6yrFXNaGsA'), ('filename', 'ETN040053-xl.jpg'), ('size', 53949), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LH9VOO1-QWVbqSBlfCpdHg/ZILQv8IWyiXuEv8vrDPHObsUKwNl3eEHI11HMPaRv5STaU5Jl14gvqOT7Q85Rjv1ugzEj0Byxabt2BK1rfpcrA/INmcYoOiFdwKFqV2QZl_yjUTWkIyaytdbo99VtoEiZU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LwLdxZbFTKez2J1i3QOgzQ/LQ2ErEJRe1xEPEbfMLfw6LdMUa4lHxdXURUjwrpUJNkObvQy6yh4QEiTKon_RB1--YzbzdVJLnLlVWvy6Q-yag/r0UaUVgJi43ScfRiYbsjtv0P36zI3YLRjKJtRdl0dOw'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cfYFq7TTLm2n-rwxiPFEw/quBDi89yhEJfDV6GuiePn1tRu4LIjZBCiBP1MztDFl7g2r2AXMxxmdZPrj58koXoNdYNaU--ztNiVI9GmYBDGQ/CA45yKB31zOaGOkYL-kwh9Bf6o6DeYfTmgVXuwTsbWM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,835.34,,,,
287,550.0,USA,"The TC200 Temperature Controller is a bench top controller intended for use with resistive heating elements
rated up to 18 Watts. This general purpose instrument can drive various types of heaters, including foil and
resistive coil types. It accepts feedback from either positive or negative temperature coefficient thermistors, has
programmable P, I, and D gains, and will display the temperature in °C, °F, or K. In addition, it can be
programmed for up to five sequential temperature settings along with associated ramp and hold times for each
level. A user-programmable maximum temperature limit provides protection to the device being heated, and a
user-programmable power limit protects the heating element from being over driven. ",TC 200,598.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a TC200 Temperature Controllers,https://www.omega.ca/en/resources/temperature-controllers,['Temperature Controllers'],"As the name implies, a temperature controller is an instrument used to control temperatures, mainly without extensive operator involvement. A controller in a temperature control system will accept a temperature sensor such as a thermocouple or RTD as input and compare the actual temperature to the desired control temperature, or setpoint. It will then provide an output to a control element.

Digital temperature controllers are used in a variety of applications, ranging from industrial processes to consumer products. For example, industrial applications such as HVAC systems, food processing, and chemical processing often require precise temperature control in order to ensure quality and safety. On the other hand, consumer products such as refrigerators, air conditioners, and water heaters also rely on temperature controllers to maintain a comfortable environment.",TC200,https://www.thorlabs.com/_sd.cfm?fileName=12597-D02.pdf&partNumber=TC200,"[OrderedDict([('id', 'attcuzwqvuj6cXzvc'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KZHPM3WKqIl6hZ2naVlJHQ/GSiuYFgc76jmvt0w5MbcjcKNEmpOogyMhxNW6Kn22BX_KxE0ej7_0cUEOuSXFD2D7tc64aREKB7mUTf27tD1Iycr5opv6qPTaZTUdvIKHS4/FDIOHDyAZVeGuitA1q-6t8rchHuRe38iula-lWkYgbw'), ('filename', '12597-xl.jpg'), ('size', 35659), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/v86cvgTYcsWu356qGwuHaA/l6h7tDvbYcWXBX9JOW-nfBWXFLKd9qvhF4U3C_0mqIdhSOoGvDpQZ5ze18eE2noTID83kFMBV7EC-QlohZYuJA/OGCYQgov6wpUBvrg_AgqUSrce013PxDahTmmkYUNwFY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EaEKAKh0SOMJIzA5JAVC-Q/2Zi0gtex4-1pweYEQEX8IccSHefebT_NlBlXgGiZFvbSXIF0Exre5G21byeQfIGPwLkTFSJJReaHexZtRfQxOQ/RiRReIXPamqv4MjlFQi6u7LY9iSbg8y-gwJt7zf7Cl4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bjMqa0K2-RuYukG-6PTugA/AEsZM7CyKB0M3X8FATVZbNhSLPv5DhlGzLU5Ncmya8TXkd35I5yAvgwj-B4Bcv0dbYPQdob1GCdrhQHtbkwxfQ/uV5WjWehvAgliZaqkYiTMUTS-V6QZiB423A_s-oB6v8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/thorproduct.cfm?partnumber=TC200,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/tc200.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#tc200-temperature-controller,,,True,,
290,5458.6,USA,"HDO4000A oscilloscopes have 4 analog input channels, 12-bit resolution using Teledyne LeCroy’s HD4096 high definition technology, up to 1 GHz of bandwidth and a compact form factor with a large 12.1” multi-touch display. They are ideal for debug and troubleshooting of power electronics designs, digital power management or power integrity analysis, automotive electronics systems, and deeply embedded or mechatronic designs.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a HDO4000A Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",HDO4000A,https://cdn.teledynelecroy.com/files/pdf/hdo4000a-oscilloscopes-datasheet.pdf,"[OrderedDict([('id', 'attFW6vjF1JLHmN7h'), ('width', 260), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GpUIp3Y6RaSOgbNpqH6plw/jbMQnApC1o91ZnOIDDLO7mcVRJnCinF15Xn6paZP41CZGOq953oWnu0k2_YkpS0xxWMHvvHm1KVjahaplEoVnv3bmqRy34VWbDk7vh_kC4g/2VOhgX2QCKRHYVM9oSfNn4ScRogRYA65khopTTqOVPQ'), ('filename', 'hdo4000a-00.webp'), ('size', 18318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2Q-U7x_gdcsJiqtKqZfP6Q/mlZey2Iqp-qewRGgMYX9vAVhgaT-hxOKDh0N0SifB5VzrvAH7NC0hZsjv6NZ_3SWSM8K4kbp6T292BEzuNNuBJnvSd6rzA1iQgqgKwMuGHg/DbaC84VN1zPol_daS06M4puom_6Blg0e27x0IvtItHo'), ('width', 37), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/z6XBafHiLu1kaU4VRJrNlw/CJqJyQBc0oHjq2OPQrp87ycjR-617nQVs3WA4d9m8V-omxtrCaIqwxjQQCkpPUxgVzUsmr-o2KmvPycBzSWWp4-YG6H47wu2_tYfYzMqM_g/jGbYx9Y78_7q5ABrOpRZDyIofsj9RT4lHUvh4Fcd7aE'), ('width', 260), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZGEp3Ttg9KsLPxKCz4v3FQ/_HZMMwKyTz23QC6HqBniC7kjklTS_ANjKxTezSBUH2efVpOknbB6Yjxbl0p8gMjXnReXmOio3pTLYRbTMrrsEOqrsPRfXdINxgyzvgVVyXw/PKG5ufcDM0rIbNtPWxoaSCSD91bAn15LnpZgF0sJ2rU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/hdo4000a-high-definition-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,,,,,
293,3500.0,"Irvine, California, United States",,Aguc 2,380.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Instrumentkit,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Instrumentkit to connect to a {Device name} ,,,,,,,,,,,,,,
299,,,"Instrument class to communicate with Mettler Toledo balances using the MT-SICS Standared Interface Command Set.

",Mtsics,368.0,"
",Instrumentkit,Mettler Toledo,,,Write a Python script that uses Instrumentkit to connect to a MT Standard Interface Communication Software ,,,,MT Standard Interface Communication Software,,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/mettler_toledo/mt_sics.py,https://instrumentkit.readthedocs.io/en/latest/apiref/mettler_toledo.html?highlight=mettler%20toeldo#instruments.mettler_toledo.MTSICS,,,,,
300,21.4,"Westerville, Ohio, USA","Lake Shore combined the technical advantages of digital signal processing with over a decade of experience in precision magnetic field measurements to produce the first commercial digital signal processor (DSP) based Hall effect gaussmeter, the Model 475. DSP technology creates a solid foundation for accurate, stable, and repeatable field measurement while simultaneously enabling the gaussmeter to offer an unequaled set of useful measurement features. The Model 475 is intended for the most demanding DC and AC applications. In many cases, it provides the functionality of two or more instruments in a field measurement system.",Lakeshore 475,348.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Instrumentkit,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Instrumentkit to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Magnetometer,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.",,https://www.optixs.cz/data/ke-stazeni/475_dsp_gaussmeter-d879.pdf,"[OrderedDict([('id', 'attN0SqMNqnS9oS5O'), ('width', 500), ('height', 271), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gjDfRkjGR0ySQH7Go7cO0Q/U0fqxa00f1i83Os5XdOX3_deC_CHvvkehhBHNAd-HbDscco9OJBQ3t-I-FVpCnMMhaR3IK032hDsx_qzPdl2-w/sO6bUOp2XMsad_PRa2BvRTg0xbwpmXWI2fNbv0jHgLs'), ('filename', '475.png'), ('size', 146533), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/n6fyROXSYclPKwTDA1mHOg/oRHfVf_znnDt9ujVLRNu1K_4ZUatRknh01EgK7FE9no0b1Ga5HPH9o5eUWgBG3uYW7XN__9eO9kYXN4EA0oddA/CWzpM_7vwBi5tYKIclqP2HGq9uEV5et-JrAbEVSRsXM'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PCcjIgvlCaT5Xp-GVuDeCQ/xCTAC-NgvNuDQQTz3BDfd_-i_9BRPrLS8p0uvY3_6uzPS1p48mTna43Irn4HlKhHLrhMDm4po6XkwkVS8PG6eg/moEGFQGY0u2HXhwA4wJKtkWky02ny6EeiQ0UqAbmir8'), ('width', 500), ('height', 271)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7XLKmuH_eRzgG8VOap7oOQ/8yJV2NiRYDROkwIscziIJPwM_v2uZH8wGG75ZgvecBIXWbYSriaCHQZPJJp82kQRth06aqeOTysk2VpQqjO3QQ/VlaLsaxaFxx3B2Gn4f2lqdctTDkWiicw5eXFBgD9Ih8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-475-dsp-gaussmeter,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/lakeshore/lakeshore475.py,https://instrumentkit.readthedocs.io/en/latest/apiref/lakeshore.html#lakeshore475-gaussmeter,4454.0,,,,
309,110.6,"Cleveland, Ohio, United States","The Model 6220 DC Current Source and Model 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the Models 6220 and 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",Keithley 6220,240.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'attqJ7B2tvK8wDFSb'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eEWgxtQ1ignvNCNdSQHTBA/JvdfKldRx3-dduPvVBZ7TYJqU9xVMQRAjVxvO9t6AOJDOPjaryEYfZqL-uML3MX00t2l6E76sShZvsCteJqdC5HTTYdC1SBEbGtouNlp9euctWDq-scgknfCVfxNGoUFSOSBcjvrso64LDOdtcFa1g/YB5sXl50gPHI2Hof2oElJSN4AKs9ECV8b3NEXFIUEZ8'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2MlrMXHq0o0p24sEAflnyA/kV7X1iTyxFr5qcHFvVceqFRP-jVfzr3qcmg7DnibaS_2ryzqiXOZ26UDRqb8MvbSKUz0CzYFQAz5xDQ5PLAodA/bbW2tR_Dkhz5jUtLHtRgyeRSVn_Fp5Xc1ccAfE0Re4s'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YmavVP0OzK5GfooSYDhDkQ/ASyIf0jRPqIwrnfDwKMHL2YYsMiO3j7oh2LrB7EPFlgZvVuK3c8Swy-AftJV6ZjVbqKAZk9ZlsP5XneWCNYu4A/padkiQ76qYwdzFmQ0bGXOPAj9rTBiCCVRk7AULKc4Mk'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0__j5ObJjobGgg2RaP8p4A/O9QITnx1ltp_5DNT4P-HlIS_MFo8Ri8HrP7HpBrYMg1voCeXoWO1CkA7WpuRoGMPl0otoE0LeK-Yt2H3pZFl7Q/UlY9PRj-4SDLr42jA93ee4TSzJI_FV60BUpPZNS3emg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a Keithley 6220 ,,,,Keithley 6220,https://www.testequipmenthq.com/datasheets/KEITHLEY-6220-Datasheet.pdf,"[OrderedDict([('id', 'att6Ci3HjK0Dquoa4'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_p6ovMxkzYA-Tit1L38RQA/RqxVUE7pcI27TaMyDmV3VfJVqVIow0Kl1BLDLN3T_TC0uA3p7ykYpyhVDd4DNBbof2bTcdVi5jE6JQBTNM1WDw/yJWzpgGUuu-CX1UuAeevNDg9jstxDPoO-xOw9ILIdhA'), ('filename', '6220.jpg'), ('size', 23235), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gzV-ZAPDRrrymVV_3C1_8g/nYQxFU-AIGoN59gEyw2v7NKcMhMqiJ1O3XsM5VVZL-T5cIRloJRRSciqbU_BP1nMUMui3kp1J4wv_2vADki6lg/qKIMVDE5fgIy-eGdvdBhKH7ME0jLppth_f19UN71VfE'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UKW7JfuYLVvodJWj0ohmdA/J7KB04ZSkaQXxo72kx8xhtLeHGKiGFW-OcLXAi-ZhqQ0Gj4S0mcJGtmhMUIPUABnvMasYoNg5R88WX2fNxy7wA/FB6Tarjqoy_QcZsXeNPpEVTPnVEP7WdP_es4jeWx1Rs'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SFD4UWzokU-yeNGcjz9nQA/85FpDZciMaohq8RwRojfg8FJ1Tx85kMrqqKIWgz86Joc5sESC2fXqzyVHWfcPvMLBfGXDNH4KcH3rduUupPUMQ/cFKhlvH2OccsiMZxXT3KfLHn7eVxEolCJOrCbvTOm5Q'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/series-6200,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6220.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6220-constant-current-supply,6210.0,,,,
311,,,"All SCPI Multimeters
",SCPI multimeter,135.0,"
",Instrumentkit,Generic SCPI,,,Write a Python script that uses Instrumentkit to connect to a SCPI multimeter Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"SCPI Multimeter
",SCPI multimeter,,,https://supereyes.ru/img/instructions/OWON_HDS_SCPI_manual.pdf,https://github.com/andrey-nakin/scpi-multimeter,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/generic_scpi/scpi_multimeter.html,,,,"Many Devices and Vendors SCPI Multimeters, And Github Project seems Coded in C++",
316,23.0,"Beijing, China","The 1000 Series from RIGOL include the B, D, and E series oscilloscopes. The E Series are the value leader with 50-100 MHz models that include 2 channels and 1 Million points of memory. The D Series add low speed digital capture enabling basic mixed signal analysis in a economic package. The B Series provide more speed and power including our economic 4 channel, 200 MHz DS1204B model which provides 2 GSa/sec sampling. With features including FFTs, record and replay, roll mode, alternate trigger mode, and adjustable trigger sensitivity the 1000 Series is a great entry for value oscilloscope requirements.",Rigolds 1000 Series,444.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Instrumentkit,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Instrumentkit to connect to a Rigol DS1000 (Series) Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,Rigol DS1000 (Series),,,https://www.rigolna.com/products/digital-oscilloscopes/1000/,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/rigol/rigolds1000.py,https://instrumentkit.readthedocs.io/en/latest/apiref/rigol.html#rigolds1000series-oscilloscope,,,,,
328,,,"All SCPI Instrument
","Scpi Instrument
",134.0,,Instrumentkit,Generic SCPI,,,"Write a Python script that uses Instrumentkit to connect to a Scpi Instrument
 ",https://fr.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments,,"SCPI Instrument
","Scpi Instrument
",,,,https://github.com/bicarlsen/easy-scpi/blob/main/easy_scpi/scpi_instrument.py,https://pypi.org/project/easy-scpi/,,,,Generic Python Library for communication with SCPI Instruments,
338,5420.0,USA,The Keysight 33220A is a 20 MHz synthesized function generator with built-in arbitrary waveform and pulse capabilities. Itscombination of bench-top and system features makes this function generator a versatile solution for your testing requirements now and in the future.,Agilent 33220 A,41.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Instrumentkit,Agilent,"[OrderedDict([('id', 'attXkc513oAf08kfb'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Pbq0Rl4kkKIgp8OM--alPg/vL8IgcXTXBsJxdgY-_LWU--n1pUZehJi5YmXCv--rLIV9B5VfAuzxdc6UEQM72t9YFiWcCXYpmwfPHYNqPXtDHbw5CqAh_YuPTAQ9bGiIfg/xvp5R5aZou1Byvbsc6sl6WooGkv9SA5W7E5BX8U9NCg'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ba9I6e8MR9jjaDAAMlpyKw/QxuGfydU8Kb8jarGkH6njkeKPbcSLobwkmlOYP1lIUjDsfDSnwMwFgcjrtiULQGafKtemzUb9SU8gLtdjqPv8JvzqxhCkN9cN0swYcbt7tY/GZeGTQcx_ZH8aMwEk5nykp6x_5gw_bUxmxoW5-QcEEM'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/s7eCVUpzrvrxqwj38NersA/lWkMeuhQhoVIP2lk_W51AiS9Xvm_aq9GSffqHoldDAxFq-iLUwwsDiEfnVwpkZPSzcV0HiiL8dWyj6FKmOdtKX2GTq_5fioiEmQdkDrlQwA/BRnsca05SbkzCXotaLbaq_CGsWXb35zobwtvEo2d0yg'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ltn8Oc6CcO-nE1TVONqZpg/hfOWirlV_gh_YvhIm-2UzadXU1dJ_OcvqELBynNqcKcaejyskpIU5w15Yr72Z99UsJGuXj2qSwqTsaN2hVVfgxDC_mDIsRVBwBPNc9EPIFg/4HCvFioP9PZhTbiyDyPmCwWZWz6aWCpWY7g7-4-keqM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Instrumentkit to connect to a KEYSIGHT 33220A RF Signal Generator,https://www.keysight.com/us/en/products/waveform-and-function-generators.html,['RF Signal Generator'],"Function / Arbitrary Waveform Generator, 20 MHz",KEYSIGHT 33220A,https://www.keysight.com/us/en/assets/7018-01144/data-sheets/5988-8544.pdf,"[OrderedDict([('id', 'att9Bw70ALrjUCUhO'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/i67Sivz6LWivrZYr8zI8XA/VwCUEHTba8vc1sxQv3T6N5JmMveStLB9QJfnL7Ptr_kPJOh6VFsVJgvznv8OkdL_huPUF7IcQ5nByBSHQIKjVG8cUzYZ0P3dbWBj3we773w/5MZhvkbZ6uqm89lD-ztjMfkbuC32HJOpB_LW_95tQaU'), ('filename', 'PROD-127539-01.webp'), ('size', 12382), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Q2RJC20Q77M6VPjwD7ZsTw/3gkppaZggJKID2cNPTVl52vBhet002LGBwSmgkstYbJORmceNsdLZB3v9KVMm-Jx4Y8mLlEzuCpVT7HqpGgJuFjSY-mnCEjP4aCkHJM6Lko/0jZcfDKUltBFe2x63geaco0rsH9Pn_YOTyNY95iD9fQ'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L6G2jZIRu5O_SEKF7qar3A/33-zOwIMLpSpb0ote-KrZmnpEVoxjq5-qvPPdSpPwidX7GxgGboo3m8eOoeI18bej9tdhXiT2VwNuPaJdTGLJeDdSPobYU3gaz0-UXOt6Cw/pokxyMhMMlQ3i5N3ONEmeoNHtzEyJCpyZhyUL3Q2Ias'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/z0XJsnGf42xx-Z5SjOaIog/QAajhnDS17LYlpPjqqmS3ZKbym3EC05SRNdjgEWRqnM3qnpxk6Mc0yakSrsJJi2CnUIUG9Hud6tW5OK4ZID1vHCCPYEM7eQ_IyyWk8pRfAc/pSjS0g5--VM-G6VZ1Zt-iqpIaE7dhcp_f6laabN1c-c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/support/33220A/function--arbitrary-waveform-generator-20-mhz.html,https://github.com/dyordyevich/Agilent-33220-Python-GUI/blob/master/program.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/index.html,,"
",True,,
361,110.6,"Cleveland, Ohio, United States","6514 electrometer combines flexible interfacing capabilities with current sensitivity, charge measurement capabilities, resolution, and speed that are equal or superior to our earlier electrometers. The Model 6514’s built-in IEEE-488, RS-232, and digital I/O interfaces make it simple to configure fully automated, high speed systems for low-level testing. The 5½-digit Model 6514 is designed for applications that demand fast, yet precise measurements of low currents, voltages from high resistance sources, charges, or high resistances. The Model 6514’s exceptional measurement performance comes at an affordable price. While its cost is comparable with that of many high end DMMs, the Model 6514 offers far greater current sensitivity and significantly lower voltage burden (as low as 20μV) than other instruments can provide.",Keithley 6514,218.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Instrumentkit,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a Keithley 6514 Power Meters,https://en.wikipedia.org/wiki/Electrometer,['Power Meters'],"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.",Keithley 6514,https://www.farnell.com/datasheets/1484270.pdf,"[OrderedDict([('id', 'att30haLadU97rFh4'), ('width', 320), ('height', 161), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/w-xi2yh7Pae_Ek54hR38xA/XImDwAIDhH0R_zlU4IkFqhZyTXbYQkSGd0X6AF9M0Dw_pSZ7khy184uM5l6KjxHcFgD77udsmaTBI5bYO2hNfdqXJEgrzK_LJTS1ahAYpLg/zwebuNhabhTT-kGinxC8vifIeOJzCrdP11w1UVTX3nA'), ('filename', '6514.webp'), ('size', 4232), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wKTFzUtgKHmKkPb8xMzUJg/rXS8SJqau-4W-D2EDNLt4dfYOccvETe5W4jLhBnoNUrwUcf9wFQbGCbH_uS44zWtKDWZO9cJH0btrdiaFpz8OnIOk9gcObE3Y9w65M1smaY/VskP8WiORP1BQiG6yLqXsDsn4V49yDtPczNXZywZcz0'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LHgn8L_snKk5tucs36OnCg/RhwDMa4Q6KChCsluUoRP6kmB7Zo7LW_OpjBj6z11q7ZHGx_C52Xu9yKdmHNLt-yhEuNK-YOxKqO9BSG9WxLQdjCJd1cA1rC2caY01W2v0TE/7x76VC5ScezMZbF4x3NIYjdT5mYO980Yoi7_PEl3F8Q'), ('width', 320), ('height', 161)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hQR4iiKw-0ZeYcRUAvmHRg/UA5gFLfz5kMc035HO53kgiT9PIQHJq7DtYXPdWu6HdU2AZOdgIRwM65iCYmk5iUwf30lF-GepSYI8eDBs6PCq_XOpWMWzhfwLP0P8ajj3qk/EI82KGF7T1dKI47WKy-_HxJhPlLvAtyFnWSrI9ALwC8'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/6514/electrometer-20pa-to-20ma-2v-to/dp/59K0092,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/keithley/keithley6514.py,https://instrumentkit.readthedocs.io/en/latest/apiref/keithley.html#keithley6514-electrometer,11161.7,,,,
363,550.0,USA,"The APT™ MST602 module is a dual-channel, high-resolution, rack-mounted stepper motor driver designed for use with the APT MMR601 Motion Control 19"" Modular Rack System. It has been designed to drive 2-phase bi-polar stepper motors up to 50 W, with or without encoder feedback, and is compatible with the full range of stepper-motor-equipped nanopositioning actuators and stages offered by Thorlabs. Alternatively, it is also compatible with any generic two-phase bi-polar motor of varying powers and varying cardinal step sizes. ",Aptmotorcontroller,604.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a APT Stepper Motor Control Module Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",APT Stepper Motor Control Module,https://www.thorlabs.com/_sd.cfm?fileName=ETN012478-D02.pdf&partNumber=MST602,"[OrderedDict([('id', 'attYtJhsEvZTymA09'), ('width', 780), ('height', 508), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yxKyD2KCGOK-ck14m-sVOg/2zG9aEgLMohn51Mi1fNrJ7zPdxoznXDk83FeRRqirjrwEZzhNCMdgAtvnnsa3PDFCq7FNDQKMGUZkBr__aoQ5GUuWce_Yf0NvioS2w2Jolg/-xSLQjJprEIPnM6azTat7c6IHQJMEXT-9aI17HrHDW0'), ('filename', 'ETN012478-xl.jpg'), ('size', 49930), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hqksbx_lljCc8i-lMgM4yw/ZaMfU1hka_1W1n6vvnKTq70edbfU09ywLdJ2_X0hPREZdZsesNJi9nHX4gCUqvSZQ5Et5dFtxBIu-YKzussXqg/m5yLu1FBYVHrpjzPsPHuJXLbM28n5Gftw8Vm_5xIVvo'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pdSe819tvguY3y9SOTODSw/-aYvqDC7ouERoXHXIXwQtyb65bpQ56y7mp8gLwgdLQ5ruxk7EjqiHyn6lNOTATxIMp-Benqiwz8Iq8pMsxCnqA/JjApVH1NyAO8kdcOl1friOvd4tqoa6IbtdYLJFZ3ujg'), ('width', 780), ('height', 508)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_l2NIU5o9TpzJDelEVS_jQ/0VJ3Ig__ARtkJOmGVrkr4yIDcph0QAfkAciWubDnYvlTnlHEwqk3hA74Vec8_C7NZ8J_nSMwL7AxXCy0jE2dpQ/aax7dcSqqLOKuJ_pci_Zdj2LpbBNu0M4-0jBvL93494'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=1186,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,1523.17,,,,
372,550.0,USA,"The easy-to-read LCD front panel provides access to the same commands as the included LabVIEW and LabWindows software packages. In addition to simply opening or closing the shutter, a repeating sequence of open and close events with exposure times as low as 10 ms can be set up and initiated either by a front panel button, a TTL pulse (+5 V), or a computer command via RS-232. Alternatively, the shutter can be synchronized to follow the rising and falling edges of an external voltage supplied over BNC.

",SC 10,599.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a SC10 ,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927,,"Optical Shutters utilize a rotary, electro-mechanical actuator to provide millisecond shutter operation. During operation, these shutters remain in a closed position and then open when a pulse control signal is applied by an external controller. As long as the control voltage to the optical shutter remains high, the shutter stays open, but as soon as the voltage goes low, the shutter closes, providing inherent ""fail-safe"" operation. The frequency at which the device is opened and closed can be controlled. An optical sensor, which detects the shutter blade position in the housing, provides information that confirms the state of the optical shutter position. This makes it ideal in applications where a laser safety lockout is required.",SC10,https://www.thorlabs.com/_sd.cfm?fileName=8654-D02.pdf&partNumber=SC10,"[OrderedDict([('id', 'attuCdx2mUAVBjH8G'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/28SpXECdqwdPh0VF0x7yBw/DRq0t6owimMCGFkLBiC5YKdyQttLYgjfROHVQYSsPj4Z8bh_VSyEAb2AcGP9ciegoaByoTMDcBJdBCX3uDQnYl7HzaC_GlpdirwEfzdJlks/2OMHMVyYnovP3RnUT_VZHelnDpyVLgBbR16Ns8bCOw4'), ('filename', '2698_SC10_SGL.jpg'), ('size', 29251), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xrvYI6ddo9rbh7C16SzeBA/bDIshAE0ioZ9WJcWaSCXEnR_BtYXZi0ipDIrxJdte8jojkYL_tV3-kJWL7fV93Diswjb9JxnZDGi3NAeTFSjhw/lw5z7qPqjKp3IoSmCseZEx9YOahuUFkEflonhGXCwqY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1ssKzOxYPqZTA_GRxIoflA/Hve52M6uQrbg7dKpg3srWPlboNoSj92mT_4zvDS4dTSTpULMkCtKvWHrRts_XKYdTmu4U2jJP-DS-68KihB1Xg/gfiYAltxNjY3S2Qe1Pg0lY7MdBXUmZ5K5CGMa9zbMiA'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Tb9YwBoZFOZ9h8WQ3pLb0A/c0sGqSDX_gjd5HM6jngYiD5H95Yoiw6w8zNV9a3pWL5q4MedMDQnsxltsf1j-wJhONQR81HoDYv_KZqG5SBBlw/RQNXdo7DUQ-xe64Q0cKDGFDRoPFMEpPGtaN81mPMuPs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=927&pn=SC10,https://github.com/hebecked/PyDAQ/blob/master/bin/rotational_stage/old/old_modified/sc10.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html,844.36,,,,
375,24.9,"Sunnyvale, California","CTC100 Cryogenic Temperature Controller—a high performance instrument that can monitor and control temperatures with millikelvin resolution.

The CTC100 Cryogenic Temperature Controller is configured to suit a wide range of research and industrial applications. The system consists of four sensor inputs, two powered and four analog voltage outputs, and up to six feedback control loops.",Srs ctc 100,495.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Instrumentkit,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Instrumentkit to connect to a CTC100 Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",CTC100,https://www.thinksrs.com/downloads/pdfs/catalog/CTC100c.pdf,"[OrderedDict([('id', 'attWJtT5pqwcUvIF4'), ('width', 3996), ('height', 2704), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/m95hNNgraznPGDS3WUoMPA/spfsQjPNn0TRJN8nui9MTGUDTX0SJ-gNmB70a0xSFkbMBM8Z4UcrO2jbgFxNuiA2j9gKQ_6QGoz8rE7rr1qXomX7om0CETiOwzuGViEHsGo/t6QyBVdTh_jSUq2iIYHPaHl4lHfm6LvzQ47nKtb2OOA'), ('filename', 'CTC100_Main2.jpg'), ('size', 2127759), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bt4np8Po7yVp1wr94zeMmw/IOwWlSHWyto4iKUgNsSEl6rpevtAkw3vqyVhK3Pn_mC1rrkrEdTYsiOh7MrJ-O_UAGJKDc8-OgpN2Rz9Vw8bxw/k5J6OgpygXXksF3Z_I1JMzYP8aacg4aISBqc_dnbtdY'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qNjjclvtoVq6C0tzYJKXFw/HpHgB1k5DRZpD4VerPK0jC1EHb4h9D1IXHfM3ggvrgCiMWlPAa7va3bUuglDswJZft2uRGeUXYAIxOLfzsA5bA/9iswyQm6iT8bWaz9cXHvWZDf7MB52kf4A08C3dZzhCY'), ('width', 757), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rnEZDMqt54Vw4GK3mYq7Jw/ml2cOAECqeVea6eoyiFGyZll_NQUDD-Gz6Ma-QFiBj01gOpG2FkU3WTC4e21hfTPLR_TQ8FTa6rdZlQ_PGsH7g/bEOWQpz_22z7Z9jJvQOHzzukWdT0xTEr8rjuaXFvzts'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/ctc100.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsctc100.py,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsctc100-cryogenic-temperature-controller,3495.0,,,,
378,5.0,Finland,The Picowatt AVS 47 is a resistance bridge used to measure the resistance of low-temperature sensors.,Picowattavs 47,419.0,"RV-Elektroniikka Oy PICOWATT is specialized in manufacturing instruments for thermometry at ultralow temperatures. Founded in February 1978, we have gathered 45 years of experience in designing and manufacturing low-noise precision
",Instrumentkit,Picowatt,"[OrderedDict([('id', 'attgTI15cND1GBG9f'), ('width', 150), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yEs2Utb2aOSwGJr81XNcTA/8Id-7eNrn0rg2-j5jxDR0wvx_iP0fgEGQRnflQFEdBu0iPsSgORumfbi-Khj6ntUMiCqUiUdCC-bgX8EdrGpL3vuDdUoly5tcrx6ieNtu6Y/RUJVc9GaWDyvqW5R2rH2tGplqFAUc_6Hmq36GM6Tk-0'), ('filename', 'logotext.gif'), ('size', 543), ('type', 'image/gif'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/373k8AKNWyfyuz5x4R6O9Q/DnBLWPdPtDhmtZnMgtGWov057ld_5rm111jWp8OpKpCf3GmAIJWSukgPzkdRO36yXRx0MMhik7SJG2tjf4vDqA/oxlCKhvMNCOxKMEKrfZSKhVb5GkihofQIvqwWNoRTcM'), ('width', 108), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fkRU1veWmvOxwp9eRUOfdg/T81om_1m-bMOQ6oG98MCHPALor8wCtqzYo2oPoA9I5vGbVeg2uirAkqFNj3sMEYmf2qzG73i_zuhrcdYjvWlvg/bT4bmCsrz5DZXvviXJHr6rZYM9cz8hGXVPGQ0IDG1bU'), ('width', 150), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7sl8S92xlJQjD7dTqhZrfA/3pD1zoAZnG-uAsGfmfI_faTvu6zlF0Vg-UkzTQSu5BpuJtozlwQXvyW8hFCEMqGALC5wBP1FB_S_vNMOevFRzw/aSCx3cuNr9SOlI7rAA8bgXG4yobnHNYxzSTwxsRXL3E'), ('width', 3000), ('height', 3000)]))]))])]",https://www.picowatt.fi/index1.html,Write a Python script that uses Instrumentkit to connect to a AVS 47 Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",AVS 47,https://www.picowatt.fi/interfacing/avs47_serial_usb/avs47_serial_usb_w_userguide.pdf,"[OrderedDict([('id', 'attLoXHvdB7eWnmFg'), ('width', 2935), ('height', 1593), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u7-pF0kF1s6hF_ZF0s9fgg/iffUVit4C4BAXGgw5LgmZu--JBMBEZ7Y6MBDjLnboOC2l8JsAeAw_r9zD-oOiLA0d6tN7BNVL8RJt90roSyCuh7a_-f5L8I0X3jqVUgbWc78qa2d1qE3vSriYrW1gvLY/jLc2P2CiWAZp1wJqjow1E_ILqEwUMmdHCMcov9LFzWQ'), ('filename', 'avs48si_physical_front_panel.jpg'), ('size', 188257), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HWzLa_eM7EU0ILINrYaNjQ/AHJyF_6TZCZ3MF3XQ6WVG2Jnn8bT-CcQ-MdFdAV4YYxPyl3BFT7die0Br9aEant8CVhcYK9fnxrwbhY9wK7P7w/764rt6rUtFu9I6roxrSiBDHGspygS4YoD29R8HFMEgc'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M0B8zpbd3-6XyYC5SmiXyw/5ly1faGvq1sIbyh9__CYB_sWxpDKLJUMoWhgUjfGqJ1UMDESYKgUFFRZ6LZsOECgxnH-q6dYEVcrTVmMRlVRNQ/Gi-glnvKMECZan07FyBaH5PSQRZJM3tmMXiE6QtuprI'), ('width', 943), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/K8piUUXxGOorDdLrukWriw/OeVtG4wqYH4RsHK2jrE7pgdF9fVXfPMLyBbAm6UEU4gEQU1kSU8p7NGwbHaeLrRg5F09yKhzKAV8pnJytQsdGg/RsmBn9CG7RhPTxjQyJKm4E37_UbQdPw596FLpA-N3jo'), ('width', 3000), ('height', 3000)]))]))])]",https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/picowatt/picowattavs47.py,https://instrumentkit.readthedocs.io/en/latest/apiref/picowatt.html#picowattavs47-resistance-bridge,,,True,,
379,550.0,USA,"The LPS710E(/M) Amplified Piezo Stage provides long range, fine focus Z-axis travel for a microscope slide while maintaining a compact, low-profile footprint. It features submicron repeatability, nanometer positioning resolution, low angular error, and fast millisecond response and settling times. When used with the LPSA1(/M) microscope slide holder, the stage is ideal for imaging modalities requiring sensitive sample positioning and sectioning, such as confocal laser scanning microscopy. This stage is not compatible with trans-illumination.",Aptpiezostage,602.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Instrumentkit,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Instrumentkit to connect to a LPS710E(/M) Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",LPS710E(/M),https://www.thorlabs.com/_sd.cfm?fileName=ETN035405-D02.pdf&partNumber=LPS710E,"[OrderedDict([('id', 'attM8R0YwBzGU5Fsz'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PNoK0Zd9nEHCPyf3PE-EHQ/G-KR8KbHktw-q2GO2io2JbkevWGM8D1HxIys92pTxYU--4m9vlBKudqqFavZPO7pSvu8A0o73DN2q86NMm5dve31m8eIXVGOC3cfbzli7wk/38newM8g2IF1ms8dhKaabskFq5yfJOn1tkFT308XIhQ'), ('filename', 'ETN035405-xl.jpg'), ('size', 40288), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l0Ml4eQFKmXO4FkURv-KzQ/lVXCas1n5UIGm8wxVx9vc36hFU5WBaxP63UJpedRC-gpGBZ_7SUN7RW5zyznKA9l_ihCNtrqGQBOJraP8DzY0A/4rGs8JcrTe7oZvko0MoNz9Z69G8O27SVb7pOPrG8bdU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dpdUnQTBvXjQ7GcOKIvrDA/gTLOyLhbWYgC4mqwl1yLQFDcGlY1CSQl2zcqQhXoX_mzhp_HhSlI8V1_ub5gzTTjecXsGW3U7IOqSh9-6mUm4g/ybsCqgQTgSf7SBIEhbX9cFc7wemfBDP6r9Qcu9397NU'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KiAtRr5Dy9Wi76ApUS6LPQ/R0632xfIQI_XQZm5YIhuTqhZ5ZQbvmW36gG_PiMYHQVr4mPNkvm_IlR7C72fPMKwaSOgfhPb1tb4xPzji6bHrg/5UFwaq-3SsZHLYfU--39AJhlKumF5U2zxZHf1Sn5aAY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=11303,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/thorlabs/thorlabsapt.py,https://instrumentkit.readthedocs.io/en/latest/apiref/thorlabs.html#thorlabsapt-thorlabs-apt-controller,5309.35,,,,
388,24.9,"Sunnyvale, California",SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,SRS 830,497.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Instrumentkit,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Instrumentkit to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,"[OrderedDict([('id', 'attNaj1PW0Au0Ue7A'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UkvoX3FrigK3aiWaVoS_3A/dMwcYDTrzZvb7zKKETnrQZDr6TTcQaliEx6Fbah618lHP4L1O11q0GDamwoNNfua2p6dTnLqvipTnRqyy6XnIO9YhkFGufPQqofGeogN1Zs/52W3jSDxJgf72Q7STnJCzyOwB0VfL0wHztlGJxcW8qA'), ('filename', 'SR830_FP_Wide1.jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ReVW0iKIB3nNDXuziK3Yxg/iAf-SWtwFMSsdozQjGyYZu7LgKN77RayoIBZWHwEyiqt8pqfebj_D9MRJHY9Zd_aM2-PXo9WlkLBma29rMSUgQ/0dotHi8bhgkg0bEQbz0VK999Xc_9Rcwu8-VmKHjrGd8'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7_BcH9jE98857QzqxfNqYg/E6THw00DciQ2PG8x_cbTVumeejYFV0ysrydlqzUPE0ji7_ZvXLUMPs1naPFjsMBOwjfzMlgo_xwWqrfEdBPhzw/VT-0ApTPDlFi6dOVm4cPy8mu4OkUQNTk3SoRwx6ZCFY'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g4rtJBVtoCBzLQf37gH5Cg/uPB7U5dWBYNpvQWHbRuMhNrMipM_anoNO5SLUL9jCFQWOWwAzrleEcFvO8SSId6iPmvJZC9wcoSd9Of2QPoMnw/oAKtaqvcqxvP8W-9bKPznBguL2CAtvt1qPbv9QFvLYk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr810830.htm,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srs830.py,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srs830-lock-in-amplifier,4250.0,,,,
389,24.9,"Sunnyvale, California","The DG645 is a versatile digital delay/pulse generator that provides precisely defined pulses at repetition rates up to 10 MHz. The instrument offers several improvements over older designs—lower jitter, higher accuracy, faster trigger rates, and more outputs. The DG645 also has Ethernet, GPIB and RS-232 interfaces for computer or network control of the instrument.",Srs dg645,496.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Instrumentkit,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Instrumentkit to connect to a DG645 Pulse Generator,https://en.wikipedia.org/wiki/Pulse_generator,['Pulse Generator'],A pulse generator is either an electronic circuit or a piece of electronic test equipment used to generate rectangular pulses. Pulse generators are used primarily for working with digital circuits; related function generators are used primarily for analog circuits.,DG645,https://www.thinksrs.com/downloads/pdfs/catalog/DG645c.pdf,"[OrderedDict([('id', 'attQqnPuoAadlGes3'), ('width', 2000), ('height', 1435), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Np8L3aCKr_QjsdOa8yUvSQ/NTzDJSMSz-YAj9gJqtKbRfLAQMKcubbwhIIVDErQ-wmvTMGUglSR-MO52zSjOZjQwd9JGMmeGKvwUI4gH5-JKmQyI8qdkuKVZRAY_nkl5_o/kKyNZzdakbb-uRLj39jhRdhNapE07PBBLEJF_AwAF-E'), ('filename', 'DG645_Wide_Reflect.jpg'), ('size', 472623), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e7eoBmwdBu05cItoYfNRcA/4y7TdqP5J5REXV-waPevlUEbbA9fsasG7eO1dxOhflbOMysPr6t-akeZwO-JKM_u_pqLDLjqYRPbeEr4Kt7fJw/3UGoBNqWuUc1PLoqkFJRZHq2jZki0gpUVnuLCtXvdDQ'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9GpG7uyoJw_MpLf7onn2Cw/sC177TzkGhw6p6-T6gZjKOVfu6liW280ROC5tDx8ILmo-uV_wTCbJPlAkitLcmDj9MoHolQ1MG4bvSvsQc2WYw/CSw2ouew1ggK396M_2YYV_dIZDtqamrb6vYgwQZ525w'), ('width', 714), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tEkDGSN5ybN9umjXBVGYkQ/cvULiWSj3o6vCu25pxXWA4EBVm1LcOzwvQsmbTw8lplAXvZ8G77fSX1uruGtcImG9h1RQahTMnju0l5rb6S3Cw/ggy2lI6-ND3_zxNLZe2gXvS3ebp3AEaqu0ksZ8jEt7E'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/dg645.html,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/srs/srsdg645.py,https://instrumentkit.readthedocs.io/en/latest/apiref/srs.html#srsdg645-digital-delay-generator,4695.0,,,,
401,5458.6,USA,"The WaveMaster 8 Zi-B combines the performance, signal fidelity and feature set needed for today’s high-speed measurements with the ease of use of a standard benchtop oscilloscope. Featuring the highest-speed serial data triggers, the only complete multi-lane serial data analysis and eye diagram solution, and the most comprehensive set of compliance packages, the WaveMaster 8 Zi-B simplifies the most complex testing.",Maui,584.0,"Teledyne LeCroy is an American manufacturer of oscilloscopes, protocol analyzers and other test equipment. LeCroy is now a subsidiary of Teledyne Technologies.
",Instrumentkit,Teledyne,"[OrderedDict([('id', 'attersdRiQkVIGMyA'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awIz4KB27M0OHgoOK543NQ/72nwl8TV6BFriunIyg8k4KRvg99FaekA9MmgrZ753iL9cjzgS7NE0JY_VcTdUWznSEUG4aQXd6ZqL3pnahE8dsCoYruqSUO9Z1RsB8wZse4/KiNco58T6iZXqz2pdoySg6BHd-__a7BztZCE46QL_us'), ('filename', 'telelec.png'), ('size', 3899), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OyMJcanSnwdRGE1gq2K_fw/jKEBfI1k3EfnlQtX-MIhRSl5FbUcn7ylDOSU83-YB-TOkwmlQjxg11SAIJ4N6tke2fi3TIxKoK03bYAWvrA3FQ/WvorM_o7LaIDxzhl16laeLxpya_PcAwJIGPPs45f3yk'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/S2bbOVUBpePkW1l6TBGBbw/TFw1TJvNQeRFTGF5Ij9fdB0Hcpar2WJqE-fEKHUqcB5_yi68LTSwxp67T9uSJZWLiIQYhWDA9aoZosNcVpz7iw/4jwiJjIRtVdUDGZXE8cu0OK85t6bcfnVvePf_tostws'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7Upull2VoKyid9WU7Rap5Q/-GC5i6gWmxmP5mzp29R-U8JfOL4MIYK99D0cM1xy96Mpdncyqqd17MrDOAFyk8o7OTxy7vZ6gHYIeWrCScEGkw/U8ndls8LTktzp2UpG30oo-RNOcmDfowyHlTOm6YKGK4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/,Write a Python script that uses Instrumentkit to connect to a WaveMaster / SDA /DDA 8 Zi-B Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",WaveMaster / SDA /DDA 8 Zi-B,https://cdn.teledynelecroy.com/files/pdf/wavemaster-8zi-b-datasheet.pdf,"[OrderedDict([('id', 'att9dZv0ctFtBQxTK'), ('width', 665), ('height', 705), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u5LhAdBjV8kBuX8j5nSZog/aDKWaXZWyNmphUxureIvPlHSi44jxpmMuRX4-yfptz8D6burnVuR3Na4L4TJbFV0PdVl4rwJh7Hum12pFRbZFfm28ghOFMsA0ejkHWn38AQ/Z2CrkyGU6oPAqO45eOr266hHX6TjfxCkTQv0p6qabu4'), ('filename', 'wavemaster8zi-b-02.png'), ('size', 436672), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ufDhpLLLg-GujtKlBCNo1w/ARehaBBj0JHWQfbhdJepcjBQiJzfr5VazS62YUbSrsDEqmgiUjbZlwd0uYEI_8-dhklxWD77f9U-N4rGBPJB7A/rDbLBPbp9PiUEBke6ka1xaRfaLCaJnCdx_e4xztT7Vk'), ('width', 34), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lPOz0MlgGOUWuWXOGVfYGg/3rGeEK2t8i_DOEnH8kcs9qtXG0RryGxqtYte0mAWypnkEjKupAtKW3GHUvCI7b1lrzacZ4G4qMxpknfrzHoy-g/VGI-jcY1TDqJgkgBpYdSZq_zvXrMdkmwatCu6YQMJ2I'), ('width', 512), ('height', 543)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xagwxGVlDumazLTPcEVhJA/BVpgGSzMa04JKs4oFyEI_bltPFRkoBlNcY6TAOq6LeCME5Upv7mptFwn9vC-kPZiWh4YV8bdxMGms76BmIfTRw/xX0lvmp8OkW8uzoSYjelAmCtcjjoXb9yB1omZj435Ao'), ('width', 3000), ('height', 3000)]))]))])]",https://www.teledynelecroy.com/oscilloscope/wavemaster-sda-dda-8-zi-b-oscilloscopes,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/teledyne/maui.py,https://instrumentkit.readthedocs.io/en/latest/apiref/teledyne.html#maui-oscilloscope-controller,,,,,"

Source code for instruments.teledyne.maui
#!/usr/bin/env python
""""""
Provides support for the Teledyne-Lecroy Oscilloscopes that use the
MAUI interface.

Development follows the IEEE 488.2 Command Reference from the MAUI
Oscilloscopes Remote Control and Automation Manual, document number
maui-remote-control-automation_10mar20.pdf

Where possible, commands are sent using the enum_property, ... that
are usually used for SCPI classes, even though, this is not an SCPI
class.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.abstract_instruments import Oscilloscope
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, enum_property, bool_property, ProxyList

# CLASSES #####################################################################


# pylint: disable=too-many-lines,arguments-differ


class MAUI(Oscilloscope):

    """"""
    Medium to high-end Teledyne-Lecroy Oscilloscopes are shipped with
    the MAUI user interface. This class can be used to communicate with
    these instruments.

    By default, the IEEE 488.2 commands are used. However, commands
    based on MAUI's `app` definition can be submitted too using the
    appropriate send / query commands.

    Your scope must be set up to communicate via LXI (VXI11) to be used
    with pyvisa. Make sure that either the pyvisa-py or the NI-VISA
    backend is installed. Please see the pyvisa documentation for more
    information.

    This class inherits from: `Oscilloscope`

    Example usage (more examples below):
        >>> import instruments as ik
        >>> import instruments.units as u
        >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
        >>> # start the trigger in automatic mode
        >>> inst.run()
        >>> print(inst.trigger_state)  # print the trigger state
        <TriggerState.auto: 'AUTO'>
        >>> # set timebase to 20 ns per division
        >>> inst.time_div = u.Quantity(20, u.ns)
        >>> # call the first oscilloscope channel
        >>> channel = inst.channel[0]
        >>> channel.trace = True  # turn the trace on
        >>> channel.coupling = channel.Coupling.dc50  # coupling to 50 Ohm
        >>> channel.scale = u.Quantity(1, u.V)  # vertical scale to 1V/division
        >>> # transfer a waveform into xdat and ydat:
        >>> xdat, ydat = channel.read_waveform()
    """"""

    # CONSTANTS #

    # number of horizontal and vertical divisions on the scope
    # HOR_DIVS = 10
    # VERT_DIVS = 8

    def __init__(self, filelike):
        super().__init__(filelike)

        # turn off command headers -> for SCPI like behavior
        self.sendcmd(""COMM_HEADER OFF"")

        # constants
        self._number_channels = 4
        self._number_functions = 2
        self._number_measurements = 6

    # ENUMS #

    class MeasurementParameters(Enum):
        """"""
        Enum containing valid measurement parameters that only require
        one or more sources. Only single source parameters are currently
        implemented.
        """"""

        amplitude = ""AMPL""
        area = ""AREA""
        base = ""BASE""
        delay = ""DLY""
        duty_cycle = ""DUTY""
        fall_time_80_20 = ""FALL82""
        fall_time_90_10 = ""FALL""
        frequency = ""FREQ""
        maximum = ""MAX""
        minimum = ""MIN""
        mean = ""MEAN""
        none = ""NULL""
        overshoot_pos = ""OVSP""
        overshoot_neg = ""OVSN""
        peak_to_peak = ""PKPK""
        period = ""PER""
        phase = ""PHASE""
        rise_time_20_80 = ""RISE28""
        rise_time_10_90 = ""RISE""
        rms = ""RMS""
        stdev = ""SDEV""
        top = ""TOP""
        width_50_pos = ""WID""
        width_50_neg = ""WIDN""

    class TriggerState(Enum):

        """"""
        Enum containing valid trigger state for the oscilloscope.
        """"""

        auto = ""AUTO""
        normal = ""NORM""
        single = ""SINGLE""
        stop = ""STOP""

    class TriggerType(Enum):
        """"""Enum containing valid trigger state.

        Availability depends on oscilloscope options. Please consult
        your manual. Only simple types are currently included.

        .. warning:: Some of the trigger types are untested and might
            need further parameters in order to be appropriately set.
        """"""

        dropout = ""DROPOUT""
        edge = ""EDGE""
        glitch = ""GLIT""
        interval = ""INTV""
        pattern = ""PA""
        runt = ""RUNT""
        slew_rate = ""SLEW""
        width = ""WIDTH""
        qualified = ""TEQ""
        tv = ""TV""

    class TriggerSource(Enum):
        """"""Enum containing valid trigger sources.

        This is an enum for the default values.

        .. note:: This class is initialized like this for four channels,
            which is the default setting. If you change the number of
            channels, `TriggerSource` will be recreated using the
            routine `_create_trigger_source_enum`. This will make
            further channels available to you or remove channels that
            are not present in your setup.
        """"""

        c0 = ""C1""
        c1 = ""C2""
        c2 = ""C3""
        c3 = ""C4""
        ext = ""EX""
        ext5 = ""EX5""
        ext10 = ""EX10""
        etm10 = ""ETM10""
        line = ""LINE""

    def _create_trigger_source_enum(self):
        """"""Create an Enum for the trigger source class.

        Needs to be dynamically generated, in case channel number
        changes!

        .. note:: Not all trigger sources are available on all scopes.
            Please consult the manual for your oscilloscope.
        """"""
        names = [""ext"", ""ext5"", ""ext10"", ""etm10"", ""line""]
        values = [""EX"", ""EX5"", ""EX10"", ""ETM10"", ""LINE""]
        # now add the channels
        for it in range(self._number_channels):
            names.append(f""c{it}"")
            values.append(f""C{it + 1}"")  # to send to scope
        # create and store the enum
        self.TriggerSource = Enum(""TriggerSource"", zip(names, values))

    # CLASSES #

    class DataSource(Oscilloscope.DataSource):

        """"""
        Class representing a data source (channel, math, ref) on a MAUI
        oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        # PROPERTIES #

        @property
        def name(self):
            return self._name

        # METHODS #

        def read_waveform(self, bin_format=False, single=True):
            """"""
            Reads the waveform and returns an array of floats with the
            data.

            :param bin_format: Not implemented, always False
            :type bin_format: bool
            :param single: Run a single trigger? Default True. In case
                a waveform from a channel is required, this option
                is recommended to be set to True. This means that the
                acquisition system is first stopped, a single trigger
                is issued, then the waveform is transfered, and the
                system is set back into the state it was in before.
                If sampling math with multiple samples, set this to
                false, otherwise the sweeps are cleared by the
                oscilloscope prior when a single trigger command is
                issued.
            :type single: bool

            :return: Data (time, signal) where time is in seconds and
                signal in V
            :rtype: `tuple`[`tuple`[`~pint.Quantity`, ...], `tuple`[`~pint.Quantity`, ...]]
                or if numpy is installed, `tuple`[`numpy.array`, `numpy.array`]

            :raises NotImplementedError: Bin format was chosen, but
                it is not implemented.

            Example usage:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> xdat, ydat = channel.read_waveform()  # read waveform
            """"""
            if bin_format:
                raise NotImplementedError(
                    ""Bin format reading is currently ""
                    ""not implemented for the MAUI ""
                    ""routine.""
                )

            if single:
                # get current trigger state (to reset after read)
                trig_state = self._parent.trigger_state
                # trigger state to single
                self._parent.trigger_state = self._parent.TriggerState.single

            # now read the data
            retval = self.query(""INSPECT? 'SIMPLE'"")  # pylint: disable=E1101

            # read the parameters to create time-base array
            horiz_off = self.query(""INSPECT? 'HORIZ_OFFSET'"")  # pylint: disable=E1101
            horiz_int = self.query(""INSPECT? 'HORIZ_INTERVAL'"")  # pylint: disable=E1101

            if single:
                # reset trigger
                self._parent.trigger_state = trig_state

            # format the string to appropriate data
            retval = retval.replace('""', """").split()
            if numpy:
                dat_val = numpy.array(retval, dtype=float)  # Convert to ndarray
            else:
                dat_val = tuple(map(float, retval))

            # format horizontal data into floats
            horiz_off = float(horiz_off.replace('""', """").split("":"")[1])
            horiz_int = float(horiz_int.replace('""', """").split("":"")[1])

            # create time base
            if numpy:
                dat_time = numpy.arange(
                    horiz_off, horiz_off + horiz_int * (len(dat_val)), horiz_int
                )
            else:
                dat_time = tuple(
                    val * horiz_int + horiz_off for val in range(len(dat_val))
                )

            # fix length bug, sometimes dat_time is longer than dat_signal
            if len(dat_time) > len(dat_val):
                dat_time = dat_time[0 : len(dat_val)]
            else:  # in case the opposite is the case
                dat_val = dat_val[0 : len(dat_time)]

            if numpy:
                return numpy.stack((dat_time, dat_val))
            else:
                return dat_time, dat_val

        trace = bool_property(
            command=""TRA"",
            doc=""""""
            Gets/Sets if a given trace is turned on or off.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.trace = False
            """""",
        )

    class Channel(DataSource, Oscilloscope.Channel):

        """"""
        Class representing a channel on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""C{self._idx}"")

        # ENUMS #

        class Coupling(Enum):
            """"""
            Enum containing valid coupling modes for the oscilloscope
            channel. 1 MOhm and 50 Ohm are included.
            """"""

            ac1M = ""A1M""
            dc1M = ""D1M""
            dc50 = ""D50""
            ground = ""GND""

        coupling = enum_property(
            ""CPL"",
            Coupling,
            doc=""""""
            Gets/sets the coupling for the specified channel.

            Example usage:

            >>> import instruments as ik
            >>> address = ""TCPIP0::192.168.0.10::INSTR""
            >>> inst = inst = ik.teledyne.MAUI.open_visa(address)
            >>> channel = inst.channel[0]
            >>> channel.coupling = channel.Coupling.dc50
            """""",
        )

        # PROPERTIES #

        @property
        def offset(self):
            """"""
            Sets/gets the vertical offset of the specified input
            channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.offset = u.Quantity(-1, u.V)
            """"""
            return u.Quantity(float(self.query(""OFST?"")), u.V)

        @offset.setter
        def offset(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""OFST {newval}"")

        @property
        def scale(self):
            """"""
            Sets/Gets the vertical scale of the channel.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> channel.scale = u.Quantity(20, u.mV)
            """"""
            return u.Quantity(float(self.query(""VDIV?"")), u.V)

        @scale.setter
        def scale(self, newval):
            newval = assume_units(newval, ""V"").to(u.V).magnitude
            self.sendcmd(f""VDIV {newval}"")

        # METHODS #

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""C{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""C{self._idx}:{cmd}"", size=size)

    class Math(DataSource):

        """"""
        Class representing a function on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

            # Initialize as a data source with name C{}.
            super().__init__(self._parent, f""F{self._idx}"")

        # CLASSES #

        class Operators:
            """"""
            Sets the operator for a given channel.
            Most operators need a source `src`. If the source is given
            as an integer, it is assume that the a signal channel is
            requested. If you want to select another math channel for
            example, you will need to specify the source as a tuple:
            Example: `src=('f', 0)` would represent the first function
            channel (called F1 in the MAUI manual). A channel could be
            selected by calling `src=('c', 1)`, which would request the
            second channel (oscilloscope channel 2). Please consult the
            oscilloscope manual / the math setup itself for further
            possibilities.

            .. note:: Your oscilloscope might not have all functions
            that are described here. Also: Not all possibilities are
            currently implemented. However, extension of this
            functionality should be simple when following the given
            structure
            """"""

            def __init__(self, parent):
                self._parent = parent

            # PROPERTIES #

            @property
            def current_setting(self):
                """"""
                Gets the current setting and returns it as the full
                command, as sent to the scope when setting an operator.
                """"""
                return self._parent.query(""DEF?"")

            # METHODS - OPERATORS #

            def absolute(self, src):
                """"""
                Absolute of wave form.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                send_str = f""'ABS({src_str})'""
                self._send_operator(send_str)

            def average(self, src, average_type=""summed"", sweeps=1000):
                """"""
                Average of wave form.

                :param int,tuple src: Source, see info above
                :param str average_type: `summed` or `continuous`
                :param int sweeps: In summed mode, how many sweeps to
                    collect. In `continuous` mode the weight of each
                    sweep is equal to 1/`1`sweeps`
                """"""
                src_str = _source(src)

                avgtp_str = ""SUMMED""
                if average_type == ""continuous"":
                    avgtp_str = ""CONTINUOUS""

                send_str = ""'AVG({})',AVERAGETYPE,{},SWEEPS,{}"".format(
                    src_str, avgtp_str, sweeps
                )

                self._send_operator(send_str)

            def derivative(self, src, vscale=1e6, voffset=0, autoscale=True):
                """"""
                Derivative of waveform using subtraction of adjacent
                samples. If vscale and voffset are unitless, V/s are
                assumed.

                :param int,tuple src: Source, see info above
                :param float vscale: vertical units to display (V/s)
                :param float voffset: vertical offset (V/s)
                :param bool autoscale: auto scaling of vscale, voffset?
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V / u.s).to(u.V / u.s).magnitude

                voffset = assume_units(voffset, u.V / u.s).to(u.V / u.s).magnitude

                autoscale_str = ""OFF""
                if autoscale:
                    autoscale_str = ""ON""

                send_str = (
                    ""'DERI({})',VERSCALE,{},VEROFFSET,{},""
                    ""ENABLEAUTOSCALE,{}"".format(src_str, vscale, voffset, autoscale_str)
                )

                self._send_operator(send_str)

            def difference(self, src1, src2, vscale_variable=False):
                """"""
                Difference between two sources, `src1`-`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                :param bool vscale_variable: Horizontal and vertical
                    scale for addition and subtraction must be
                    identical. Allow for variable vertical scale in
                    result?
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                opt_str = ""FALSE""
                if vscale_variable:
                    opt_str = ""TRUE""

                send_str = ""'{}-{}',VERSCALEVARIABLE,{}"".format(
                    src1_str, src2_str, opt_str
                )

                self._send_operator(send_str)

            def envelope(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest and lowest Y values at each X in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'EXTR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def eres(self, src, bits=0.5):
                """"""
                Smoothing function defined by extra bits of resolution.

                :param int,tuple src: Source, see info above
                :param float bits: Number of bits. Possible values are
                    (0.5, 1.0, 1.5, 2.0, 2.5, 3.0). If not in list,
                    default to 0.5.
                """"""
                src_str = _source(src)

                bits_possible = (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
                if bits not in bits_possible:
                    bits = 0.5

                send_str = f""'ERES({src_str})',BITS,{bits}""

                self._send_operator(send_str)

            def fft(
                self, src, type=""powerspectrum"", window=""vonhann"", suppress_dc=True
            ):
                """"""
                Fast Fourier Transform of signal.

                :param int,tuple src: Source, see info above
                :param str type: Type of power spectrum. Possible
                    options are: ['real', 'imaginary', 'magnitude',
                    'phase', 'powerspectrum', 'powerdensity'].
                    Default: 'powerspectrum'
                :param str window: Window. Possible options are:
                    ['blackmanharris', 'flattop', 'hamming',
                    'rectangular', 'vonhann']. Default: 'vonhann'
                :param bool suppress_dc: Supress DC?
                """"""
                src_str = _source(src)

                type_possible = [
                    ""real"",
                    ""imaginary"",
                    ""magnitude"",
                    ""phase"",
                    ""powerspectrum"",
                    ""powerdensity"",
                ]
                if type not in type_possible:
                    type = ""powerspectrum""

                window_possible = [
                    ""blackmanharris"",
                    ""flattop"",
                    ""hamming"",
                    ""rectangular"",
                    ""vonhann"",
                ]
                if window not in window_possible:
                    window = ""vonhann""

                if suppress_dc:
                    opt = ""ON""
                else:
                    opt = ""OFF""

                send_str = ""'FFT({})',TYPE,{},WINDOW,{},SUPPRESSDC,{}"".format(
                    src_str, type, window, opt
                )

                self._send_operator(send_str)

            def floor(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Lowest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'FLOOR({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def integral(self, src, multiplier=1, adder=0, vscale=1e-3, voffset=0):
                """"""
                Integral of waveform.

                :param int,tuple src: Source, see info above
                :param float multiplier: 0 to 1e15
                :param float adder: 0 to 1e15
                :param float vscale: vertical units to display (Wb)
                :param float voffset: vertical offset (Wb)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.Wb).to(u.Wb).magnitude

                voffset = assume_units(voffset, u.Wb).to(u.Wb).magnitude

                send_str = (
                    ""'INTG({}),MULTIPLIER,{},ADDER,{},VERSCALE,{},""
                    ""VEROFFSET,{}"".format(src_str, multiplier, adder, vscale, voffset)
                )

                self._send_operator(send_str)

            def invert(self, src):
                """"""
                Inversion of waveform (-waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'-{src_str}'"")

            def product(self, src1, src2):
                """"""
                Product of two sources, `src1`*`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}*{src2_str}'""

                self._send_operator(send_str)

            def ratio(self, src1, src2):
                """"""
                Ratio of two sources, `src1`/`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}/{src2_str}'""

                self._send_operator(send_str)

            def reciprocal(self, src):
                """"""
                Reciprocal of waveform (1/waveform).

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'1/{src_str}'"")

            def rescale(self, src, multiplier=1, adder=0):
                """"""
                Rescales the waveform (w) in the style.
                multiplier * w + adder

                :param int,tuple src: Source, see info above
                :param float multiplier: multiplier
                :param float adder: addition in V or assuming V
                """"""
                src_str = _source(src)

                adder = assume_units(adder, u.V).to(u.V).magnitude

                send_str = ""'RESC({})',MULTIPLIER,{},ADDER,{}"".format(
                    src_str, multiplier, adder
                )

                self._send_operator(send_str)

            def sinx(self, src):
                """"""
                Sin(x)/x interpolation to produce 10x output samples.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SINX({src_str})'"")

            def square(self, src):
                """"""
                Square of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQR({src_str})'"")

            def square_root(self, src):
                """"""
                Square root of the input waveform.

                :param int,tuple src: Source, see info above
                """"""
                src_str = _source(src)
                self._send_operator(f""'SQRT({src_str})'"")

            def sum(self, src1, src2):
                """"""
                Product of two sources, `src1`+`src2`.

                :param int,tuple src1: Source 1, see info above
                :param int,tuple src2: Source 2, see info above
                """"""
                src1_str = _source(src1)
                src2_str = _source(src2)

                send_str = f""'{src1_str}+{src2_str}'""

                self._send_operator(send_str)

            def trend(self, src, vscale=1, center=0, autoscale=True):
                """"""
                Trend of the values of a paramter

                :param float vscale: vertical units to display (V)
                :param float center: center (V)
                """"""
                src_str = _source(src)

                vscale = assume_units(vscale, u.V).to(u.V).magnitude

                center = assume_units(center, u.V).to(u.V).magnitude

                if autoscale:
                    auto_str = ""ON""
                else:
                    auto_str = ""OFF""

                send_str = (
                    ""'TREND({})',VERSCALE,{},CENTER,{},""
                    ""AUTOFINDSCALE,{}"".format(src_str, vscale, center, auto_str)
                )

                self._send_operator(send_str)

            def roof(self, src, sweeps=1000, limit_sweeps=True):
                """"""
                Highest vertical value at each X value in N sweeps.

                :param int,tuple src: Source, see info above
                :param int sweeps: Number of sweeps
                :param bool limit_sweeps: Limit the number of sweeps?
                """"""
                src_str = _source(src)
                send_str = ""'ROOF({})',SWEEPS,{},LIMITNUMSWEEPS,{}"".format(
                    src_str, sweeps, limit_sweeps
                )
                self._send_operator(send_str)

            def _send_operator(self, cmd):
                """"""
                Set the operator in the scope.
                """"""
                self._parent.sendcmd(""{},{}"".format(""DEFINE EQN"", cmd))

        # PROPERTIES #

        @property
        def operator(self):
            """"""Get an operator object to set use to do math.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> channel = inst.channel[0]  # set up channel
                >>> # set up the first math function
                >>> function = inst.math[0]
                >>> function.trace = True  # turn the trace on
                >>> # set function to average the first oscilloscope channel
                >>> function.operator.average(0)
            """"""
            return self.Operators(self)

        # METHODS #

        def clear_sweeps(self):
            """"""Clear the sweeps in a measurement.""""""
            self._parent.clear_sweeps()  # re-implemented because handy

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(f""F{self._idx}:{cmd}"")

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(f""F{self._idx}:{cmd}"", size=size)

    class Measurement:

        """"""
        Class representing a measurement on a MAUI oscilloscope.

        .. warning:: This class should NOT be manually created by the
            user. It is designed to be initialized by the `MAUI` class.
        """"""

        def __init__(self, parent, idx):
            self._parent = parent
            self._idx = idx + 1  # 1-based

        # CLASSES #

        class State(Enum):
            """"""
            Enum class for Measurement Parameters. Required to turn it
            on or off.
            """"""

            statistics = ""CUST,STAT""
            histogram_icon = ""CUST,HISTICON""
            both = ""CUST,BOTH""
            off = ""CUST,OFF""

        # PROPERTIES #

        measurement_state = enum_property(
            command=""PARM"",
            enum=State,
            doc=""""""
                Sets / Gets the measurement state. Valid values are
                'statistics', 'histogram_icon', 'both', 'off'.

                Example:
                    >>> import instruments as ik
                    >>> import instruments.units as u
                    >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                    >>> msr1 = inst.measurement[0]  # set up first measurement
                    >>> msr1.measurement_state = msr1.State.both  # set to `both`
                """""",
        )

        @property
        def statistics(self):
            """"""
            Gets the statistics for the selected parameter. The scope
            must be in `My_Measure` mode.

            :return tuple: (average, low, high, sigma, sweeps)
            :return type: (float, float, float, float, float)
            """"""
            ret_str = self.query(f""PAST? CUST, P{self._idx}"").rstrip().split("","")
            # parse the return string -> put into dictionary:
            ret_dict = {
                ret_str[it]: ret_str[it + 1] for it in range(0, len(ret_str), 2)
            }
            try:
                stats = (
                    float(ret_dict[""AVG""]),
                    float(ret_dict[""LOW""]),
                    float(ret_dict[""HIGH""]),
                    float(ret_dict[""SIGMA""]),
                    float(ret_dict[""SWEEPS""]),
                )
            except ValueError:  # some statistics did not return
                raise ValueError(
                    ""Some statistics did not return useful ""
                    ""values. The return string is {}. Please ""
                    ""ensure that statistics is properly turned ""
                    ""on."".format(ret_str)
                )
            return stats

        # METHODS #

        def delete(self):
            """"""
            Deletes the given measurement parameter.
            """"""
            self.sendcmd(f""PADL {self._idx}"")

        def set_parameter(self, param, src):
            """"""
            Sets a given parameter that should be measured on this
            given channel.

            :param `inst.MeasurementParameters` param: The parameter
                to set from the given enum list.
            :param int,tuple src: Source, either as an integer if a
                channel is requested (e.g., src=0 for Channel 1) or as
                a tuple in the form, e.g., ('F', 1). Here 'F' refers
                to a mathematical function and 1 would take the second
                mathematical function `F2`.

            :raises AttributeError: The chosen parameter is invalid.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> msr1 = inst.measurement[0]  # set up first measurement
                >>> # setup to measure the 10 - 90% rise time on first channel
                >>> msr1.set_parameter(inst.MeasurementParameters.rise_time_10_90, 0)
            """"""
            if not isinstance(param, self._parent.MeasurementParameters):
                raise AttributeError(
                    ""Parameter must be selected from {}."".format(
                        self._parent.MeasurementParameters
                    )
                )

            send_str = f""PACU {self._idx},{param.value},{_source(src)}""

            self.sendcmd(send_str)

        def sendcmd(self, cmd):
            """"""
            Wraps commands sent from property factories in this class
            with identifiers for the specified channel.

            :param str cmd: Command to send to the instrument
            """"""
            self._parent.sendcmd(cmd)

        def query(self, cmd, size=-1):
            """"""
            Executes the given query. Wraps commands sent from property
            factories in this class with identifiers for the specified
            channel.

            :param str cmd: String containing the query to
                execute.
            :param int size: Number of bytes to be read. Default is read
                until termination character is found.
            :return: The result of the query as returned by the
                connected instrument.
            :rtype: `str`
            """"""
            return self._parent.query(cmd, size=size)

    # PROPERTIES #

    @property
    def channel(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        channel objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> channel = inst.channel[0]  # get first channel
        """"""
        return ProxyList(self, self.Channel, range(self.number_channels))

    @property
    def math(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        math data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> math = inst.math[0]  # get first math function
        """"""
        return ProxyList(self, self.Math, range(self.number_functions))

    @property
    def measurement(self):
        """"""
        Gets an iterator or list for easy Pythonic access to the various
        measurement data sources objects on the oscilloscope instrument.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> msr = inst.measurement[0]  # get first measurement parameter
        """"""
        return ProxyList(self, self.Measurement, range(self.number_measurements))

    @property
    def ref(self):
        raise NotImplementedError

    # PROPERTIES

    @property
    def number_channels(self):
        """"""
        Sets/Gets the number of channels available on the specific
        oscilloscope. Defaults to 4.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_channel = 2  # for a oscilloscope with 2 channels
            >>> inst.number_channel
            2
        """"""
        return self._number_channels

    @number_channels.setter
    def number_channels(self, newval):
        self._number_channels = newval
        # create new trigger source enum
        self._create_trigger_source_enum()

    @property
    def number_functions(self):
        """"""
        Sets/Gets the number of functions available on the specific
        oscilloscope. Defaults to 2.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_functions = 4  # for a oscilloscope with 4 math functions
            >>> inst.number_functions
            4
        """"""
        return self._number_functions

    @number_functions.setter
    def number_functions(self, newval):
        self._number_functions = newval

    @property
    def number_measurements(self):
        """"""
        Sets/Gets the number of measurements available on the specific
        oscilloscope. Defaults to 6.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.number_measurements = 4  # for a oscilloscope with 4 measurements
            >>> inst.number_measurements
            4
        """"""
        return self._number_measurements

    @number_measurements.setter
    def number_measurements(self, newval):
        self._number_measurements = newval

    @property
    def self_test(self):
        """"""
        Runs an oscilloscope's internal self test and returns the
        result. The self-test includes testing the hardware of all
        channels, the timebase and the trigger circuits.
        Hardware failures are identified by a unique binary code in the
        returned <status> number. A status of 0 indicates that no
        failures occurred.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.self_test()
        """"""
        # increase timeout x 10 to allow for enough time to test
        self.timeout *= 10
        retval = self.query(""*TST?"")
        self.timeout /= 10
        return retval

    @property
    def show_id(self):
        """"""
        Gets the scope information and returns it. The response
        comprises manufacturer, oscilloscope model, serial number,
        and firmware revision level.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_id()
        """"""
        return self.query(""*IDN?"")

    @property
    def show_options(self):
        """"""
        Gets and returns oscilloscope options: installed software or
        hardware that is additional to the standard instrument
        configuration. The response consists of a series of response
        fields listing all the installed options.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.show_options()
        """"""
        return self.query(""*OPT?"")

    @property
    def time_div(self):
        """"""
        Sets/Gets the time per division, modifies the timebase setting.
        Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.time_div = u.Quantity(200, u.ns)
        """"""
        return u.Quantity(float(self.query(""TDIV?"")), u.s)

    @time_div.setter
    def time_div(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TDIV {newval}"")

    # TRIGGER PROPERTIES

    trigger_state = enum_property(
        command=""TRMD"",
        enum=TriggerState,
        doc=""""""
            Sets / Gets the trigger state. Valid values are are defined
            in `TriggerState` enum class.

            Example:
                >>> import instruments as ik
                >>> import instruments.units as u
                >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
                >>> inst.trigger_state = inst.TriggerState.normal
            """""",
    )

    @property
    def trigger_delay(self):
        """"""
        Sets/Gets the trigger offset with respect to time zero (i.e.,
        a horizontal shift). Unitful.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_delay = u.Quantity(60, u.ns)

        """"""
        return u.Quantity(float(self.query(""TRDL?"")), u.s)

    @trigger_delay.setter
    def trigger_delay(self, newval):
        newval = assume_units(newval, ""s"").to(u.s).magnitude
        self.sendcmd(f""TRDL {newval}"")

    @property
    def trigger_source(self):
        """"""Sets / Gets the trigger source.

        .. note:: The `TriggerSource` class is dynamically generated
        when the number of channels is switched. The above shown class
        is only the default! Channels are added and removed, as
        required.

        .. warning:: If a trigger type is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger source.
        :rtype: Member of `TriggerSource` class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_source = inst.TriggerSource.ext  # external trigger
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[2]
        return self.TriggerSource(retval)

    @trigger_source.setter
    def trigger_source(self, newval):
        curr_trig_typ = self.trigger_type
        cmd = f""TRIG_SELECT {curr_trig_typ.value},SR,{newval.value}""
        self.sendcmd(cmd)

    @property
    def trigger_type(self):
        """"""Sets / Gets the trigger type.

        .. warning:: If a trigger source is currently set on the
            oscilloscope that is not implemented in this class,
            setting the source will fail. The oscilloscope is set up
            such that the the trigger type and source are set at the
            same time. However, for convenience, these two properties
            are split apart here.

        :return: Trigger type.
        :rtype: Member of `TriggerType` enum class.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.trigger_type = inst.TriggerType.edge  # trigger on edge
        """"""
        retval = self.query(""TRIG_SELECT?"").split("","")[0]
        return self.TriggerType(retval)

    @trigger_type.setter
    def trigger_type(self, newval):
        curr_trig_src = self.trigger_source
        cmd = f""TRIG_SELECT {newval.value},SR,{curr_trig_src.value}""
        self.sendcmd(cmd)

    # METHODS #

    def clear_sweeps(self):
        """"""Clears the sweeps in a measurement.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.clear_sweeps()
        """"""
        self.sendcmd(""CLEAR_SWEEPS"")

    def force_trigger(self):
        """"""Forces a trigger event to occur on the attached oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.force_trigger()
        """"""
        self.sendcmd(""ARM"")

    def run(self):
        """"""Enables the trigger for the oscilloscope and sets it to auto.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.run()
        """"""
        self.trigger_state = self.TriggerState.auto

    def stop(self):
        """"""Disables the trigger for the oscilloscope.

        Example:
            >>> import instruments as ik
            >>> import instruments.units as u
            >>> inst = ik.teledyne.MAUI.open_visa(""TCPIP0::192.168.0.10::INSTR"")
            >>> inst.stop()
        """"""
        self.sendcmd(""STOP"")


# STATICS #


def _source(src):
    """"""Stich the source together properly and return it.""""""
    if isinstance(src, int):
        return f""C{src + 1}""
    elif isinstance(src, tuple) and len(src) == 2:
        return f""{src[0].upper()}{int(src[1]) + 1}""
    else:
        raise ValueError(
            ""An invalid source was specified. ""
            ""Source must be an integer or a tuple of ""
            ""length 2.""
        )


"
408,,,,Phasematrix FSW 0020,415.0,,Instrumentkit,Phasematrix,,,Write a Python script that uses Instrumentkit to connect to a FSW - 0200 ,,,,FSW - 0200,,,,,,,,,,
409,5800.0,USA,,Tektds 5 XX,551.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS500 Series,,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
416,5420.0,USA,3456A 6 1/2 Digit Digital Multimeter,HP 3456 A,149.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Instrumentkit,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Instrumentkit to connect to a Keysight 3456A Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Keysight 3456A,Not Available,"[OrderedDict([('id', 'att0ooJCGULf7i5fN'), ('width', 900), ('height', 288), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_K93Pc1njDu0SpP-qr6u0Q/8cM8pRpcQ4cvjh3vZKysMn2R3DZzVjnZjUnrytqLPUZagiTHzsunDUnEtsY5hDd9-ATuoMISOpsnUZ82JX04N6rR7qRNRlOORieOO-OHwHM/6HiN0_sq8gkVlKMpgSAqgd5arpQVkRK_0VqqKkKLLIo'), ('filename', 'face_1.jpg'), ('size', 64705), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hozcfdkYO6RG2r4vVpyTeg/268IGG2qNhUwydsLmmA62G6Amkex-J00gWj67dFSu4tuYT-1K2yXtRSeeIrqCHEC6W_-_dyvhpncMFxozU-0TA/ymMd9l-qX0x_TeVzXXGacHTBDlwdzlzxqJU5o20fEm8'), ('width', 113), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PQCqna3qwWyF4YAguGqAwQ/I2065yZ-LNQdZLKM5YC3vDD2oJYHByvfD7JBSIrYcDfsvYzTUCHLQKbnzui6L49s7OukuFdI6oAco6oYuH1vag/KDgtd4sXYQyfcBssl6NS7hHEQO8GH6u8-IFz8OiMzJM'), ('width', 900), ('height', 288)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wsgK7llLMICZJuF_qT100A/QjfWfWh7hZLgiYHCC9JJAZlIwwHMw6DNl5el1OTknBvwt8y0Ozu2pCyRO1noetipIeiwNlwRdhcFMDPWEbZNQQ/q6uxaq9Er1PJwgLmWu6NgewpussAQWbnez72PXYJc_k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/3456A/6-12-digit-digital-multimeter.html,https://github.com/coburnw/hp3456-ivi/blob/master/contrib/agilent3456A.py,,,,True,,
421,5800.0,USA,,Tektds 5 XX,551.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a TDS500 Series Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS500 Series,,,,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tektds5xx.py,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tektds5xx-oscilloscope,,,True,,"

Source code for instruments.tektronix.tekawg2000
#!/usr/bin/env python
""""""
Provides support for the Tektronix AWG2000 series arbitrary wave generators.
""""""

# IMPORTS #####################################################################

from enum import Enum

from instruments.generic_scpi import SCPIInstrument
from instruments.optional_dep_finder import numpy
from instruments.units import ureg as u
from instruments.util_fns import assume_units, ProxyList

# CLASSES #####################################################################


class TekAWG2000(SCPIInstrument):

    """"""
    Communicates with a Tektronix AWG2000 series instrument using the SCPI
    commands documented in the user's guide.
    """"""

    # INNER CLASSES #

    class Channel:

        """"""
        Class representing a physical channel on the Tektronix AWG 2000

        .. warning:: This class should NOT be manually created by the user. It
        is designed to be initialized by the `TekAWG2000` class.
        """"""

        def __init__(self, tek, idx):
            self._tek = tek
            # Zero-based for pythonic convienence, so we need to convert to
            # Tektronix's one-based notation here.
            self._name = f""CH{idx + 1}""

            # Remember what the old data source was for use as a context manager
            self._old_dsrc = None

        # PROPERTIES #

        @property
        def name(self):
            """"""
            Gets the name of this AWG channel

            :type: `str`
            """"""
            return self._name

        @property
        def amplitude(self):
            """"""
            Gets/sets the amplitude of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts peak-to-peak.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:AMPL?"").strip()), u.V
            )

        @amplitude.setter
        def amplitude(self, newval):
            self._tek.sendcmd(
                ""FG:{}:AMPL {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def offset(self):
            """"""
            Gets/sets the offset of the specified channel.

            :units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Volts.
            :type: `~pint.Quantity` with units Volts.
            """"""
            return u.Quantity(
                float(self._tek.query(f""FG:{self._name}:OFFS?"").strip()), u.V
            )

        @offset.setter
        def offset(self, newval):
            self._tek.sendcmd(
                ""FG:{}:OFFS {}"".format(
                    self._name, assume_units(newval, u.V).to(u.V).magnitude
                )
            )

        @property
        def frequency(self):
            """"""
            Gets/sets the frequency of the specified channel when using the built-in
            function generator.

            ::units: As specified (if a `~pint.Quantity`) or assumed to be
                of units Hertz.
            :type: `~pint.Quantity` with units Hertz.
            """"""
            return u.Quantity(float(self._tek.query(""FG:FREQ?"").strip()), u.Hz)

        @frequency.setter
        def frequency(self, newval):
            self._tek.sendcmd(
                f""FG:FREQ {assume_units(newval, u.Hz).to(u.Hz).magnitude}HZ""
            )

        @property
        def polarity(self):
            """"""
            Gets/sets the polarity of the specified channel.

            :type: `TekAWG2000.Polarity`
            """"""
            return TekAWG2000.Polarity(self._tek.query(f""FG:{self._name}:POL?"").strip())

        @polarity.setter
        def polarity(self, newval):
            if not isinstance(newval, TekAWG2000.Polarity):
                raise TypeError(
                    ""Polarity settings must be a ""
                    ""`TekAWG2000.Polarity` value, got {} ""
                    ""instead."".format(type(newval))
                )

            self._tek.sendcmd(f""FG:{self._name}:POL {newval.value}"")

        @property
        def shape(self):
            """"""
            Gets/sets the waveform shape of the specified channel. The AWG will
            use the internal function generator for these shapes.

            :type: `TekAWG2000.Shape`
            """"""
            return TekAWG2000.Shape(
                self._tek.query(f""FG:{self._name}:SHAP?"").strip().split("","")[0]
            )

        @shape.setter
        def shape(self, newval):
            if not isinstance(newval, TekAWG2000.Shape):
                raise TypeError(
                    ""Shape settings must be a `TekAWG2000.Shape` ""
                    ""value, got {} instead."".format(type(newval))
                )
            self._tek.sendcmd(f""FG:{self._name}:SHAP {newval.value}"")

    # ENUMS #

    class Polarity(Enum):
        """"""
        Enum containing valid polarity modes for the AWG2000
        """"""

        normal = ""NORMAL""
        inverted = ""INVERTED""

    class Shape(Enum):
        """"""
        Enum containing valid waveform shape modes for hte AWG2000
        """"""

        sine = ""SINUSOID""
        pulse = ""PULSE""
        ramp = ""RAMP""
        square = ""SQUARE""
        triangle = ""TRIANGLE""

    # Properties #

    @property
    def waveform_name(self):
        """"""
        Gets/sets the destination waveform name for upload.

        This is the file name that will be used on the AWG for any following
        waveform data that is uploaded.

        :type: `str`
        """"""
        return self.query(""DATA:DEST?"").strip()

    @waveform_name.setter
    def waveform_name(self, newval):
        if not isinstance(newval, str):
            raise TypeError(""Waveform name must be specified as a string."")
        self.sendcmd(f'DATA:DEST ""{newval}""')

    @property
    def channel(self):
        """"""
        Gets a specific channel on the AWG2000. The desired channel is accessed
        like one would access a list.

        Example usage:

        >>> import instruments as ik
        >>> inst = ik.tektronix.TekAWG2000.open_gpibusb(""/dev/ttyUSB0"", 1)
        >>> print(inst.channel[0].frequency)

        :return: A channel object for the AWG2000
        :rtype: `TekAWG2000.Channel`
        """"""
        return ProxyList(self, self.Channel, range(2))

    # METHODS #

    def upload_waveform(self, yzero, ymult, xincr, waveform):
        """"""
        Uploads a waveform from the PC to the instrument.

        :param yzero: Y-axis origin offset
        :type yzero: `float` or `int`

        :param ymult: Y-axis data point multiplier
        :type ymult: `float` or `int`

        :param xincr: X-axis data point increment
        :type xincr: `float` or `int`

        :param `numpy.ndarray` waveform: Numpy array of values representing the
            waveform to be uploaded. This array should be normalized. This means
            that all absolute values contained within the array should not
            exceed 1.
        """"""
        if numpy is None:
            raise ImportError(
                ""Missing optional dependency numpy, which is required""
                ""for uploading waveforms.""
            )

        if not isinstance(yzero, float) and not isinstance(yzero, int):
            raise TypeError(""yzero must be specified as a float or int"")

        if not isinstance(ymult, float) and not isinstance(ymult, int):
            raise TypeError(""ymult must be specified as a float or int"")

        if not isinstance(xincr, float) and not isinstance(xincr, int):
            raise TypeError(""xincr must be specified as a float or int"")

        if not isinstance(waveform, numpy.ndarray):
            raise TypeError(""waveform must be specified as a numpy array"")

        if numpy.max(numpy.abs(waveform)) > 1:
            raise ValueError(""The max value for an element in waveform is 1."")

        self.sendcmd(f""WFMP:YZERO {yzero}"")
        self.sendcmd(f""WFMP:YMULT {ymult}"")
        self.sendcmd(f""WFMP:XINCR {xincr}"")

        waveform *= 2**12 - 1
        waveform = waveform.astype(""<u2"").tobytes()
        wfm_header_2 = str(len(waveform))
        wfm_header_1 = len(wfm_header_2)

        bin_str = f""#{wfm_header_1}{wfm_header_2}{waveform}""

        self.sendcmd(f""CURVE {bin_str}"")


"
428,5800.0,USA,"The DPO4104 Digital Phosphor Oscilloscope delivers the performance you need to visualize even your most demanding signals. With a 1 GHz Bandwidth and offering a minimum of 5x oversampling on all channels and si (x)/x interpolation standard, you can be confident that even the fastest transient events will be captured and displayed accurately. The standard 10 M record length on all channels enables you to capture long windows of signal activity while maintaining fine timing resolution.",Tekdpo 4104,549.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Instrumentkit,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Instrumentkit to connect to a DPO4104 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",DPO4104,https://download.tek.com/datasheet/DPO4000-Digital-Phosphor-Oscilloscope-Datasheet-48W1903210.pdf,"[OrderedDict([('id', 'attZKmurDfbgmKnMC'), ('width', 620), ('height', 413), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LWpQLgjV5_jG1Kv7VWnJJw/XdPVWZtYQgPAtuq_VOu9r7g-t6EnKjIT1EE-2HMzuVO7I2Al6l7tT13-24jrGnCLLOB_B_0n2wg4JQ8fCOIP4EtlXu439vBPBBvyP0Rawz_U9AHZe6eyVhHPuEiA5UUC/r_jrk6fqlXYoJNI87iWU1NGjwNF2Z48W9rdC0SbigFc'), ('filename', 'Tektronix_MSO_DPO4000.jpg'), ('size', 63004), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fRSZNG2Ulrg0x8b6DTRVRg/PfIbmrIjSopLpQV-TQ0aK_C3MX0nI_aRdTpfdsHFMHh_oL2o2WoOF4RWpH25mwGHZqTjUAUBxOCYrUtUJOz6ww/JmWw8dAcLsVuC7jrnukS6KzdD6wZvX-uDX6y3Y7d5nQ'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/40B8DOcIPdtCkVD6OHryTA/umy6lL1Aeouk1GZvmH0h_Ks7FrnsH_gDpWVl7QXQpnNU9bGCrWRuyTbHPkAAzpigganS0GG1V2dxWcyGan2Xcg/luktjF1lXf5e9kO-rex52ItbJWhr5CrWIVuifpVxjOw'), ('width', 620), ('height', 413)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CT5LpID7aFBYvm1Wh4WC0w/Sk0ovPXOwC3iCduBmtsYdw7seiCS8buj-TeWhIEnt1YEnpHBLpPqp4U9pV9_EQlpiaY2QRnyWYPwxTWNi7ja6Q/UUogT0DB0EWPdlTS-vJgM5btyse0CpfwoJh1r0n5-BA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.valuetronics.com/product/dpo4104-tektronix-digital-oscilloscope-used,https://instrumentkit.readthedocs.io/en/latest/apiref/tektronix.html#tekdpo4104-oscilloscope,https://github.com/instrumentkit/InstrumentKit/blob/main/src/instruments/tektronix/tekdpo4104.py,7995.0,,True,,
