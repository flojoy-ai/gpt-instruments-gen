,Field 1,Vendor,Device,Library,Device Description,Python docs link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Corrected device name,Device picture,Device Description Link,Device Category,Vendor logo,Vendor wikipedia or cruncbase description,Vendor website,Device datasheet (PDF),Vendor headquarters,"Yearly revenue (millions, USD)",Category Description,Category description link,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,Notes,docstring
15,,PCO,PCO,Instrumental,"The pco.pixelfly™ 1.3 SWIR is a high-performance machine vision camera due to its special InGaAs image sensor which is sensitive in the shortwave infrared, near infrared and visible range of the electromagnetic spectrum.
",https://instrumental-lib.readthedocs.io/en/0.7/cameras-pixelfly.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/cameras/pixelfly.py,PCO Pixelfly,"[OrderedDict([('id', 'att8fWvmDAnaGMGMR'), ('width', 60), ('height', 60), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/URfKyN5vaRuT6zzy8FytGg/FVOVIj_ebDN8P86JAp3_9gKYylg4Ua4es9WxFJ7iH28LebDjh0EoQBJ1UuniUD_NeXT9sKDL_8pSHvkQhaivjDlUTwYV1crQLE7xleqSw9Y/dC09yqlPeTA17kKN9nK-pSwFL_JAxsVhux4KRoE5HjQ'), ('filename', '29533-2571181.webp'), ('size', 516), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/s692s_6V99GCj0ZNaNuT5w/UbrAT-w6nKzN0k0hwm-QK5WxHL0KF7xAy7sBnxFr3FfHuxBvmhCIdfjs06DMYDyWJnEAK9Ncq9JIAN2zfEdCuy_hG-sEesPItXQt69W8MIs/8UXRTJV40-3vk19jdISaIRDj4U53j7ZHxlbg7yc2c14'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/RHW8_kQ_LDuqv-QMys3V5Q/IcahVsUGIPsfZ1KdxXBLAes6Q5UwjjcaSgqaJzVBO6mhR7mPOxObZcH_4e1qRUkSb7QThUTByAJL_xPSisWCAPEHu2CnP8TWJn6uLbju18o/a_jNek_Xyw2orL242FC55I-sQP4iWN3Z2-qnuzsv5Gw'), ('width', 60), ('height', 60)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/z1U6c0MFsbHFtHMwm47rrA/j4QMHDCYsS9ekeK7Jj9cOdp4HA-ZpzXLtV-8scGYJ3B5ReAptIsNUT9jW5ytA7qUQOldcIeufiOf0SC2nsgcVzeCG-B30lE951nrlkzNtpE/7ryzODloxtIdeG_0JFJAR9_CEY5tDsAHhgOwbMTl3JE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.pco.de/scientific-cameras/pcopixelflytm-13-swir/,['Cameras'],"[OrderedDict([('id', 'attxVqZoiiRf18FSt'), ('width', 800), ('height', 235), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/PYERwwV7Os3T0enKW-tV5Q/MnJ8u_uC85zinEd4zxfPj8kFE08qBsitg9GYqbXt5lDTPbnrRhcQy_YI08JuJuz4Oyj72mlg8voWZ_yPcLYvP2CL51HgUyolxhM9ZkwWMlA/VT3bpponipPhPUTQ8QNJ4KaL4U5OcSvEKf_SZ_1XFQc'), ('filename', '800px-Pco_logo.png'), ('size', 77223), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/YuQ4x6dUs20XLZTPZq1slw/fkFmLK-YLJXPNc3lv9jlZrtJr0lYgiqoUdTJSP3JQLeN8iExl35YyYrYKZOx4JnJ1WQ-6pqA0KA8o6G9gbjmew/oUXLk_OF6aLF60C1ItFaA-8iDdMrFsBi_rHVKUWaqSI'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/RUV_yiPQ1BQl-hKmlCVfHQ/5ZySCILswR3VJYiYZCr-gLpNAVEJz3DmXyTOwsLmpvPtpXOrNJ-xmvmqgCEgHfgvYnPqSulYJYsQClGQZacjcQ/kBSUqbY_fkeJJpyVm_FqXQyBgladhxwhpzS86QMFIrU'), ('width', 800), ('height', 235)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/RAIHVsRQ96bETrz0T9MfjA/W9vInmHkySFszUZbCNEvaOemjF1Thd3dACPhBdK77hb15Zd6YBw5lmdIrTfMTNR6ftCSycvf29yEtkioXm9qMg/VUdYINm_Fy6bPKmr8WU0ZU8yh6LN_NnbswdmDPUM_so'), ('width', 3000), ('height', 3000)]))]))])]","**PCO** is one of the leading manufacturers of scientific **cameras**: sCMOS & Highspeed **camera** systems, developed and produced in Kelheim Bavaria Germany.

",https://www.pco-tech.com,https://www.pco.de/fileadmin/user_upload/pco-product_sheets/FL_PCOPIXELFLY13SWIR_V101.pdf,Germany,7.0,"Machine vision (MV) is the technology and methods used to provide imaging-based automatic inspection and analysis for such applications as automatic inspection, process control, and robot guidance, usually in industry",https://en.wikipedia.org/wiki/Machine_vision,Write a Python script that uses Instrumental to connect to a PCO Pixelfly Cameras,,,,,"# -*- coding: utf-8 -*-
# Copyright 2015-2018 Nate Bogdanowicz
""""""
Driver for PCO Pixelfly cameras.
""""""
from future.utils import PY2

import os.path
import numpy as np
from scipy.interpolate import interp1d
import win32event

from nicelib import NiceLib, Sig, NiceObject, load_lib, RetHandler

from . import Camera
from .. import ParamSet
from ..util import check_units
from ...errors import Error, TimeoutError, LibError
from ... import Q_, u

if PY2:
    memoryview = buffer  # Needed b/c np.frombuffer is broken on memoryviews in PY2
    from time import clock
else:
    from time import process_time as clock

__all__ = ['Pixelfly']

# Developed using version 2.1.0.29 of pf_cam.dll
info = load_lib('pixelfly', __package__)
ffi = info._ffi


class PixelflyLibError(LibError):
    MSG_FORMAT = '(0x{:X}) {}'


@RetHandler(num_retvals=0)
def pixelfly_errorcheck(code):
    from ._pixelfly import errortext  # Hide from sphinx
    if code != 0:
        pbuf = errortext.ffi.new('char[]', 1024)
        errortext.lib.PCO_GetErrorText(errortext.ffi.cast('unsigned int', code), pbuf, len(pbuf))
        err_message = errortext.ffi.string(pbuf)
        raise PixelflyLibError(code & 0xFFFFFFFF, err_message)


class NicePixelfly(NiceLib):
    _info_ = info
    _ret_ = pixelfly_errorcheck

    INITBOARD = Sig('in', 'out')  # Second arg should really be 'inout'
    CHECK_BOARD_AVAILABILITY = Sig('in')

    class Board(NiceObject):
        _init_ = 'INITBOARD'

        CLOSEBOARD = Sig('inout')
        START_CAMERA = Sig('in')
        STOP_CAMERA = Sig('in')
        TRIGGER_CAMERA = Sig('in')
        SETMODE = Sig('in', 'in', 'in', 'in', 'in', 'in', 'in', 'in', 'in', 'in')
        SET_EXPOSURE = Sig('in', 'in')
        GETMODE = Sig('in', 'out', 'out', 'out', 'out', 'out', 'out', 'out', 'out', 'out')
        GETSIZES = Sig('in', 'out', 'out', 'out', 'out', 'out')
        READVERSION = Sig('in', 'in', 'buf', 'len=64')
        READTEMPERATURE = Sig('in', 'out')
        WRRDORION = Sig('in', 'in', 'out')
        SETORIONINT = Sig('in', 'in', 'in', 'in', 'in')  # TODO: NiceLib needs something like bufin
        GETORIONINT = Sig('in', 'in', 'in', 'buf', 'len')
        READEEPROM = Sig('in', 'in', 'in', 'out')
        WRITEEEPROM = Sig('in', 'in', 'in', 'in')
        SETTIMEOUTS = Sig('in', 'in', 'in', 'in')
        #SET_TIMEOUT_VALUES = Sig('in', 'arr', 'len')  # TODO: len is in bytes
        SETDRIVER_EVENT = Sig('in', 'in', 'inout')
        PCC_GET_VERSION = Sig('in', 'out', 'out')
        READ_IMAGE = Sig('in', 'in', 'len', 'arr', 'in')  # TODO: Check this
        ALLOCATE_BUFFER_EX = Sig('in', 'inout', 'in', 'inout', 'inout')
        FREE_BUFFER = Sig('in', 'in')
        SETBUFFER_EVENT = Sig('in', 'in', 'inout')
        CLEARBUFFER_EVENT = Sig('in', 'in', 'inout')
        PCC_RESETEVENT = Sig('in', 'in')
        ADD_BUFFER_TO_LIST = Sig('in', 'in', 'in', 'in', 'in')
        REMOVE_BUFFER_FROM_LIST = Sig('in', 'in')
        ADD_BUFFER = Sig('in', 'in', 'in', 'in', 'in')
        REMOVE_BUFFER = Sig('in', 'in')
        REMOVE_ALL_BUFFERS_FROM_LIST = Sig('in')
        PCC_WAITFORBUFFER = Sig('in', 'in', 'inout', 'in')
        GETBUFFER_STATUS = Sig('in', 'in', 'in', 'arr', 'len=4:byte')

        @Sig('in', 'in', 'inout')
        def GETBOARDVAL(self, pcc_val):
            data = ffi.new('DWORD*')
            self._autofunc_GETBOARDVAL(pcc_val, ffi.cast('void*', data))
            return data[0]


# Load QE curves
data_dir = os.path.join(os.path.dirname(__file__), '_pixelfly')
def load_qe_curve(fname):
    data = np.loadtxt(os.path.join(data_dir, fname))
    return interp1d(data[:, 0], data[:, 1]*0.01, bounds_error=False, fill_value=0.,
                    assume_sorted=True)


def support_checker(mask):
    return property(lambda self: bool(mask & self._dev.GETBOARDVAL(0x00)))


def unitful_boardval(pcc_val, units):
    return property(lambda self: Q_(self._dev.GETBOARDVAL(pcc_val), units))


class Pixelfly(Camera):
    _INST_PARAMS_ = ['number']

    DEFAULT_KWDS = Camera.DEFAULT_KWDS.copy()
    DEFAULT_KWDS.update(trig='software', shutter='single', gain='low')

    _qe_high = load_qe_curve('QEHigh.tsv')
    _qe_low = load_qe_curve('QELow.tsv')
    _qe_vga = load_qe_curve('VGA.tsv')

    def _initialize(self):
        number = self._paramset.get('number', 0)
        self._dev = NicePixelfly.Board(number)
        self._cam_started = False
        self._mode_set = False
        self._mem_set_up = False
        self._partial_sequence = []
        self._capture_started = False

        self._bufsizes = []
        self._bufnums = []
        self._bufptrs = []
        self._buf_events = []
        self._nbufs = 0
        self._buf_i = 0

        self._double_img = None  # Used for latest_frame

        try:
            self.set_mode()
        except PixelflyLibError as e:
            self._dev.STOP_CAMERA()
            self._dev.CLOSEBOARD()
            if e.code != 0x80202032:
                raise
            self._dev = NicePixelfly.Board(number)
            self.set_mode()

        self._last_kwds = {}

    @staticmethod
    def _list_boards():
        board_nums = []

        for board_num in range(8):
            try:
                NicePixelfly.CHECK_BOARD_AVAILABILITY(board_num)
            except PixelflyLibError as e:
                if e.code != 0x80202006:
                    raise
            else:
                board_nums.append(board_num)

        return board_nums

    def close(self):
        """""" Clean up memory and close the camera.""""""
        if self._cam_started:
            self._dev.STOP_CAMERA()

        self._dev.REMOVE_ALL_BUFFERS_FROM_LIST()
        for bufnum in self._bufnums:
            self._dev.FREE_BUFFER(bufnum)
        self._bufsizes, self._bufnums, self._bufptrs = [], [], []
        self._nbufs = 0

        self._dev.CLOSEBOARD()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def set_mode(self, shutter='single', trig='software', exposure='10ms',
                 hbin=1, vbin=1, gain='low', depth=12):
        """""" Set the mode of the camera.

        Parameters
        ----------
        shutter : str
            One of 'single', 'double', or 'video'.
        trig : str
            One of 'software' or 'hardware'.
        exposure : Quantity or str
            Exposure time. Up to 65.6 ms with microsecond resolution.
        hbin : int
            Horizontal binning factor. Either 1 or 2.
        vbin : int
            Vertical binning factor. Either 1 or 2.
        gain : str
            Gain of camera. Either 'low' or 'high'.
        depth : int
            Bit depth of each pixel. Either 8 or 12.
        """"""
        # Normalize all the parameters
        shutter_map = {'single': 0x10, 'double': 0x20, 'video': 0x30}
        mode = shutter_map[shutter] + (1 if trig == 'software' else 0)
        exp_units = 'ms' if shutter == 'video' else 'us'
        exptime = int(Q_(exposure).to(exp_units).magnitude)

        # Check exptime bounds to avoid cryptic errors
        if shutter == 'video':
            if not (1 <= exptime <= 65535):
                raise Error(""Invalid exposure time {}. Exposure must be between 1 us and ""
                            ""65.535 ms when in video shutter mode"".format(exposure))
        else:
            if not (5 <= exptime <= 65535):
                raise Error(""Invalid exposure time {}. Exposure must be between 5 us and ""
                            ""65.535 ms when in single shutter mode"".format(exposure))

        hbin_val = 0 if hbin == 1 else 1
        vbin_val = 0 if vbin == 1 else 1
        gain_val = 0 if gain == 'low' else 1
        bit_pix = 12 if depth == 12 else 8

        self._shutter = shutter

        # Camera must be stopped before SETMODE is called
        if self._cam_started:
            self._dev.STOP_CAMERA()

        self._dev.SETMODE(mode, 0, exptime, hbin_val, vbin_val, gain_val, 0, bit_pix, 0)

        self._load_sizes()
        self._allocate_buffers()
        self.color_mode = 'mono16'

    def start_live_video(self, **kwds):
        self._handle_kwds(kwds)
        self._last_kwds = kwds

        #self.set_mode('video')
        self.set_mode(exposure=kwds['exposure_time'], hbin=kwds['hbin'], vbin=kwds['vbin'],
                      shutter='video', trig=kwds.pop('trig', 'software'),
                      gain=kwds['gain'])

        # Set software ROI; must be after call to set_mode()
        self._width = kwds['width']
        self._height = kwds['height']

        self._trigger()

    def stop_live_video(self):
        self.set_mode()

    @check_units(timeout='?ms')
    def wait_for_frame(self, timeout=None):
        if self._double_img is not None:
            return True

        timeout = win32event.INFINITE if timeout is None else max(0, timeout.m_as('ms'))

        buf_i = (self._buf_i) % self._nbufs  # Most recently triggered buffer
        ret = win32event.WaitForSingleObject(int(self._buf_events[buf_i]), int(timeout))

        if ret != win32event.WAIT_OBJECT_0:
            return False  # Object is not signaled

        win32event.ResetEvent(int(self._buf_events[buf_i]))
        self._dev.PCC_RESETEVENT(buf_i)
        status = self._dev.GETBUFFER_STATUS(self._bufnums[buf_i], 0)

        #if px.PCC_BUF_STAT_ERROR(ptr):
        if status[0] & 0xF000:
            uptr = ffi.cast('DWORD *', status)
            raise Exception(""Buffer error 0x{:08X} 0x{:08X} 0x{:08X} 0x{:08X}"".format(
                            uptr[0], uptr[1], uptr[2], uptr[3]))

        if self._shutter == 'video':
            self._dev.ADD_BUFFER_TO_LIST(self._bufnums[self._buf_i], self._frame_size(), 0, 0)
        self._buf_i = (self._buf_i + 1) % self._nbufs

        return True

    def _frame_size(self):
        nimgs = 2 if self._shutter == 'double' else 1
        nbytes = ((self.bit_depth+7)//8)
        return self._binned_width * self._binned_height * nbytes * nimgs

    def _allocate_buffers(self, nbufs=None):
        if nbufs is None:
            if self._nbufs > 1:
                nbufs = self._nbufs
            elif self._shutter == 'video':
                nbufs = 2
            else:
                nbufs = 1

        frame_size = self._frame_size()
        bufnr_p = ffi.new('int *')

        # Remove and free all existing buffers
        self._dev.REMOVE_ALL_BUFFERS_FROM_LIST()
        for bufnum in self._bufnums:
            self._dev.FREE_BUFFER(bufnum)
        self._bufnums = []
        self._bufsizes = []
        self._buf_events = []
        self._bufptrs = []

        # Create new buffers
        for i in range(nbufs):
            adr = ffi.new('void **')
            bufnr_p[0] = -1  # Allocate new buffer
            event_p = ffi.new('HANDLE *', ffi.NULL)

            self._dev.ALLOCATE_BUFFER_EX(bufnr_p, frame_size, event_p, adr)

            self._bufnums.append(bufnr_p[0])
            self._bufsizes.append(frame_size)
            self._buf_events.append(ffi.cast('unsigned int', event_p[0]))
            self._bufptrs.append(ffi.cast('void *', adr[0]))
        self._nbufs = nbufs

        self._dev.START_CAMERA()
        self._cam_started = True
        self._mem_set_up = True

    def _trigger(self):
        frame_size = self._frame_size()

        for i in range(self._nbufs):
            self._dev.ADD_BUFFER_TO_LIST(self._bufnums[i], frame_size, 0, 0)
        self._buf_i = 0
        self._capture_started = True

        self._dev.TRIGGER_CAMERA()

    def latest_frame(self, copy=True):
        if self._double_img is not None:
            img = self._double_img
            self._double_img = None
            return self._crop_roi(img)

        buf_i = (self._buf_i - 1) % self._nbufs
        if copy:
            buf = memoryview(ffi.buffer(self._bufptrs[buf_i], self._frame_size())[:])
        else:
            buf = memoryview(ffi.buffer(self._bufptrs[buf_i], self._frame_size()))

        if self._shutter == 'double':
            arr, self._double_img = self._arrays_from_buffer(buf)
        else:
            arr, = self._arrays_from_buffer(buf)

        return self._crop_roi(arr)

    def _crop_roi(self, arr, kwds=None):
        kwds = self._last_kwds if kwds is None else kwds
        return arr[kwds['top']:kwds['bot'], kwds['left']:kwds['right']]

    def start_capture(self, **kwds):
        self._handle_kwds(kwds)
        self._last_kwds = kwds

        # Clear any old capture data
        self._double_img = None

        #if kwds['n_frames'] > 1:
        #    raise Error(""Pixelfly camera does not support multi-image capture sequences"")
        self._nbufs = kwds.get('n_frames', 1)

        self.set_mode(exposure=kwds['exposure_time'], hbin=kwds['hbin'], vbin=kwds['vbin'],
                      shutter=kwds.pop('shutter', 'single'), trig=kwds.pop('trig', 'software'),
                      gain=kwds['gain'])

        # Set software ROI; must be after call to set_mode()
        self._width = kwds['width']
        self._height = kwds['height']

        self._trigger()

    def cancel_capture(self):
        """"""Cancels a capture sequence, cleaning up and stopping the camera""""""
        pass

    @check_units(timeout='?ms')
    def get_captured_image(self, timeout='1s', copy=True, **kwds):
        self._handle_kwds(kwds)  # Should get rid of this duplication somehow...
        image_arrs = []

        if not self._capture_started:
            raise Error(""No capture initiated. You must first call start_capture()"")

        start_time = clock() * u.s
        while self._buf_i < self._nbufs:
            if timeout is None:
                frame_ready = self.wait_for_frame(timeout=None)
            else:
                elapsed_time = clock() * u.s - start_time
                frame_ready = self.wait_for_frame(timeout - elapsed_time)

            if not frame_ready:
                self._partial_sequence.extend(image_arrs)  # Save for later
                raise TimeoutError

            if copy:
                buf = memoryview(ffi.buffer(self._bufptrs[self._buf_i], self._frame_size())[:])
            else:
                buf = memoryview(ffi.buffer(self._bufptrs[self._buf_i], self._frame_size()))

            arrays = self._arrays_from_buffer(buf)

            if kwds['fix_hotpixels']:
                arrays = [self._correct_hot_pixels(a) for a in arrays]

            # Software ROI
            kwds = self._last_kwds
            arrays = [a[kwds['top']:kwds['bot'], kwds['left']:kwds['right']] for a in arrays]

            image_arrs.extend(arrays)
            self._buf_i += 1

            # FIXME: HACK -- remove me
            if self._buf_i < self._nbufs:
                self._dev.TRIGGER_CAMERA()

        image_arrs = self._partial_sequence + image_arrs
        self._partial_sequence = []

        if len(image_arrs) == 1:
            return image_arrs[0]
        else:
            return tuple(image_arrs)

    def _arrays_from_buffer(self, buf):
        dtype = np.uint8 if self.bit_depth <= 8 else np.uint16
        if self._shutter != 'double':
            arr = np.frombuffer(buf, dtype)
            return (arr.reshape((self._binned_height, self._binned_width)),)
        else:
            px_per_frame = self._binned_width*self._binned_height
            byte_per_px = (self.bit_depth+7)//8
            arr1 = np.frombuffer(buf, dtype, px_per_frame, 0)
            arr2 = np.frombuffer(buf, dtype, px_per_frame, px_per_frame*byte_per_px)
            return (arr1.reshape((self._binned_height, self._binned_width)),
                    arr2.reshape((self._binned_height, self._binned_width)))

    def grab_image(self, timeout='1s', copy=True, **kwds):
        self.start_capture(**kwds)
        return self.get_captured_image(timeout=timeout, copy=copy, **kwds)

    def _load_sizes(self):
        ccdx, ccdy, actualx, actualy, bit_pix = self._dev.GETSIZES()
        self._max_width = ccdx
        self._max_height = ccdy
        self._binned_width = actualx
        self._binned_height = actualy
        self._bit_depth = bit_pix

        self._width = self._binned_width
        self._height = self._binned_height

        if self._shutter == 'double':
            self._height = self._height // 2  # Give the height of *each* image individually
            self._binned_height = self._binned_height // 2

    def _version(self, typ):
        return self._dev.READVERSION(typ)

    @check_units(wavlen='nm')
    def quantum_efficiency(self, wavlen, high_gain=False):
        """"""quantum_efficiency(self, wavlen, high_gain=False)

        Fractional quantum efficiency of the sensor at a given wavelength
        """"""
        if self.max_width == 640:
            curve = self._qe_vga
        elif self.max_width == 1392:
            curve = self._qe_high if high_gain else self._qe_low
        else:
            raise Error(""Unrecognized pixelfly model"")
        return float(curve(wavlen.m_as('nm')))

    @property
    def temperature(self):
        """""" The temperature of the CCD. """"""
        temp_C = self._dev.READTEMPERATURE()
        return Q_(temp_C, 'degC')

    frame_time = unitful_boardval(0x40, 'us')
    readout_time = unitful_boardval(0x41, 'us')
    last_exposure_time = unitful_boardval(0x0C, 'ms')

    supports_svga = support_checker(0x2000)
    supports_hvga = support_checker(0x4000)
    supports_ir_mode = support_checker(0x8000)
    supports_double_mode = support_checker(0x10000)
    supports_set_exposure = support_checker(0x20000)
    supports_vga2 = support_checker(0x40000)
    supports_qe = support_checker(0x80000)
    supports_5us_exposure = support_checker(0x200000)

    width = property(lambda self: self._width)
    height = property(lambda self: self._height)
    max_width = property(lambda self: self._max_width)
    max_height = property(lambda self: self._max_height)
    bit_depth = property(lambda self: self._bit_depth)


def list_instruments():
    board_nums = Pixelfly._list_boards()
    return [ParamSet(Pixelfly, number=n) for n in board_nums]


def close_all():
    board = NicePixelfly.Board(0)
    board.STOP_CAMERA()
    board.CLOSEBOARD()
"
22,,Agilent,Keysight 81110 A,Instrumental,"Keysight 81110A
Pulse Pattern Generator / 165/330 MHz",https://github.com/mabuchilab/Instrumental/tree/master,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/funcgenerators/agilent.py,KEYSIGHT 81110A,"[OrderedDict([('id', 'attXDU3MLQIOvGG3t'), ('width', 5472), ('height', 3648), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/V1q8sYGt2gSeSg6YnRvx7w/ufnU7HUxtlxu-zowOXXkcJy-LTvkk99VHi75daSZonxlnqkCpVJGx_3yYBcWdvqhwY9i5ywGfU295l28l9W75Z0khHcx91redkLqLU-_qRo/W_yyRgkQwH1e65NDBLnBItDKphQV16cm6rzzqBfDM5c'), ('filename', '81110.jpeg'), ('size', 2392802), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/5hoDByYrc6z6jsKyD13OTg/PYd24elrVqS13gxctD8oqgR6LDxVUOl6YxiJ9f4xW9c96NhAEcX15yUkOxcJc_rX72j4FlBkvANMTBdkOsy3cQ/aRLok9ZATawWba8h0YZ0tw8sk9PqvHHzMd97P3qDzLo'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/1p3ZcF8yKqBE8HDp5R-qAQ/qiZrkAGFZX8lCRN_i-lVnN-dc09PVyJ5XLkKOUslhPyn5v9adkusui0FrTAHq67ATqHzLBEUYDtswtPNysMSbw/jXauhUEcGaXYrRZ1DT3wOIM1NdXncEb0kOgSqohtDKU'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/4pEMOGm21nKZZIQVzTqB1g/i_XiKtUM4BuOmaYRv3J6ehqnSWCXDdLuCJQlann3yFm2gFH1f-zQbeDABz4ZR6HfFsXe4hjMLStIo8NWcQrEtg/pH1ZK_pv8LewBcheTTqC3LXjXoo96c6yMvhMyGJSJww'), ('width', 3000), ('height', 3000)]))]))])]",https://saving.em.keysight.com/en/used/function-aw-signal-generators/81110a-e2504113?channel=CP_DSA_MLP&gclid=Cj0KCQjw7uSkBhDGARIsAMCZNJswNSak-h4YCvdtOEGCPo8AxKoSOofAXGHH6SjIfDn3NmD_VvY5EEUaAkOGEALw_wcB,['Function Generators'],"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/8NkKhA8DZeFFmg0HG2vqBQ/i7sDvZcWrL5feAhte--WAZM60GUxo9LTsA-7dk6rmOVygu1Ou_gc7kx0YSRD27VLr_M2S8wt_XWr3gIVECX4T4YeDfmJMtrHSEf5Nk2DwoI/YGN6XtEZXUbWTSu0FH-7VyoSBDRzQ_hI8Fke3VgdSKk'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/kbgU2hXgNoSbC-ewOQvmFA/D3hUZhYwx_RgIq6vH4rfWuT8pq68LrWNhHgrtXcT1Vf8K1VoD8QEO24c3N9OWU4bWrYPdblEnMBJqyoSLlOL6dwzeLrG6M5dpP0Uy64gf-k/uHb-q9tV4J4jO1fE9AbWhoTnaJteJiVbZduAjDyzG4M'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/1ozcXGboSZAYhgcpQC_O6w/EV57a2hcUNT8ApFrBEXKSUX6Bc0CIFY8MFy9FgEYNoiO34isoXtI3ZDxOsuTpxR1cJMg0YMSarxqvuj1asaBjXs0zf4QJrO8zUO6PrIPHtw/HGIiMTzU385vGc7X6RfrHa89MgNf99Wnm09cw7Qexi4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/i242n2rzQFygxwq2tZNabQ/pjedlALU6nhGN5bQm-4E4SqyD_dgQ17IXZgj-zfgw3C31OM0-JIYUZyvsWvdlPhhTghzRyazfISXr3208IhnLN824HRpbNtUv2WHScoWZAg/a_lx0nJBDLnp_eF2USN3-noYe9tHOtcKDcv-Fv6cQTg'), ('width', 3000), ('height', 3000)]))]))])]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://www.keysight.com/us/en/home.html,https://www.keysight.com/us/en/assets/3121-1445/data-sheets-archived/5980-1215.pdf,USA,5420.0,"Signal generators are routinely used when designing, manufacturing, testing, troubleshooting, servicing, calibrating or repairing electronic devices. Depending on the frequency range of the signal generator and electronic device, this may range from mechanical- and electro-accoustic applications to high and ultra-high frequencies in the digital, wireless, radar spectrum",https://saving.em.keysight.com/en/used/function-aw-signal-generators,Write a Python script that uses Instrumental to connect to a KEYSIGHT 81110A Function Generators,6500.0,"
",,,"# -*- coding: utf-8 -*-
# Copyright 2018-2019 Nate Bogdanowicz
""""""
Driver module for Agilent signal generators.

MXG driver was initially developed for and tested on the N5181A.
""""""
from enum import Enum
from . import FunctionGenerator
from .. import VisaMixin, SCPI_Facet
from ... import u, Q_


def _convert_enum(enum_type):
    """"""Check if arg is an instance or key of enum_type, and return that enum

    Strings are converted to lowercase first, so enum fields must be lowercase.
    """"""
    def convert(arg):
        if isinstance(arg, enum_type):
            return arg
        try:
            return enum_type[arg.lower()]
        except (KeyError, AttributeError):
            raise ValueError(""{} is not a valid {} enum"".format(arg, enum_type.__name__))
    return convert


class TriggerSource(Enum):
    bus = 'BUS'
    immediate = 'IMMMEDIATE'
    external = 'EXT'
    key = 'KEY'
    timer = 'TIMER'
    manual = 'MAN'
    
    
class TriggerSensing(Enum):
    edge = 'EDGE'
    level = 'LEV'
    
    
class TriggerSlope(Enum):
    positive = 'POS'
    negative = 'NEG'
    either = 'EITH'


class FreqMode(Enum):
    cw = fixed = 'FIXED'
    list = 'LIST'


class AgilentMXG(FunctionGenerator, VisaMixin):
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Agilent Technologies', ['N5181A'])

    def _initialize(self):
        self._rsrc.read_termination = '\n'

    cw_frequency = SCPI_Facet('FREQ:CW', convert=float, units='Hz')
    sweep_center_frequency = SCPI_Facet('FREQ:CENTER', convert=float, units='Hz')
    sweep_span_frequency = SCPI_Facet('FREQ:SPAN', convert=float, units='Hz')
    sweep_start_frequency = SCPI_Facet('FREQ:START', convert=float, units='Hz')
    sweep_stop_frequency = SCPI_Facet('FREQ:STOP', convert=float, units='Hz')

    freq_mode = SCPI_Facet('FREQ:MODE', convert=_convert_enum(FreqMode))

    # enabling freq and/or amplitude sweep
    # sweep triggering
    # load a list sweep file

class OnOffState(Enum):
    ON = True
    OFF = False

class CombinedState(Enum):
    PLUS = True
    OFF = False

class Agilent33250A(FunctionGenerator, VisaMixin):
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Agilent Technologies', ['33250A'])

    def _initialize(self):
        self._rsrc.read_termination = '\n'

    frequency = SCPI_Facet('FREQ', convert=float, units='Hz')
    voltage = SCPI_Facet('VOLT', convert=float, units='V')

class AgilentE4400B(FunctionGenerator, VisaMixin):
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Hewlett-Packard', ['ESG-1000B'])
    width1 = SCPI_Facet('PULS:WIDTh1 ', convert=float, units='ns')
    width2 = SCPI_Facet('SOURce2:FUNCtion:PULSe:WIDTh', convert=float, units='s')

    def _initialize(self):
        self._rsrc.read_termination = '\n'

    frequency = SCPI_Facet('FREQ:FIXED', convert=float, units='Hz')

class AgilentFuncGenerator(FunctionGenerator, VisaMixin):
    def set_polarity(self, polarity, channel=1):
        """""" Set the polarity of a channel.

        Parameters
        ----------
        pol : either ""NORM"" for normal or ""INV"" for inverse
        
        channel: int
            The channel number
        """"""
        self.write('OUTP{:d}:POL {}', channel, polarity)
    
    def get_polarity(self, channel=1):
        return self.query(""OUTP{:d}:POL?"", channel)
    
    def set_trigger_source(self, source):
        """""" Set the trigger source.

        Parameters
        ----------
        source : either ""MAN"" for manual or ""EXT"" for external
        """"""
        self.write('ARM:SOUR ' + source)

    
    def get_trigger_source(self):
        return TriggerSource(self.query(""ARM:SOUR?"")).name
    
    def set_trigger_sensing(self, sensing):
        """""" Set the trigger sensing.
    
        Parameters
        ----------
        sensing : either ""EDGE"" for edge or ""LEV"" for level
        """"""
        self.write('ARM:SENS ' + sensing)
    
    def get_trigger_sensing(self):
        return TriggerSensing(self.query(""ARM:SENS?"")).name
    
    def set_trigger_slope(self, slope):
        """""" Set the trigger slope.
    
        Parameters
        ----------
        slope : either ""POS"" for positive or ""NEG"" for negative or ""EITH"" for either.
        """"""
        self.write('ARM:SLOP ' + slope)
    
    def get_trigger_slope(self):
        return TriggerSlope(self.query(""ARM:SLOP?"")).name
    
    def get_errors(self):
        return self.query('SYST:ERR?')

    def set_delay(self, delay, channel=1):
        """""" Set the delay of a channel.

        Parameters
        ----------
        delay: pint.Quantity
            The new delay in nanosecond-compatible units
        
        channel: int
            The channel number
        """"""
        val = Q_(delay)
        mag = val.to('ns').magnitude
        self.write('PULS:DEL{:d} {}NS', channel, mag)

    def set_out_impedance(self, imp, channel=1):
        """""" Set the output impedance of a channel.

        Parameters
        ----------
        imp : pint.Quantity
            The impedance value in Ohm
        
        channel: int
            The channel number
        """"""
        val = Q_(imp)
        mag = val.to('ohm').magnitude
        self.write('OUTP{:d}:IMP:EXT {:f}OHM', channel, mag)

    def set_width(self, width, channel=1):
        """""" Set the width.

        Parameters
        ----------
        width : pint.Quantity
            The new width in nanosecond-compatible units
        
        channel: int
            Channel number
        """"""
        val = Q_(width)
        mag = val.to('ns').magnitude
        self.write('PULS:WIDTh{:d} {:f}NS', channel, mag)

    def set_high(self, high, channel=1):
        """""" Set the high voltage level.

        This changes the high level while keeping the low level fixed.
        
        Parameters
        ----------
        high : pint.Quantity
            The new high level in volt-compatible units
        
        channel: int
            Channel number
        """"""
        high = Q_(high)
        mag = high.to('V').magnitude
        self.write('VOLT{:d}:HIGH {:5.2f}V', channel, mag)

    def set_low(self, low, channel=1):
        """""" Set the low voltage level.

        This changes the low level while keeping the high level fixed.

        Parameters
        ----------
        low : pint.Quantity
            The new low level in volt-compatible units
        
        channel: int
            Channel number
        """"""
        low = Q_(low)
        mag = low.to('V').magnitude
        self.write('VOLT{:d}:LOW {:5.2f}V', channel, mag)

    @property
    def output1(self):
        val = self.query(':OUTP1?')
        return bool(int(val))

    @output1.setter
    def output1(self, val):
        val = int(bool(val))
        self.write('OUTP1 %s' % OnOffState(val).name)

    @property
    def output2(self):
        val = self.query('OUTP2?')
        return bool(int(val))

    @output2.setter
    def output2(self, val):
        val = int(bool(val))
        self.write('OUTP2 %s' % OnOffState(val).name)
    
    @property
    def combined(self):
        val = self.query('CHAN:MATH?')
        if val == ""PLUS"":
            return True
        else:
            return False
    
    @combined.setter
    def combined(self, val):
        val = int(bool(val))
        self.write('CHAN:MATH ' + CombinedState(val).name)
    
    @property
    def trigger_level(self):
        val = self.query('ARM:LEV?')
        return Q_(val, u.V)
    
    @trigger_level.setter
    def trigger_level(self, val):
        low = Q_(val)
        mag = low.to('V').magnitude
        self.write('ARM:LEV {:5.2f}V', mag)

class Agilent81110A(AgilentFuncGenerator):
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('HEWLETT-PACKARD', ['HP81110A'])

    def _initialize(self):
        self._rsrc.read_termination = '\n'
    
    def set_subsystem(self, subsystem, channel=1):
        """""" Switch between substems commands.

        Parameters
        ----------
        subsystem : either ""VOLT"" for voltage or ""CURR"" for current.
        
        channel: int
            Channel number
        """"""
        self.write('HOLD{:d} {}', channel, subsystem)


class Keysight81160A(AgilentFuncGenerator):
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Agilent Technologies', ['81160A'])
   
    def _initialize(self):
        self._rsrc.read_termination = '\n'"
26,,Newport,"1830-C
",Instrumental,"The Model 1830C Power Meter is a high-resolution autoranging picoammeter compatible with all of Newport’s 818 Series low-power silicon, germanium and indium gallium arsenide detectors
",https://instrumental-lib.readthedocs.io/en/latest/newport-powermeters.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/powermeters/newport.py,"1830-C
","[OrderedDict([('id', 'attnXKAv9pW4yOSDG'), ('width', 600), ('height', 511), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/cs9FNX5YNoIEZV6rbkIeHw/Okj26cYawhSXT718O_96WWxOalEhGR8vE2-9Ph9dnil_WViWKnsZ1RWjTl9QDyAibvWtFiEq5KlIyCLaHO0PAuqMsKcckTUiTlJVJLIHKS0/5EXKK3pVsiLL9l4D5XWt25Z87RWfA7rS4d45xf-qO1A'), ('filename', 'Newport_1830C_View1.jpeg'), ('size', 35599), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/O2wc9af5dZlC3Y2EdLrGmg/BK1bf6Ubdk3YSAZb-vU_KV0YNkvGmGcKMyDQrjQYheqN7lkjGdOaGyYqVzLAgnuFXZWRrgdS4XoFQuliM1aLNw/yS7tL_7hy6kNRYl8abdFFhGkc7qtD_5PbbgRzpsmmcE'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/HiJmEevJdr1Epzz7WbtGgQ/gkAu7azFUZRjzfHpkuBTtcichNYEz_P_kfzO-THIY47Iks16ufOiMeofbrV3YkJkY1hSo-6jKFrFyM_6eEb51g/rzz23lKHBJy0eA_WJdiucLZn4cv0OJRrAuUEcT4DwKo'), ('width', 600), ('height', 511)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/LNdxpCC1T_vsaoVcrggXcA/hJDtjv0pB6TfnjhRTWaDVBPXtK76k1JTI5B4hkwULELqjw_FyptWB-PpjbT4CgBVDrZUVYottppQtVKnNmvjVw/bIqLOiocdzTD-Fvf-oExRTNC54JFwlB8IN5ECMfUnqA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/44731-1/Newport-1830-C-Picowatt-Digital-Optical-Power-Meter,['Power Meters'],"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/aHvQ0YFZO4B_N8gB1pC9KA/CpbV98JoA5eNfc0KkK54TLprYElRVw41eo0-8r54R1CDxuct__8q69K4JnU0AV6F4EbhmEmi7kZ7R7AKyOtHboPv6i9mhGlxEvV6veEoyRc/M-iyzjzev9swHbZ6-JPM6sH4f_f9jG3MCmMkHXrn0kQ'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/8NPYyiMVWzq4fHqsJxoe9w/Olr4cPBJL9FGEv3UCc7l2c7x4eiSahS6cNFvrrXBvHvdwQeHs982ePEtMSSs2sTW-jZRu5eMtwd2_1jLKi1Vnw/POCeuOeRurI5O8gnrvL2uGSIf28Uh-kw-0Bio20Phlc'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/PMwYSwppghErbn0UCbRHig/wroBULeNtI5gq7jwOrK2vgYfAZYD4SlnWSn_dipNL0xaBIVWwIGs4pqFoNw22OfdE2dZRAChd_LXr3LIO-r15g/c6s8ysRQucIctAKr148JxynJRzpvh5sOSji5wVm71D0'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/leF3e80zmv_xLL7whTEZvw/OYKmd-Xm5LzPvqQepc0FbVzQeRYmAAL4RCDS26HUIsK3QZze9XKUzWNTzNGqBva7tLEMUxHYdr7hW7k3o94Akw/zmgrWkXDbTDIDmWs-OCLsChmtjgJDxFBG9bllrL5-OA'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,,"Irvine, California, United States",3500.0,"An optical power meter (OPM) is a device used to measure the power in an optical signal
",https://en.wikipedia.org/wiki/Optical_power_meter,Write a Python script that uses Instrumental to connect to a {Device name} Power Meters,,,,,"# -*- coding: utf-8 -*-
# Copyright 2014-2019 Chris Rogers, Nate Bogdanowicz
""""""
Driver module for Newport power meters. Supports:

* 1830-C

For example, suppose a power meter is connected on port COM1.
One can then connect and measure the power using the following sequence::

    >>> from instrumental import instrument
    >>> newport_power_meter = instrument(visa_address='COM1',
                                         classname='Newport_1830_C',
                                         module='powermeters.newport')
    >>> newport_power_meter.power
    <Quantity(3.003776, 'W')>

""""""
import time

from . import PowerMeter
from .. import Facet, MessageFacet, VisaMixin, deprecated
from ..util import visa_timeout_context
from ... import Q_, u


def _check_visa_support(visa_inst):
    with visa_timeout_context(visa_inst, 100):
        try:
            if int(visa_inst.query('Z?')) in (0, 1):
                return 'Newport_1830_C'
        except:
            pass
    return None


def MyFacet(msg, readonly=False, **kwds):
    """"""Like SCPI_Facet, but without a space before the set-value""""""
    get_msg = msg + '?'
    set_msg = None if readonly else (msg + '{}')
    return MessageFacet(get_msg, set_msg, convert=int, **kwds)


class Newport_1830_C(PowerMeter, VisaMixin):
    """"""A Newport 1830-C power meter""""""
    _INST_PRIORITY_ = 8  # IDN isn't supported
    _INST_PARAMS_ = ['visa_address']

    # Status byte codes
    _PARAM_ERROR = 1
    _COMMAND_ERROR = 2
    _SATURATED = 4
    _OUT_OF_RANGE = 8
    _MSG_AVAILABLE = 16
    _BUSY = 32
    _SERVICE_REQUEST = 64
    _READY_READING = 128

    # Filter averaging constants
    SLOW_FILTER = 1
    MEDIUM_FILTER = 2
    NO_FILTER = 3

    def _initialize(self):
        self._rsrc.read_termination = '\n'
        self._rsrc.write_termination = '\n'

    def close(self):
        self.local_lockout = False

    status_byte = MyFacet('Q', readonly=True)

    @deprecated('status_byte')
    def get_status_byte(self):
        """"""Query the status byte register and return it as an int""""""
        return self.status_byte

    @Facet(units='W', cached=False)
    def power(self):
        """"""Get the current power measurement

        Returns
        -------
        power : Quantity
            Power in units of watts, regardless of the power meter's current
            'units' setting.
        """"""
        original_units = self.query('U?')
        if original_units != '1':
            self.write('U1')  # Measure in watts
            power = float(self.query('D?'))
            self.write('U' + original_units)
        else:
            power = float(self.query('D?'))

        return Q_(power, 'watts')

    @deprecated('power')
    def get_power(self):
        return self.power

    range = MyFacet('R', doc=""The current input range, [1-8], where 1 is lowest signal."")

    def enable_auto_range(self):
        """"""Enable auto-range""""""
        self.set_range(0)

    def disable_auto_range(self):
        """"""Disable auto-range

        Leaves the signal range at its current position.
        """"""
        cur_range = self.get_range()
        self.set_range(cur_range)

    @deprecated('range')
    def set_range(self, range_num):
        """"""Set the range for power measurements

        range_num = 0 for auto-range
        range_num = 1 to 8 for manual signal range
        (1 is lowest, and 8 is highest)

        Parameters
        ----------
        n : int
            Sets the signal range for the input signal.
        """"""
        self.range = range_num

    @deprecated('range')
    def get_range(self):
        """"""Return the current range setting as an int

        1 corresponds to the lowest range, while 8 is the highest range (least
        amplifier gain).

        Note that this does not query the status of auto-range.

        Returns
        -------
        range : int
            the current range setting. Possible values are from 1-8.
        """"""
        return self.range

    wavelength = MyFacet('W', units='nm')

    @deprecated('wavelength')
    def set_wavelength(self, wavelength):
        """"""Set the input signal wavelength setting

        Parameters
        ----------
        wavelength : Quantity
            wavelength of the input signal, in units of [length]
        """"""
        self.wavelength = wavelength

    @deprecated('wavelength')
    def get_wavelength(self):
        """"""Get the input wavelength setting""""""
        return self.wavelength

    attenuator = MyFacet('A', value={False:0, True:1}, doc=""Whether the attenuator is enabled"")

    @deprecated('attenuator')
    def enable_attenuator(self, enabled=True):
        """"""Enable the power meter attenuator""""""
        self.write('A{}', int(enabled))

    @deprecated('attenuator')
    def disable_attenuator(self):
        """"""Disable the power meter attenuator""""""
        self.enable_attenuator(False)

    @deprecated('attenuator')
    def attenuator_enabled(self):
        """"""Whether the attenuator is enabled

        Returns
        -------
        enabled : bool
            whether the attenuator is enabled
        """"""
        val = self.write('A?')
        return bool(val)

    def get_valid_power(self, max_attempts=10, polling_interval=0.1*u.s):
        """"""Returns a valid power reading

        This convience function will try to measure a valid power up to a
        maximum of `max_attempts` times, pausing for time
        `polling_interval` between each attempt.
        If a power reading is taken when the power meter is over-range,
        saturated, or busy, the reading will be invalid.
        In practice, this function also seems to mitigate
        the fact that about 1 in 500 power readings mysteriously fails.

        Parameters
        ----------
        max_attempts : integer
            maximum number of attempts to measure a valid power

        polling_interval : Quantity
            time to wait between measurement attemps, in units of time

        Returns
        -------
        power : Quantity
            Power in units of watts, regardless of the power meter's current
            'units' setting.
        """"""
        self.enable_auto_range()
        i_attempts = 0
        is_valid = False

        while not is_valid:
            self.disable_hold()
            time.sleep(polling_interval.to('s').m)
            self.enable_hold()
            i_attempts += 1

            try:
                is_valid = self.is_measurement_valid()
                if is_valid:
                    power = self.power
                    self.disable_hold()
                    return power
            except:
                is_valid = False
                if i_attempts > max_attempts:
                    self.disable_hold()
                    err_string = ""No valid power readings were taken over the maximum allowed number of attempts `max_attempts`.""
                    err_string += ""  The power meter is likely saturated.""
                    raise Exception(err_string)

    def set_slow_filter(self):
        """"""Set the averaging filter to slow mode

        The slow filter uses a 16-measurement running average.
        """"""
        self.write('F1')

    def set_medium_filter(self):
        """"""Set the averaging filter to medium mode

        The medium filter uses a 4-measurement running average.
        """"""
        self.write('F2')

    def set_no_filter(self):
        """"""Set the averaging filter to fast mode, i.e. no averaging""""""
        self.write('F3')

    def get_filter(self):
        """"""Get the current setting for the averaging filter

        Returns
        -------
        SLOW_FILTER, MEDIUM_FILTER, NO_FILTER
            the current averaging filter
        """"""
        val = self.query(""F?"")
        return int(val)

    def enable_hold(self, enable=True):
        """"""Enable hold mode""""""
        self.write('G{}', int(not enable))

    def disable_hold(self):
        """"""Disable hold mode""""""
        self.enable_hold(False)

    def hold_enabled(self):
        """"""Whether hold mode is enabled

        Returns
        -------
        enabled : bool
            True if in hold mode, False if in run mode
        """"""
        val = int(self.query('G?'))
        return (val == 0)

    def is_measurement_valid(self):
        """"""Whether the current measurement is valid

        The measurement is considered invalid if the power meter is saturated,
        over-range or busy.
        """"""
        reg = self.get_status_byte()
        is_saturated = bool(reg & self._SATURATED)
        is_over_range = bool(reg & self._OUT_OF_RANGE)
        is_busy = bool(reg & self._BUSY)

        return not (is_saturated or is_over_range or is_busy)

    def store_reference(self):
        """"""Store the current power input as a reference

        Sets the current power measurement as the reference power for future dB
        or relative measurements.
        """"""
        self.write('S')

    def enable_zero(self, enable=True):
        """"""Enable the zero function

        When enabled, the next power reading is stored as a background value
        and is subtracted off of all subsequent power readings.
        """"""
        self.write(""Z{}"", int(enable))

    def disable_zero(self):
        """"""Disable the zero function""""""
        self.enable_zero(False)

    def zero_enabled(self):
        """"""Whether the zero function is enabled""""""
        val = int(self.query('Z?'))  # Need to cast to int first
        return bool(val)

    def set_units(self, units):
        """"""Set the units for displaying power measurements

        The different unit modes are watts, dB, dBm, and REL. Each displays
        the power in a different way.

        'watts' displays absolute power in watts

        'dBm' displays power in dBm (i.e. dBm = 10 * log(P / 1mW))

        'dB' displays power in dB relative to the current reference power (i.e.
        dB = 10 * log(P / Pref). At power-up, the reference power is set to
        1mW.

        'REL' displays power relative to the current reference power (i.e.
        REL = P / Pref)

        The current reference power can be set using `store_reference()`.

        Parameters
        ----------
        units : 'watts', 'dBm', 'dB', or 'REL'
            Case-insensitive str indicating which units mode to enter.
        """"""
        units = units.lower()
        valid_units = {'watts': 1, 'dbm': 2, 'db': 3, 'rel': 4}

        if units not in valid_units:
            raise Exception(""`units` must be one of 'watts', 'dbm', 'db', or 'rel"")

        self.write('U{}', valid_units[units])

    def get_units(self):
        """"""Get the units used for displaying power measurements

        Returns
        -------
        units : str
            'watts', 'db', 'dbm', or 'rel'
        """"""
        val = int(self.query('U?'))
        units = {1: 'watts', 2: 'db', 3: 'dbm', 4: 'rel'}
        return units[val]

    @property
    def local_lockout(self):
        """"""Whether local-lockout is enabled""""""
        return bool(self.query('L?'))

    @local_lockout.setter
    def local_lockout(self, enable):
        self.write(""L{}"", int(enable))
"
70,,Agilent,"Agilent 86100A

",Instrumental,"Keysight 86100A
Infiniium DCA Wide-Bandwidth Oscilloscope / up to 50 GHz
",https://github.com/mabuchilab/Instrumental/tree/master,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/scopes/agilent.py,KEYSIGHT 86100A,"[OrderedDict([('id', 'attaN02T4s8ifJYhU'), ('width', 5472), ('height', 3648), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/x3w0qKGNM1qpJQVQ1ag_WA/_15GW4e0GHaWvodC76hA6FeyBUKew-jVHtbAv9zAeIKhmbsDed-BrECm4Km5LdGlsWV51lCwRQIZNmlSQGWhaHhdEbfSWHkHW7znO_s3Luo/DXyg7FEjXbGdr6_CW4TdKeTwHVRbrmUEk7hdTropoMg'), ('filename', '86100.jpeg'), ('size', 2851285), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/vkWn-Bn7dP2BiJ1PmXyVJQ/eNB_6K15j960hzFLXyfT_ndSmiEZDp8zqFivZxqkzz7LO24zIxoyNl7oHWKSzz8OoJbwwpnR6g_aAY4Zr1-vcA/MdAzhHgfF_0UcalbO3kSAWosPgp2gnvWDuNyAtvodgg'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/DtJzx2O5df1UACGtAUz5JA/0CWWCt6ZGEbwhcnWtZTdA2cn_E1tngUxJyMZSIFmWARKnjP_4HTVOvObWoYwmKPY5StYQDcNrt0vHWKbnQ9YgA/oqts502-ThClPl2TyB15pz-LUhElBkqBFPWtVe5PaRE'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/OTl_Dsiw52P_5NOPjvK-7g/mYIoVc5yk7WLbwFYZcxKMNKEG9zLIReVzsA38jj8XYG7wrI_i0Rk6oeFDwbUV3EtzKhtUcFlIQlv9rPuhi3RgA/Do-NZxOmCLS8DhwK0O8mOWO-_dAgIECBQTNYWIMEgIQ'), ('width', 3000), ('height', 3000)]))]))])]",https://saving.em.keysight.com/en/used/digital-communication-analyzers/86100a-e2506142,['Oscilloscopes'],"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/8NkKhA8DZeFFmg0HG2vqBQ/i7sDvZcWrL5feAhte--WAZM60GUxo9LTsA-7dk6rmOVygu1Ou_gc7kx0YSRD27VLr_M2S8wt_XWr3gIVECX4T4YeDfmJMtrHSEf5Nk2DwoI/YGN6XtEZXUbWTSu0FH-7VyoSBDRzQ_hI8Fke3VgdSKk'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/kbgU2hXgNoSbC-ewOQvmFA/D3hUZhYwx_RgIq6vH4rfWuT8pq68LrWNhHgrtXcT1Vf8K1VoD8QEO24c3N9OWU4bWrYPdblEnMBJqyoSLlOL6dwzeLrG6M5dpP0Uy64gf-k/uHb-q9tV4J4jO1fE9AbWhoTnaJteJiVbZduAjDyzG4M'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/1ozcXGboSZAYhgcpQC_O6w/EV57a2hcUNT8ApFrBEXKSUX6Bc0CIFY8MFy9FgEYNoiO34isoXtI3ZDxOsuTpxR1cJMg0YMSarxqvuj1asaBjXs0zf4QJrO8zUO6PrIPHtw/HGIiMTzU385vGc7X6RfrHa89MgNf99Wnm09cw7Qexi4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/i242n2rzQFygxwq2tZNabQ/pjedlALU6nhGN5bQm-4E4SqyD_dgQ17IXZgj-zfgw3C31OM0-JIYUZyvsWvdlPhhTghzRyazfISXr3208IhnLN824HRpbNtUv2WHScoWZAg/a_lx0nJBDLnp_eF2USN3-noYe9tHOtcKDcv-Fv6cQTg'), ('width', 3000), ('height', 3000)]))]))])]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://www.keysight.com/us/en/home.html,https://www.keysight.com/us/en/assets/9018-05081/service-manuals/9018-05081.pdf,USA,5420.0,"Digital Communications Analyzers (DCA) are often modular instruments, also known as sampling oscilloscopes or equivalent-time sampling oscilloscopes",https://saving.em.keysight.com/en/used/digital-communication-analyzers/86100a-e2506142,Write a Python script that uses Instrumental to connect to a KEYSIGHT 86100A Oscilloscopes,4200.0,"
",,,"# -*- coding: utf-8 -*-
# Copyright 2013-2018 Nate Bogdanowicz
""""""
Driver module for Tektronix oscilloscopes. Currently supports

* TDS 3000 series
* MSO/DPO 4000 series
""""""
import visa
from pyvisa.constants import InterfaceType
import numpy as np
from pint import UndefinedUnitError
from . import Scope
from .. import VisaMixin, SCPI_Facet, Facet
from ..util import visa_context
from ... import u, Q_
from enum import Enum

MODEL_CHANNELS = {
    'DSO1024': 4,
}

class PointsMode(Enum):
    normal = 'NORMal'
    maximum = 'MAXimum'
    raw = 'RAW'

# This code is not used right now, it was a preliminary effort to do things the
# ""clean"" way...
class DataFormat(Enum):
    word = 'WORD'
    byte = 'BYTE'
    ascii = 'ASCii'

def infer_termination(msg_str):
    if msg_str.endswith('\r\n'):
        return '\r\n'
    elif msg_str.endswith('\r'):
        return '\r'
    elif msg_str.endswith('\n'):
        return '\n'
    return None

class AgilentScope(Scope, VisaMixin):
    """"""
    A base class for Agilent Technologies Scopes
    """"""
    
    def _initialize(self):
        msg = self.query('*IDN?')
        self._rsrc.read_termination = infer_termination(msg)
        
    points_mode = SCPI_Facet(':WAVeform:POINts:MODE', convert=PointsMode,
                                 doc=""sets the type of data returned by the :WAV:DATA? query"")
    points = SCPI_Facet(':WAVeform:POINts', convert=int,
                        doc=""Number of points to return on :WAV:DATA?"")
    
    format = SCPI_Facet(':WAVeform:FORMat',
                        doc=""Format of the returned data"")

    def run(self):
        """"""Performs continuous acquisitions""""""
        self._rsrc.write(':RUN')

    def stop(self):
        """"""Stops continuous acquisitions""""""
        self._rsrc.write(':STOP')

    def single(self):
        """"""Runs a single acquisition""""""
        self._rsrc.write(':SINGLE')

    def capture(self, channel):
        """""" Returns unitful arrays for (time, voltage)""""""
        self.write(':WAVeform:SOURce CHAN%i' % channel)
        preamble = self.query(':WAVeform:PREAMBLE?')
        (fmt, typ, num_points, _, 
            x_increment, x_origin, x_reference,
            y_increment, y_origin, y_reference,
        ) = np.fromstring(preamble, sep=',')
        
        t = x_origin + (np.arange(num_points) * x_increment) * u.second
        
        if fmt == 0:
            # WORD
            dtype = 'h'
        if fmt == 1:
            # BYTE
            dtype = 'B'
        if fmt >= 0 and fmt <= 1:
            data = self._rsrc.query_binary_values(':WAVeform:DATA? CHAN%i' % channel, datatype=dtype, is_big_endian=True)
            data = (y_reference - data) * y_increment - y_origin
            return t, data * u.volt
        if fmt == 2:
            # ASCII
            data = self.query(':WAVeform:DATA? CHAN%i' % channel)
            data = np.fromstring(data[13:], sep=',') # Take off some header information
            return t, data * u.volt

class DSO_1000(AgilentScope):

    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Agilent Technologies', ['DSO1024A'])"
135,,Thorlabs,Thorlabs Tsi (All Cameras),Instrumental,"Kiralux 12.3 MP Monochrome CMOS Camera, Hermetically Sealed Cooled Package, USB 3.0 Interface, 1/4""-20 Taps
",https://instrumental-lib.readthedocs.io/en/stable/cameras-tsi.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/cameras/tsi.py,CC126Mu (Example),"[OrderedDict([('id', 'attQB4KqLwtljUVvu'), ('width', 150), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/6yOZ5BrGCaAiHvKdH1owjw/Qpa6kzvKIoLrFR0gmdUD3mPBOUs7pyhU5WGhgfynncoqlaBsk0kab_BZo6ut-QOD1BL_dkJmcViC2mLgMBLsosyu4H38IAJxh6CBGdaO6V4/48asN5NALTs4wxP08k6feCKVj5RH8G52p6X0tlDmipc'), ('filename', 'ITN004855-std.jpg'), ('size', 12030), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/HskA1lK08-N3FSf9WhtVXw/aVJ8V25_bTfb0mcVyXi_YQhL2sxM_F8qoicsGFnEOY4y2EGExz7Be055TscNQImsWkokNATegXQ6bHN1R_rD4w/mFCsL2x7yUfKweeVudiKtJBJfzbMmeMAlB2maIBBeGE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Gq16qcSsJzONSLKJWwXxWw/CR5bxBbvXJ38ThrSU6D0d89TPa513c6EcXTIg6y2klD6MWzzyBU2CjKNZYHcZe2DUcgYMf7Ggit74QYuG9kEaw/AZwKyaSxh4HDzcn_uJd1RwJzpXDbZjvxdFTEb90XLXo'), ('width', 150), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/eusFiEeb-AoqMo6Orm2DeQ/5lbfi79nJTA8o380-ggqhcKIMOep30fHshFPAcxr8xh6HHR0LwjOIEBoGUjCXyEaG4uAPVNVlnuTbMgo0DTx_A/TyDdKJyM53lwAJ_woY11-MRNt11hAeos-uhN03bjhr8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=13243,['Cameras'],"[OrderedDict([('id', 'attUZyCLkkmIuEgLg'), ('width', 2560), ('height', 398), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/IpVdg5h66qcP5fQupHixWw/L4zWVcBMKSljETAVSR8gGnaULDF7mRFX2K8Y_onNjJ_np62joMIp0jXKYAa3O03b5TXy1wWvgTNqAmE1r9cdDEPEcQDBP3MbkGRjQQxPnYE/py3pp2bwaCEmkZMr1IpQQG9RBYnEsMcoHEWZilYpS50'), ('filename', 'Image.png'), ('size', 70770), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/uW66V2CF2fNhJnRxF0J6fA/Pv2-LqsTrZGPH1tXjbSF17nQP4vUws2uALbApkEnzkST0q-D8u9rdfv8JM4tQYTvK4wHEzLr1riMilSBhiR6-A/jNldDMqu7cH1SQMuTSUqtcouTV3BeISjypseu6DoqAM'), ('width', 232), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/n00bWyqMiS_PmN1FdO6uSA/UsC-PTHfcl55UudUDWfVBpWyBO6pTGZ6AbYKMY-2CIx3cWewU6FNWsb-Q4daHe4CwqF-nluIBcGneZf3cVtdzQ/qnmFdd7wmPMmdjKULV_XbUiMwcS52NCWqd7RV1l4N6Y'), ('width', 2560), ('height', 398)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/6xmbSrRsXVitp4DhUmplfA/Al4hRmtCtrXIL5D8_ONlSCLh97HSS_LkHZeWBrKoNwAlBzkWNyHXBYXT6zTuAPwVPe9gqvYDlhrJymMQuVlugA/R-r6N4hbkal-yyljiQbzYNEX-kuz6iBhajrwVFlUoH4'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ITN004586-D02.pdf&partNumber=CC126MU,USA,550.0,"A camera module is an image sensor integrated with a lens, control electronics, and an interface like CSI, Ethernet or plain raw low-voltage differential signaling.",https://en.wikipedia.org/wiki/Camera_module,Write a Python script that uses Instrumental to connect to a CC126Mu (Example) Cameras,5200.0,,,TSI Driver is made for all scientific Camera from ThorLABS,"# -*- coding: utf-8 -*-
# Copyright 2017 Nate Bogdanowicz
from future.utils import PY2

import sys
import os.path

import numpy as np
from cffi import FFI
from enum import Enum

from . import Camera
from ..util import as_enum, unit_mag, check_units
from .. import ParamSet, register_cleanup
from ...errors import Error, TimeoutError
from ...log import get_logger
from ... import u

log = get_logger(__name__)

_INST_PARAMS = ['serial', 'number']
_INST_CLASSES = ['TSI_Camera']

if PY2:
    memoryview = buffer  # Needed b/c np.frombuffer is broken on memoryviews in PY2
    from time import clock
else:
    from time import process_time as clock

ffi = FFI()
mod_dir, _ = os.path.split(__file__)
with open(os.path.join(mod_dir, '_tsi', 'tsi.h')) as f:
    ffi.cdef(f.read())
ffi.cdef(""""""
    #define WAIT_OBJECT_0       0x00L
    #define WAIT_ABANDONED      0x80L
    #define WAIT_TIMEOUT        0x102L
    #define WAIT_FAILED         0xFFFFFFFF
    #define INFINITE            0xFFFFFFFF
    DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
    BOOL ResetEvent(HANDLE hEvent);
"""""")
lib = ffi.dlopen('tsi_sdk')
winlib = ffi.dlopen('Kernel32.dll')

param_type = {
    lib.TSI_PARAM_ATTR: 'uint8_t*',
    lib.TSI_PARAM_PROTOCOL: 'uint32_t*',
    lib.TSI_PARAM_FW_VER: 'char[64]',
    lib.TSI_PARAM_HW_VER: 'char[64]',
    lib.TSI_PARAM_HW_MODEL: 'char[64]',
    lib.TSI_PARAM_HW_SER_NUM: 'char[64]',
    lib.TSI_PARAM_CAMSTATE: 'uint32_t*',
    lib.TSI_PARAM_CAM_EXPOSURE_STATE: None,
    lib.TSI_PARAM_CAM_TRIGGER_STATE: 'uint32_t*',
    lib.TSI_PARAM_EXPOSURE_UNIT: 'TSI_EXPOSURE_UNITS*',
    lib.TSI_PARAM_EXPOSURE_TIME: 'uint32_t*',
    lib.TSI_PARAM_ACTUAL_EXPOSURE_TIME: 'uint32_t*',
    lib.TSI_PARAM_FRAME_TIME: 'float*',
    lib.TSI_PARAM_VSIZE: 'uint32_t*',
    lib.TSI_PARAM_HSIZE: 'uint32_t*',
    lib.TSI_PARAM_ROI_BIN: 'TSI_ROI_BIN*',
    lib.TSI_PARAM_FRAME_COUNT: 'uint32_t*',
    lib.TSI_PARAM_CURRENT_FRAME: 'uint32_t*',
    lib.TSI_PARAM_OP_MODE: 'TSI_OP_MODE*',
    lib.TSI_PARAM_CDS_GAIN: 'uint32_t*',
    lib.TSI_PARAM_VGA_GAIN: 'uint32_t*',
    lib.TSI_PARAM_GAIN: 'uint32_t*',
    lib.TSI_PARAM_OPTICAL_BLACK_LEVEL: 'uint32_t*',
    lib.TSI_PARAM_PIXEL_OFFSET: 'uint32_t*',
    lib.TSI_PARAM_READOUT_SPEED_INDEX: 'uint32_t*',
    lib.TSI_PARAM_READOUT_SPEED: 'uint32_t*',
    lib.TSI_PARAM_FRAME_RATE: 'float*',
    lib.TSI_PARAM_COOLING_MODE: 'uint32_t*',
    lib.TSI_PARAM_COOLING_SETPOINT: 'int32_t*',
    lib.TSI_PARAM_TEMPERATURE: 'int32_t*',
    lib.TSI_PARAM_QX_OPTION_MODE: 'uint32_t*',
    lib.TSI_PARAM_TURBO_CODE_MODE: 'uint32_t*',
    lib.TSI_PARAM_XORIGIN: 'uint32_t*',
    lib.TSI_PARAM_YORIGIN: 'uint32_t*',
    lib.TSI_PARAM_XPIXELS: 'uint32_t*',
    lib.TSI_PARAM_YPIXELS: 'uint32_t*',
    lib.TSI_PARAM_XBIN: 'uint32_t*',
    lib.TSI_PARAM_YBIN: 'uint32_t*',
    #lib.TSI_PARAM_IMAGE_ACQUISTION_MODE: 'uint32_t*',
    lib.TSI_PARAM_NAMED_VALUE: 'char[128]',
    lib.TSI_PARAM_TAPS_INDEX: 'uint32_t*',
    lib.TSI_PARAM_TAPS_VALUE: 'uint32_t*',
    #lib.TSI_PARAM_RESERVED_1: None,
    #lib.TSI_PARAM_RESERVED_2: None,
    #lib.TSI_PARAM_RESERVED_3: None,
    #lib.TSI_PARAM_RESERVED_4: None,
    lib.TSI_PARAM_GLOBAL_CAMERA_NAME: 'char[64]',
    lib.TSI_PARAM_CDS_GAIN_VALUE: 'uint32_t*',
    lib.TSI_PARAM_PIXEL_SIZE: 'float*',
    lib.TSI_PARAM_READOUT_TIME: 'float*',
    lib.TSI_PARAM_HW_TRIGGER_ACTIVE: 'uint32_t*',
    lib.TSI_PARAM_HW_TRIG_SOURCE: 'TSI_HW_TRIG_SOURCE*',
    lib.TSI_PARAM_HW_TRIG_POLARITY: 'TSI_HW_TRIG_POLARITY*',
    lib.TSI_PARAM_TAP_BALANCE_ENABLE: 'uint32_t*',
    lib.TSI_PARAM_DROPPED_FRAMES: 'uint32_t*',
    lib.TSI_PARAM_EXPOSURE_TIME_US: 'uint32_t*',
    #lib.TSI_PARAM_RESERVED_5: None,
    #lib.TSI_PARAM_RESERVED_6: None,
    #lib.TSI_PARAM_RESERVED_7: None,
    lib.TSI_PARAM_UPDATE_PARAMETERS: 'uint32_t*',
    #lib.TSI_PARAM_FEATURE_LIST: None,
    #lib.TSI_PARAM_FEATURE_VALID: None,
    lib.TSI_PARAM_NUM_IMAGE_BUFFERS: 'int32_t*',
    lib.TSI_PARAM_COLOR_FILTER_TYPE: 'char[32]',
    #lib.TSI_PARAM_COLOR_FILTER_PHASE: '',
    #lib.TSI_PARAM_IR_FILTER_TYPE: '',
    #lib.TSI_PARAM_COLOR_CAMERA_CORRECTION_MATRIX: None,
    #lib.TSI_PARAM_CCM_OUTPUT_COLOR_SPACE: None,
    #lib.TSI_PARAM_DEFAULT_WHITE_BALANCE_MATRIX: None,
    lib.TSI_PARAM_USB_ENABLE_LED: 'uint32_t*',
}


def from_enum(item):
    return item._value_ if isinstance(item, Enum) else item


def _strip_prefix(value, prefix):
    return value[len(prefix):] if value.startswith(prefix) else value


enum_map = {}


if 'sphinx' in sys.modules:
    class make_enum(object):
        def __init__(self, *args):
            pass
        def __getattr__(self, name):
            return name
else:
    def make_enum(name, c_name, prefix=''):
        ctype = ffi.typeof(c_name)
        d = {_strip_prefix(v, prefix):k for k,v in ctype.elements.items()}
        new_enum = Enum(name, d)
        enum_map[c_name] = new_enum
        return new_enum


Param = make_enum('Param', 'TSI_PARAM_ID', 'TSI_PARAM_')
ExpUnit = make_enum('ExpUnit', 'TSI_EXPOSURE_UNITS', 'TSI_EXP_UNIT_')
Status = make_enum('Status', 'TSI_CAMERA_STATUS', 'TSI_STATUS_')
AcqStatus = make_enum('AcqStatus', 'TSI_ACQ_STATUS_ID', 'TSI_ACQ_STATUS_')
TrigSource = make_enum('TrigSource', 'TSI_HW_TRIG_SOURCE', 'TSI_HW_TRIG_')
TrigPol = make_enum('TrigPol', 'TSI_HW_TRIG_POLARITY', 'TSI_HW_TRIG_')
OpMode = make_enum('OpMode', 'TSI_OP_MODE', 'TSI_OP_MODE_')


class TSI_DLL_SDK(object):
    def __init__(self):
        self._ll = lib.tsi_create_sdk()

    def destroy(self):
        log.info(""Destroying TSI_DLL_SDK"")
        self.Close()
        lib.tsi_destroy_sdk(self._ll)

    def Open(self):
        self._ll.vptr.Open(self._ll)

    def Close(self):
        log.info(""Closing TSI_DLL_SDK"")
        self._ll.vptr.Close(self._ll)

    def GetNumberOfCameras(self):
        return self._ll.vptr.GetNumberOfCameras(self._ll)

    def GetCamera(self, camera_number):
        cam_ptr = self._ll.vptr.GetCamera(self._ll, camera_number)
        if cam_ptr == ffi.NULL:
            raise Error(""Camera not found. Make sure you called GetNumberOfCameras first"")
        return TSI_DLL_Camera(cam_ptr)

    def GetCameraInterfaceTypeStr(self, camera_number):
        ret = self._ll.vptr.GetCameraInterfaceTypeStr(self._ll, camera_number)
        if ret == ffi.NULL:
            raise Error(""Camera not found. Make sure you called GetNumberOfCameras first"")
        return ffi.string(ret)

    def GetCameraAddressStr(self, camera_number, address_select):
        ret = self._ll.vptr.GetCameraAddressStr(self._ll, camera_number, address_select)
        if ret == ffi.NULL:
            raise Error(""Camera not found, or invalid address_select value for this camera. ""
                        ""Make sure you called GetNumberOfCameras first"")
        return ffi.string(ret)

    def GetCameraName(self, camera_number):
        ret = self._ll.vptr.GetCameraName(self._ll, camera_number)
        if ret == ffi.NULL:
            raise Error(""Camera not found. Make sure you called GetNumberOfCameras first"")
        return ffi.string(ret)

    def GetCameraSerialNumStr(self, camera_number):
        ret = self._ll.vptr.GetCameraSerialNumStr(self._ll, camera_number)
        if ret == ffi.NULL:
            raise Error(""Camera not found. Make sure you called GetNumberOfCameras first"")
        return ffi.string(ret)


sdk = TSI_DLL_SDK()
sdk.Open()
register_cleanup(sdk.destroy)


class TSI_DLL_Camera(object):
    def __init__(self, ptr):
        self._ll = ptr

    def Open(self):
        success = self._ll.vptr.Open(self._ll)
        if not success:
            raise Exception(""Opening camera failed"")

    def Close(self):
        log.info(""Closing TSI_DLL_Camera"")
        success = self._ll.vptr.Close(self._ll)
        if not success:
            raise Exception(""Closing camera failed"")

    def Status(self):
        p_status = ffi.new('TSI_CAMERA_STATUS*')
        success = self._ll.vptr.Status(self._ll, p_status)
        if not success:
            raise Exception(""Failed to get camera status"")
        return Status(p_status[0])

    def GetCameraName(self):
        return ffi.string(self._ll.vptr.GetCameraName(self._ll))

    def SetCameraName(self, name):
        success = self._ll.vptr.SetCameraName(self._ll, name)
        if not success:
            raise Exception(""Setting camera name failed"")

    def GetDataTypeSize(self, data_type):
        return self._ll.vptr.GetDataTypeSize(self._ll, data_type)

    def _param_data_type(self, param_id):
        p_data = ffi.new('TSI_DATA_TYPE*')
        self._ll.vptr.GetParameter(self._ll, lib.TSI_ATTR_DATA_TYPE, ffi.sizeof('TSI_DATA_TYPE'),
                                   p_data)
        return p_data[0]

    def GetParameter(self, param_id):
        param_id = from_enum(param_id)
        ctype = ffi.typeof(param_type[param_id])

        if ctype.kind == 'pointer':
            size = ffi.sizeof(ctype.item)
        else:
            size = ffi.sizeof(ctype)

        p_data = ffi.new(ctype)
        success = self._ll.vptr.GetParameter(self._ll, param_id, size, p_data)
        if not success:
            raise Exception(""Failed to get camera parameter"")

        if param_type[param_id].startswith('char'):
            return ffi.string(p_data)
        elif ctype.kind == 'enum':
            return enum_map[ctype.cname](p_data[0])
        else:
            return p_data[0]

    def SetParameter(self, param_id, data):
        param_id = from_enum(param_id)
        data = from_enum(data)

        ctype = ffi.typeof(param_type[param_id])
        if ctype.kind == 'array':
            p_data = data
        else:
            p_data = ffi.new(ctype, data)
        success = self._ll.vptr.SetParameter(self._ll, param_id, p_data)
        if not success:
            raise Exception(""Failed to set camera parameter"")

    def ResetCamera(self):
        ok = self._ll.vptr.ResetCamera(self._ll)
        if not ok:
            raise Exception(""Failed to reset camera"")

    def FreeImage(self, image):
        ok = self._ll.vptr.FreeImage(self._ll, image)
        if not ok:
            raise Exception(""Failed to free image"")

    def StartAndWait(self, timeout_ms):
        ok = self._ll.vptr.StartAndWait(self._ll, timeout_ms)
        if not ok:
            raise Exception(""Failed to start capture. Current camera parameters do not permit ""
                            ""operation of the camera."")

    def Start(self):
        ok = self._ll.vptr.Start(self._ll)
        if not ok:
            raise Exception(""Failed to start capture"")

    def Stop(self):
        ok = self._ll.vptr.Stop(self._ll)
        if not ok:
            raise Exception(""Failed to stop capture"")

    def GetAcquisitionStatus(self):
        return AcqStatus(self._ll.vptr.GetAcquisitionStatus(self._ll))

    def GetExposeCount(self):
        # This appears to always return zero
        return self._ll.vptr.GetExposeCount(self._ll)

    def GetFrameCount(self):
        return self._ll.vptr.GetFrameCount(self._ll)

    def WaitForImage(self, timeout_ms=-1):
        return self._ll.vptr.WaitForImage(self._ll, timeout_ms)

    def ResetExposure(self):
        return self._ll.vptr.ResetExposure(self._ll)

    def GetErrorCode(self):
        return self._ll.vptr.GetErrorCode(self._ll)

    def ClearError(self):
        ok = self._ll.vptr.ClearError(self._ll)
        if not ok:
            raise Exception(""Failed to clear error"")

    def GetErrorStr(self, code):
        ptr_size = ffi.new('int*', 256)
        buf = ffi.new('char[]', ptr_size[0])
        ok = self._ll.vptr.GetErrorStr(self._ll, code, buf, ptr_size)
        if not ok:
            raise Exception(""Failed to get error string"")
        return ffi.string(buf)

    def GetLastErrorStr(self):
        msg = self._ll.vptr.GetLastErrorStr(self._ll)
        return ffi.string(msg)

    def GetPendingImage(self):
        return self._ll.vptr.GetPendingImage(self._ll)


def _rw_property(param):
    def fget(self):
        return self._get_parameter(param)

    def fset(self, value):
        self._set_parameter(param, value)

    return property(fget, fset)


def _ro_property(param):
    def fget(self):
        return self._get_parameter(param)
    return property(fget)


class TSI_Camera(Camera):
    DEFAULT_KWDS = Camera.DEFAULT_KWDS.copy()
    DEFAULT_KWDS.update(trig='auto', rising=True)

    class TriggerMode(Enum):
        auto = OpMode.NORMAL
        """"""Auto-trigger as fast as possible once capture has started""""""
        software = auto
        """"""Alias for `auto`""""""
        hw_edge = OpMode.TOE
        """"""Trigger a single exposure on an edge, using a software-defined exposure time""""""
        hw_bulb = OpMode.PDX
        """"""Trigger a single exposure on an edge of a pulse, and stop the exposure at the end of the
        pulse
        """"""

    def _initialize(self):
        sdk.GetNumberOfCameras()
        self._partial_sequence = []
        self._next_frame_idx = 0
        self._tot_frames = None  # Zero means 'infinite' capture
        self._trig_mode = None
        self._dev = sdk.GetCamera(self._paramset.get('number', 0))

        if self._dev.Status() != Status.CLOSED:
            raise Error(""Camera is already open"")

        self._dev.Open()
        self._set_parameter(Param.EXPOSURE_UNIT, ExpUnit.MILLISECONDS)

    def close(self):
        log.info('Closing TSI camera...')
        self._dev.Stop()
        self._dev.Close()

    def _get_parameter(self, param_id):
        return self._dev.GetParameter(param_id)

    def _set_parameter(self, param_id, data):
        self._dev.SetParameter(param_id, data)

    @check_units(exp_time='ms')
    def _set_exposure_time(self, exp_time):
        time_ms = int(exp_time.m_as('ms'))
        self._set_parameter(Param.EXPOSURE_TIME, time_ms)

    def _get_exposure_time(self):
        return self._get_parameter(Param.EXPOSURE_TIME) * u.ms

    def _set_ROI(self, params):
        roi_data = {
            'XOrigin': int(params['left']),
            'YOrigin': int(params['top']),
            'XPixels': int(params['right'] - params['left']),
            'YPixels': int(params['bot'] - params['top']),
            'XBin': int(params['hbin']),
            'YBin': int(params['vbin']),
        }
        self._set_parameter(Param.ROI_BIN, roi_data)

    def _get_ROI(self):
        return self._get_parameter(Param.ROI_BIN)

    def _set_n_frames(self, n_frames):
        # Ensure only one exposure per HW edge trigger
        if self._trig_mode == self.TriggerMode.hw_edge:
            n_frames = 1
        self._set_parameter(Param.FRAME_COUNT, n_frames)

    def grab_image(self, timeout='1s', copy=True, **kwds):
        self.start_capture(**kwds)
        try:
            images = self.get_captured_image(timeout=timeout, copy=copy, **kwds)
        finally:
            self._dev.Stop()
        return images

    def cancel_capture(self):
        """"""Cancel a capture sequence, cleaning up and stopping the camera""""""
        self._dev.Stop()

    @check_units(timeout='?ms')
    def get_captured_image(self, timeout='1s', copy=True, wait_for_all=True, **kwds):
        image_arrs = []

        if self._tot_frames and self._next_frame_idx >= self._tot_frames:
            raise Error(""No capture initiated. You must first call start_capture()"")

        start_time = clock() * u.s
        while self._next_frame_idx < self._tot_frames:
            if timeout is None:
                frame_ready = self.wait_for_frame(timeout=None)
            else:
                elapsed_time = clock() * u.s - start_time
                frame_ready = self.wait_for_frame(timeout - elapsed_time)

            if not frame_ready:
                if wait_for_all or not image_arrs:
                    self._partial_sequence.extend(image_arrs)  # Save for later
                    raise TimeoutError(""Timed out while waiting for image readout"")
                else:
                    break

            array = self.latest_frame(copy)
            image_arrs.append(array)
        image_arrs = self._partial_sequence + image_arrs

        if self._tot_frames and self._next_frame_idx >= self._tot_frames:
            self._dev.Stop()
            self._partial_sequence = []

        if len(image_arrs) == 1:
            return image_arrs[0]
        else:
            return tuple(image_arrs)

    def start_capture(self, **kwds):
        self._handle_kwds(kwds)

        self._set_ROI(kwds)
        self._set_exposure_time(kwds['exposure_time'])
        self._set_trig_mode(kwds['trig'], kwds['rising'])
        self._set_n_frames(kwds['n_frames'])
        self._tot_frames = kwds['n_frames']
        self._partial_sequence = []
        self._next_frame_idx = 0

        self._dev.Stop()  # Ensure old captures are finished
        self._dev.Start()

    @unit_mag(timeout='?s')
    def wait_for_frame(self, timeout=None):
        timeout_s = timeout
        start_time = clock()

        while True:
            img = self._dev.GetPendingImage()
            if img != ffi.NULL:
                self._latest_tsi_img = img
                self._next_frame_idx += 1
                return True

            elapsed_time = clock() - start_time
            if timeout_s is not None and elapsed_time > timeout_s:
                return False

    def latest_frame(self, copy=True):
        # Frees the TSI image buffer if `copy` is true. Otherwise, it's the user's responsibility
        # If no buffers are available for use, the frame count will never increment, and
        # wait_for_frame will block (until its timeout is reached)
        img = self._arr_from_img_struct(self._latest_tsi_img, copy)
        self._dev.FreeImage(self._latest_tsi_img)
        return img

    def _arr_from_img_struct(self, tsi_img, copy):
        p_buf = tsi_img.m_PixelData.ui16
        # Note: m_SizeInBytes doesn't seem to work correctly
        frame_size = tsi_img.m_Width * tsi_img.m_Height * tsi_img.m_BytesPerPixel
        self._tsi_img = tsi_img

        if copy:
            image_buf = memoryview(ffi.buffer(p_buf, frame_size)[:])
        else:
            image_buf = memoryview(ffi.buffer(p_buf, frame_size))

        # Convert to array (currently assumes mono16)
        array = np.frombuffer(image_buf, np.uint16)
        array = array.reshape((tsi_img.m_Height, tsi_img.m_Width))

        return array

    def start_live_video(self, **kwds):
        self._handle_kwds(kwds)

        self._set_ROI(kwds)
        self._set_trig_mode(self.TriggerMode.auto)
        self._set_exposure_time(kwds['exposure_time'])
        self._set_n_frames(0)
        self._tot_frames = 0
        self._next_frame_idx = 0

        self._dev.Stop()  # Ensure old captures are finished
        self._dev.Start()

    def stop_live_video(self):
        self._dev.Stop()

    def _set_trig_mode(self, mode, rising=True):
        self._trig_mode = mode = as_enum(self.TriggerMode, mode)
        use_hw_trigger = (mode != self.TriggerMode.auto)
        trig_source = mode.value
        polarity = TrigPol.ACTIVE_HIGH if rising else TrigPol.ACTIVE_LOW

        self._set_parameter(Param.HW_TRIGGER_ACTIVE, use_hw_trigger)
        self._set_parameter(Param.OP_MODE, trig_source)
        self._set_parameter(Param.HW_TRIG_POLARITY, polarity)

    @property
    def name(self):
        return self._dev.GetCameraName()

    @name.setter
    def name(self, name):
        self._dev.SetCameraName(name)

    @property
    def max_width(self):
        sensor_width = self._get_parameter(Param.HSIZE)
        xbin = self._get_parameter(Param.XBIN)
        return sensor_width // xbin

    @property
    def max_height(self):
        sensor_height = self._get_parameter(Param.VSIZE)
        ybin = self._get_parameter(Param.YBIN)
        return sensor_height // ybin

    model = _ro_property(Param.HW_MODEL)
    serial = _ro_property(Param.HW_SER_NUM)
    led_on = _rw_property(Param.USB_ENABLE_LED)

    width = _rw_property(Param.XPIXELS)
    height = _rw_property(Param.YPIXELS)


def list_instruments():
    cameras = []
    for i in range(sdk.GetNumberOfCameras()):
        cam_ser = sdk.GetCameraSerialNumStr(i)
        params = ParamSet(TSI_Camera, serial=cam_ser, number=i)
        cameras.append(params)
    return cameras
"
148,,Attocube,Attocube ECC 100,Instrumental,"The ECC100 is a state-ofthe-art motion controller, allowing the simultaneous operation of up to three positioners from attocube’s industrial ECS Drive series.",https://instrumental-lib.readthedocs.io/en/0.3.1/ecc100.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/motion/ecc100.py,Attocube ECC 100,"[OrderedDict([('id', 'attT8ecDBvpxYrTlB'), ('width', 850), ('height', 550), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/rSHDJCR2QZs0cWgRKEMEOQ/KVNEIh9w9Dr1X3H-U5AIZr3yothFFk22hzoIbYBnUDg6dNwyXGxp3eubp7WhSElw5HDUD3FRMK1OkrsM9y6M98OfRJkS22XZ-hh0LRMU9bw/FfN7Ryz5oSMEgM-jvmyTYArvu_eMVUE9ZH0ul4Rumc0'), ('filename', 'ECC100_Legacy.png'), ('size', 47654), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/pKI_UV8mYQUoDgzUMCpJAA/26NIEXdcQ08L76ATeEoB7Qnvol6J6gth_4193pNYTR5eCSHT0IxM_eO6EMptXkNQxeQrmB3oW3oncaJ_GXzxaQ/aMfQ-K4bHnwsjpgzEjECdfQN8awXVTt-_mqjvHQs3oY'), ('width', 56), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/N-ENEE7a4BM7-L9iS9j9iA/KzBihl3N_LGsGMb8Q4J0Pczo6ypbKSixChnYhfLX_d5qG2ZA_wHdWeWnGjXUZSh3mFyx5-rwxgEalFp92g8tEw/NLZNtUimY7tIwwEGFHX_YYKmGbYZV4_XWbrYZTfA_ZA'), ('width', 791), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/e6xoGjQ4meWZFvOfagZ7Rw/4w6NKVEXdl1LFmEy8l8mvc8y0rMzPdC2GXr5GsMclhLkoxuwxZiPO3_jppKcr8cNj9DcG4SVbxBjoCZwCVx-zg/ocwLqbmZF45LEWyWcPBGCUZozCKUHFQF4E2SSdDo2Ik'), ('width', 3000), ('height', 3000)]))]))])]",https://www.observatorysciences.co.uk/assets/uploads/downloads/ECC100_Developers_Manual_V1-0.pdf,['Motion'],"[OrderedDict([('id', 'att3WtxPNsVQ6tRkf'), ('width', 711), ('height', 165), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/b10hJSWoKf9UASBILF0Ijg/b_kwwtyYjb4qVkM2BGzOk-XDUcjbBtBZ4IKub0kmtb2ZM9kLIb2PVk3ew1lgudHT6vrRc63u_ZBI5MnSGCJEXmT2GktfaOMC26Q0DV4Kn-4/6Jts0-464pxLpJOvVaOVVh4sJQjzG5rBgP7ZEdxEB7c'), ('filename', 'attocube_systems.png'), ('size', 42332), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/8ad1qNQCD822gGEC5XlkVA/sUrJeErl4IPhdkKMvn_JgaqS_yDFv19Izm1rvuipsBhwpH8svSpKGxEmO4xoaQznSThT5K8A5JSveHV4sb3feg/CeK-kiD-5Yajq3IEBQzvwn8_FUXGjc441oBfSmcySR8'), ('width', 155), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/NFtALxJI2svBdE93p9O0CQ/ylWfnBZWdArYl-N-078xvMVDYzLiLHi44Ol9kFkHXmXhTJ8Ws2iQ62uAvwZNX8EWPadZhv7VVdK4g__9rMZvLA/jDSYwIDbzUru2HUyybtrYm9VASg7OoQTcBXa1-r9rmc'), ('width', 711), ('height', 165)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/_YBZDZoUxDRO0B92No67hw/cKwyIgETGO4f4Z7SXSKu8zGGPnC3eDDks-pgDSTDRS46xB3CyHXKnt1xev448aEBZIThYUtYX95cYVttFARRtA/PTC6uXh25ZNjooT7c166TZzBESX4nVtSXM1T4114FJc'), ('width', 3000), ('height', 3000)]))]))])]","**Attocube** is a leading pioneer for nanotechnology solutions in precision motion and nanopositioning applications, cryogenic microscopy,

",https://www.attocube.com/en,https://www.attocube.com/application/files/6416/3697/3543/Specifications_ECC100.pdf,Germany,14.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumental to connect to a {Device name} Motion,,,,,"# -*- coding: utf-8 -*-
# Copyright 2014-2017 Chris Rogers, Nate Bogdanowicz
""""""Driver module for Attocube stages.

Interfaces with the ECC100 controller, which has support for various stages:
    * ECS3030
    * ECS3040
    * ECS3050
    * ECS3060
    * ECS3070
    * ECS3080
    * ECS5050
    * ECGp5050
    * ECGt5050
    * ECR3030

Note that ecc.dll must be on the system path, and that this is a windows only
driver.
""""""

from __future__ import print_function

import warnings
warnings.warn(
    ""Driver {!r} is out of date and incompatible with the current Instrumental core. ""
    ""Pull requests fixing this are welcome."".format(__name__)
)

import time
from enum import Enum
from ctypes import (c_int32, c_bool, byref, create_string_buffer,
                    Structure, POINTER, oledll)
from . import Motion
from .. import ParamSet
from ..util import check_units, check_enums
from ...errors import InstrumentNotFoundError
from ... import Q_

_INST_PARAMS = ['id']
_INST_CLASSES = ['ECC100']

# __all__ = ['LinearStage', 'Goniometer', 'RotationStage', 'ECC100']

lib = oledll.LoadLibrary('ecc.dll')
_err_map = {
    -1: 'Unspecified error.',
    1: 'Communication timeout.',
    2: 'No active connection to device.',
    3: 'Error in communication with driver.',
    7: 'Device is already in use.',
    9: 'Parameter out of range.',
    10: 'Feature only available in pro version.'
}


def list_instruments():
    _, info_list = check_for_devices()
    return [ParamSet(ECC100, id=info.id) for info in info_list]


def check_for_devices():
    """""" Checks for devices, returns their info and how many there are.

    Returns
    -------
    num : int
        number of devices connected
    info : list of EccInfo
        info list. Each EccInfo object has the attributes 'id', and
        'locked'
    """"""
    info = POINTER(EccInfo)()
    num = lib.ECC_Check(byref(info))

    info_list = [info[i] for i in range(num)]
    return num, info_list

class EccInfo(Structure):
    _fields_ = [('id', c_int32), ('locked', c_bool)]


class Actor(Motion):
    def __init__(self, controller, axis):
        self._c = controller
        self.axis = axis
        self.name = self._c._getActorName(self.axis)
        self.type = self._c._getActorType(self.axis)
        self.enable()

    def __repr__(self):
        return ""<{} {}, axis={}>"".format(self.__class__.__name__, self.name,
                                         self.axis)

    def enable(self):
        """""" Enables communication from the controller to the stage. """"""
        self._c._controlOutput(self.axis, enable=True, set=True)

    def disable(self):
        """""" Disables communication from the controller to the stage. """"""
        self._c._controlOutput(self.axis, enable=False, set=True)

    def is_enabled(self):
        """""" Returns whether communication to the stage is enabled. """"""
        return self._c._controlOutput(self.axis, set=False)

    def is_ref_position_valid(self):
        """""" Returns whether the reference position is valid. """"""
        return self._c._getStatusReference(self.axis)

    @check_units(amplitude='mV')
    def set_amplitude(self, amplitude):
        """""" Sets the amplitude of the actuator signal.

        This modifies the step size of the positioner.

        Parameters
        ----------
        amplitude : pint.Quantity
            amplitude of the actuator signal in volt-compatible units. The
            allowed range of inputs is from 0 V to 45 V.
        """"""
        amp_in_mV = int(Q_(amplitude).to('mV').magnitude)
        if not (0 <= amp_in_mV <= 45e3):
            raise Exception(""Amplitude must be between 0 and 45 V"")
        self._c._controlAmplitude(self.axis, amp_in_mV, set=True)

    def get_amplitude(self):
        """""" Gets the amplitude of the actuator signal. """"""
        amp_in_mV = self._c._controlAmplitude(self.axis, set=False)
        return Q_(amp_in_mV, 'mV').to('V')

    @check_units(frequency='Hz')
    def set_frequency(self, frequency):
        """""" Sets the frequency of the actuation voltage applied to the stage.

        The frequency is proportional to the travel speed of the positioner.

        Parameters
        ----------
        frequency : pint.Quantity
            frequency of the actuator signal in Hz-compatible units. The
            allowed range of inputs is from 1 Hz to 2 kHz.
        """"""
        freq_in_mHz = int(Q_(frequency).to('mHz').magnitude)
        if not (1e3 <= freq_in_mHz <= 2e6):
            raise Exception(""Frequency must be between 1 Hz and 2 kHz"")
        self._c._controlFrequency(self.axis, freq_in_mHz, set=True)

    def get_frequency(self):
        """""" Gets the frequency of the actuator signal. """"""
        freq_in_mHz = self._c._controlFrequency(self.axis, set=False)
        return Q_(freq_in_mHz, 'mHz').to('Hz')

    def step_once(self, backward=False):
        """""" Step once. """"""
        self._c._setSingleStep(self.axis, backward)

    def start_stepping(self, backward=False):
        """"""
        Step continously until stopped.

        This will stop any ongoing motion in the opposite direction.
        """"""
        if backward:
            self._c._controlContinuousBkwd(self.axis, enable=True, set=True)
        else:
            self._c._controlContinuousFwd(self.axis, enable=True, set=True)

    def stop_stepping(self):
        """""" Stop any continuous stepping. """"""
        if self.is_stepping_backward():
            self._c._controlContinuousBkwd(self.axis, enable=False, set=True)
        elif self.is_stepping_forward():
            self._c._controlContinuousFwd(self.axis, enable=False, set=True)

    def is_stepping_backward(self):
        return self._c._controlContinuousBkwd(self.axis, set=False)

    def is_stepping_forward(self):
        return self._c._controlContinuousFwd(self.axis, set=False)

    def get_position(self):
        """""" Returns the current postion""""""
        pos = self._c._getPosition(self.axis)
        return Q_(pos, self._pos_units)

    def get_ref_position(self):
        """""" Returns the current reference positoin""""""
        pos = self._c._getReferencePosition(self.axis)
        return Q_(pos, self._pos_units)

    def enable_feedback(self, enable=True):
        """""" Control the positioning feedback-control loop

        enable: bool, where False corresponds to OFF and True corresponds to ON
        """"""
        self._c._controlMove(self.axis, enable, set=True)

    @check_units(duration='s')
    def timed_move(self, direction, duration):
        """""" Moves in the specified direction for the specified
        duration.

        direction: bool controlling the direciton of movement.  True
        corresponds to the positive direction for linear stages and the
        negative direction for goniometers

        duration: duration of motion, a pint quantity with units of time
        """"""
        self._c._setContinuous(self.axis, direction, control=True)
        time.sleep(duration.to('s').magnitude)
        self._c._setContinuous(self.axis, direction, control=False)

    def is_feedback_on(self):
        """""" Indicates if the feedback-control loop is ON
        (True) or OFF (False)
        """"""
        enable = self._c._controlMove(self.axis, set=False)
        return enable

    def set_target(self, target):
        """""" Sets the target position of the feedback control loop.

        target: target position, in nm for linear stages, in micro radians for
        goniometers
        """"""
        target = Q_(target)
        target_mag = target.to(self._pos_units).magnitude
        self._c._controlTargetPosition(self.axis, target_mag, set=True)

    def get_target(self):
        """""" Returns the target position of the feedback control loop.""""""
        targetPosition = self._c._controlTargetPosition(self.axis, set=False)
        return Q_(targetPosition, self._pos_units)

    def move_to(self, pos, wait=False):
        """""" Moves to a location using closed loop control. """"""
        pos = Q_(pos)
        self.set_target(pos)
        self.enable_feedback(True)

        if wait:
            self.wait_unitl_at_position()

    @check_units(update_interval='ms')
    def wait_until_at_position(self, update_interval='10 ms', delta_pos=None):
        """"""Waits to return until the actor is at the target position

        delta_pos is the margin within which the device is considered to be at
        the target position
        """"""
        at_target = self.at_target(delta_pos)
        while not at_target:
            time.sleep(update_interval.to('s').magnitude)
            at_target = self.at_target(delta_pos)
            if at_target:
                return

    def at_target(self, delta_pos=None):
        """""" Indicates whether the stage is at the target position.

        delta_pos is the tolerance within which the stage is considered
        'at position'
        """"""
        if delta_pos is None:
            if self._actor_type==ActorType.LinearStage:
                delta_pos = Q_('1nm')
            if self._actor_type==Goniometer:
                delta_pos = Q_('1 urad')
        target = self.get_target()
        position = self.get_position()
        delta = target - position
        delta = delta.to(self._pos_units).magnitude
        if delta <= delta_pos.to(self._pos_units).magnitude:
            return True
        else:
            return False


class LinearStage(Actor):
    def __init__(self, device, axis):
        super(LinearStage, self).__init__(device, axis)
        self._pos_units = 'nm'
        self._actor_type = ActorType.LinearStage


class Goniometer(Actor):
    def __init__(self, device, axis):
        super(Goniometer, self).__init__(device, axis)
        self._pos_units = 'micro radians'
        self._actor_type = ActorType.Goniometer


class RotationStage(Actor):
    pass

class ActorType(Enum):
    LinearStage = 0
    Goniometer = 1
    RotationStage = 2


class Status(Enum):
    idle =0
    moving = 1
    pending = 2


class Axis(Enum):
    one = 0
    two = 1
    three = 2


class ECC100(Motion):
    """"""
    Interfaces with the Attocube ECC100 controller. Windows-only.
    """"""
    def __init__(self, paramset):
        """""" Connects to the attocube controller.

        id is the id of the device to be connected to
        """"""

        self._lib = lib
        self.ActorType = ActorType
        self.Status = Status
        self.Axis = Axis

        num, info = self._Check()
        if num < 1:
            raise Exception(""No Devices Detected"")

        if 'id' not in paramset:
            # Attempt to connect to the first device
            self._dev_num = 0
        else:
            self._dev_num = self._get_dev_num_from_id(int(paramset['id']))
        self._Connect()
        self._load_actors()
        self._default_actors = self.actors

    def _handle_err(self, retval, message=None, func=None):
        """""" Handles the error codes returned from the functions in ecc.dll. """"""
        if retval == 0:
            return
        lines = []

        if message:
            lines.append(message)
        if func:
            lines.append(""Error returned by '{}'"".format(func))
        lines.append(_err_map[retval])

        raise Exception(""\n"".join(lines))

    def _load_actors(self):
        self.actors = []
        for cur_axis in range(3):
            cur_axis = Axis(cur_axis)
            if self._getStatusConnected(cur_axis):
                actor_type = ActorType(self._getActorType(cur_axis))
                if actor_type == ActorType.LinearStage:
                    actor = LinearStage(self, cur_axis)
                elif actor_type == ActorType.Goniometer:
                    actor = Goniometer(self, cur_axis)
                else:
                    actor = Actor(self, cur_axis)
                self.actors.append(actor)

    def _get_dev_num_from_id(self, device_id):
        N, info_list = self._Check()
        for i in range(N):
            if info_list[i].id==device_id:
                return i
        err_string = 'No ecc100 device with id matching {} found'.format(device_id)
        raise InstrumentNotFoundError(err_string)

    def _Check(self):
        """""" Checks for devices and returns their info and how many there are.

        Returns
        -------
        num : int
            number of devices connected
        info : list of EccInfo
            info list. Each EccInfo object has the attributes 'id', and
            'locked'
        """"""
        info = POINTER(EccInfo)()
        num = self._lib.ECC_Check(byref(info))

        info_list = [info[i] for i in range(num)]
        return num, info_list

    def close(self):
        """""" Closes the connection to the controller. """"""
        ret = self._lib.ECC_Close(self._dev_handle)
        self._handle_err(ret, func=""Close"")

    def _Connect(self):
        """"""
        Attempts to open a connection to the controller.

        If successful, sets
        the device handle self._dev_handle. Reads from self._dev_num.
        """"""
        handle = c_int32()
        ret = self._lib.ECC_Connect(self._dev_num, byref(handle))
        self._handle_err(ret, func=""Connect"")
        self._dev_handle = handle.value

    @check_enums(axis=Axis)
    def _controlActorSelection(self, axis, actor=0, set=False):
        """"""
        Controls the 'actor' property of a particular axis (ex. ECS3030)

        Parameters
        ----------
        axis : instance of Axis
            axis of control
        actor : int
            actor id, 0..255
        """"""
        actor = c_int32(actor)
        ret = self._lib.ECC_controlActorSelection(self._dev_handle, axis.value,
                                                  byref(actor), set)
        self._handle_err(ret, func=""controlActorSelection"")
        return actor.value

    @check_units(amplitude='mV')
    @check_enums(axis=Axis)
    def _controlAmplitude(self, axis, amplitude='0 mV', set=False):
        """""" Controls the applied voltage for the specified axis. """"""
        amplitude = c_int32(int(amplitude.to('mV').magnitude))
        ret = self._lib.ECC_controlAmplitude(self._dev_handle, axis.value,
                                             byref(amplitude), set)
        self._handle_err(ret, func=""controlAmplitude"")
        return Q_(amplitude.value, 'mV')

    @check_enums(axis=Axis)
    def _controlAutoReset(self, axis, enable=False, set=False):
        """""" Controls the auto-reset setting. """"""
        enable = c_int32(enable)
        ret = self._lib.ECC_controlAutoReset(self._dev_handle, axis.value,
                                             byref(enable), set)
        self._handle_err(ret, func=""controlAutoReset"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlContinuousBkwd(self, axis, enable=False, set=False):
        """""" Controls continuous backward motion of the specified axis. """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlContinousBkwd(self._dev_handle, axis.value,
                                                 byref(enable), set)
        self._handle_err(ret, func=""controlContinousBkwd"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlContinuousFwd(self, axis, enable=False, set=False):
        """""" Controls continuous forward motion of the specified axis. """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlContinousFwd(self._dev_handle, axis.value,
                                                byref(enable), set)
        self._handle_err(ret, func=""controlContinousFwd"")
        return bool(enable.value)

    def _controlDeviceId(self, id=0, set=False):
        """""" Controls the device identifier stored in the device flash. """"""
        id = c_int32(id)
        ret = self._lib.ECC_controlDeviceId(self._dev_handle, byref(id), set)
        self._handle_err(ret, func=""controlDeviceId"")
        return id.value

    @check_enums(axis=Axis)
    def _controlEotOutputDeactivate(self, axis, enable=False, set=False):
        """"""
        Controls whether the given axis should deactivate its output when end
        of travel (EOT) is reached.
        """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlEotOutputDeactive(self._dev_handle, axis.value,
                                                     byref(enable), set)
        self._handle_err(ret, func=""controlEotOutputDeactivate"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlExtTrigger(self, axis, enable=False, set=False):
        """""" Controls the input trigger for steps. """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlExtTrigger(self._dev_handle, axis.value,
                                              byref(enable), set)
        self._handle_err(ret, func=""controlExtTrigger"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    @check_units(voltage='uV')
    def _controlFixOutputVoltage(self, axis, voltage='0 uV', set=False):
        """""" Controls the DC level on the output in uV. """"""
        voltage = c_int32(int(voltage.to('uV').magnitude))
        ret = self._lib.ECC_controlFixOutputVoltage(self._dev_handle, axis.value,
                                                    byref(voltage), set)
        self._handle_err(ret, func=""controlFixOutputVoltage"")
        return Q_(voltage.value, 'uV')

    @check_enums(axis=Axis)
    @check_units(frequency='Hz')
    def _controlFrequency(self, axis, frequency='0 Hz', set=False):
        """""" Control the frequency parameter.  """"""
        frequency = c_int32(int(frequency.to('mHz').magnitude))
        ret = self._lib.ECC_controlFrequency(self._dev_handle, axis.value,
                                             byref(frequency), set)
        self._handle_err(ret, func=""controlFrequency"")
        return Q_(frequency.value, 'mHz')

    @check_enums(axis=Axis)
    def _controlMove(self, axis, enable=False, set=False):
        """"""
        Controls the feedback-control loop used for positioning the specified
        axis.
        """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlMove(self._dev_handle, axis.value,
                                        byref(enable), set)
        self._handle_err(ret, func=""controlMove"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlOutput(self, axis, enable=False, set=False):
        """""" Controls the 'output' state of a specific axis. """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlOutput(self._dev_handle, axis.value,
                                          byref(enable), set)
        self._handle_err(ret, func=""controlOutput"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlReferenceAutoUpdate(self, axis, enable=False, set=False):
        """""" Controls the reference auto update setting. """"""
        enable = c_bool(enable)
        ret = self._lib.ECC_controlReferenceAutoUpdate(self._dev_handle, axis.value,
                                                       byref(enable), set)
        self._handle_err(ret, func=""controlReferenceAutoUpdate"")
        return bool(enable.value)

    @check_enums(axis=Axis)
    def _controlTargetPosition(self, axis, target=0, set=False):
        """""" Control the target position of the feedback control loop. """"""
        target = c_int32(int(target))
        ret = self._lib.ECC_controlTargetPosition(self._dev_handle, axis.value,
                                                  byref(target), set)
        self._handle_err(ret, func=""controlTargetPosition"")
        return target.value

    @check_enums(axis=Axis)
    def _controlTargetRange(self, axis, target_range=0, set=False):
        """"""
        Control the range around the target position where the stage is
        considered to be at the target.
        """"""
        target_range = c_int32(int(target_range))
        ret = self._lib.ECC_controlTargetRange(self._dev_handle, axis.value,
                                               byref(target_range), set)
        self._handle_err(ret, func=""controlTargetRange"")
        return target_range.value

    @check_enums(axis=Axis)
    def _getActorName(self, axis):
        """""" Returns the name of the 'actor' of the specified axis. """"""
        buf = create_string_buffer(20)
        ret = self._lib.ECC_getActorName(self._dev_handle, axis.value, buf)
        self._handle_err(ret, func=""getActorName"")
        return buf.value.strip()

    @check_enums(axis=Axis)
    def _getActorType(self, axis):
        """""" Returns  an int corrsesponding to the type of actor associated with
        the specified axis.
        """"""
        _type = c_int32()
        ret = self._lib.ECC_getActorType(self._dev_handle, axis.value,
                                         byref(_type))
        self._handle_err(ret, func=""getActorType"")
        return ActorType(_type.value)

    def _getDeviceInfo(self):
        """"""
        Returns the device ID and a boolean that indicates whether or not the
        device is locked.
        """"""
        dev_id = c_int32(0)
        locked = c_bool(0)
        ret = self._lib.ECC_getDeviceInfo(self._dev_num, byref(dev_id),
                                          byref(locked))
        self._handle_err(ret, func=""getDeviceInfo"")
        return dev_id.value, locked.value

    @check_enums(axis=Axis)
    def _getPosition(self, axis):
        """"""
        Returns the position of the stage on the specifed axis (in nm for
        linear stages, micro radians for goniometers).
        """"""
        position = c_int32()
        ret = self._lib.ECC_getPosition(self._dev_handle, axis.value,
                                        byref(position))
        self._handle_err(ret, func=""getPosition"")
        return position.value

    @check_enums(axis=Axis)
    def _getReferencePosition(self, axis):
        """"""
        Returns the reference position of the stage on the specifed axis (in nm
        for linear stages, micro radians for goniometers).
        """"""
        reference = c_int32()
        ret = self._lib.ECC_getReferencePosition(self._dev_handle, axis.value,
                                                 byref(reference))
        self._handle_err(ret, func=""getReferencePosition"")
        return reference.value

    @check_enums(axis=Axis)
    def _getStatusConnected(self, axis):
        """""" Returns whether actor given by `axis` is connected or not. """"""
        connected = c_int32()
        ret = self._lib.ECC_getStatusConnected(self._dev_handle, axis.value,
                                               byref(connected))
        self._handle_err(ret)
        return bool(connected.value)

    @check_enums(axis=Axis)
    def _getStatusEotBkwd(self, axis):
        """"""
        Returns whether the given axis is at the end of travel (EOT) in the
        backward direction.
        """"""
        at_eot = c_bool()
        ret = self._lib.ECC_getStatusEotBkwd(self._dev_handle, axis.value,
                                             byref(at_eot))
        self._handle_err(ret, func=""getStatusEotBkwd"")
        return bool(at_eot.value)

    @check_enums(axis=Axis)
    def _getStatusEotFwd(self, axis):
        """"""
        Returns whether the given axis is at the end of travel (EOT) in the
        forward direction.
        """"""
        at_eot = c_bool()
        ret = self._lib.ECC_getStatusEotFwd(self._dev_handle, axis.value,
                                            byref(at_eot))
        self._handle_err(ret, func=""getStatusEotFwd"")
        return bool(at_eot.value)

    @check_enums(axis=Axis)
    def _getStatusError(self, axis):
        """""" Returns True if there is an error due to sensor malfunction. """"""
        has_err = c_bool()
        ret = self._lib.ECC_getStatusError(self._dev_handle, axis.value,
                                           byref(has_err))
        self._handle_err(ret, func=""getStatusError"")
        return bool(has_err.value)

    @check_enums(axis=Axis)
    def _getStatusFlash(self, axis):
        """""" Returns whether the flash is being written to or not. """"""
        flash_is_writing = c_bool()
        ret = self._lib.ECC_getStatusFlash(self._dev_handle, axis.value,
                                           byref(flash_is_writing))
        self._handle_err(ret, func=""getStatusFlash"")
        return bool(flash_is_writing.value)

    @check_enums(axis=Axis)
    def _getStatusMoving(self, axis):
        """"""
        Returns whether the specified axis is idle, moving or pending.

        Returns
        -------
        instance of Status
        """"""
        moving = c_int32()
        ret = self._lib.ECC_getStatusMoving(self._dev_handle, axis.value,
                                            byref(moving))
        self._handle_err(ret, func=""getStatusMoving"")
        return Status(moving.value)

    @check_enums(axis=Axis)
    def _getStatusReference(self, axis):
        """""" Checks whether or not the reference position is valid. """"""
        status = c_bool()
        ret = self._lib.ECC_getStatusReference(self._dev_handle, axis.value,
                                               byref(status))
        self._handle_err(ret, func=""getStatusReference"")
        return bool(status.value)

    @check_enums(axis=Axis)
    def _getStatusTargetRange(self, axis):
        """""" Returns whether the stage is considered to be at its target. """"""
        at_target = c_bool()
        ret = self._lib.ECC_getStatusTargetRange(self._dev_handle, axis.value,
                                                 byref(at_target))
        self._handle_err(ret, func=""getStatusTargetRange"")
        return bool(at_target.value)

    @check_enums(axis=Axis)
    def _setReset(self, axis):
        """""" Resets the reference position to the current position.  """"""
        ret = self._lib.ECC_setReset(self._dev_handle, axis.value)
        self._handle_err(ret, func=""resetReference"")

    @check_enums(axis=Axis)
    def _setSingleStep(self, axis, backward):
        """""" Causes the stage along the specified axis to take a single 'step'

        direction = 0 -> positive movement for linear stages, and negative
        movement for goniometers

        direction = 1 -> negative movement for linear stages, and positive
        movement for goniometers
        """"""
        ret = self._lib.ECC_setSingleStep(self._dev_handle, axis.value,
                                          backward)
        self._handle_err(ret, func=""setSingleStep"")

    # As-yet unconverted functions below here

    @check_enums(axis=Axis)
    def _set_actor(self, axis, actor_id):
        """""" Sets the 'actor' property of the specified axis

        Parameters
        ----------
        actor:  int
            id corresponding to a particular `actor`
        """"""
        ret = self._controlActorSelection(axis.value, actor_id, set=True)
        self._handle_err(ret, func=""constrolActorSelection"")

    @check_enums(axis=Axis)
    def _get_actor(self, axis):
        """"""
        Returns the 'actor' property (as an integer) of the specified axis
        """"""
        actor = self._controlActorSelection(axis.value, set=False)
        return actor

    @check_enums(axis=Axis)
    def _setContinuous(self, axis, forward, control):
        """""" Allows for control of continuous movement for the specified actor

        forward = True -> movement in the positive direction for
        linear stages, and in the negative direction for goniometers

        forward = False -> movement in the negative direction for
        linear stages, and in the positive direction for goniometers

        control = True -> start motion in the specified direction

        control = False -> stop all continuous motion on the specified axis
        """"""
        if type(forward)!=bool:
            raise TypeError('forward must be a boolean')
        if forward:
            self.controlContinuousFwd(axis, control, set=True)
        if not forward:
            self.controlContinuousBkwd(axis, control, set=True)

    def set_default_actors(self, actors):
        """""" Sets the default list of actors used in various functions.

        Actors should be a list of instances of Actor
        """"""
        for actor in actors:
            if not isinstance(Actor):
                raise TypeError(""actors must be a list of instances of Actor"")
        self._default_actors = actors

    def wait_until_at_position(self, actors=None, delta_pos=None):
        """"""Waits to return until all actors are at the target
        position

        If actors is None, then the default actors are used.  The default actors
        are set using set_default_actors
        """"""
        if actors is None:
            actors = self._default_actors
        if delta_pos is None:
            delta_pos = [None for i in range(len(actors))]
        for actor, delta in zip(actors, delta_pos):
            actor.wait_until_at_position(delta_pos=delta)

    def move_to(self, positions, actors=None, wait=False):
        """""" Moves to the positions in the list positions.

        actors is a list of type Actor, or one can use the default actors, set
        by set_default_actors
        """"""
        if actors is None:
            actors = self._default_actors
        if len(actors) != len(positions):
            raise ValueError(""positions must have the same length as actors"")
        for actor, position in zip(actors, positions):
            actor.move_to(position)
        if wait:
            self.wait_until_at_position(actors)

    def get_target(self, actors=None):
        """""" Gets the target positions of the actors in the list actors.

        Returns a list of target positions.

        actors is a list of type Actor, or one can use the default actors, set
        by set_default_actors
        """"""
        targets = []
        if actors is None:
            actors = self._default_actors
        for actor in actors:
            targets.append(actor.get_target())
        return targets

    def set_target(self, target, actors=None):
        """""" Sets the target positions of the actors in the list actors.

        target is a list of position that are unitful pint quantities

        actors is a list of type Actor, or one can use the default actors, set
        by set_default_actors
        """"""
        if actors is None:
            actors = self._default_actors
        for actor, pos in zip(actors, target):
            actor.set_target(pos)

    def get_position(self, actors=None):
        """""" Gets the positions of the actors in the list actors.

        actors is a list of type Actor, or one can use the default actors, set
        by set_default_actors
        """"""
        targets = []
        if actors is None:
            actors = self._default_actors
        for actor in actors:
            targets.append(actor.get_position())
        return targets
"
193,,Thorlabs,"DCx Series
",Instrumental,"DCU224C - CCD Camera, 1280 x 1024 Resolution, Color, USB 2.0 ",https://instrumental-lib.readthedocs.io/en/stable/uc480-cameras.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/cameras/uc480.py,Thorlab DCU224C (Example),"[OrderedDict([('id', 'attcWK1mi1vITqbL4'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/74Y04RoZXX4nRX5qrFa1zA/rzZOZsPiI2hz31UlJRBrXATN2UietbO9h2A7DuxREPijcaNaAE5OB9Zy2LGlslh5qm99fln_zBGzq4sdLyxe_Fs0q9sjn9QkrinIe4d3oAM/SIEUAW5jguxc1Keaunxn3Pkdk3eVEqDmXeteIvF36oo'), ('filename', '15985-std.jpg'), ('size', 6487), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/KNopvs2YVT3wsYsqUF3kYw/VguFT1m24FySu0FSm9L322dItCRHp3OMi_JMCl3qKb_luSwig9qhtxCKKrRxnVR_k5NkInupU2Ot13-jecdavA/Q3LptCXyfOiJcHGZUW-Ibnncg4MpivRDTVh-SjWn1Yo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/sRogme3XdDwDUXmUAGvaEA/CDIGSkLmC94xN6bXsJOFtmYd8JvPrCJhKOz4EHfmwqkv4Z84kKpTQULVuzmxN51JAT5GOzfcmpVMMvxEQiOnVw/hZN3X7kgKmSwhvZw-40GFfdWptvlavqOOdvtE_f1PMc'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/mWczQjGs1cMlm-Y3bFpljw/bT3wqx3ve4yBRBG3ofSwCjKMYM2hX5lZxQbCR8of5SLwhp68HtQpjh7Xjq6PPND3bxR6BSDdyRL-GKuyAP3-uA/WLbIq7MmBT5UGhxgrzoF9sNXDBcGBRB2zlcWudd1uSM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/thorproduct.cfm?partnumber=DCU224C,['Cameras'],"[OrderedDict([('id', 'attUZyCLkkmIuEgLg'), ('width', 2560), ('height', 398), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/IpVdg5h66qcP5fQupHixWw/L4zWVcBMKSljETAVSR8gGnaULDF7mRFX2K8Y_onNjJ_np62joMIp0jXKYAa3O03b5TXy1wWvgTNqAmE1r9cdDEPEcQDBP3MbkGRjQQxPnYE/py3pp2bwaCEmkZMr1IpQQG9RBYnEsMcoHEWZilYpS50'), ('filename', 'Image.png'), ('size', 70770), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/uW66V2CF2fNhJnRxF0J6fA/Pv2-LqsTrZGPH1tXjbSF17nQP4vUws2uALbApkEnzkST0q-D8u9rdfv8JM4tQYTvK4wHEzLr1riMilSBhiR6-A/jNldDMqu7cH1SQMuTSUqtcouTV3BeISjypseu6DoqAM'), ('width', 232), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/n00bWyqMiS_PmN1FdO6uSA/UsC-PTHfcl55UudUDWfVBpWyBO6pTGZ6AbYKMY-2CIx3cWewU6FNWsb-Q4daHe4CwqF-nluIBcGneZf3cVtdzQ/qnmFdd7wmPMmdjKULV_XbUiMwcS52NCWqd7RV1l4N6Y'), ('width', 2560), ('height', 398)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/6xmbSrRsXVitp4DhUmplfA/Al4hRmtCtrXIL5D8_ONlSCLh97HSS_LkHZeWBrKoNwAlBzkWNyHXBYXT6zTuAPwVPe9gqvYDlhrJymMQuVlugA/R-r6N4hbkal-yyljiQbzYNEX-kuz6iBhajrwVFlUoH4'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=ITN000493-D02.pdf&partNumber=DCU224C,USA,550.0,"A camera module is an image sensor integrated with a lens, control electronics, and an interface like CSI, Ethernet or plain raw low-voltage differential signaling.",https://en.wikipedia.org/wiki/Camera_module,Write a Python script that uses Instrumental to connect to a Thorlab DCU224C (Example) Cameras,,,True,,"# -*- coding: utf-8 -*-
# Copyright 2013-2018 Nate Bogdanowicz
""""""
Driver for Thorlabs DCx cameras. May be compatible with iDS cameras that use
uEye software. Currently Windows-only, but Linux support should be
possible to implement if desired.
""""""
from past.builtins import basestring, unicode

import struct
import weakref
import fnmatch
import numpy as np
import win32event  # req: pywin32

from nicelib import (NiceLib, NiceObject, load_lib,
                     RetHandler, Sig, ret_return)  # req: nicelib >= 0.5

from . import Camera
from ..util import check_units
from .. import ParamSet, Facet
from ...errors import (InstrumentNotFoundError, Error, TimeoutError, LibError,
                       UnsupportedFeatureError)
from ...log import get_logger
from ... import Q_

log = get_logger(__name__)

_INST_PARAMS = ['serial', 'id', 'model']
_INST_CLASSES = ['UC480_Camera']

info = load_lib('uc480', __package__)
ffi = info._ffi

__all__ = ['UC480_Camera']

global_weakkeydict = weakref.WeakKeyDictionary()


def to_bytes(text):
    if isinstance(text, bytes):
        return text
    elif isinstance(text, unicode):
        text.encode('utf-8')


def char_to_int(char):
    return struct.unpack('B', char)[0]


def cmd_ret_handler(getcmd_names, cmd_pos=1):
    """"""Create an error wrapping function for a UC480 command-taking function.

    A bunch of UC480 functions take ints indicating a ""command"" to run. Often, ""get"" commands will
    use the return value to return their value, while ""set"" commands will use it as an error code.
    This function helps generate a wrapper that will disable error-checking if one of the given
    ""get"" commands is passed in.

    getcmd_names : sequence of strs
        glob patterns which match the names of the GET command constants for this function
    cmd_pos : int
        the position of the command UINT in the function's arglist
    """"""
    if isinstance(getcmd_names, basestring):
        getcmd_names = (getcmd_names,)

    getcmd_vals = [info._defs[const_name]
                   for pattern in getcmd_names
                   for const_name in fnmatch.filter(info._defs.keys(), pattern)]

    # Note: we don't specify num_retvals, since it depends on the command issued
    @RetHandler
    def wrap(result, funcargs, niceobj):
        # Need to cast in case arg is CData
        if int(funcargs[cmd_pos]) in getcmd_vals:
            return result
        elif result != info._defs['IS_SUCCESS']:
            raise get_last_error(result, niceobj)

    return wrap


class UC480Error(LibError):
    MESSAGES = {
        -1: ""Undefined error occurred"",
        1: ""Invalid camera handle"",
        2: (""An IO request from the uc480 driver failed. Maybe the versions of the DLL (API) and ""
            ""the driver (.sys) file do not match""),
        3: (""An attempt to initialize or select the camera failed (no camera connected or ""
            ""initialization error)""),
    }


def sig(*args):
    def decorator(func):
        func.sig = args
        return func
    return decorator


@RetHandler(num_retvals=0)
def ret_errcheck(result):
    if result != NiceUC480.SUCCESS:
        raise UC480Error(code=result)


@RetHandler(num_retvals=0)
def ret_cam_errcheck(result, niceobj):
    if result != NiceUC480.SUCCESS:
        raise get_last_error(result, niceobj)


@RetHandler(num_retvals=0)
def ret_geterror(result, niceobj):
    if result != NiceUC480.SUCCESS:
        raise UC480Error(code=result, msg='Call to GetError() failed')


def get_last_error(result, niceobj):
    """"""Get UC480Error describing the last error

    Tries to recover if GetError() fails.
    """"""
    try:
        err_code, err_msg = niceobj.GetError()
    except Exception:
        err_msg = ('Error. While handling this error, GetError failed, so no error message '
                   'is available. Please look up the error code in the DCx SDK manual')
    return UC480Error(code=result, msg=err_msg)


class NiceUC480(NiceLib):
    _info_ = info
    _prefix_ = ('is_', 'IS_')
    _ret_ = ret_errcheck

    # Classmethods
    #
    GetNumberOfCameras = Sig('out')
    GetCameraList = Sig('inout')
    InitCamera = Sig('inout', 'in')

    # Camera methods
    #
    class Camera(NiceObject):
        _init_ = 'InitCamera'
        _ret_ = ret_cam_errcheck

        AddToSequence = Sig('in', 'in', 'in')
        AllocImageMem = Sig('in', 'in', 'in', 'in', 'out', 'out')
        CaptureVideo = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_LIVE'))
        ClearSequence = Sig('in')
        DisableEvent = Sig('in', 'in')
        EnableEvent = Sig('in', 'in')
        ExitCamera = Sig('in')
        ExitEvent = Sig('in', 'in')
        ExitImageQueue = Sig('in')
        FreeImageMem = Sig('in', 'in', 'in')
        GetActSeqBuf = Sig('in', 'out', 'out', 'out')
        GetError = Sig('in', 'out', 'bufout', ret=ret_geterror)
        GetImageMemPitch = Sig('in', 'out')
        GetSensorInfo = Sig('in', 'out')
        HasVideoStarted = Sig('in', 'out')
        InitEvent = Sig('in', 'in', 'in')
        InitImageQueue = Sig('in', 'in')
        ParameterSet = Sig('in', 'in', 'inout', 'in')
        ResetToDefault = Sig('in')
        SetAutoParameter = Sig('in', 'in', 'inout', 'inout')
        SetBinning = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_*BINNING*'))
        SetCameraID = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_CAMERA_ID'))
        SetColorMode = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_COLOR_MODE'))
        SetDisplayMode = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_DISPLAY_MODE'))
        SetExternalTrigger = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_*TRIGGER*'))
        SetFrameRate = Sig('in', 'in', 'out')
        SetGainBoost = Sig('in', 'in', ret=cmd_ret_handler(('IS_GET_GAINBOOST',
                                                           'IS_GET_SUPPORTED_GAINBOOST')))
        SetHWGainFactor = Sig('in', 'in', 'in', ret=ret_return)
        SetSubSampling = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_*SUBSAMPLING*'))
        SetTriggerDelay = Sig('in', 'in', ret=cmd_ret_handler('IS_GET_*TRIGGER*'))
        StopLiveVideo = Sig('in', 'in')
        SetHardwareGain = Sig('in', 'in', 'in', 'in', 'in',
                              ret=cmd_ret_handler(
                                  ('IS_GET_MASTER_GAIN', 'IS_GET_RED_GAIN', 'IS_GET_GREEN_GAIN',
                                   'IS_GET_BLUE_GAIN', 'IS_GET_DEFAULT_MASTER',
                                   'IS_GET_DEFAULT_RED', 'IS_GET_DEFAULT_GREEN',
                                   'IS_GET_DEFAULT_BLUE')))

        # Hand-wrapped methods
        #
        @Sig('in', 'in', 'inout', 'in')
        def AOI(self, command, param=None):
            """"""AOI(command, param=None)""""""
            if command & lib.AOI_MULTI_GET_AOI:
                if command == lib.AOI_MULTI_GET_AOI:
                    raise Error(""command AOI_MULTI_GET_AOI must be or'd together with another flag"")
                param_type = 'UINT[8]'
                getting = True
            elif command in AOI_GET_PARAM_TYPES:
                param_type = AOI_GET_PARAM_TYPES[command]
                getting = True
            elif command in AOI_SET_PARAM_TYPES:
                param_type = AOI_SET_PARAM_TYPES[command]
                getting = False
            else:
                raise Error(""Unsupported command given"")

            if getting and param is not None:
                raise ValueError(""Cannot give a param value when using a GET command"")
            elif not getting and param is None:
                raise ValueError(""Must give a param value when using a SET command"")

            param_type = ffi.typeof(param_type)
            deref = (param_type.kind == 'pointer')  # Don't dereference arrays

            param_data = ffi.new(param_type, param)
            size = ffi.sizeof(ffi.typeof(param_data).item if deref else param_data)
            param_ptr = ffi.cast('void*', param_data)
            self._autofunc_AOI(command, param_ptr, size)

            if getting:
                return param_data[0] if deref else param_data

        @Sig('in', 'in', 'inout', 'in')
        def Exposure(self, command, param=None):
            if command in EXPOSURE_GET_PARAM_TYPES:
                param_type = EXPOSURE_GET_PARAM_TYPES[command]
                getting = True
            elif command in EXPOSURE_SET_PARAM_TYPES:
                param_type = EXPOSURE_SET_PARAM_TYPES[command]
                getting = False
            else:
                raise Error(""Unsupported command given"")

            if getting and param is not None:
                raise ValueError(""Cannot give a param value when using a GET command"")
            elif not getting and param is None:
                raise ValueError(""Must give a param value when using a SET command"")

            param_type = ffi.typeof(param_type)
            deref = (param_type.kind == 'pointer')  # Don't dereference arrays

            param_data = ffi.new(param_type, param)
            size = ffi.sizeof(ffi.typeof(param_data).item if deref else param_data)
            param_ptr = ffi.cast('void*', param_data)
            self._autofunc_Exposure(command, param_ptr, size)

            if getting:
                return param_data[0] if deref else param_data

        @Sig('in', 'in', 'inout', 'in')
        def Gamma(self, command, param=None):
            if command in (lib.GAMMA_CMD_GET, lib.GAMMA_CMD_GET_DEFAULT):
                getting = True
            elif command == lib.GAMMA_CMD_SET:
                getting = False
            else:
                raise ValueError(""Unsupported command given"")

            if getting and param is not None:
                raise ValueError(""Cannot give a param value when using a GET command"")
            elif not getting and param is None:
                raise ValueError(""Must give a param value when using a SET command"")

            param_data = ffi.new('INT*', param)
            size = ffi.sizeof('INT')
            param_ptr = ffi.cast('void*', param_data)
            self._autofunc_Gamma(command, param_ptr, size)

            if getting:
                return param_data[0]

        @Sig('in', 'in', 'inout', 'in')
        def Blacklevel(self, command, param=None):
            if command in BLACKLEVEL_GET_PARAM_TYPES:
                param_type = BLACKLEVEL_GET_PARAM_TYPES[command]
                getting = True
            elif command in BLACKLEVEL_SET_PARAM_TYPES:
                param_type = BLACKLEVEL_SET_PARAM_TYPES[command]
                getting = False
            else:
                raise Error(""Unsupported command given"")

            if getting and param is not None:
                raise ValueError(""Cannot give a param value when using a GET command"")
            elif not getting and param is None:
                raise ValueError(""Must give a param value when using a SET command"")

            param_type = ffi.typeof(param_type)
            deref = (param_type.kind == 'pointer')  # Don't dereference arrays

            param_data = ffi.new(param_type, param)
            size = ffi.sizeof(ffi.typeof(param_data).item if deref else param_data)
            param_ptr = ffi.cast('void*', param_data)
            self._autofunc_Blacklevel(command, param_ptr, size)

            if getting:
                return param_data[0] if deref else param_data

        @Sig('in', 'in', 'inout', 'in')
        def PixelClock(self, command, param=None):
            if command in PIXELCLOCK_GET_PARAM_TYPES:
                param_type = PIXELCLOCK_GET_PARAM_TYPES[command]
                getting = True
            elif command in PIXELCLOCK_SET_PARAM_TYPES:
                param_type = PIXELCLOCK_SET_PARAM_TYPES[command]
                getting = False
            else:
                raise Error(""Unsupported command given"")

            if getting and param is not None:
                raise ValueError(""Cannot give a param value when using a GET command"")
            elif not getting and param is None:
                raise ValueError(""Must give a param value when using a SET command"")

            param_type = ffi.typeof(param_type)
            deref = (param_type.kind == 'pointer')  # Don't dereference arrays

            param_data = ffi.new(param_type, param)
            size = ffi.sizeof(ffi.typeof(param_data).item if deref else param_data)
            param_ptr = ffi.cast('void*', param_data)
            self._autofunc_PixelClock(command, param_ptr, size)

            if getting:
                return param_data[0] if deref else param_data


lib = NiceUC480

# Shim to support older versions of uc480.h
if not hasattr(lib, 'AOI_IMAGE_GET_POS_FAST_SUPPORTED'):
    lib.AOI_IMAGE_GET_POS_FAST_SUPPORTED = lib.AOI_IMAGE_SET_POS_FAST_SUPPORTED

AOI_GET_PARAM_TYPES = {
    lib.AOI_IMAGE_GET_AOI: 'IS_RECT*',
    lib.AOI_IMAGE_GET_POS: 'IS_POINT_2D*',
    lib.AOI_IMAGE_GET_SIZE: 'IS_SIZE_2D*',
    lib.AOI_IMAGE_GET_POS_MIN: 'IS_POINT_2D*',
    lib.AOI_IMAGE_GET_SIZE_MIN: 'IS_SIZE_2D*',
    lib.AOI_IMAGE_GET_POS_MAX: 'IS_POINT_2D*',
    lib.AOI_IMAGE_GET_SIZE_MAX: 'IS_SIZE_2D*',
    lib.AOI_IMAGE_GET_POS_INC: 'IS_POINT_2D*',
    lib.AOI_IMAGE_GET_SIZE_INC: 'IS_SIZE_2D*',
    lib.AOI_IMAGE_GET_POS_X_ABS: 'UINT*',
    lib.AOI_IMAGE_GET_POS_Y_ABS: 'UINT*',
    lib.AOI_IMAGE_GET_ORIGINAL_AOI: 'IS_RECT*',
    lib.AOI_AUTO_BRIGHTNESS_GET_AOI: 'IS_RECT*',
    lib.AOI_AUTO_WHITEBALANCE_GET_AOI: 'IS_RECT*',
    lib.AOI_MULTI_GET_SUPPORTED_MODES: 'UINT*',
    lib.AOI_SEQUENCE_GET_SUPPORTED: 'UINT*',
    lib.AOI_SEQUENCE_GET_PARAMS: 'AOI_SEQUENCE_PARAMS*',
    lib.AOI_SEQUENCE_GET_ENABLE: 'UINT*',
    lib.AOI_IMAGE_GET_POS_FAST_SUPPORTED: 'UINT*',
}

AOI_SET_PARAM_TYPES = {
    lib.AOI_IMAGE_SET_AOI: 'IS_RECT*',
    lib.AOI_IMAGE_SET_POS: 'IS_POINT_2D*',
    lib.AOI_IMAGE_SET_SIZE: 'IS_SIZE_2D*',
    lib.AOI_IMAGE_SET_POS_FAST: 'IS_POINT_2D*',
    lib.AOI_AUTO_BRIGHTNESS_SET_AOI: 'IS_RECT*',
    lib.AOI_AUTO_WHITEBALANCE_SET_AOI: 'IS_RECT*',

    # TODO: Implement these commands
    lib.AOI_MULTI_SET_AOI: '',
    lib.AOI_MULTI_DISABLE_AOI: '',
    lib.AOI_SEQUENCE_SET_PARAMS: '',
    lib.AOI_SEQUENCE_SET_ENABLE: '',
}

BLACKLEVEL_GET_PARAM_TYPES = {
    lib.BLACKLEVEL_CMD_GET_CAPS: 'INT*',
    lib.BLACKLEVEL_CMD_GET_MODE_DEFAULT: 'INT*',
    lib.BLACKLEVEL_CMD_GET_MODE: 'INT*',
    lib.BLACKLEVEL_CMD_GET_OFFSET_DEFAULT: 'INT*',
    lib.BLACKLEVEL_CMD_GET_OFFSET_RANGE: 'IS_RANGE_S32*',
    lib.BLACKLEVEL_CMD_GET_OFFSET: 'INT*',
}

BLACKLEVEL_SET_PARAM_TYPES = {
    lib.BLACKLEVEL_CMD_SET_MODE: 'INT*',
    lib.BLACKLEVEL_CMD_SET_OFFSET: 'INT*',
}

PIXELCLOCK_GET_PARAM_TYPES = {
    lib.PIXELCLOCK_CMD_GET_NUMBER: 'UINT*',
    lib.PIXELCLOCK_CMD_GET_LIST: 'UINT[150]',
    lib.PIXELCLOCK_CMD_GET_RANGE: 'UINT[3]',
    lib.PIXELCLOCK_CMD_GET_DEFAULT: 'UINT*',
    lib.PIXELCLOCK_CMD_GET: 'UINT*',
}

PIXELCLOCK_SET_PARAM_TYPES = {
    lib.PIXELCLOCK_CMD_SET: 'UINT*',
}

EXPOSURE_GET_PARAM_TYPES = {
    lib.IS_EXPOSURE_CMD_GET_CAPS: 'UINT*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE_DEFAULT: 'double*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE: 'double*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_MIN: 'double*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_MAX: 'double*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_INC: 'double*',
    lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE: 'double[3]',
    lib.IS_EXPOSURE_CMD_GET_FINE_INCREMENT_RANGE_MIN: 'double*',
    lib.IS_EXPOSURE_CMD_GET_FINE_INCREMENT_RANGE_MAX: 'double*',
    lib.IS_EXPOSURE_CMD_GET_FINE_INCREMENT_RANGE_INC: 'double*',
    lib.IS_EXPOSURE_CMD_GET_FINE_INCREMENT_RANGE: 'double[3]',
    lib.IS_EXPOSURE_CMD_GET_LONG_EXPOSURE_RANGE_MIN: 'double*',
    lib.IS_EXPOSURE_CMD_GET_LONG_EXPOSURE_RANGE_MAX: 'double*',
    lib.IS_EXPOSURE_CMD_GET_LONG_EXPOSURE_RANGE_INC: 'double*',
    lib.IS_EXPOSURE_CMD_GET_LONG_EXPOSURE_RANGE: 'double[3]',
    lib.IS_EXPOSURE_CMD_GET_LONG_EXPOSURE_ENABLE: 'UINT*',
}

EXPOSURE_SET_PARAM_TYPES = {
    lib.IS_EXPOSURE_CMD_SET_EXPOSURE: 'double*',
    lib.IS_EXPOSURE_CMD_SET_LONG_EXPOSURE_ENABLE: 'UINT*',
}

SUBSAMP_V_CODE_FROM_NUM = {
    1: lib.SUBSAMPLING_DISABLE,
    2: lib.SUBSAMPLING_2X_VERTICAL,
    3: lib.SUBSAMPLING_3X_VERTICAL,
    4: lib.SUBSAMPLING_4X_VERTICAL,
    5: lib.SUBSAMPLING_5X_VERTICAL,
    6: lib.SUBSAMPLING_6X_VERTICAL,
    8: lib.SUBSAMPLING_8X_VERTICAL,
    16: lib.SUBSAMPLING_16X_VERTICAL,
}
SUBSAMP_H_CODE_FROM_NUM = {
    1: lib.SUBSAMPLING_DISABLE,
    2: lib.SUBSAMPLING_2X_HORIZONTAL,
    3: lib.SUBSAMPLING_3X_HORIZONTAL,
    4: lib.SUBSAMPLING_4X_HORIZONTAL,
    5: lib.SUBSAMPLING_5X_HORIZONTAL,
    6: lib.SUBSAMPLING_6X_HORIZONTAL,
    8: lib.SUBSAMPLING_8X_HORIZONTAL,
    16: lib.SUBSAMPLING_16X_HORIZONTAL,
}

BIN_V_CODE_FROM_NUM = {
    1: lib.BINNING_DISABLE,
    2: lib.BINNING_2X_VERTICAL,
    3: lib.BINNING_3X_VERTICAL,
    4: lib.BINNING_4X_VERTICAL,
    5: lib.BINNING_5X_VERTICAL,
    6: lib.BINNING_6X_VERTICAL,
    8: lib.BINNING_8X_VERTICAL,
    16: lib.BINNING_16X_VERTICAL
}
BIN_H_CODE_FROM_NUM = {
    1: lib.BINNING_DISABLE,
    2: lib.BINNING_2X_HORIZONTAL,
    3: lib.BINNING_3X_HORIZONTAL,
    4: lib.BINNING_4X_HORIZONTAL,
    5: lib.BINNING_5X_HORIZONTAL,
    6: lib.BINNING_6X_HORIZONTAL,
    8: lib.BINNING_8X_HORIZONTAL,
    16: lib.BINNING_16X_HORIZONTAL
}


def list_instruments():
    return _cameras()


def camera_info_list():
    """"""
    Note that the returned array object must be kept alive, or the struct memory will become
    garbage.
    """"""
    num_cams = lib.GetNumberOfCameras()
    if not num_cams:
        return []

    n_bytes = ffi.sizeof('DWORD') + num_cams * ffi.sizeof('UC480_CAMERA_INFO')
    mem = ffi.new('BYTE[]', n_bytes)
    cam_list_struct = ffi.cast('UC480_CAMERA_LIST*', mem)
    cam_list_struct.dwCount = num_cams

    lib.GetCameraList(cam_list_struct)

    info_list = ffi.cast('UC480_CAMERA_INFO[%d]' % num_cams, cam_list_struct.uci)
    global_weakkeydict[info_list] = mem  # Keep mem from being cleaned up
    return info_list


def _cameras():
    """"""Get a list of ParamSets for all cameras currently attached.""""""
    cam_list = camera_info_list()
    if not cam_list:
        return []

    cams = []
    ids = []
    repeated = []
    for info in cam_list:
        id = info.dwCameraID
        if id in ids:
            repeated.append(id)
        ids.append(id)

    if not repeated:
        for info in cam_list:
            params = ParamSet(UC480_Camera,
                              serial=ffi.string(info.SerNo),
                              model=ffi.string(info.Model),
                              id=int(info.dwCameraID))
            cams.append(params)

    else:
        log.info(""Some cameras have duplicate IDs. Uniquifying IDs now..."")
        # Choose IDs that haven't been used yet
        potential_ids = [i for i in range(1, len(ids)+1) if i not in ids]
        for id in repeated:
            new_id = potential_ids.pop(0)
            log.info(""Trying to set id from {} to {}"".format(id, new_id))

            try:
                dev = lib.Camera(id, ffi.NULL)
            except Error:
                log.error(""Error connecting to camera {}"".format(id))
                return []  # Avoid infinite recursion

            try:
                dev.SetCameraID(new_id)
            except Error:
                log.error(""Error setting the camera id"")
                return []  # Avoid infinite recursion

        # All IDs should be fixed now, let's retry
        cams = _cameras()

    return cams


def _get_legit_params(params):
    """"""
    Get the ParamSet of the camera that matches params. Useful for e.g.
    checking that a camera with the given id exists and for getting its serial
    and model numbers.
    """"""
    param_list = _cameras()
    if not param_list:
        raise InstrumentNotFoundError(""No cameras attached"")

    for cam_params in param_list:
        if all(cam_params[k] == v for k, v in params.items() if v is not None):
            return cam_params

    raise InstrumentNotFoundError(""No camera found matching the given parameters"")


def AutoParamEnableFacet(name, doc=None):
    GET_CMD = getattr(lib, 'GET_ENABLE_' + name)
    SET_CMD = getattr(lib, 'SET_ENABLE_' + name)
    def fget(self):
        val1, val2 = self._dev.SetAutoParameter(GET_CMD, 0, 0)
        return bool(val1)

    def fset(self, enable):
        self._dev.SetAutoParameter(SET_CMD, enable, 0)

    return Facet(fget, fset, type=bool, doc=doc)


class BufferInfo(object):
    def __init__(self, ptr, id):
        self.ptr = ptr
        self.id = id


class UC480_Camera(Camera):
    """"""A uc480-supported Camera""""""
    DEFAULT_KWDS = Camera.DEFAULT_KWDS.copy()
    DEFAULT_KWDS.update(vsub=1, hsub=1)

    def _initialize(self):
        """"""Create a UC480_Camera object.

        A camera can be identified by its id, serial number, or both. If no
        arguments are given, returns the first camera it finds.

        The constructor automatically opens a connection to the camera, and the
        user is responsible for closing it. You can do this via ``close()`` or
        by using the constructor as a context manager, e.g.

            >>> with UC480_Camera(id=1) as cam:
            >>>     cam.save_image('image.jpg')

        Parameters
        ----------
        id : int, optional
            The uEye camera ID
        serial : str, optional
            The serial number string of the camera
        model : str, optional
            The model of the camera
        """"""
        self._id = int(self._paramset['id'])
        self._serial = self._paramset['serial']
        self._model = self._paramset['model']

        self.is_open = False
        self._width, self._height = 0, 0
        self._color_depth = 0
        self._color_mode = 0
        self._list_p_img_mem = None
        self._list_memid = None

        self._buffers = []
        self._queue_enabled = False
        self._trigger_mode = lib.SET_TRIGGER_OFF

        self.open()

    def _load_constants(self):
        self._max_master_gain = self._dev.SetHWGainFactor(lib.INQUIRE_MASTER_GAIN_FACTOR, 100) / 100.

        offset_range = self._dev.Blacklevel(lib.BLACKLEVEL_CMD_GET_OFFSET_RANGE)
        self._blacklevel_offset_min = offset_range.s32Min
        self._blacklevel_offset_max = offset_range.s32Max
        self._blacklevel_offset_inc = offset_range.s32Inc

    def __del__(self):
        if self.is_open:
            self.close()  # In case someone forgot to close()

    def set_auto_exposure(self, enable=True):
        """"""Enable or disable the auto exposure shutter.""""""
        self._dev.SetAutoParameter(lib.SET_ENABLE_AUTO_SHUTTER, enable, 0)

    def load_params(self, filename=None):
        """"""Load camera parameters from file or EEPROM.

        Parameters
        ----------
        filename : str, optional
            By default, loads the parameters from the camera's EEPROM. Otherwise,
            loads it from the specified parameter file. If filename is the empty
            string '', will open a 'Load' dialog to select the file.
        """"""
        if filename is None:
            cmd = lib.PARAMETERSET_CMD_LOAD_EEPROM
            param = ffi.new('char[]', b'/cam/set1')
        else:
            cmd = lib.PARAMETERSET_CMD_LOAD_FILE
            param = ffi.new('wchar_t[]', filename)

        self._dev.ParameterSet(cmd, param, ffi.sizeof(param))
        self._init_colormode()  # Ignore loaded color mode b/c we only support a few

        # Make sure memory is set up for right color depth
        depth_map = {
            lib.CM_MONO8: 8,
            lib.CM_RGBA8_PACKED: 32,
            lib.CM_BGRA8_PACKED: 32
        }
        mode = self._dev.SetColorMode(lib.GET_COLOR_MODE)
        depth = depth_map[mode]
        if depth != self._color_depth:
            log.debug(""Color depth changed from %s to %s"",
                      self._color_depth, depth)
            num_bufs = len(self._buffers)
            self._free_image_mem_seq()
            self._color_depth = depth
            self._allocate_mem_seq(num_bufs)
        self._color_mode = mode

    def open(self, num_bufs=1, force=False):
        """""" Connect to the camera and set up the image memory.

        Parameters
        ----------
        force : bool
            If True, run the open routine even if the camera is already open (``self.is_open`` is
            True).
        """"""
        if self.is_open and not force:
            return

        self._dev = lib.Camera(self._id, ffi.NULL)
        self.is_open = True
        self._refresh_sizes()
        log.debug('image width=%d, height=%d', self.width, self.height)

        self._init_colormode()
        self._set_AOI(0, 0, self._width, self._height)
        self._allocate_mem_seq(num_bufs)

        self._seq_event = win32event.CreateEvent(None, False, False, '')
        self._frame_event = win32event.CreateEvent(None, True, False, '')  # Don't auto-reset
        self._dev.InitEvent(self._seq_event.handle, lib.SET_EVENT_SEQ)
        self._dev.InitEvent(self._frame_event.handle, lib.SET_EVENT_FRAME)

        self._load_constants()

    def _init_colormode(self):
        log.debug(""Initializing default color mode"")
        sensor_mode = self._get_sensor_color_mode()
        mode_map = {
            lib.COLORMODE_MONOCHROME: (lib.CM_MONO8, 8),
            lib.COLORMODE_BAYER: (lib.CM_RGBA8_PACKED, 32)
        }
        try:
            mode, depth = mode_map[sensor_mode]
        except KeyError:
            raise Exception(""Currently unsupported sensor color mode!"")

        self._color_mode = mode
        self._color_depth = depth
        log.debug('color_depth=%d, color_mode=%d', depth, mode)

        self._dev.SetColorMode(self._color_mode)

    def _free_image_mem_seq(self):
        self._dev.ClearSequence()
        for buf in self._buffers:
            self._dev.FreeImageMem(buf.ptr, buf.id)
        self._buffers = []

    def _allocate_mem_seq(self, num_bufs):
        """"""Create and setup the image memory for live capture.""""""
        for i in range(num_bufs):
            p_img_mem, memid = self._dev.AllocImageMem(self._width, self._height, self._color_depth)
            self._dev.AddToSequence(p_img_mem, memid)
            self._buffers.append(BufferInfo(p_img_mem, memid))

        # Initialize display
        self._dev.SetDisplayMode(lib.SET_DM_DIB)

    def close(self, force=False):
        """"""Close the camera and release the associated image memory.

        Parameters
        ----------
        force : bool
            If True, run the close routine even if the camera is already closed (``self.is_open`` is
            False).
        """"""
        if not self.is_open and not force:
            return

        self._dev.ExitEvent(lib.SET_EVENT_SEQ)
        self._dev.ExitEvent(lib.SET_EVENT_FRAME)

        try:
            self._dev.ExitCamera()
            self.is_open = False
        except Exception as e:
            log.error(""Failed to close camera"")
            log.error(str(e))

    def _bytes_per_line(self):
        pitch = self._dev.GetImageMemPitch()
        log.debug('bytes_per_line=%d', pitch)
        return pitch

    def _get_max_img_size(self):
        """"""Max (w,h) of AOI, given current binning and subsampling""""""
        size = self._dev.AOI(lib.AOI_IMAGE_GET_SIZE_MAX)
        return size.s32Width, size.s32Height

    def _get_sensor_color_mode(self):
        info = self._dev.GetSensorInfo()
        return char_to_int(info.nColorMode)

    def _array_from_buffer(self, buf):
        h = self.height
        arr = np.frombuffer(buf, np.uint8)

        if self._color_mode == lib.CM_RGBA8_PACKED:
            w = self.bytes_per_line // 4
            arr = arr.reshape((h, w, 4), order='C')[:,:,:3]
        elif self._color_mode == lib.CM_BGRA8_PACKED:
            w = self.bytes_per_line // 4
            arr = arr.reshape((h, w, 4), order='C')[:, :, 2::-1]
        elif self._color_mode == lib.CM_MONO8:
            w = self.bytes_per_line
            arr = arr.reshape((h, w), order='C')
        else:
            raise Error(""Unsupported color mode!"")
        return arr

    def _set_queueing(self, enable):
        if enable:
            if not self._queue_enabled:
                self._dev.InitImageQueue(0)
        else:
            if self._queue_enabled:
                self._dev.ExitImageQueue()
        self._queue_enabled = enable

    def _set_subsampling(self, vsub, hsub):
        mode = SUBSAMP_V_CODE_FROM_NUM[vsub] | SUBSAMP_H_CODE_FROM_NUM[hsub]
        self._dev.SetSubSampling(mode)

    def _get_subsampling(self):
        vsub = self._dev.SetSubSampling(lib.GET_SUBSAMPLING_FACTOR_VERTICAL)
        hsub = self._dev.SetSubSampling(lib.GET_SUBSAMPLING_FACTOR_HORIZONTAL)
        return vsub, hsub

    def _set_binning(self, vbin, hbin):
        mode = BIN_V_CODE_FROM_NUM[vbin] | BIN_H_CODE_FROM_NUM[hbin]
        self._dev.SetBinning(mode)

    def start_capture(self, **kwds):
        self._handle_kwds(kwds, fill_coords=False)

        self._set_binning(kwds['vbin'], kwds['hbin'])
        self._set_subsampling(kwds['vsub'], kwds['hsub'])
        self._refresh_sizes()

        # Fill coords now b/c max width/height may have changed
        self._handle_kwds(kwds, fill_coords=True)
        self._set_AOI(kwds['left'], kwds['top'], kwds['right'], kwds['bot'])
        self._set_exposure(kwds['exposure_time'])
        self._set_gain(kwds['gain'])

        self._free_image_mem_seq()
        self._allocate_mem_seq(kwds['n_frames'])

        self._set_queueing(True)  # Use queue instead of ring buffer for finite sequence

        if self._trigger_mode == lib.SET_TRIGGER_OFF:
            self._trigger_mode = lib.SET_TRIGGER_SOFTWARE

        self._dev.SetExternalTrigger(self._trigger_mode)
        self._dev.EnableEvent(lib.SET_EVENT_SEQ)
        self._dev.CaptureVideo(lib.DONT_WAIT)  # Trigger

    @check_units(timeout='ms')
    def get_captured_image(self, timeout='1s', copy=True):
        ret = win32event.WaitForSingleObject(self._seq_event, int(timeout.m_as('ms')))
        self._dev.DisableEvent(lib.SET_EVENT_SEQ)

        if ret == win32event.WAIT_TIMEOUT:
            raise TimeoutError
        elif ret != win32event.WAIT_OBJECT_0:
            raise Error(""Failed to grab image"")

        # Assumes we have exactly as many images as buffers
        arrays = []
        for buf in self._buffers:
            buf_size = self.bytes_per_line * self.height
            array = self._array_from_buffer(ffi.buffer(buf.ptr, buf_size))
            arrays.append(np.copy(array) if copy else array)

        self._dev.StopLiveVideo(lib.WAIT)

        if len(arrays) == 1:
            return arrays[0]
        else:
            return tuple(arrays)

    def grab_image(self, timeout='1s', copy=True, **kwds):
        self.start_capture(**kwds)
        return self.get_captured_image(timeout=timeout, copy=copy)

    @check_units(framerate='?Hz')
    def start_live_video(self, framerate=None, **kwds):
        self._handle_kwds(kwds, fill_coords=False)

        self._set_binning(kwds['vbin'], kwds['hbin'])
        self._set_subsampling(kwds['vsub'], kwds['hsub'])
        self._refresh_sizes()

        # Fill coords now b/c max width/height may have changed
        self._handle_kwds(kwds, fill_coords=True)
        self._set_AOI(kwds['left'], kwds['top'], kwds['right'], kwds['bot'])

        # Framerate should be set *before* exposure time
        if framerate is None:
            # This is necessary to ensure that the exposure_time is within the reachable range
            framerate = 1/Q_(kwds['exposure_time'])
        self._dev.SetFrameRate(framerate.m_as('Hz'))

        self._set_exposure(kwds['exposure_time'])
        self._set_gain(kwds['gain'])

        self._free_image_mem_seq()
        self._allocate_mem_seq(num_bufs=2)
        self._set_queueing(False)

        self._trigger_mode = lib.SET_TRIGGER_OFF
        self._dev.SetExternalTrigger(self._trigger_mode)
        self._dev.EnableEvent(lib.SET_EVENT_FRAME)
        self._dev.CaptureVideo(lib.WAIT)

    def stop_live_video(self):
        self._dev.StopLiveVideo(lib.WAIT)
        self._dev.DisableEvent(lib.SET_EVENT_FRAME)

    @check_units(timeout='?ms')
    def wait_for_frame(self, timeout=None):
        timeout_ms = win32event.INFINITE if timeout is None else int(timeout.m_as('ms'))
        ret = win32event.WaitForSingleObject(self._frame_event, timeout_ms)
        win32event.ResetEvent(self._frame_event)

        if ret == win32event.WAIT_TIMEOUT:
            return False
        elif ret != win32event.WAIT_OBJECT_0:
            raise Error(""Failed to grab image: Windows event return code 0x{:x}"".format(ret))

        return True

    def latest_frame(self, copy=True):
        buf_num, buf_ptr, last_buf_ptr = self._dev.GetActSeqBuf()
        buf_size = self.bytes_per_line * self.height
        array = self._array_from_buffer(ffi.buffer(last_buf_ptr, buf_size))
        return np.copy(array) if copy else array

    def _get_AOI(self):
        rect = self._dev.AOI(lib.AOI_IMAGE_GET_AOI)
        return rect.s32X, rect.s32Y, rect.s32Width, rect.s32Height

    def _set_AOI(self, x0, y0, x1, y1):
        self._dev.AOI(lib.AOI_IMAGE_SET_AOI, (x0, y0, x1-x0, y1-y0))
        self._refresh_sizes()

    def _refresh_sizes(self):
        _, _, self._width, self._height = self._get_AOI()
        self._max_width, self._max_height = self._get_max_img_size()

    @check_units(exp_time='ms')
    def _set_exposure(self, exp_time):
        self._dev.Exposure(lib.IS_EXPOSURE_CMD_SET_EXPOSURE, exp_time.m_as('ms'))

    def _get_exposure(self):
        exp_ms = self._dev.Exposure(lib.IS_EXPOSURE_CMD_GET_EXPOSURE)
        return Q_(exp_ms, 'ms')

    @Facet
    def exposure(self):
        return self._get_exposure()

    @exposure.setter
    def exposure(self, exposure):
        if isinstance(exposure, float):
            exposure = Q_(exposure, 'ms')
        self._set_exposure(exposure)

    def _get_exposure_range(self):
        exp_ms_min = self._dev.Exposure(lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_MIN)
        exp_ms_max = self._dev.Exposure(lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_MAX)
        return Q_(exp_ms_min, 'ms'), Q_(exp_ms_max, 'ms')

    def _get_exposure_inc(self):
        inc_ms = self._dev.Exposure(lib.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE_INC)
        return Q_(inc_ms, 'ms')

    def _get_gain(self):
        ignore = lib.IGNORE_PARAMETER
        return self._dev.SetHardwareGain(lib.IS_GET_MASTER_GAIN, ignore, ignore, ignore)

    def _set_gain(self, gain):
        ignore = lib.IGNORE_PARAMETER
        return self._dev.SetHardwareGain(max(min(gain, 100), 0), ignore, ignore, ignore)

    def _last_img_mem(self):
        """"""Get a ctypes char-pointer to the starting address of the image memory
        last used for image capturing.""""""
        buf_num, buf_ptr, last_buf_ptr = self._dev.GetActSeqBuf()
        return last_buf_ptr

    def _color_mode_string(self):
        MAP = {
            lib.CM_MONO8: 'mono8',
            lib.CM_MONO16: 'mono16',
        }
        return MAP.get(self._color_mode)

    def set_trigger(self, mode='software', edge='rising'):
        """"""Set the camera trigger mode.

        Parameters
        ----------
        mode : string
            Either 'off', 'software'(default), or 'hardware'.
        edge : string
            Hardware trigger is either on the 'rising'(default) or 'falling' edge.
        """"""
        if mode == 'off':
            new_mode = lib.SET_TRIGGER_OFF
        elif mode == 'software':
            new_mode = lib.SET_TRIGGER_SOFTWARE
        elif mode == 'hardware':
            if edge == 'rising':
                new_mode = lib.SET_TRIGGER_LO_HI
            elif edge == 'falling':
                new_mode = lib.SET_TRIGGER_HI_LO
            else:
                raise Error(""Trigger edge value {} must be either 'rising' or 'falling'"".format(edge))
        else:
            raise Error(""Unrecognized trigger mode {}"".format(mode))

        ret = lib.is_SetExternalTrigger(self._id, new_mode)
        if ret != lib.SUCCESS:
            raise Error(""Failed to set external trigger. Return code 0x{:x}"".format(ret))
        else:
            self._trigger_mode = new_mode

    def _get_trigger(self):
        """"""Get the current trigger settings.

        Returns
        -------
        string
            off, hardware or software
        """"""
        self._trigger_mode = self._dev.SetExternalTrigger(lib.GET_EXTERNALTRIGGER)

        if self._trigger_mode == lib.SET_TRIGGER_OFF:
            return 'off'
        if self._trigger_mode == lib.SET_TRIGGER_SOFTWARE:
            return 'software'
        else:
            return 'hardware'

    def get_trigger_level(self):
        """"""Get the current hardware trigger level.

        Returns
        -------
        int
            A value of 0 indicates trigger signal is low (not triggered)
        """"""
        return self._dev.SetExternalTrigger(lib.GET_TRIGGER_STATUS)

    @check_units(delay='?us')
    def set_trigger_delay(self, delay):
        """"""Set the time to delay a hardware trigger.

        Parameters
        ----------
        delay : ``[time]``-dimensioned Quantity
            The delay time after trigger signal is received to trigger the camera. Has microsecond
            resolution.
        """"""
        delay_us = 0 if delay is None else int(delay.m_as('us'))
        self._dev.SetTriggerDelay(delay_us)

    def get_trigger_delay(self):
        """"""Get the trigger delay in ``[time]`` units.

        Returns
        -------
        string
            Trigger delay
        """"""
        param = self._dev.SetTriggerDelay(lib.GET_TRIGGER_DELAY)
        return Q_(param, 'us')

    @Facet
    def auto_blacklevel(self):
        """"""Whether auto-blacklevel correction is turned on""""""
        mode = self._dev.Blacklevel(lib.BLACKLEVEL_CMD_GET_MODE)
        return bool(mode == lib.AUTO_BLACKLEVEL_ON)

    @auto_blacklevel.setter
    def auto_blacklevel(self, enable):
        caps = self._dev.Blacklevel(lib.BLACKLEVEL_CMD_GET_CAPS)
        if not (caps & lib.BLACKLEVEL_CAP_SET_AUTO_BLACKLEVEL):
            raise UnsupportedFeatureError

        mode = lib.AUTO_BLACKLEVEL_ON if enable else lib.AUTO_BLACKLEVEL_OFF
        self._dev.Blacklevel(lib.BLACKLEVEL_CMD_SET_MODE, mode)

    @Facet(limits=('_blacklevel_offset_min', '_blacklevel_offset_max', '_blacklevel_offset_inc'))
    def blacklevel_offset(self):
        """"""The blacklevel offset value (an int)""""""
        return self._dev.Blacklevel(lib.BLACKLEVEL_CMD_GET_OFFSET)

    @blacklevel_offset.setter
    def blacklevel_offset(self, offset):
        self._dev.Blacklevel(lib.BLACKLEVEL_CMD_SET_OFFSET, offset)

    @Facet(type=int, units='MHz')
    def pixelclock(self):
        return self._dev.PixelClock(lib.PIXELCLOCK_CMD_GET)

    # TODO: Add some bounds checking. This is tricky since the bounds can change based on camera
    # mode. May have to add dynamic limits to Facets if we want to do this within the facet.
    # Otherwise we could either always pull in a new range to check against, or only check the range
    # on an ""invalid parameter"" error.
    @pixelclock.setter
    def pixelclock(self, clock):
        self._dev.PixelClock(lib.PIXELCLOCK_CMD_SET, clock)

    @Facet(units='MHz')
    def pixelclock_default(self):
        return self._dev.PixelClock(lib.PIXELCLOCK_CMD_GET_DEFAULT)

    @Facet(limits=(1.0, 10.0))
    def gamma(self):
        """"""The gamma correction value (1.0-10.0)""""""
        return self._dev.Gamma(lib.GAMMA_CMD_GET) / 100.

    @gamma.setter
    def gamma(self, gamma):
        gamma_factor = int(round(gamma * 100))
        self._dev.Gamma(lib.GAMMA_CMD_SET, gamma_factor)

    @Facet
    def gain_boost(self):
        """"""Whether the analog gain boost is enabled

        A change to the gain boost will not affect the very next image captured. It's unclear
        whether this is an inadequacy of Instrumental, or an underlying bug/feature of the library.
        """"""
        if not self._dev.SetGainBoost(lib.GET_SUPPORTED_GAINBOOST):
            return None
        boost = self._dev.SetGainBoost(lib.GET_GAINBOOST)
        return bool(boost == lib.SET_GAINBOOST_ON)

    @gain_boost.setter
    def gain_boost(self, boost):
        # For some reason, this does not take effect on the next image captured, but the
        # image after that. It is unclear what's causing this.
        if not self._dev.SetGainBoost(lib.GET_SUPPORTED_GAINBOOST):
            raise UnsupportedFeatureError(""Camera does not support the gain boost feature"")
        val = lib.SET_GAINBOOST_ON if boost else lib.SET_GAINBOOST_OFF
        self._dev.SetGainBoost(val)

    @Facet(limits=(1.0, 'max_master_gain'))
    def master_gain(self):
        """"""The master gain factor; 1.0 is the lowest gain.""""""
        gain_factor = self._dev.SetHWGainFactor(lib.GET_MASTER_GAIN_FACTOR, 0)
        return gain_factor / 100.

    @master_gain.setter
    def master_gain(self, gain):
        gain_factor = int(round(gain * 100))
        self._dev.SetHWGainFactor(lib.SET_MASTER_GAIN_FACTOR, gain_factor)

    max_master_gain = property(lambda self: self._max_master_gain,
                               doc=""Max value that ``master_gain`` can take"")

    auto_gain = AutoParamEnableFacet(
        'AUTO_GAIN',
        doc=""Whether auto gain is enabled""
    )
    auto_sensor_gain = AutoParamEnableFacet(
        'AUTO_SENSOR_GAIN',
        doc=""Whether sensor-based auto gain is enabled""
    )
    auto_exposure = AutoParamEnableFacet(
        'AUTO_SHUTTER',
        doc=""Whether auto exposure is enabled""
    )
    auto_sensor_exposure = AutoParamEnableFacet(
        'AUTO_SENSOR_SHUTTER',
        doc=""Whether sensor-based auto exposure is enabled""
    )
    auto_whitebalance = AutoParamEnableFacet(
        'AUTO_WHITEBALANCE',
        doc=""Whether auto whitebalance is enabled""
    )
    auto_sensor_whitebalance = AutoParamEnableFacet(
        'AUTO_SENSOR_WHITEBALANCE',
        doc=""Whether sensor-based auto whitebalance is enabled""
    )
    auto_framerate = AutoParamEnableFacet(
        'AUTO_FRAMERATE',
        doc=""Whether auto framerate is enabled""
    )
    auto_sensor_framerate = AutoParamEnableFacet(
        'AUTO_SENSOR_FRAMERATE',
        doc=""Whether sensor-based auto framerate is enabled""
    )

    #: uEye camera ID number. Read-only
    id = property(lambda self: self._id)

    #: Camera serial number string. Read-only
    serial = property(lambda self: self._serial)

    #: Camera model number string. Read-only
    model = property(lambda self: self._model)

    #: Number of bytes used by each line of the image. Read-only
    bytes_per_line = property(lambda self: self._bytes_per_line())

    #: Width of the camera image in pixels
    width = property(lambda self: self._width)
    max_width = property(lambda self: self._max_width)

    #: Height of the camera image in pixels
    height = property(lambda self: self._height)
    max_height = property(lambda self: self._max_height)

    #: Color mode string. Read-only
    color_mode = property(lambda self: self._color_mode_string())

    #: Trigger mode string. Read-only
    trigger_mode = property(lambda self: self._get_trigger())

    #: Current framerate, in ``[time]⁻¹`` units. Read-only
    framerate = property(lambda self: Q_(self._dev.SetFrameRate(lib.GET_FRAMERATE), 'Hz'))
"
219,,Pvcam,"Photometrics - Cameras
",Instrumental,The Kinetix sCMOS delivers the highest speed and largest field of view with near-perfect 96% quantum efficiency,https://pylablib.readthedocs.io/en/latest/devices/Pvcam.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/cameras/pvcam.py,Kinetix sCMOS (And All the Cameras)),"[OrderedDict([('id', 'attVX5StrhkYMHgb7'), ('width', 323), ('height', 366), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/X2IL1wyu2BSQD0RoU8GAnQ/g_QkC23mOaluTmccMaNMkWcHdzAhi1Aw4fWnywWXBVVthJuTvfnY7PQuiQQx8wMjsncL4uAM1dGRDMhgB4w5DdtsZpSARR4EVhBR_uShXcdQhIbnODgJ-5wlwrcYkmTl/r2rkwMF8DtkCu7EEeLcAAlf8WtnlCYuaxfDUFlc6SEQ'), ('filename', 'Kinetix-mock-up-v4-copy.png'), ('size', 168825), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/6CPxlXptbAINGbAiqNql7A/WhGjOIfZLtqPaJO-MmJzEvhBQfHg46LpBi9Lu0VaUqfRYeQL7R9hfVF8V4f2oi4ND15NKQNGi8icc0sWYf_3LQ/zfQP7VR8LJiXNQZe6AEBNCJjmwtbwkI6WuT0_TAIHFo'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/4Cy93aW32gfXaZDP84RUYQ/u5LVEhT_9aW6Y5PDrJqPIFvILLLOviUoe-SmJUryprEURFrXXZ7LQbIXQY3YpJxBCX-q9oCJA0YY_xE6Nuo-Kg/fcO6CvgO_I87Kd1JRDE3OOD0Dan9yheUZhmEi11dQnk'), ('width', 323), ('height', 366)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/57dUHrjFbC9ZAycYf6hbyg/KzE0VmodT3UJ8lUKV3WVC0kl5Z4-Ukr2VCjxMR1dNtYtzC1x0_27xLe3uTYi0fmm8AueXdeG4RNB0G_3b13vUw/vRE2qBrwhWIcxwKel7g-0OVCDhkMUURKbmdQlufD-fg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.photometrics.com/products/kinetix-family/kinetix,['Cameras'],"[OrderedDict([('id', 'attUlYZ9niDgdYtKl'), ('width', 2560), ('height', 599), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/zvGdk0ttX0xj6ICiT0Re0g/A5gj1EIdV2chkw5LHx_eLBpumacG6JiCPNpnU6MSGUf6IpH2XcAfcaZvaEOp6TUO6gKMYPj6e7TVReZiFB9-cCBJTAzduCINx5gxKlJE32g/_JUcSTXHS1WkA3odyWQ_7RbG0hXvBADbbdkcOGpumMM'), ('filename', 'Teledyne_logo.svg.png'), ('size', 40989), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/gPscCeGgmArXHZM93Jlw7w/QZmNBYuJp2iP-acfm4nMZzpDuVUiQV8H6EhA6i3F6LTyip3ZpUAtBryTXhTyGKW44j_Qtr8lkLCcTng38IHc4w/8ajU8wuuYRw2whrC2yUzYBtyNM9L7NLw5CV9hfGqV-8'), ('width', 154), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Y2HiPOHs_sMIESnENaMuBA/WyuCcJuhJgvrkY_yI4aUJKjl2xjjfgqNxT_0gYPFiC04ur1Pm6vZM2GVqLgQlVGjqeeYpCjs1Fg0yT0dUC_M-A/4eUPy3TYyog6dbS-UWNOWqM4a9iFQODHs4GAdU4Zb_A'), ('width', 2188), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Y5cSIPZM4S5xnEP8_TSI4g/JhIAy5RGDdLNDvSiEVg5mIUcKCMuwhx9p-QJAx45vF7d-zRcL9zDarP5F8Iq4t-RBzoCT-YJovGZ3cVWUQXDiQ/MvsE2DKfttR5tGaFoxDt8OhyturaJjf2V08GvTuci3k'), ('width', 3000), ('height', 3000)]))]))])]","**Teledyne** provides enabling technologies to sense, transmit and analyze information for industrial growth markets.
",https://www.teledyne.com,https://www.photometrics.com/wp-content/uploads/2023/03/Kinetix-Datasheet-Rev-A3-08032023.pdf,USA,4614.0,"A camera module is an image sensor integrated with a lens, control electronics, and an interface like CSI, Ethernet or plain raw low-voltage differential signaling.",https://en.wikipedia.org/wiki/Camera_module,Write a Python script that uses Instrumental to connect to a Kinetix sCMOS (And All the Cameras)) Cameras,,,,,"# -*- coding: utf-8 -*-
# Copyright 2015-2017 Nate Bogdanowicz
""""""
Driver for Photometrics cameras.
""""""
import warnings
warnings.warn(
    ""Driver {!r} is out of date and incompatible with the current Instrumental core. ""
    ""Pull requests fixing this are welcome."".format(__name__)
)

import time
import os.path
import numpy as np
from cffi import FFI
from ._pvcam import macros
from . import Camera
from .. import _ParamDict
from ..util import check_units
from ...errors import InstrumentTypeError, InstrumentNotFoundError
from ... import Q_, u


__all__ = ['PVCam']

ffi = FFI()
with open(os.path.join(os.path.dirname(__file__), '_pvcam', 'pvcam_clean.h')) as f:
    ffi.cdef(f.read())
lib = ffi.dlopen('Pvcam32')


# Here we create a proxy for 'lib' that includes some nicer features like
# automatic error handling, includes enums, and excludes pl_ from function
# names
class PLLib(object):
    pass
pv = PLLib()

pv_funcs = [
    'cam_check',
    'cam_close',
    'cam_deregister_callback',
    'cam_get_diags',
    'cam_get_name',
    'cam_get_total',
    'cam_open',
    'cam_register_callback',
    'ddi_get_ver',
    'pvcam_get_ver',
    'pvcam_init',
    'pvcam_uninit',
    'error_code',
    'error_message',
    'enum_str_length',
    'get_enum_param',
    'get_param',
    'pp_reset',
    'set_param',
    'exp_abort',
    'exp_check_cont_status',
    'exp_check_status',
    'exp_finish_seq',
    'exp_get_driver_buffer',
    'exp_get_latest_frame',
    'exp_get_oldest_frame',
    'exp_init_seq',
    'exp_setup_cont',
    'exp_setup_seq',
    'exp_start_cont',
    'exp_start_seq',
    'exp_stop_cont',
    'exp_uninit_seq',
    'exp_unlock_oldest_frame',
    'exp_unravel',
    'io_clear_script_control',
    'io_script_control',
    'buf_alloc',
    'buf_free',
    'buf_get_bits',
    'buf_get_exp_date',
    'buf_get_exp_time',
    'buf_get_exp_total',
    'buf_get_img_bin',
    'buf_get_img_handle',
    'buf_get_img_ofs',
    'buf_get_img_ptr',
    'buf_get_img_size',
    'buf_get_img_total',
    'buf_get_size',
    'buf_init',
    'buf_set_exp_date',
    'buf_uninit'
]

# Include macro-constants from headers
for name in dir(macros):
    if not name.startswith('__'):
        setattr(pv, name, getattr(macros, name))

# Include enums from CFFI library version of headers
# for some reason, enums aren't available until after first dir()...
dir(lib)
for name in dir(lib):
    if not name.startswith('__'):
        setattr(pv, name, getattr(lib, name))


def err_wrap(func):
    def err_wrapped(*args):
        success = func(*args)
        if not success:
            msg = ffi.new('char[{}]'.format(pv.ERROR_MSG_LEN))
            err_code = lib.pl_error_code()
            lib.pl_error_message(err_code, msg)
            e = Exception(ffi.string(msg))
            e.err_code = err_code
            raise e
    err_wrapped.__name__ = str(func)
    return err_wrapped

# Include (and wrap) functions from CFFI library
for func_name in pv_funcs:
    func = getattr(lib, 'pl_'+func_name)
    setattr(pv, func_name, err_wrap(func))


class PVCam(Camera):
    num_cams_open = 0

    def start_capture(self, **kwds):
        raise NotImplementedError

    @check_units(timeout='?ms')
    def get_captured_image(self, timeout='1s', copy=True):
        raise NotImplementedError

    def grab_image(self, timeout='1s', copy=True, **kwds):
        raise NotImplementedError

    def latest_frame(self, copy=True):
        raise NotImplementedError

    def __init__(self, name=''):
        cam_name = ffi.new('char[{}]'.format(pv.CAM_NAME_LEN), name)
        hcam_p = ffi.new('int16[1]')

        if PVCam.num_cams_open == 0:
            self._try_init()
            pv.buf_init()

        if not name:
            pv.cam_get_name(0, cam_name)

        pv.cam_open(cam_name, hcam_p, lib.OPEN_EXCLUSIVE)
        pv.exp_init_seq()

        self.hcam = hcam_p[0]
        self.seq_is_set_up = False
        self.cont_is_set_up = False
        PVCam.num_cams_open += 1

        self.bytes_per_line = self.width*2
        self.color_mode = 'mono16'

        # For saving
        self._param_dict = _ParamDict(""<PVCam '{}'>"".format(name))
        self._param_dict['module'] = 'cameras.pvcam'
        self._param_dict['pvcam_name'] = ffi.string(cam_name)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    @classmethod
    def _total_cams(cls):
        """"""The total number of cameras on the system""""""
        if cls.num_cams_open == 0:
            PVCam._try_init()
            pv.buf_init()

        total_cams_p = ffi.new('int16_ptr')
        pv.cam_get_total(total_cams_p)

        if cls.num_cams_open == 0:
            cls._try_uninit()
            pv.buf_uninit()
        return total_cams_p[0]

    @classmethod
    def _cam_names(cls):
        """"""A list of the names of all cameras on the system""""""
        if cls.num_cams_open == 0:
            PVCam._try_init()
            pv.buf_init()
        cls.num_cams_open += 1  # Fool _total_cams() so we don't have to reinit

        total = PVCam._total_cams()
        cam_name = ffi.new('char[{}]'.format(pv.CAM_NAME_LEN))

        names = []
        for i in range(total):
            pv.cam_get_name(i, cam_name)
            names.append(ffi.string(cam_name))

        cls.num_cams_open -= 1
        if cls.num_cams_open == 0:
            cls._try_uninit()
            pv.buf_uninit()

        return names

    @staticmethod
    def _try_init():
        try:
            pv.pvcam_init()
        except Exception as e:
            if e.err_code != pv.C2_PVCAM_ALREADY_INITED:
                raise e

    @staticmethod
    def _try_uninit():
        try:
            pv.pvcam_uninit()
        except Exception as e:
            if e.err_code not in (pv.C0_PVCAM_NOT_INITED,
                                  pv.C2_PVCAM_NOT_INITED):
                raise e

    def close(self):
        if self.seq_is_set_up:
            self._unsetup_sequence()
        elif self.cont_is_set_up:
            self.stop_live_video()
            pv.exp_uninit_seq()
        pv.cam_close(self.hcam)

        PVCam.num_cams_open -= 1
        if PVCam.num_cams_open == 0:
            self._try_uninit()
            pv.buf_uninit()

    def start_live_video(self, **kwds):
        raise NotImplementedError

        exposure_ms = kwds['exposure_time'].m_as('ms')

        if self.seq_is_set_up:
            #self._unsetup_sequence()
            pass
        mode = pv.TIMED_MODE

        w, h = self.width, self.height
        region_p = ffi.new('rgn_type *', (0, w-1, 1, 0, h-1, 1))
        frame_size_p = ffi.new('uns32 *')

        n_exposures = 2  # Double buffering
        n_regions = 1
        pv.exp_setup_cont(self.hcam, n_regions, region_p, mode, exposure_ms,
                          frame_size_p, pv.CIRC_OVERWRITE)

        # frame_size_p[0] is the number of BYTES per frame
        buffer_size = frame_size_p[0]*n_exposures
        self.stream_buf = ffi.new('uns16[{}]'.format(buffer_size/ffi.sizeof('uns16')))
        self.cont_is_set_up = True
        self.nframes = n_exposures

        pv.exp_start_cont(self.hcam, self.stream_buf, buffer_size)

    def stop_live_video(self):
        pv.exp_stop_cont(self.hcam, pv.CCS_HALT)
        self.cont_is_set_up = False

    def image_buffer(self):
        frame_p = ffi.new('void **')
        pv.exp_get_latest_frame(self.hcam, frame_p)

        f_nbytes = self.width*self.height*2
        return buffer(ffi.buffer(frame_p[0], f_nbytes)[:])

    def image_array(self):
        return self.grab_ndarray(fresh_capture=False)

    @check_units(timeout='?ms')
    def wait_for_frame(self, timeout=None):
        raise NotImplementedError

        status_p = ffi.new('int16_ptr')
        byte_cnt_p = ffi.new('uns32_ptr')
        buffer_cnt_p = ffi.new('uns32_ptr')

        t = time.clock() * u.s
        if timeout is not None:
            tfinal = t + timeout

        status = pv.READOUT_NOT_ACTIVE
        while status != pv.READOUT_COMPLETE and status != pv.READOUT_FAILED and (timeout is None or
                                                                                 t <= tfinal):
            pv.exp_check_cont_status(self.hcam, status_p, byte_cnt_p, buffer_cnt_p)
            status = status_p[0]
            t = time.clock() * u.s

        if status == pv.READOUT_FAILED:
            raise Exception(""Data collection error: {}"".format(pv.error_code()))

        return status == pv.READOUT_COMPLETE

    def setup_sequence(self, exp_time='100ms', nframes=1, mode='timed', regions=None):
        """"""
        Parameters
        ----------
        exp_time : int
            The exposure time, in milliseconds
        nframes : int
            The number of frames to expose during the sequence.
        mode : str
            The exposure mode. One of 'timed', 'variable', 'trigger',
            'strobed', 'bulb', and 'flash'.
        """"""
        if self.seq_is_set_up:
            pv.exp_finish_seq(self.hcam, self.stream_buf, 0)

        mode_map = {
            'timed': pv.TIMED_MODE,
            'variable': pv.VARIABLE_TIMED_MODE,
            'trigger': pv.TRIGGER_FIRST_MODE,
            'strobed': pv.STROBED_MODE,
            'bulb': pv.BULB_MODE,
            'flash': pv.FLASH_MODE
        }
        mode = mode_map[mode]

        w, h = self.width, self.height

        # Build region list
        if regions is None:
            self.regions = [(0, w-1, 1, 0, h-1, 1)]
        else:
            self.regions = []
            for region in regions:
                try:
                    # Verify region has six items
                    self.regions.append(tuple(region[0:6]))
                except TypeError:
                    # The tuple isn't nested yet, so nest it
                    self.regions = [tuple(regions[0:6])]
                    break

        # Region sizes in pixels
        self.region_sizes = []
        for region in self.regions:
            x0, x1, xbin, y0, y1, ybin = region
            self.region_sizes.append((x1-x0+1)*(y1-y0+1)/(xbin*ybin))

        region_p = ffi.new('rgn_type[]', self.regions)
        size_p = ffi.new('uns32 *')
        self.region_p = region_p

        n_exposures = int(nframes)
        exp_time = Q_(exp_time).to('ms').magnitude
        pv.exp_setup_seq(self.hcam, n_exposures, len(self.regions), region_p,
                         mode, exp_time, size_p)

        # Create buffer
        hbuf_p = ffi.new('int16_ptr')
        pv.buf_alloc(hbuf_p, n_exposures, pv.PRECISION_UNS16,
                     len(self.regions), region_p)
        self.hbuf = hbuf_p[0]

        # size_p[0] is the number of BYTES in the pixel stream
        # Do we need to worry about page-locking this memory?
        self.stream_buf = ffi.new('uns16[{}]'.format(size_p[0]/2))
        self.seq_is_set_up = True
        self.nframes = nframes

    def _unsetup_sequence(self):
        pv.exp_finish_seq(self.hcam, self.stream_buf, 0)
        pv.exp_uninit_seq()

    def start_capture(self):
        pv.exp_start_seq(self.hcam, self.stream_buf)

    def abort_sequence(self):
        pv.exp_abort(self.hcam, pv.CCS_HALT)

    def grab_frame(self, fresh_capture=True, force_list=False, timeout=-1):
        status_p = ffi.new('int16_ptr')
        byte_cnt_p = ffi.new('uns32_ptr')

        if not self.seq_is_set_up:
            self.setup_sequence()

        if fresh_capture:
            pv.exp_start_seq(self.hcam, self.stream_buf)

        t = time.clock()
        tfinal = float('inf') if timeout == -1 else (t + timeout/1000.)
        status = pv.READOUT_NOT_ACTIVE
        while status != pv.READOUT_COMPLETE and status != pv.READOUT_FAILED and t <= tfinal:
            pv.exp_check_status(self.hcam, status_p, byte_cnt_p)
            status = status_p[0]
            t = time.clock()

        if status == pv.READOUT_FAILED:
            raise Exception(""Data collection error: {}"".format(pv.error_code()))

        if status != pv.READOUT_COMPLETE:
            return None

        # Dump images into the buffer
        pv.exp_finish_seq(self.hcam, self.stream_buf, self.hbuf)
        himg_p = ffi.new('int16_ptr')
        img_addr_p = ffi.new('void_ptr_ptr')
        w_p = ffi.new('int16_ptr')
        h_p = ffi.new('int16_ptr')

        images = []
        for i in range(self.nframes):
            image_regions = []
            for j in range(len(self.regions)):
                pv.buf_get_img_handle(self.hbuf, i, j, himg_p)
                pv.buf_get_img_ptr(himg_p[0], img_addr_p)
                pv.buf_get_img_size(himg_p[0], w_p, h_p)
                img_addr = img_addr_p[0]
                size = w_p[0]*h_p[0]
                buf = ffi.buffer(img_addr, size*2)
                image_regions.append(buf)
            images.append(image_regions)

        if not force_list and self.nframes == 1 and len(self.regions) == 1:
            return images[0][0]

        return images

    def grab_ndarray(self, fresh_capture=True, force_list=False, timeout=-1):
        bufs = self.grab_frame(fresh_capture, force_list=True, timeout=timeout)

        if bufs is None:
            return None

        arrays = []
        for i, per_exposure_bufs in enumerate(bufs):
            per_exposure_arrs = []
            for buf, region in zip(per_exposure_bufs, self.regions):
                x0, x1, xbin, y0, y1, ybin = region
                w, h = (x1-x0+1)/xbin, (y1-y0+1)/ybin
                per_exposure_arrs.append(np.frombuffer(buffer(buf), np.uint16, w*h).reshape((h, w)))
            arrays.append(per_exposure_arrs)

        if not force_list and self.nframes == 1 and len(self.regions) == 1:
            return arrays[0][0]

        return arrays

    def get_param(self, param_id, attrib):
        attr_type_map = {
            pv.ATTR_ACCESS: 'uns16_ptr',
            pv.ATTR_AVAIL: 'rs_bool_ptr',
            pv.ATTR_COUNT: 'uns32_ptr',
            pv.ATTR_CURRENT: None,
            pv.ATTR_DEFAULT: None,
            pv.ATTR_INCREMENT: None,
            pv.ATTR_MAX: None,
            pv.ATTR_MIN: None,
            pv.ATTR_TYPE: 'uns16_ptr'
        }
        param_type_map = {
            pv.TYPE_CHAR_PTR: 'char_ptr',
            pv.TYPE_INT8: 'int8_ptr',
            pv.TYPE_UNS8: 'uns8_ptr',
            pv.TYPE_INT16: 'int16_ptr',
            pv.TYPE_UNS16: 'uns16_ptr',
            pv.TYPE_INT32: 'int32_ptr',
            pv.TYPE_UNS32: 'uns32_ptr',
            pv.TYPE_FLT64: 'flt64_ptr',
            pv.TYPE_ENUM: 'uns32_ptr',
            pv.TYPE_BOOLEAN: 'rs_bool_ptr',
            pv.TYPE_VOID_PTR: 'void_ptr',
            pv.TYPE_VOID_PTR_PTR: 'void_ptr_ptr'
        }
        attr_type = attr_type_map[attrib]
        if attr_type is None:
            param_value = ffi.new('uns16_ptr')
            pv.get_param(self.hcam, param_id, pv.ATTR_TYPE, param_value)
            attr_type = param_type_map[param_value[0]]

        if attr_type == 'char_ptr':
            param_value = ffi.new('uns32_ptr')
            pv.get_param(self.hcam, param_id, pv.ATTR_COUNT, param_value)
            # ATTR_COUNT gives us the length of the string...
            param_value = ffi.new('char[{}]'.format(param_value[0]))
        else:
            param_value = ffi.new(attr_type)

        pv.get_param(self.hcam, param_id, attrib, param_value)

        if attr_type == 'char_ptr':
            result = ffi.string(param_value)
        else:
            result = param_value[0]
        return result

    def _width(self):
        return self.get_param(pv.PARAM_SER_SIZE, pv.ATTR_CURRENT)

    def _height(self):
        return self.get_param(pv.PARAM_PAR_SIZE, pv.ATTR_CURRENT)

    def bit_depth(self):
        return self.get_param(pv.PARAM_BIT_DEPTH, pv.ATTR_CURRENT)

    width = property(_width)
    height = property(_height)


def list_instruments():
    names = PVCam._cam_names()
    cams = []

    for name in names:
        params = _ParamDict(""<PVCam '{}'>"".format(name))
        params['module'] = 'cameras.pvcam'
        params['pvcam_name'] = name
        cams.append(params)
    return cams


def _instrument(params):
    if 'pvcam_name' in params:
        cam = PVCam(params['pvcam_name'])
    elif params['module'] == 'cameras.pvcam':
        cam = PVCam()
    else:
        raise InstrumentTypeError()

    return cam
"
243,,Picam,Pi camera,Instrumental,"The v2 Camera Module has a Sony IMX219 8-megapixel sensor (compared to the 5-megapixel OmniVision OV5647 sensor of the original camera).
",https://picamera.readthedocs.io/en/release-1.13/,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/cameras/picam.py,Pi Camera,"[OrderedDict([('id', 'attliEXRgwCLXh2Iw'), ('width', 225), ('height', 225), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/xq30WKQu3IUJR6G3fK3hrA/YKKgklO5V6RcRrrccvQ68WTZYYhe1AdykM3jbxEZhTwoADLnY9rDIDJgv7QaU9MR6Ew8rKUbg75UtMVtN2hs4szAteQe6fKnSnhsu-1bPP8/C8rokPwXaY5aul5LWnMPVpwaJsyqbYeyaLGibj8QtAs'), ('filename', 'téléchargement (2.jpeg'), ('size', 7947), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/pkMFQWfjpM6zfPz8iZ947Q/P1-sCy7r6m7Vnr-tlZcrwSiw3ipHBt8stQ_7TNhYJqdPsIpVB8OGTKhvKzNP_-wIfjtuKA-BAf2JIwOgVb7d5Q/QmSqrlyOWWjmo_iP2KVhJe4u1tS8ZXfEeiyxb5HGZ_M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Ozonnu_ZEylJWAVV3YVtXQ/pAONgObchgwA-4-R-Y7o-V0jkqSbwWISGkxB0lo1P6UkfPRfygQ3dJGeag5Cs5dmV8zbgDqZW7Mg4dgKrnlfuA/chZeDxs9ADbPpe1stIjJzYg3HDk_r8dztpRySdwZWKU'), ('width', 225), ('height', 225)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/1t5jItYnQ_ig43HhMgsb0w/C09UdWBvTeEnir7gy1HwRdbgK5E0ervTRbMoIN9zaFH4Kwr5eAzAIrORvCfaljFjcaGlB2Mr-CX55UBg2LRUIA/OfuZtaOaDuWGLtloeSdtU9WUSURYulkbURtPgwXlBqE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.raspberrypi.com/products/camera-module-v2/,['Cameras'],"[OrderedDict([('id', 'atti0qfPjfhBvCOcX'), ('width', 318), ('height', 159), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/KTMTvZ2J0bxxWzjE_949Jg/pp2uauAfHzAocmWFGo63kDJIm843Grdbw3iQ9-kM8GyR1LV4bGD4nOWpw7XViIZs_WlzncmPgMf0ybA09ACni1jFAoopiwLduzxkE5BZom0/0MYHkBdeZ0WDofAJkRnj2rumQwc9oqbltgm2d37SQkM'), ('filename', 'téléchargement.png'), ('size', 3789), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/O19AZadvsxwU4i2U570O3Q/yGfhEGlVDbCQ4cCscCGRdlSXSg3eH9NkH4nk8dS0TAhVUAJndUXWBuzRXAVIBmgxc84I3CH5BJG3felxrT_W3Q/7myygQCrIIVTha5AUmNPcZkL2ZjYkJKHopFhsIkszPU'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/X33cxySt1EusO6JthVxZ_g/Et94GzGkdesfDZGtULAVWmysMqs_tzuP769Q2f2HFLt3pdnmykQDt27FRM8w4Hp__mwJ-n9PwXjwpBq-5cyBog/mStYDAYKb3BLsRlkiuH9Wp3OGiDb9ojpmy9S1l3LCeA'), ('width', 318), ('height', 159)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/gseCbyhTYC1I2HNgR76hbQ/qb5_euCeUaBzlEqQkNH-KxsyxSl8-BT47VMitd75vsKDtDacNHahXK1SDQY989IXxHQ3-KvBy6jT0TxRc2rkrw/KJL3HbBWN5A59MkWVkNhV4SnzVgdv5wTGPO8LXkmgos'), ('width', 3000), ('height', 3000)]))]))])]","**Raspberry Pi** is a series of small single-board computers (SBCs) developed in the United Kingdom by the **Raspberry Pi** Foundation in association with Broadcom
",https://www.raspberrypi.org/,https://www.raspberrypi.com/documentation/accessories/camera.html,UK,44.0,"A camera module is an image sensor integrated with a lens, control electronics, and an interface like CSI, Ethernet or plain raw low-voltage differential signaling.",https://en.wikipedia.org/wiki/Camera_module,Write a Python script that uses Instrumental to connect to a Pi Camera Cameras,25.0,,,,"# -*- coding: utf-8 -*-
# Copyright 2015-2021 Christopher Rogers, Nate Bogdanowicz
from future.utils import PY2

import time
from warnings import warn

import numpy as np
from enum import IntEnum
from nicelib import NiceLib, load_lib, RetHandler, ret_ignore, Sig, NiceObject

from . import Camera
from .. import ParamSet, register_cleanup
from ..util import check_units, check_enums
from ...errors import Error, InstrumentNotFoundError, TimeoutError
from ...log import get_logger
from ... import Q_

log = get_logger(__name__)

# could not find an equivalent in the future module, so I don't knwow what that buffer is??
if PY2:
    memoryview = buffer  # Needed b/c np.frombuffer is broken on memoryviews in PY2


class PicamError(Error):
    def __init__(self, msg, code=None):
        super(Error, self).__init__(msg)
        self.msg = msg
        self.code = code


lib = load_lib('picam', __package__)
BYTES_PER_PIXEL = 2


@RetHandler(num_retvals=0)
def ret_error(error):
    if error != 0:
        code = PicamEnums.Error(error)

        if bool(NicePicamLib.IsLibraryInitialized()):
            msg = NicePicamLib.GetEnumerationString(lib.PicamEnumeratedType_Error, error).decode()
            raise PicamError(msg, code)
        else:
            ret_enum_string_error.__func__(error)


@RetHandler(num_retvals=0)
def ret_enum_string_error(error):
    if error != 0:
        code = PicamEnums.Error(error)

        if error == lib.PicamError_LibraryNotInitialized:
            msg = 'Library not initialized'
        if error == lib.PicamError_InvalidEnumeratedType:
            msg = 'Invalid enumerated Type'
        if error == lib.PicamError_EnumerationValueNotDefined:
            msg = 'Enumeration value not defined.'
        else:
            msg = 'Error when getting enumeration string. Error code {}'.format(code.name)

        raise PicamError(msg, code)


class NicePicamLib(NiceLib):
    """"""Wrapper for Picam.dll""""""
    _info_ = lib
    _buflen_ = 256
    _prefix_ = 'Picam_'
    _ret_ = ret_error

    GetVersion = Sig('out', 'out', 'out', 'out')
    IsLibraryInitialized = Sig('out', ret=ret_ignore)
    InitializeLibrary = Sig()
    UninitializeLibrary = Sig()
    DestroyString = Sig('in')
    # GetEnumerationString = Sig('in', 'in', 'bufout', ret=ret_ignore)
    GetEnumerationString = Sig('in', 'in', 'bufout', ret=ret_enum_string_error)
    DestroyCameraIDs = Sig('in')
    GetAvailableCameraIDs = Sig('out', 'out')
    GetUnavailableCameraIDs = Sig('out', 'out')
    IsCameraIDConnected = Sig('in', 'out')
    IsCameraIDOpenElsewhere = Sig('in', 'out')
    DestroyHandles = Sig('in')
    OpenFirstCamera = Sig('out')
    OpenCamera = Sig('in', 'out')
    # DestroyFirmwareDetails = Sig(firmware_array)
    DestroyFirmwareDetails = Sig('in')
    # DestroyModels = Sig(model_array)
    DestroyModels = Sig('in')
    GetAvailableDemoCameraModels = Sig('out', 'out')
    ConnectDemoCamera = Sig('in', 'in', 'out')
    DisconnectDemoCamera = Sig('in')
    GetOpenCameras = Sig('out', 'out')
    IsDemoCamera = Sig('in', 'out')
    # GetFirmwareDetails = Sig(id, firmware_array, firmware_count)
    GetFirmwareDetails = Sig('in', 'out', 'out')
    # DestroyRois = Sig(rois)
    DestroyRois = Sig('in')
    # DestroyModulations = Sig(modulations)
    DestroyModulations = Sig('in')
    # DestroyPulses = Sig(pulses)
    DestroyPulses = Sig('in')
    # DestroyParameters = Sig(parameter_array)
    DestroyParameters = Sig('in')
    # DestroyCollectionConstraints = Sig(constraint_array)
    DestroyCollectionConstraints = Sig('in')
    # DestroyRangeConstraints = Sig(constraint_array)
    DestroyRangeConstraints = Sig('in')
    # DestroyRoisConstraints = Sig(constraint_array)
    DestroyRoisConstraints = Sig('in')
    # DestroyModulationsConstraints = Sig(constraint_array)
    DestroyModulationsConstraints = Sig('in')
    # DestroyPulseConstraints = Sig(constraint_array)
    DestroyPulseConstraints = Sig('in')

    class Camera(NiceObject):
        _init_ = 'OpenCamera'

        CloseCamera = Sig('in')
        IsCameraConnected = Sig('in', 'out')
        GetCameraID = Sig('in', 'out')
        #GetParameterIntegerValue = Sig(camera, parameter, value)
        GetParameterIntegerValue = Sig('in', 'in', 'out')
        #SetParameterIntegerValue = Sig(camera, parameter, value)
        SetParameterIntegerValue = Sig('in', 'in', 'in')
        #CanSetParameterIntegerValue = Sig(camera, parameter, value, settable)
        CanSetParameterIntegerValue = Sig('in', 'in', 'in', 'out')
        #GetParameterLargeIntegerValue = Sig(camera, parameter, value)
        GetParameterLargeIntegerValue = Sig('in', 'in', 'out')
        #SetParameterLargeIntegerValue = Sig(camera, parameter, value)
        SetParameterLargeIntegerValue = Sig('in', 'in', 'in')
        #CanSetParameterLargeIntegerValue = Sig(camera, parameter, value, settable)
        CanSetParameterLargeIntegerValue = Sig('in', 'in', 'in', 'out')
        #GetParameterFloatingPointValue = Sig(camera, parameter, value)
        GetParameterFloatingPointValue = Sig('in', 'in', 'out')
        #SetParameterFloatingPointValue = Sig(camera, parameter, value)
        SetParameterFloatingPointValue = Sig('in', 'in', 'in')
        #CanSetParameterFloatingPointValue = Sig(camera, parameter, value, settable)
        CanSetParameterFloatingPointValue = Sig('in', 'in', 'in', 'out')
        #GetParameterRoisValue = Sig(camera, parameter, value)
        GetParameterRoisValue = Sig('in', 'in', 'out')
        #SetParameterRoisValue = Sig(camera, parameter, value)
        SetParameterRoisValue = Sig('in', 'in', 'in')
        #CanSetParameterRoisValue = Sig(camera, parameter, value, settable)
        CanSetParameterRoisValue = Sig('in', 'in', 'in', 'out')
        #GetParameterPulseValue = Sig(camera, parameter, value)
        GetParameterPulseValue = Sig('in', 'in', 'out')
        #SetParameterPulseValue = Sig(camera, parameter, value)
        SetParameterPulseValue = Sig('in', 'in', 'in')
        #CanSetParameterPulseValue = Sig(camera, parameter, value, settable)
        CanSetParameterPulseValue = Sig('in', 'in', 'in', 'out')
        #GetParameterModulationsValue = Sig(camera, parameter, value)
        GetParameterModulationsValue = Sig('in', 'in', 'out')
        #SetParameterModulationsValue = Sig(camera, parameter, value)
        SetParameterModulationsValue = Sig('in', 'in', 'in')
        #CanSetParameterModulationsValue = Sig(camera, parameter, value, settable)
        CanSetParameterModulationsValue = Sig('in', 'in', 'in', 'out')
        #GetParameterIntegerDefaultValue = Sig(camera, parameter, value)
        GetParameterIntegerDefaultValue = Sig('in', 'in', 'out')
        #GetParameterLargeIntegerDefaultValue = Sig(camera, parameter, value)
        GetParameterLargeIntegerDefaultValue = Sig('in', 'in', 'out')
        #GetParameterFloatingPointDefaultValue = Sig(camera, parameter, value)
        GetParameterFloatingPointDefaultValue = Sig('in', 'in', 'out')
        #GetParameterRoisDefaultValue = Sig(camera, parameter, value)
        GetParameterRoisDefaultValue = Sig('in', 'in', 'out')
        #GetParameterPulseDefaultValue = Sig(camera, parameter, value)
        GetParameterPulseDefaultValue = Sig('in', 'in', 'out')
        #GetParameterModulationsDefaultValue = Sig(camera, parameter, value)
        GetParameterModulationsDefaultValue = Sig('in', 'in', 'out')
        #CanSetParameterOnline = Sig(camera, parameter, onlineable)
        CanSetParameterOnline = Sig('in', 'in', 'out')
        #SetParameterIntegerValueOnline = Sig(camera, parameter, value)
        SetParameterIntegerValueOnline = Sig('in', 'in', 'in')
        #SetParameterFloatingPointValueOnline = Sig(camera, parameter, value)

        SetParameterFloatingPointValueOnline = Sig('in', 'in', 'in')
        #SetParameterPulseValueOnline = Sig(camera, parameter, value)
        SetParameterPulseValueOnline = Sig('in', 'in', 'in')
        #CanReadParameter = Sig(camera, parameter, readable)
        CanReadParameter = Sig('in', 'in', 'out')
        #ReadParameterIntegerValue = Sig(camera, parameter, value)
        ReadParameterIntegerValue = Sig('in', 'in', 'out')
        #ReadParameterFloatingPointValue = Sig(camera, parameter, value)
        ReadParameterFloatingPointValue = Sig('in', 'in', 'out')
        #GetParameters = Sig(camera, parameter_array, parameter_count)
        GetParameters = Sig('in', 'out', 'out')
        #DoesParameterExist = Sig(camera, parameter, exists)
        DoesParameterExist = Sig('in', 'in', 'out')
        #IsParameterRelevant = Sig(camera, parameter, relevant)
        IsParameterRelevant = Sig('in', 'in', 'out')
        #GetParameterValueType = Sig(camera, parameter, type)
        GetParameterValueType = Sig('in', 'in', 'out')
        #GetParameterEnumeratedType = Sig(camera, parameter, type)
        GetParameterEnumeratedType = Sig('in', 'in', 'out')
        #GetParameterValueAccess = Sig(camera, parameter, access)
        GetParameterValueAccess = Sig('in', 'in', 'out')
        #GetParameterConstraintType = Sig(camera, parameter, type)
        GetParameterConstraintType = Sig('in', 'in', 'out')
        #GetParameterCollectionConstraint = Sig(camera, parameter, category, constraint)
        GetParameterCollectionConstraint = Sig('in', 'in', 'in', 'out')
        #GetParameterRangeConstraint = Sig(camera, parameter, category, constraint)
        GetParameterRangeConstraint = Sig('in', 'in', 'in', 'out')
        #GetParameterRoisConstraint = Sig(camera, parameter, category, constraint)
        GetParameterRoisConstraint = Sig('in', 'in', 'in', 'out')
        #GetParameterPulseConstraint = Sig(camera, parameter, category, constraint)
        GetParameterPulseConstraint = Sig('in', 'in', 'in', 'out')
        #GetParameterModulationsConstraint = Sig(camera, parameter, category, constraint)
        GetParameterModulationsConstraint = Sig('in', 'in', 'in', 'out')
        #AreParametersCommitted = Sig(camera, committed)
        AreParametersCommitted = Sig('in', 'out')
        #CommitParameters = Sig(camera, failed_parameter_array, failed_parameter_count)
        CommitParameters = Sig('in', 'out', 'out', ret=ret_ignore)
        #Acquire = Sig(camera, readout_count, readout_time_out, available, errors)
        Acquire = Sig('in', 'in', 'in', 'out', 'out')
        #StartAcquisition = Sig(camera)
        StartAcquisition = Sig('in')
        #StopAcquisition = Sig(camera)
        StopAcquisition = Sig('in')
        #IsAcquisitionRunning = Sig(camera, running)
        IsAcquisitionRunning = Sig('in', 'out')
        #WaitForAcquisitionUpdate = Sig(camera, readout_time_out, available, status)
        WaitForAcquisitionUpdate = Sig('in', 'in', 'out', 'out')


ffi = NicePicamLib._ffi
ffilib = NicePicamLib._ffilib


def _c_data_to_numpy(address, size, dtype=float):
    """"""Creates a numpy array from a C array at ``address`` with ``size`` bytes.

    Does *not* copy the data.
    """"""
    image_buf = memoryview(ffi.buffer(address, size))
    return np.frombuffer(image_buf, dtype)


class EnumTypes(object):
    """""" Class containg the enumerations in Picam.dll""""""
    def __init__(self):
        enum_type_dict = self._get_enum_dict()
        for enum_type, enum in enum_type_dict.items():
            self.__dict__[enum_type] = enum

    def _get_enum_dict(self):
        lib_dict = NicePicamLib._ffilib.__dict__
        enum_type_dict = {}
        for enum, value in lib_dict.items():
            if isinstance(value, int):
                enum_type, enum_name = enum.split('_', 1)
                if enum_type[0:5] == 'Picam':
                    enum_type = enum_type[5:]
                if enum_type == '':
                    enum_type_dict[enum_name] = value
                else:
                    if enum_type not in enum_type_dict:
                        enum_type_dict[enum_type] = {}
                    enum_type_dict[enum_type][enum_name] = value
        for enum_type, enum_dict in enum_type_dict.items():
            if isinstance(enum_dict, dict):
                enum_type_dict[enum_type] = IntEnum(enum_type, enum_dict)
        return enum_type_dict


#: Namespace of all the enums in the Picam SDK
PicamEnums = EnumTypes()


#class PicamAcquisitionError(PicamError):
#    def __init__(self, value):
#        self.value = value
#
#    def __str__(self):
#        if self.value == NicePicamLib._ffilib.PicamAcquisitionErrorsMask_None:
#            return ""No error occured""
#        elif self.value == NicePicamLib._ffilib.PicamAcquisitionErrorsMask_DataLost:
#            return ""DataLost""
#        elif self.value == NicePicamLib._ffilib.PicamAcquisitionErrorsMask_ConnectionLost:
#            return ""ConnectionLost""
#        else:
#            return ""An unkown error with code {}"".format(self.value)


# Destroyable data:
#   The idea for any destroyable data is to immediately pass it through `ffi.gc()` to get a
# reference-counting owner of the data. In some cases that data is an *array* of items. In this
# case, each item-wrapping object we create must hold a reference to the parent array to prevent its
# cleanup.

def struct_property(name):
    def fget(self):
        return getattr(self._struct_ptr, name)

    def fset(self, value):
        setattr(self._struct_ptr, name, value)

    return property(fget, fset)


# Used to ignore errors encountered when calling the Destroy functions, which usually happen because
# the library has already been uninitialized.
def ignore_error(func):
    def wrapped(*args, **kwds):
        try:
            func(*args, **kwds)
        except Exception as e:
            log.info('Ignoring error ""%s""', e)
    return wrapped


class PicamPulse(object):
    def __init__(self, pulse_ptr):
        self._struct_ptr = pulse_ptr

    def __repr__(self):
        return f'PicamPulse({self.delay=}, {self.width=})'

    delay = struct_property('delay')
    width = struct_property('width')


class PicamRois(object):
    """"""List-like group of `PicamRoi` objects

    Supports index-based access, e.g. ``roi = rois[0]``.
    """"""
    def __init__(self, rois_ptr):
        self._ptr = rois_ptr
        self._rois = [PicamRoi(self, rois_ptr.roi_array[i]) for i in range(rois_ptr.roi_count)]

    def __repr__(self):
        rois = ', '.join(repr(roi) for roi in self._rois)
        return f'PicamRois([{rois}])'

    def __getitem__(self, index):
        return self._rois[index]

    def __len__(self):
        return len(self._rois)


class PicamRoi(object):
    def __init__(self, parent, item_ptr):
        self._parent_ref = parent  # Keep a ref to prevent collection
        self._struct_ptr = item_ptr

    def __repr__(self):
        return (f'PicamRoi({self.x=}, {self.y=}, {self.width=}, {self.height=}, '
                f'{self.x_binning=}, {self.y_binning=})')

    x = struct_property('x')
    y = struct_property('y')
    x_binning = struct_property('x_binning')
    y_binning = struct_property('y_binning')
    width = struct_property('width')
    height = struct_property('height')


class PicamModulations(object):
    """"""List-like group of `PicamModulation` objects

    Supports index-based access, e.g. ``mod = mods[0]``.
    """"""
    def __init__(self, mods_ptr):
        self._ptr = mods_ptr
        self._mods = [PicamModulation(self, mods_ptr.modulation_array[i])
                      for i in range(mods_ptr.modulation_count)]

    def __repr__(self):
        mods = ', '.join(repr(mod) for mod in self._mods)
        return f'PicamModulations([{mods}])'

    def __getitem__(self, index):
        return self._mods[index]

    def __len__(self):
        return len(self._mods)


class PicamModulation(object):
    def __init__(self, parent, item_ptr):
        self._parent_ref = parent  # Keep a ref to prevent collection
        self._struct_ptr = item_ptr

    def __repr__(self):
        return (f'PicamModulation({self.duration=}, {self.frequency=}, {self.phase=}, '
                f'{self.output_signal_frequency=})')

    duration = struct_property('duration')
    frequency = struct_property('frequency')
    phase = struct_property('phase')
    output_signal_frequency = struct_property('output_signal_frequency')


class PicamCameraID(object):
    """"""Picam CameraID""""""
    def __init__(self, base_ptr, index):
        self._base_ptr = base_ptr  # Keep a ref to prevent collection
        self._struct_ptr = base_ptr[index]

    @classmethod
    def from_array(cls, id_array, count):
        id_array = ffi.gc(id_array, ignore_error(NicePicamLib.DestroyCameraIDs))
        return [cls(id_array, i) for i in range(count)]

    def __repr__(self):
        return f'<PicamCameraID({self.model=}, {self.serial_number=})>'

    def to_params(self):
        """"""Get an instrumental ParamSet describing this PicamCameraID""""""
        is_demo = bool(NicePicamLib.IsDemoCamera(self._struct_ptr))
        return ParamSet(
            PicamCamera,
            serial=self.serial_number,
            model=self.model.name,
            is_demo=is_demo,
        )

    @property
    def computer_interface(self):
        return PicamEnums.ComputerInterface(self._struct_ptr.computer_interface)

    @property
    def model(self):
        return PicamEnums.Model(self._struct_ptr.model)

    @property
    def sensor_name(self):
        return ffi.string(self._struct_ptr.sensor_name)

    @property
    def serial_number(self):
        return ffi.string(self._struct_ptr.serial_number)


def list_instruments():
    cam_ids = sdk.get_available_camera_IDs()
    return [cam_id.to_params() for cam_id in cam_ids]


def _find_camera_id(paramset):
    """"""Find camera_id from a paramset, connecting a demo camera if its missing""""""
    # NOTE this currently isn't that useful due to the way instrumental.instrument() looks for
    # cameras. It directly calls list_instruments() and searches the results. We might consider
    # changing that function, though saving a demo camera does seem like a pretty unusual case,
    # practically speaking.
    try:
        return _find_attached_camera_id(paramset)
    except InstrumentNotFoundError:
        if not (paramset.get('is_demo') and 'model' in paramset and 'serial' in paramset):
            raise

    model_enum = PicamEnums.Model[paramset['model']]
    sdk.connect_demo_camera(model_enum, paramset['serial'])
    return _find_attached_camera_id(paramset)


def _find_attached_camera_id(paramset):
    cam_ids = sdk.get_available_camera_IDs()
    if not cam_ids:
        raise InstrumentNotFoundError(""No cameras attached"")

    for cam_id in cam_ids:
        cam_params = cam_id.to_params()
        if paramset.matches(cam_params):
            return cam_id

    raise InstrumentNotFoundError(""No camera found matching the given parameters"")


class Parameter(object):
    """"""Base class for Picam Parameters""""""
    def __init__(self, dev : NicePicamLib.Camera, parameter):
        self._dev = dev
        self._param = parameter

    @staticmethod
    def create(dev, parameter):
        VT = PicamEnums.ValueType
        ptype = PicamEnums.ValueType(dev.GetParameterValueType(parameter))
        return {
            VT.Integer: IntegerParameter,
            VT.Boolean: BooleanParameter,
            VT.Enumeration: EnumerationParameter,
            VT.LargeInteger: LargeIntegerParameter,
            VT.FloatingPoint: FloatingPointParameter,
            VT.Rois: RoisParameter,
            VT.Pulse: PulseParameter,
            VT.Modulations: ModulationsParameter,
        }[ptype](dev, parameter)


class ModulationsParameter(Parameter):
    def get_value(self) -> PicamModulations:
        _ptr = self._dev.GetParameterModulationsValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyModulations))
        return PicamModulations(ptr)

    def set_value(self, value: PicamModulations):
        self._dev.SetParameterModulationsValue(self._param, value._ptr)

    def can_set(self, value: PicamModulations) -> bool:
        return bool(self._dev.CanSetParameterModulationsValue(self._param, value._ptr))

    def get_default(self) -> PicamModulations:
        _ptr = self._dev.GetParameterModulationsDefaultValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyModulations))
        return PicamModulations(ptr)


class PulseParameter(Parameter):
    def get_value(self) -> PicamPulse:
        _ptr = self._dev.GetParameterPulseValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyPulses))
        return PicamPulse(ptr)

    def set_value(self, value: PicamPulse):
        self._dev.SetParameterPulseValue(self._param, value._struct_ptr)

    def can_set(self, value: PicamPulse) -> bool:
        return bool(self._dev.CanSetParameterPulseValue(self._param, value._struct_ptr))

    def get_default(self) -> PicamPulse:
        _ptr = self._dev.GetParameterPulseDefaultValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyPulses))
        return PicamPulse(ptr)


class RoisParameter(Parameter):
    def get_value(self) -> PicamRois:
        _ptr = self._dev.GetParameterRoisValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyRois))
        return PicamRois(ptr)

    def set_value(self, value: PicamRois):
        self._dev.SetParameterRoisValue(self._param, value._ptr)

    def can_set(self, value: PicamRois) -> bool:
        return bool(self._dev.CanSetParameterRoisValue(self._param, value._ptr))

    def get_default(self) -> PicamRois:
        _ptr = self._dev.GetParameterRoisDefaultValue(self._param)
        ptr = ffi.gc(_ptr, ignore_error(NicePicamLib.DestroyRois))
        return PicamRois(ptr)


class FloatingPointParameter(Parameter):
    def get_value(self) -> float:
        return self._dev.GetParameterFloatingPointValue(self._param)

    def set_value(self, value: float):
        self._dev.SetParameterFloatingPointValue(self._param, value)

    def can_set(self, value: float) -> bool:
        return bool(self._dev.CanSetParameterFloatingPointValue(self._param, value))

    def get_default(self) -> float:
        return self._dev.GetParameterFloatingPointDefaultValue(self._param)


class LargeIntegerParameter(Parameter):
    def get_value(self) -> int:
        return self._dev.GetParameterLargeIntegerValue(self._param)

    def set_value(self, value: int):
        self._dev.SetParameterLargeIntegerValue(self._param, value)

    def can_set(self, value: int) -> bool:
        return bool(self._dev.CanSetParameterLargeIntegerValue(self._param, value))

    def get_default(self) -> int:
        return self._dev.GetParameterLargeIntegerDefaultValue(self._param)


class IntegerParameter(Parameter):
    def get_value(self) -> int:
        return self._dev.GetParameterIntegerValue(self._param)

    def set_value(self, value: int):
        self._dev.SetParameterIntegerValue(self._param, value)

    def can_set(self, value: int) -> bool:
        return bool(self._dev.CanSetParameterIntegerValue(self._param, value))

    def get_default(self) -> int:
        return self._dev.GetParameterIntegerDefaultValue(self._param)


class BooleanParameter(IntegerParameter):
    def get_value(self):
        return bool(super().get_value())

    def get_default(self):
        return bool(super().get_default())


class EnumerationParameter(IntegerParameter):
    def __init__(self, dev, parameter):
        super().__init__(dev, parameter)
        etype = PicamEnums.EnumeratedType(self._dev.GetParameterEnumeratedType(self._param))
        self._enumtype = getattr(PicamEnums, etype.name)

    def get_value(self):
        return self._enumtype(super().get_value())

    def get_default_value(self):
        return self._enumtype(super().get_default())


class Parameters(object):
    """"""Class to namespace Parameters""""""
    def __init__(self, parameters: dict[str, Parameter]):
        self.parameters = parameters
        for name, value in parameters.items():
            setattr(self, name, value)


class Timer(object):
    def __init__(self, timeout):
        self._end_time = None if (timeout is None) else (time.time() + timeout)

    def time_left(self):
        if self._end_time is None:
            return -1
        time_left = self._end_time - time.time()
        return max(0, time_left)

    def time_left_ms(self):
        if self._end_time is None:
            return -1
        time_left = (self._end_time - time.time()) * 1000
        return max(0, time_left)


class PicamCamera(Camera):
    """""" A Picam Camera """"""
    _INST_PARAMS_ = ['serial', 'model']

    _NicePicamLib = NicePicamLib
    _NicePicam = NicePicamLib.Camera
    _ffi = NicePicamLib._ffi
    _ffilib = NicePicamLib._ffilib

    def _initialize(self):
        cam_id = _find_camera_id(self._paramset)
        self._dev = NicePicamLib.Camera(cam_id._struct_ptr)
        self._create_params()
        self._latest_available_data = None

    def _create_params(self):
        _params = {}
        for p in PicamEnums.Parameter:
            try:
                _params[p.name] = Parameter.create(self._dev, p)
            except PicamError as e:
                pass

        #: Parameters of the camera
        self.params = Parameters(_params)

    def close(self):
        log.info('Closing Picam camera...')
        self._dev.CloseCamera()

    #
    # Generic Camera interface
    @property
    def width(self):
        self._get_rois()[0].width

    @property
    def height(self):
        self._get_rois()[0].height

    @property
    def max_width(self):
        return self._get_rois_constraint().width_constraint.maximum

    @property
    def max_height(self):
        return self._get_rois_constraint().height_constraint.maximum

    def start_capture(self, **kwds):
        self._handle_kwds(kwds)

        self.set_roi(x=int(kwds['left']), y=int(kwds['top']),
                     width=int(kwds['width']), height=int(kwds['height']),
                     x_binning=kwds['hbin'], y_binning=kwds['vbin'])
        self.params.ReadoutCount.set_value(kwds['n_frames'])
        self.params.ExposureTime.set_value(int(kwds['exposure_time'].m_as('ms')))

        self.commit_parameters()
        self._dev.StartAcquisition()

    @check_units(timeout='?ms')
    def get_captured_image(self, timeout='1s', copy=True):
        timer = Timer(Q_(timeout).m_as('s'))

        error = None
        readouts = []
        running = True

        # Per the Picam API docs, we must call WaitForAcquisitionUpdate until status.running is
        # False. If there's an error, we StopAcquisition and continue reading until finished.
        while running:
            timeout_ms = int(timer.time_left_ms())

            try:
                available_data, status = self._dev.WaitForAcquisitionUpdate(timeout_ms)
            except PicamError as e:
                error = e
                self._dev.StopAcquisition()
            else:
                running = status.running
                if available_data.readout_count > 0:
                    readouts.extend(self._extract_available_data(available_data, copy))

        if error:
            if error.code == PicamEnums.Error.TimeOutOccurred:
                raise TimeoutError(""Timed out while waiting for image readout"")
            else:
                raise error

        # For our standard API, only return first frame and ROI
        if len(readouts) == 1:
            return readouts[0][0][0]
        else:
            return tuple(ro[0][0] for ro in readouts)

    def grab_image(self, timeout='1s', copy=True, **kwds):
        self.start_capture(**kwds)
        return self.get_captured_image(timeout=timeout, copy=copy)

    def start_live_video(self, **kwds):
        kwds['n_frames'] = 0
        self.start_capture(**kwds)

    def stop_live_video(self):
        self._dev.StopAcquisition()

        running = True
        while running:
            _, status = self._dev.WaitForAcquisitionUpdate(-1)
            running = status.running

    @check_units(timeout='?ms')
    def wait_for_frame(self, timeout=None):
        timeout_ms = -1 if timeout is None else Q_(timeout).m_as('ms')
        try:
            self._latest_available_data, _ = self._dev.WaitForAcquisitionUpdate(timeout_ms)
        except PicamError as e:
            if e.code == PicamEnums.Error.TimeOutOccurred:
                return False
            raise

    def latest_frame(self, copy=True):
        readouts = self._extract_available_data(self._latest_available_data, copy)
        return readouts[0][0][0]

    # /Generic Camera interface
    #

    #
    # New

    def _extract_available_data(self, available_data, copy=True):
        """"""Extract numpy arrays from available_data struct

        Parameters
        ----------
        available_data : <cdata 'struct PicamAvailableData'>
        copy : bool, optional
             Whether to copy the data out of the Picam struct.

        Returns
        -------
        A 3-D nested list of numpy arrays, indexed in order of (readout, frame, roi). Note that
        this is not 'rectangular' as the ROIs can have different sizes.
        """"""
        n_readouts = available_data.readout_count
        if n_readouts == 0:
            raise PicamError('There are no readouts in available_data')

        readout_stride = self.params.ReadoutStride.get_value()
        size = readout_stride * n_readouts

        all_data = _c_data_to_numpy(available_data.initial_readout, size, dtype=np.uint16)

        rois = self.params.Rois.get_value()
        roi_shapes = [(roi.width // roi.x_binning, roi.height // roi.y_binning) for roi in rois]

        def extract_roi_data(arr, frame_offset):
            roi_start = frame_offset
            for w,h in roi_shapes:
                roi_end = roi_start + w*h
                roi_data = np.reshape(arr[roi_start:roi_end], (h,w))
                yield roi_data.copy() if copy else roi_data
                roi_start = roi_end

        n_frames = self.params.FramesPerReadout.get_value()
        frame_stride = self.params.FrameStride.get_value()

        data = [
            [list(extract_roi_data(all_data, i*readout_stride + j*frame_stride))
             for j in range(n_frames)]
            for i in range(n_readouts)
        ]
        return data

    def set_roi(self, x=None, y=None, width=None, height=None, x_binning=None, y_binning=None):
        """"""Set one or more fields of the ROI

        If there are multiple ROIs, only applies to the first. Any args not given are left
        unmodified.
        """"""
        kwds = {k:v for k,v in vars().items() if k != 'self' and v is not None}
        rois = self.params.Rois.get_value()

        for name, value in kwds.items():
            setattr(rois[0], name, value)

        self.params.Rois.set_value(rois)

    def _get_rois(self):
        return self.params.Rois.get_value()

    def _get_rois_constraint(self):
        param = PicamEnums.Parameter.Rois
        category = PicamEnums.ConstraintCategory.Required
        rois_constraint = self._dev.GetParameterRoisConstraint(param, category)
        # NOTE: Do not keep references to sub-elements of this, as the memory will be cleaned
        # up once this object loses all direct Python references
        return ffi.gc(rois_constraint, ignore_error(NicePicamLib.DestroyRoisConstraints))

    # /New
    #

    #
    # Old

    #def set_frames(self, roi_list):
    #    """"""Sets the region(s) of interest for the camera.

    #    roi_list is a list containing region of interest elements, which can
    #    be either instances of ``PicamRois`` or dictionaries that can be used
    #    to instantiate ``PicamRois``""""""
    #    for i in range(len(roi_list)):
    #        roi = roi_list[i]
    #        if not isinstance(roi, PicamRoi):
    #            roi = PicamRoi(**roi)
    #            roi_list[i] = roi
    #        if ((roi.width-roi.x) % roi.x_binning) != 0:
    #            text = ""(width-x) must be an integer multiple of x_binning""
    #            raise(PicamError(text))
    #        if ((roi.height-roi.y) % roi.y_binning) != 0:
    #            text = ""(height-y) must be an integer multiple of y_binning""
    #            raise(PicamError(text))
    #    rois = self._create_rois(roi_list)
    #    self._set_rois(rois)

    #def _create_rois(self, roi_list):
    #    """""" Returns a C data PicamRois structure created from roi_list

    #    roi_list shoudl be a list containing instances of ``PicamRois``""""""
    #    N_roi = len(roi_list)
    #    roi_array = self._ffi.new('struct PicamRoi[{}]'.format(N_roi))
    #    for i in range(N_roi):
    #        roi_i = roi_list[i]
    #        roi_array[i].x = roi_i.x
    #        roi_array[i].width = roi_i.width
    #        roi_array[i].x_binning = roi_i.x_binning
    #        roi_array[i].y = roi_i.y
    #        roi_array[i].height = roi_i.height
    #        roi_array[i].y_binning = roi_i.y_binning

    #    rois = self._ffi.new('struct PicamRois *')
    #    rois.roi_count = N_roi
    #    rois.roi_array = roi_array
    #    self.rois_keep_alive.append((rois, roi_array))
    #    return rois

    #def get_cameraID(self):
    #    """"""Returns the PicamID structure for the camera with name cam_name""""""
    #    return self._NicePicam.GetCameraID()

    #def get_firmware_details(self):
    #    """"""Returns the camera firmware details""""""
    #    firmware_array, count = NicePicamLib.GetFirmwareDetails(self.id)
    #    if count == 0:
    #        warn(""No Firmware details available for camera {}"".format(self.cam_name))
    #    firmware_details = {}
    #    for i in range(count):
    #        name = self._ffi.string(firmware_array[i].name)
    #        detail = self._ffi.string(firmware_array[i].detail)
    #        firmware_details[name] = detail
    #    NicePicamLib.DestroyFirmwareDetails(firmware_array)
    #    return firmware_details

    #def _turn_enum_into_integer(self, parameter, value=None):
    #    param_type = self.get_parameter_value_type(parameter)
    #    if value is not None:
    #        if param_type == self.enums.ValueType.Enumeration:
    #            value = value.value
    #    if param_type == self.enums.ValueType.Enumeration:
    #        param_type = self.enums.ValueType.Integer
    #    return param_type, value

    #def are_parameters_committed(self):
    #    """"""Whether or not the camera parameters are committed""""""
    #    return bool(self._dev.AreParametersCommitted())

    def commit_parameters(self):
        """"""Commits camera parameters""""""
        bad_params, n = self._dev.CommitParameters()

        if n > 0:
            bad_str = ','.join(PicamEnums.Parameter(bad_params[i]).name for i in range(n))
            raise PicamError(""{} parameters were unsuccessfully committed: [{}]"".format(n, bad_str))

    #def start_acquisition(self):
    #    """"""Begins an acquisition and returns immediately.

    #    The number of readouts is controlled by ``set_readout_count``.
    #    """"""
    #    self._NicePicam.StartAcquisition()

    #def stop_acquisition(self):
    #    """"""Stops a currently running acuisition""""""
    #    self._NicePicam.StopAcquisition()

    #def is_aqcuisition_running(self):
    #    """"""Returns a boolean indicating whether an aqcuisition is running""""""
    #    return bool(self._NicePicam.IsAcquisitionRunning())

    #@check_units(timeout = 'ms')
    #def wait_for_aqcuisition_update(self, timeout='-1ms'):
    #    """""" Waits for a readout  """"""
    #    available, status = self._NicePicam.WaitForAcquisitionUpdate(timeout.to('ms').m)
    #    if status.errors != 0:
    #        raise PicamAcquisitionError(status.errors)
    #    return available, status

    #def get_readout_rate(self, default=False):
    #    """""" Returns the readout rate (in units of Hz) of camera cam_name,
    #    given the current settings""""""
    #    parameter = self.enums.Parameter.ReadoutRateCalculation
    #    return Q_(self._getset_param(parameter, default=default), 'Hz')

    #def get_readout_time(self, default=False):
    #    """""" Returns the readout time (in ms) """"""
    #    param = self.enums.Parameter.ReadoutTimeCalculation
    #    return Q_(self._getset_param(param, default=default), 'ms')

    #@check_units(exposure = 'ms')
    #def set_exposure_time(self, exposure, canset=False):
    #    """"""sets the value of the exposure time """"""
    #    param = self.enums.Parameter.ExposureTime
    #    return self._getset_param(param, exposure.to('ms').m, canset)

    #def get_exposure_time(self, default=False):
    #    """"""Returns value of the exposure time """"""
    #    param = self.enums.Parameter.ExposureTime
    #    return Q_(self._getset_param(param, default=default), 'ms')

    #@check_enums(gain = PicamEnums.AdcAnalogGain)
    #def set_adc_gain(self, gain, canset=False):
    #    """"""Sets the ADC gain using an enum of type AdcAnalogGain.""""""
    #    param = self.enums.Parameter.AdcAnalogGain
    #    return self._getset_param(param, gain, canset)

    #def get_adc_gain(self, default=False):
    #    """"""Gets the ADC gain. """"""
    #    param = self.enums.Parameter.AdcAnalogGain
    #    value = self._getset_param(param, default=default)
    #    return self.enums.AdcAnalogGain(value)

    #@check_units(frequency='MHz')
    #def set_adc_speed(self, frequency, canset=False):
    #    """"""Sets the ADC Frequency

    #    For many cameras, the possible values are very constrained -
    #    typical ccd cameras accept only 2MHz and 0.1MHz work.""""""
    #    param = self.enums.Parameter.AdcSpeed
    #    return self._getset_param(param, frequency.to('MHz').m, canset)

    #def get_adc_speed(self, default=False):
    #    """"""Returns the ADC speed in MHz """"""
    #    param = self.enums.Parameter.AdcSpeed
    #    value = self._getset_param(param, default=default)
    #    return Q_(value, 'MHz')

    #def get_temperature_reading(self):
    #    """"""Returns the temperature of the sensor in degrees Centigrade""""""
    #    param = self.enums.Parameter.SensorTemperatureReading
    #    return Q_(self._getset_param(param), 'celsius')

    #@check_units(temperature = 'celsius')
    #def set_temperature_setpoint(self, temperature, canset=False):
    #    """"""Set the temperature setpoint """"""
    #    param = self.enums.Parameter.SensorTemperatureSetPoint
    #    return self._getset_param(param, temperature.to('celsius').m, canset)

    #def get_temperature_setpoint(self, default=False):
    #    """"""Returns the temperature setpoint """"""
    #    param = self.enums.Parameter.SensorTemperatureSetPoint
    #    value = self._getset_param(param, default=default)
    #    return Q_(value, 'celsius')

    #def get_temperature_status(self):
    #    """"""Returns the temperature status """"""
    #    param = self.enums.Parameter.SensorTemperatureStatus
    #    return self.enums.SensorTemperatureStatus(self._getset_param(param))

    #def get_readout_count(self, default=False):
    #    """""" Gets the number of readouts for an asynchronous aquire. """"""
    #    param = self.enums.Parameter.ReadoutCount
    #    return self._getset_param(param, default=default)

    #def set_readout_count(self, readout_count=None, canset=False):
    #    """""" Sets the number of readouts for an asynchronous aquire.

    #    This does NOT affect the number of readouts for self.aqcuire
    #    """"""
    #    param = self.enums.Parameter.ReadoutCount
    #    return self._getset_param(param, readout_count, canset)

    #def get_time_stamp_mode(self, default=False):
    #    """""" Get the mode for the timestamp portion of the frame metadata. """"""
    #    param = self.enums.Parameter.TimeStamps
    #    return self.enums.TimeStampsMask(self._getset_param(param, default=default))

    #@check_enums(gain = PicamEnums.AdcAnalogGain)
    #def set_time_stamp_mode(self, mode, canset=False):
    #    """""" Sets the mode of the timestamp portion of the frame metadata using
    #    the enum ``TimeStampsMask`` """"""
    #    param = self.enums.Parameter.TimeStamps
    #    return self._getset_param(param, mode, canset)

    #@check_enums(mode = PicamEnums.ShutterTimingMode)
    #def set_shutter_mode(self, mode, canset=False):
    #    """""" Controls the shutter operation mode using the enum ``ShutterTimingMode``.""""""
    #    param = self.enums.Parameter.ShutterTimingMode
    #    return self._getset_param(param, mode, canset)

    #def get_shutter_mode(self, default=False):
    #    """""" Get the shutter operation mode.""""""
    #    param = self.enums.Parameter.ShutterTimingMode
    #    return self.enums.ShutterTimingMode(self._getset_param(param, default=default))

    #def open_shutter(self):
    #    """""" Opens the shutter """"""
    #    self.set_shutter_mode(self.enums.ShutterTimingMode.AlwaysOpen)

    #def close_shutter(self):
    #    """""" Closes the shutter """"""
    #    self.set_shutter_mode(self.enums.ShutterTimingMode.AlwaysClosed)

    #def normal_shutter(self):
    #    """""" Puts the shutter into normal mode """"""
    #    self.set_shutter_mode(self.enums.ShutterTimingMode.Normal)

    #@check_enums(parameter = PicamEnums.Parameter)
    #def does_parameter_exist(self, parameter):
    #    """"""Returns a boolean indicating whether the parameter ``parameter`` exists""""""
    #    return bool(self._NicePicam.DoesParameterExist(parameter.value))

    #@check_enums(parameter = PicamEnums.Parameter)
    #def is_parameter_relevant(self, parameter):
    #    """"""Returns a boolean indicating whether changing the parameter
    #    ``parameter`` will affect the behaviour of camera given the
    #    current settings""""""
    #    return bool(self._NicePicam.IsParameterRelevant(parameter.value))

    #def get_parameter_list(self):
    #    """"""Returns an array of all the parameters of
    #    camera and the number of parameters""""""
    #    parameter_list = []
    #    params, count = self._NicePicam.GetParameters()
    #    for i in range(count):
    #        parameter_list.append(self.enums.Parameter(params[i]))
    #    return parameter_list

    # /Old
    #


class _PicamSDK(object):
    _NicePicamLib = NicePicamLib
    _NicePicam = NicePicamLib.Camera
    _ffi = NicePicamLib._ffi
    _ffilib = NicePicamLib._ffilib
    enums = PicamEnums

    def __init__(self):
        self._open_count = 0
        self.cameras = {}

    def open(self):
        self._open_count += 1

        if not NicePicamLib.IsLibraryInitialized():
            NicePicamLib.InitializeLibrary()

    def close(self):
        self._open_count -= 1

        if self._open_count <= 0:
            for camera in self.cameras.values():
                camera.close()
            NicePicamLib.UninitializeLibrary()

    #def get_enumeration_string(self, enum_type, value):
    #    """"""Get the string associated with the enum 'value' of type 'enum_type'""""""
    #    return NicePicamLib.GetEnumerationString(enum_type, value)

    #def is_demo_camera(self, cam_id=None):
    #    """"""
    #    Returns a boolean indicating whether the camera corresponding to
    #    cam_id is a demo camera
    #    """"""
    #    if cam_id is None:
    #        cam_id = self.cam
    #    return bool(NicePicamLib.IsDemoCamera(cam_id))

    #def get_version(self):
    #    """"""
    #    Returns a string containing version information for the Picam dll
    #    """"""
    #    major, minor, distribution, release = NicePicamLib.GetVersion()

    #    temp = (major, minor, distribution, release/100, release%100)
    #    version = 'Version {0[0]}.{0[1]}.{0[2]} released in 20{0[3]}-{0[4]}'
    #    return version.format(temp)

    def get_available_camera_IDs(self):
        """"""Returns an array of cameras that it is currently possible to
        connect to.

        Returns
        -------
        ID_array: array of PicamCameraID
            ids of the available cameras
        count: int
            the number of available cameras
        """"""
        id_array, count = NicePicamLib.GetAvailableCameraIDs()
        return PicamCameraID.from_array(id_array, count)

    #def get_unavailable_camera_IDs(self):
    #    """"""
    #    Returns an array of cameras that are either open or disconnected (it is
    #    not possible to connect to these cameras)

    #    Returns
    #    -------
    #    ID_array: array of PicamCameraID
    #        ids of the unavailable cameras
    #    count: int
    #        the number of unavailable cameras
    #    """"""
    #    ID_array, count = NicePicamLib.GetUnavailableCameraIDs()
    #    return ID_array, count

    #def destroy_camera_ids(self, cam_ids):
    #    """"""
    #    Destroys the memory associated with string the picam_id 'cam_id'
    #    """"""
    #    NicePicamLib.DestroyCameraIDs(cam_ids)

    def connect_demo_camera(self, model, serial_number):
        """"""Connects a demo camera of the specified model and serial number.""""""
        NicePicamLib.ConnectDemoCamera(model, serial_number)

    #def get_available_demo_camera_models(self):
    #    """"""
    #    Returns an array of all demo camera models that it is possible to
    #    create, and the length of that array.
    #    """"""
    #    models, count = NicePicamLib.GetAvailableDemoCameraModels()
    #    return models, count

    def disconnect_demo_camera(self, cam_id):
        """"""Disconnects the demo camera specified by cam_id""""""
        NicePicamLib.DisconnectDemoCamera(cam_id._struct_ptr)

    #def destroy_models(self, models):
    #    """"""Releases memory associated with the array of cam_models 'models'""""""
    #    NicePicamLib.DestroyModels(models)

    #def is_camera_connected(self, cam_id):
    #    """"""
    #    Returns a boolean indicating whether the camera matching cam_id is
    #    connected.

    #    Parameters
    #    -------
    #    cam_id: instance of PicamCameraID
    #    """"""
    #    return bool(NicePicamLib.IsCameraIDConnected(cam_id))

    #def is_camera_open_elsewhere(self, cam_id):
    #    """"""
    #    Returns a boolean indicating whether the camera matching cam_id
    #    is open in another program.

    #    Parameters
    #    -------
    #    cam_id: instance of PicamCameraID
    #    """"""
    #    return bool(NicePicamLib.IsCameraIDOpenElsewhere(cam_id))

    #def open_first_camera(self, cam_name):
    #    """"""
    #    Opens the first available camera, and assigns it the name 'cam_name'
    #    """"""
    #    ID_array, count = self.get_available_camera_IDs()
    #    if count == 0:
    #        raise PicamError('No cameras available - could not open first camera')
    #    if count == 1:
    #        id = ID_array
    #    else:
    #        id = ID_array[0]
    #    self.open_camera(id, cam_name)

    #def add_camera(self, cam_name, nice_cam):
    #    """"""Adds a camera with the name cam_name to the dictionary of cameras, self.cameras""""""
    #    if cam_name in self.cameras:
    #        raise PicamError('Camera name {} already in use'.format(cam_name))
    #    self.cameras[cam_name] = PicamCamera(nice_cam, self)

    #def open_camera(self, cam_id : PicamCameraID, cam_name : str):
    #    """"""Opens the camera associated with cam_id, and assigns it the name 'cam_name'""""""
    #    #handle = NicePicamLib.OpenCamera(cam_id)
    #    nice_cam = NicePicamLib.Camera(cam_id)
    #    self.add_camera(cam_name, nice_cam)

    #def open_cameras(self, cam_dict):
    #    IDarray, n = self.get_available_camera_IDs()
    #    for cam_name in cam_dict.keys():
    #        for i in range(n):
    #            if IDarray[i].model == cam_dict[cam_name]:
    #                self.open_camera(IDarray[i], i)
    #                break
    #            if i == n-1:
    #                raise(PicamError(""Camera {} does not exist"".format(cam_name)))

    #def destroy_rois(self, rois):
    #    """"""Releases the memory associated with PicamRois structure 'rois'.

    #    NOTE: this only works for instances of rois created from
    #    'getset_rois', and not for user-created rois from 'create_rois'
    #    """"""
    #    NicePicamLib.DestroyRois(rois)


sdk = _PicamSDK()  # singleton
sdk.open()
register_cleanup(sdk.close)
"
245,608.0,Thorlabs,PM 100 D,Instrumental,"The PM100D Handheld Optical Power and Energy Meter is designed to measure the
optical power of laser light or other monochromatic or near monochromatic light
sources and the energy of pulsed light sources.",https://instrumental-lib.readthedocs.io/en/latest/thorlabs-powermeters.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/powermeters/thorlabs.py,PM100D,"[OrderedDict([('id', 'attqAm3Kfn2xY6J7D'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/MfFbCBmWxst_IMdQpvwCCQ/Qey2vHi2EHOMRTWZVeD2pBU2aATYNB_Armkp9O8YwMuw50Vb1BP2rR4V2dxlJFT9eJJJ0wEU87XNQ1tT7r-dOKTaBRR_Av9dOQlvzB7R18c/UzEhpI1UJVHGZc20qJYo5uywtDmhMZh4U7uBh0S2-SA'), ('filename', '17654-xl.jpg'), ('size', 109537), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/lRvSSoC9u0IDjM8ihGZWbg/ExfMbDtJGsIo8vUZu5zUOUQGZvvJ49nPkfNTx5zEbmz3A0sJ1f388HSPAw2Lm5oio689vtRqffFVtHjsyVg2pQ/Z4_tw41-a4cWrAjsU3zCxsr_IRDASML90UbNm-Thwiw'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/YUFdK-F5-QyBhsM9Ly9D3A/Qh_wy2fcZ2YK3FpRhgOy-_uA9Q0lCMxPvkb_1HdQsu0HlSu2hDE04TA3tbVOyR7Cc96RyYbZfGVhDxIivsp8jA/UEPvMnbDEIfnZFyjaYxRN7g7ubazFuqev35e4cE57uo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/cNZhtdWQgT2ZB-8AfwvRlw/ps8BvgXEZDBs0yBxVsbWDeZwWjpcyOjruWpt3HRNH6u1LMrAj-S1XdDGzu17VjWChrSQRqluG78YnKX5FhMpHg/dN6y_nvtFCvvOZ2xfxZXGREzQdb8LBPzNPADEPCehTE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/_sd.cfm?fileName=17654-D02.pdf&partNumber=PM100D,['Power Meters'],"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/3XeRqTN2DJiSB_vxjMMw8w/DVo1ArRlfIskxBfRQE73ObFDSsT72YzyBj0lHBNpcludaMkBfw-YxSVuWUd_XaGUVY466oo4Dv3a7xPukqCHCWpINPAHI3at1boZoiu5BCY/rXNQu0BkHFdbBXas0P1VZEmGnZCVmBLgBiv3LMML93w'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/-ZscM0HEX_0HCRKPT33zCg/vGSQpJOnMBJ4bkyswrKxZZfNYSvQeGDGXZrtTy-4HMJjc3oBejdQB17lRSVO73zM8MbG09dx21YRoVWgUU4Vtg/7K7FzMayj16BZwcjeeR1De7ollLJmwr3ay8YTlUfH4I'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/V-_gLspJ5JxO9O_arftFtA/K0tEp-2BnSWzf0sgSti05TLWnFkc7CviBFKQMt9m-mlJmIKfTrrULOgW39S2K6d_nIePFBZTAe2SBj4o8lRcOQ/X84JbSECSksweH0XrZdo9-lwBNTSsDh348emehsq62w'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/-DInk61KEzgdL155vuG_lw/QzYu6aoZIcEQSEwcPwX5cKbiPZcxGD79Rhbg-Yitq1I867pNaCGB_zdAzb_Nu2BLqXPqDSZOtZBpXlXbTqYVkA/eh56sEDD4NTOC3IlBKkAEaNXWbx0cJSZPUTJLOXrEZo'), ('width', 3000), ('height', 3000)]))]))])]","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://www.thorlabs.com/,https://www.thorlabs.com/_sd.cfm?fileName=17654-D02.pdf&partNumber=PM100D,USA,550.0,A Power Meter is one of the most useful and simple instruments to measure electrical power when no deeper analysis of the measured data is required. It measures the voltage (V) and current (A) and derives from these the most important power results,https://www.hbm.com/en/9206/what-is-a-power-meter/,Write a Python script that uses Instrumental to connect to a PM100D Power Meters,1245.48,,,,"# -*- coding: utf-8 -*-
# Copyright 2014-2019 Nate Bogdanowicz
""""""
Driver module for Thorlabs power meters. Supports:

* PM100D
""""""
import numpy
from . import PowerMeter
from .. import Facet, SCPI_Facet, VisaMixin, deprecated
from ... import Q_


class PM100D(PowerMeter, VisaMixin):
    """"""A Thorlabs PM100D series power meter""""""
    _INST_PARAMS_ = ['visa_address']
    _INST_VISA_INFO_ = ('Thorlabs', ['PM100D'])

    @deprecated('power')
    def get_power(self):
        return self.power

    @deprecated('range')
    def get_range(self):
        return self.range

    @deprecated('auto_range')
    def enable_auto_range(self, enable=True):
        self.auto_range = enable

    @deprecated('auto_range')
    def disable_auto_range(self):
        self.auto_range = False

    @deprecated('auto_range')
    def auto_range_enabled(self):
        return self.auto_range

    range = SCPI_Facet('power:dc:range', units='W', convert=float, readonly=True,
                       doc=""The current input range's max power"")

    @deprecated('wavelength')
    def get_wavelength(self):
        """"""Get the input signal wavelength setting

        Returns
        -------
        wavelength : Quantity
            the input signal wavelength in units of [length]
        """"""
        val = float(self._rsrc.query('sense:correction:wav?'))
        return Q_(val, 'nm')

    @deprecated('wavelength')
    def set_wavelength(self, wavelength):
        """"""Set the input signal wavelength setting

        Parameters
        ----------
        wavelength : Quantity
            the input signal wavelength in units of [length]
        """"""
        wav_nm = Q_(wavelength).to('nm').magnitude
        self.write('sense:correction:wav {}', wav_nm)

    @deprecated('num_averaged')
    def get_num_averaged(self):
        """"""Get the number of samples to average

        Returns
        -------
        num_averaged : int
            number of samples that are averaged
        """"""
        val = int(self._rsrc.query('sense:average:count?'))
        return val

    @deprecated('num_averaged')
    def set_num_averaged(self, num_averaged):
        """"""Set the number of samples to average

        Each sample takes approximately 3ms. Thus, averaging over 1000 samples
        would take about a second.

        Parameters
        ----------
        num_averaged : int
            number of samples to average
        """"""
        val = int(num_averaged)
        self.write('sense:average:count {}', val)

    auto_range = SCPI_Facet('power:dc:range:auto', convert=int, value={False:0, True:1},
                            doc=""Whether auto-ranging is enabled"")

    wavelength = SCPI_Facet('sense:corr:wav', units='nm', type=float,
                            doc=""Input signal wavelength"")

    num_averaged = SCPI_Facet('sense:average:count', type=int,
                              doc=""Number of samples to average"")

    def close(self):
        self._rsrc.control_ren(False)  # Disable remote mode

    # Tell list_instruments how to close this VISA resource properly
    @staticmethod
    def _close_resource(resource):
        resource.control_ren(False)  # Disable remote mode

    @Facet(units='W', cached=False)
    def power(self):
        """"""The measured optical power""""""
        self.write('power:dc:unit W')
        return float(self.query('measure:power?'))

    def measure(self, n_samples=100):
        """"""Make a multi-sample power measurement

        Parameters
        ----------
        n_samples : int
            Number of samples to take

        Returns
        -------
        pint.Measurement
            Measured power, with units and uncertainty, as a `pint.Measurement` object
        """"""
        n_avg = self.get_num_averaged()  # Save for later
        self.set_num_averaged(1)
        self.write('power:dc:unit W')

        raw_arr = numpy.empty((n_samples,), dtype='f')
        for i in range(n_samples):
            raw_arr[i] = float(self.query('measure:power?'))
        self.set_num_averaged(n_avg)

        return Q_(raw_arr.mean(), 'W').plus_minus(raw_arr.std())
"
279,,Sr 850,SR 850,Instrumental,"SR850 — 100 kHz DSP lock-in amplifier
",https://instrumental-lib.readthedocs.io/en/stable/sr850.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/lockins/sr850.py,SR 850,"[OrderedDict([('id', 'att5RYW0QExpohlyt'), ('width', 3947), ('height', 1835), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ZUX_dOoq2FDpA-qCVvRaEw/0YdMB03liXf8i_TlSF_WYHRIwubybglJAKxfWpJi8L3Nvzj3T_hlI1W9TEFX9tknqwegB2B0FeiBnnUJ4itwDHlJ6LwTxKjDf2rAsoop3FI/_YmoUMY0c61aug-f0-23yTzPf2feYrMMXpPFlPAej-A'), ('filename', 'SR850_Main Pic.jpg'), ('size', 1473970), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ygykV_VWo88kVvEGaEEWMg/i7ysIu64_BoE5IlfiAfsrRjxjuPfq54BqCC6CahuHAUtPKX_cmE9gCu8yFJYMVSLeN8grgxl_fNzMclioQQ1Bg/b9LYTakcWIu4eborPUqV3JH4Ovx3QvNCvzKizsSkago'), ('width', 77), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/WJlos5DDeVOmDCGWx8mB-w/222cAp7lrIfYC2qSBTBssiUtQPRWNxo8Ku2qBMta_nFH1xQU4J3DHDxeKzYpIxOPtNCMHTD0jjAL6fyCP2Qjgg/Ye8nAptc1CDba-dq7OHmTPDpjQtyTysTXLDcBlCOHwE'), ('width', 1101), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/DZo6ES0MM-MnYnjqYOjipQ/9Qvf9XKvRR0-WlOjYZY-aSlNo9y1oexmjg2XXbAe4bsbyLth6El3Uj-_jaDvJQJd28CB1HQprQQyDuO9H3YjaQ/OBcYIsHeULhvg9egwS7_y_V3ZMV9ZfyPEpkzhq-mHo4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr850.html,['Lockin Amplifiers'],"[OrderedDict([('id', 'attkoPQ5bTJDi4BdD'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/7UR1PpT4_ZwD0GUc9vVjRA/uql0-Q1XDT6kBrRZTB8syv0HAvK7K6Ch4IEPC99OgU478mEU1l9wbnw0hP6wso8KdfFHpIBb_vhF9kDOtcN-BaTZAJ5f0MAGu55nRjMYqGk/pea-KL1YBZdZGsWitEezCpr9jBstc6L0saEWUXLVcHY'), ('filename', 'téléchargement (2).jpeg'), ('size', 4298), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/74KpDNtuZt4scqCRvUzVqw/l2YYH-jOJubODAtipH38NYrfTxH6X6AnZn0LozXqanGu0DKrBXU-SW6bi6cilCnGh1L3WbqUAN-3tzpAN-yICQ/u0GYhrCYtSUENED80QcSUtrL3pw9RncPZYlsIhAzxZ0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/TIAhqs4SUf_5UYCjT1nFIQ/BpgtOSrdkGADYH1OyvNzUjH4CpVmU6JFd09AfCzA81iqGFTb-F4SojqciQdgpehwIv88ClX0igMcEOO6_gT3Ww/avp2zthziqBlUH2nlTETdLjr0_Wvu4e_1dG5qNpHws0'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/XBNNB9_EOhDsgPUlpsVo0g/MO4blUUbhZlVM0U6hV2mFBhdxLBPpAQIGnHzERmi74i3LWT4_1P9vBUU7-P9juFzd3lNYsGcU9_L8vDHkVHRag/TcMvO8Ih9u4TnIfveaJTFUYeM0lT1HcGqZRHWBFAjcA'), ('width', 3000), ('height', 3000)]))]))])]","Flexible rental terms for your short & long term projects. Choose from over 5000 models. Top quality electronic test equipment available for rent from over 80 top manufacturers
",https://www.thinksrs.com,https://www.thinksrs.com/downloads/pdfs/catalog/SR850c.pdf,USA,20.0,"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.",https://en.wikipedia.org/wiki/Lock-in_amplifier,Write a Python script that uses Instrumental to connect to a {Device name} Lockin Amplifiers,9500.0,,,,"# Copyright 2016-2017 Christopher Rogers, Nate Bogdanowicz
""""""
Driver for SRS model SR850 lock-in amplifier.

Note that the sr850 will not usually work with `list_instruments()`, because it uses a non-standard
termination character, and because one must first send the 'OUTX' command to specify which type of
output to use.
""""""
from numpy import fromstring, float32
from enum import Enum
import visa
from ..util import check_units, check_enums
from ...errors import InstrumentTypeError
from ... import Q_

_INST_PARAMS = ['visa_address']
_INST_VISA_INFO = {'SR850': ('Stanford_Research_Systems', ['SR850'])}


BYTES_PER_POINT = 4
BINARY_TIME_PER_POINT = Q_('5 ms')
ASCII_TIME_PER_POINT = Q_('16 ms')


class AlarmMode(Enum):
    off = 0
    on = 1

class ReferenceSource(Enum):
    internal = 0
    internal_sweep = 1
    external = 2

class SweepType(Enum):
    linear = 0
    logarithmic = 1

class ReferenceSlope(Enum):
    sine_zero = 0
    ttl_rising = 1
    ttl_falling = 2

class InputConfiguration(Enum):
    A = 0
    A_B = 1
    I = 2

class CurrentGain(Enum):
    oneMegaOhm = 0
    oneHundredMegaOhm = 1

class InputGround(Enum):
    floating = 0
    ground = 1

class InputCoupling(Enum):
    AC = 0
    DC = 1

class LineFilter(Enum):
    no_filters = 0
    line_notch = 1
    line_2x_notch = 2
    both_filters = 3

class Sensitivity(Enum):
    x2nV_fA = 0
    x5nV_fA = 1
    x10nV_fA = 2
    x20nV_fA = 3
    x50nV_fA = 4
    x100nV_fA = 5
    x200nV_fA = 6
    x500nV_fA = 7
    x1uV_pA = 8
    x2uV_pA = 9
    x5uV_pA = 10
    x10uV_pA = 11
    x20uV_pA = 12
    x50uV_pA = 13
    x100uV_pA = 14
    x200uV_pA = 15
    x500uV_pA = 16
    x1mV_nA = 17
    x2mV_nA = 18
    x5mV_nA = 19
    x10mV_nA = 20
    x20mV_nA = 21
    x50mV_nA = 22
    x100mV_nA = 23
    x200mV_nA = 24
    x500mV_nA = 25
    x1V_uA = 26

class ReserveMode(Enum):
    maximum = 0
    manual = 1
    minimum = 2

class TimeConstant(Enum):
    x10us = 0
    x30us = 1
    x100us = 2
    x300us = 3
    x1ms = 4
    x3ms = 5
    x10ms = 6
    x30ms = 7
    x100ms = 8
    x300ms = 9
    x1s = 10
    x3s = 11
    x10s = 12
    x30s = 13
    x100s = 14
    x300s = 15
    x1ks = 16
    x3ks = 17
    x10ks = 18
    x30ks = 19

class LowPassSlope(Enum):
    six_dB_per_octave = 0
    twelve_dB_per_octave = 1
    eighteen_dB_per_octave = 2
    twentyfour_dB_per_octave = 3

class SynchronousFilter(Enum):
    off = 0
    on = 1

class Ch1OutputSource(Enum):
    X = 0
    R = 1
    theta = 2
    trace_1 = 3
    trace_2 = 4
    trace_3 = 5
    trace_4 = 6

class Ch2OutputSource(Enum):
    Y = 0
    R = 1
    theta = 2
    trace_1 = 3
    trace_2 = 4
    trace_3 = 5
    trace_4 = 6

class OffsetSelector(Enum):
    X = 1
    Y = 2
    R = 3

class Store(Enum):
    not_stored = 0
    stored = 1

class Multiply(Enum):
    unity = 0
    X = 1
    Y = 2
    R = 3
    theta = 4
    X_n = 5
    Y_n = 6
    R_n = 7
    AuxIn1 = 8
    AuxIn2 = 9
    AuxIn3 = 10
    AuxIn4 = 11
    F = 12

class Divide(Enum):
    unity = 0
    X = 1
    Y = 2
    R = 3
    theta = 4
    X_n = 5
    Y_n = 6
    R_n = 7
    AuxIn1 = 8
    AuxIn2 = 9
    AuxIn3 = 10
    AuxIn4 = 11
    F = 12
    X_2 = 13
    Y_2 = 14
    R_2 = 15
    theta_2 = 16
    Xn_2 = 17
    Yn_2 = 18
    Rn_2 = 19
    AuxIn1_2 = 20
    AuxIn2_2 = 21
    AuxIn3_2 = 22
    AuxIn4_2 = 23
    F_2 = 24

class ScanSampleRate(Enum):
    x62_5mHz = 0
    x125mHz = 1
    x250mHz = 2
    x500mHz = 3
    x1Hz = 4
    x2Hz = 5
    x4Hz = 6
    x8Hz = 7
    x16Hz = 8
    x32Hz = 9
    x64Hz = 10
    x128Hz = 11
    x256Hz = 12
    x512Hz = 13
    trigger = 14

class ScanMode(Enum):
    single_shot = 0
    loop = 1

class TriggerStartScanMode(Enum):
    no = 0
    yes = 1

class OutputType(Enum):
    X = 1
    Y = 2
    R = 3
    theta = 4

class TraceNumber(Enum):
    one = 1
    two = 2
    three = 3
    four = 4

class AuxInput(Enum):
    one = 1
    two = 2
    three = 3
    four = 4

class Parameter(Enum):
    X = 1
    Y = 2
    R = 3
    theta = 4
    AuxIn_1 = 5
    AuxIn_2 = 6
    AuxIn_3 = 7
    AuxIn_4 = 8
    reference_frequency = 9
    trace_1 = 10
    trace_2 = 11
    trace_3 = 12
    trace_4 = 13

    def units(parameter):
        if parameter.value in [1,2,3,5,6,7,8]:
            return 'V'
        if parameter.value == 4:
            return 'degrees'
        if parameter.value == 9:
            return 'Hz'
        else:
            return None

class StatusByte(Enum):
    no_scan_in_progress = 0
    no_command_execution_in_progress = 1
    enabled_bit_in_error_status_set = 2
    enabled_bit_in_LIA_status_set = 3
    output_buffer_non_empty = 4
    enabled_bit_in_standard_status_set = 5
    service_request = 6


class SR850:
    """""" Interfaces with the SRS model SR850 Lock-in Amplifier""""""
    AlarmMode = AlarmMode
    ReferenceSource = ReferenceSource
    SweepType = SweepType
    ReferenceSlope = ReferenceSlope
    InputConfiguration = InputConfiguration
    CurrentGain = CurrentGain
    InputGround = InputGround
    InputCoupling = InputCoupling
    LineFilter = LineFilter
    Sensitivity = Sensitivity
    ReserveMode = ReserveMode
    TimeConstant = TimeConstant
    LowPassSlope = LowPassSlope
    SynchronousFilter = SynchronousFilter
    Ch1OutputSource = Ch1OutputSource
    Ch2OutputSource = Ch2OutputSource
    OffsetSelector = OffsetSelector
    Store = Store
    Multiply = Multiply
    Divide = Divide
    ScanSampleRate = ScanSampleRate
    ScanMode = ScanMode
    TriggerStartScanMode = TriggerStartScanMode
    OutputType = OutputType
    TraceNumber = TraceNumber
    AuxInput = AuxInput
    Parameter = Parameter
    StatusByte = StatusByte

    def _initialize(self, rs232=True):
        """""" Connects to SRS850

        Parameters
        ----------
        rs232 : bool, optional
            Whether to use RS-232 or GPIB to communicate. Uses RS-232 by default
        """"""

        self.set_output_interface(rs232)
        self.ID = self._rsrc.query('*IDN?')
        vendor, model, SN, version = self.ID.split(',')
        if model != 'SR850':
            raise InstrumentTypeError('Instrument not SR580')

    def set_output_interface(self, rs232_interface=True):
        """""" Sets the output interface.

        Default is serial (rs232_interface=True)
        Set rs232_interface to False for GPIB
        """"""
        string = ""OUTX {}"".format((int(rs232_interface)+1)%2)
        self._rsrc.write(string)

    @check_units(frequency='Hz')
    def set_reference_frequency(self, frequency):
        """""" Sets the frequency of the reference source""""""
        return self._set('FREQ', 'Hz', frequency)

    def get_reference_frequency(self):
        """"""Returns the frequency of the reference source""""""
        return self._get('FREQ', 'Hz')

    @check_units(phase = 'degrees')
    def set_reference_phase(self, phase):
        """""" Sets the phase shift of the reference source""""""
        return self._set('PHAS', 'degrees', phase)

    def get_reference_phase(self):
        """"""Returns the phase shift of the reference source""""""
        return self._get('PHAS', 'degrees')

    @check_enums(reference_source=ReferenceSource)
    def set_reference_source(self, reference_source):
        """""" Sets the source used for the reference frequency.

        reference_source should be of type ReferenceSource
        """"""
        return self._set_enum('FMOD', reference_source)

    def get_reference_source(self):
        """""" Returns the source used for the reference frequency.

        Returns type ReferenceSource
        """"""
        return self._get_enum('FMOD', ReferenceSource)

    @check_enums(sweep_type=SweepType)
    def set_frequency_sweep_type(self, sweep_type):
        """""" Sets whether a sweep is linear or logarithmic.

        sweep_type should be of type SweepType
        """"""
        return self._set_enum('SWPT', sweep_type)

    def get_frequency_sweep_type(self):
        """""" Returns whether a sweep is linear or logarithmic.

        Returns type SweepType""""""
        return self._get_enum('SWPT', SweepType)

    @check_units(frequency='Hz')
    def set_start_frequency(self, frequency):
        "" Sets the frequency a sweep starts at""""""
        return self._set('SLLM', 'Hz', frequency)

    def get_start_frequency(self):
        """""" Returns the freqeuncy that a sweep starts at""""""
        return self._get('SLLM', 'Hz')

    @check_units(frequency='Hz')
    def set_stop_frequency(self, frequency):
        """"""Sets the frequency that a sweep stops at""""""
        return self._set('SULM', 'Hz', frequency)

    @check_units(frequency='Hz')
    def get_stop_frequency(self):
        """"""Returns the frequency that a sweep stops at""""""
        return self._get('SULM', 'Hz')

    @check_enums(reference_slope=ReferenceSlope)
    def set_reference_slope(self, reference_slope):
        """""" Sets the mode with wich the reference source is discriminated.

        This is only relevant when an external source is used.

        reference_slope should be of type ReferenceSlope""""""
        return self._set_enum('RSLP', reference_slope)

    def get_reference_slope(self):
        """"""Returns the mode with wich the reference source is discriminated.""""""
        return self._get_enum('RSLP', ReferenceSlope)

    def set_detection_harmonic(self, harmonic):
        """""" Sets the detection harmonic """"""
        return self._set('HARM', None, harmonic)

    def get_detection_harmonic(self):
        """""" Returns the detection harmonic """"""
        return self._get('HARM', None)

    @check_units(amplitude='V')
    def set_sine_amplitude(self, amplitude):
        """"""  Sets the amplitude of the sine output.

        Must be between 0.004 and 5V.
        (Rounds to nearest 0.002 V)
        """"""
        return self._set('SLVL', 'V', amplitude)

    def get_sine_amplitude(self):
        """""" Returns the amplitude of the sine output, in Volts.""""""
        return self._get('SLVL', 'V')

    @check_enums(input_configuration=InputConfiguration)
    def set_input_configuration(self, input_configuration):
        """""" Sets the input configuration.

        input_conusing should be of type InputConfiguration
        """"""
        return self._set_enum('ISRC', input_configuration)

    def get_input_configuration(self):
        """""" Returns the input configuration.""""""
        return self._get_enum('ISRC', InputConfiguration)

    @check_enums(current_gain=CurrentGain)
    def set_current_gain(self, current_gain):
        """""" Sets the conversion gain of the input current.

        Use the enumerator CurrentGain """"""
        return self._set_enum('IGAN', current_gain)

    def get_current_gain(self):
        """"""Returns the conversion gain of the input current """"""
        return self._get_enum('IGAN', CurrentGain)

    @check_enums(input_ground=InputGround)
    def set_input_ground(self, input_ground):
        """""" Sets the input shield grounding mode.

        Use the enumerator InputGround""""""
        return self._set_enum('IGND', input_ground)

    def get_input_ground(self):
        """""" Returns the input shield grounding mode.""""""
        return self._get_enum('IGND', InputGround)

    @check_enums(input_coupling=InputCoupling)
    def set_input_coupling(self, input_coupling):
        """""" Sets the input coupling mode
        Use the enumerator InputCoupling""""""
        return self._set_enum('ICPL', input_coupling)

    def get_input_coupling(self):
        """""" Returns the input coupling mode""""""
        return self._get_enum('ICPL', InputCoupling)

    @check_enums(line_filter=LineFilter)
    def set_line_filter_status(self, line_filter):
        """""" Sets the configuration of the line filters.

        Use the enumerator LineFilter""""""
        return self._set_enum('ILIN', line_filter)

    def get_line_filter_status(self):
        """""" Returns the configuratin of the line filters""""""
        return self._get_enum('ILIN', LineFilter)

    @check_enums(sensitivity=Sensitivity)
    def set_sensitivity(self, sensitivity):
        """""" Sets the sensitivity of the instrument.

        Use the enumerator Sensitivity""""""
        return self._set_enum('SENS', sensitivity)

    def get_sensitivity(self):
        """"""Returns the sensitivity setting of the instrument """"""
        return self._get_enum('SENS', Sensitivity)

    @check_enums(reserve_mode=ReserveMode)
    def set_reserve_mode(self, reserve_mode):
        """""" Sets the reserve mode of the instrument

        Use the enumerator ReserveMode""""""
        return self._set_enum('RMOD', reserve_mode)

    def get_reserve_mode(self):
        """""" Returns the reserve mode of the instrument.""""""
        return self._get_enum('RMOD', ReserveMode)

    def set_reserve(self, reserve):
        """""" Sets the manual dynamic reserve.

        Reserve should be an integer
        between 0 and 5, inclusive. 0 sets the minimum reserve for the current
        time constant and sensitivity.  Each increment increases the reserve
        by 10dB. """"""
        return self._set('RSRV', None, reserve)

    def get_reserve(self):
        """""" Returns the current value of the dynamic reserve.""""""
        return self._get('RSVR', None)

    @check_enums(time_constant=TimeConstant)
    def set_time_constant(self, time_constant):
        """""" Sets the time constant of the instrument

        Use the enumerator TimeConstant""""""
        return self._set_enum('OFLT', time_constant)

    def get_time_constant(self):
        """"""Get the current time constant of the instrument.""""""
        return self._get_enum('OFLT', TimeConstant)

    @check_enums(low_pass_slope=LowPassSlope)
    def set_low_pass_slope(self, low_pass_slope):
        """""" Sets the slope for the low pass filter

        Use the enumerator LowPassSlope""""""
        return self._set_enum('OFSL', low_pass_slope)

    def get_low_pass_slope(self):
        """""" Returns the slope of the low pass filter.""""""
        return self._get_enum('OFSL', LowPassSlope)

    @check_enums(synchronous_filter=SynchronousFilter)
    def set_synchronous_filter(self, synchronous_filter):
        """""" Sets the state of the synchronous filter.

        Use the enumerator SynchronousFilter.
        Note that the synchronous filter only operates if
        the detection frequency is below 200Hz""""""
        return self._set_enum('SYNC', synchronous_filter)

    def get_synchronous_filter(self):
        """"""Returns the state of the synchronous filter.""""""
        return self._get_enum('SYNC', SynchronousFilter)

    @check_enums(ch1_output_source=Ch1OutputSource)
    def set_ch1_output_source(self, ch1_output_source):
        """""" Sets the output source for channel 1.

        Use the enumerator Ch1OutputSource. """"""
        return self._set_enum('FOUT1,', ch1_output_source)

    def get_ch1_output_source(self):
        """"""Returns the output source for channel 1.""""""
        return self._get_enum('FOUT?1', Ch1OutputSource, QM=False)

    @check_enums(ch2_output_source=Ch2OutputSource)
    def set_ch2_output_source(self, ch2_output_source):
        """""" Sets the output source for channel 2

        Use the enumerator Ch2OutputSource. """"""
        return self._set_enum('FOUT2,', ch2_output_source)

    def get_ch2_output_source(self):
        """"""Returns the output source for channel 2.""""""
        return self._get_enum('FOUT?2', Ch2OutputSource, QM=False)

    @check_enums(offset_selector=OffsetSelector)
    def set_output_offsets_and_expands(self, offset_selector, offset,
                                       expand):
        """""" Sets the offsets and expands for the selected quadrature.

        offset_selector is of type OffsetSelector, and indicates which
        quadrature to use.
        Note that offset_selector should be in percent, and expand should
        be an integer between 1 and 256 """"""
        offset = offset
        command_string = ""OEXP {}, {}, {}""
        command_string = command_string.format(offset_selector.value,
                                               offset, int(expand))
        val = self._rsrc.write(command_string)
        assert val == len(command_string)

    @check_enums(offset_selector=OffsetSelector)
    def get_output_offsets_and_expands(self, offset_selector):
        """""" Returns the offsets and expands for the selected quadrature.

        offset_selector should be of type OffsetSelector""""""
        command_string = ""OEXP? {}"".format(offset_selector.value)
        value = self._rsrc.query(command_string)
        offset, expand = value.split(',')
        return offset, expand

    @check_enums(offset_selector=OffsetSelector)
    def auto_offset(self, offset_selector):
        """""" Automatically offsets the selected quadrature to zero

        offset_selector should be of type OffsetSelector """"""
        self._set_enum('AOFF', offset_selector)

    @check_enums(trace=TraceNumber, m1=Multiply, m2=Multiply, d=Divide,
                 store=Store)
    def set_trace_definitions(self, trace, m1,
                              m2=Multiply.unity, d=Divide.unity,
                              store=Store.stored):
        """""" Sets the definition of the given trace 'trace' to be
        m1*m2/d.

        Trace should be an enumerator of Trace,
        m1 and m2 should be enumerators of Multiply,
        d should be an enumerator of Divide,
        and store should be an enumerator of Store.
        """"""
        m1 = m1.value
        m2 = m2.value
        d = d.value
        trace = trace.value
        store = store.value
        command_string = ""TRCD {}, {}, {}, {}, {}""

        command_string = command_string.format(trace, m1, m2,
                                               d, store)
        self._rsrc.write(command_string)

    @check_enums(trace=TraceNumber)
    def get_trace_definitions(self, trace):
        """""" Returns the definition of the given trace.

        Trace should be an enumerator of Trace.
        The trace definition is of the form m1*m2/d

        Returns
        --------

        m1, m2 of type Multiply
        d of type Divide
        store of type Store
        """"""
        command_string = ""TRCD? {}"".format(trace.value)
        value = self._rsrc.query(command_string)
        m1, m2, d, store = value.split(',')
        m1 = Multiply(int(m1))
        m2 = Multiply(int(m2))
        d = Divide(int(d))
        store = Store(int(store))
        return m1, m2, d, store

    @check_enums(scan_sample_rate=ScanSampleRate)
    def set_scan_sample_rate(self, scan_sample_rate):
        """""" Sets the sampling rate of a scan.

        Use the enumerator ScanSampleRate. """"""
        return self._set_enum('SRAT', scan_sample_rate)

    def get_scan_sample_rate(self):
        """""" Sets the sampling rate of a scan. """"""
        return self._get_enum('SRAT', ScanSampleRate)

    @check_units(scan_length='s')
    def set_scan_length(self, scan_length):
        """""" Sets the scan length.""""""
        return self._set('SLEN', 's', scan_length)

    def get_scan_length(self):
        """"""Returns the scan length.""""""
        return self._get('SLEN', 's')

    @check_enums(scan_mode=ScanMode)
    def set_scan_mode(self, scan_mode):
        """""" Sets the scan mode.
        Use the enumerator ScanMode. """"""
        return self._set_enum('SEND', scan_mode)

    def get_scan_mode(self):
        """"""Returns the scan mode.""""""
        return self._get_enum('SEND', ScanMode)

    def trigger(self):
        """""" Initiates a trigger event. """"""
        self._send_command('TRIG')

    @check_enums(aux_in=AuxInput)
    def get_aux_in(self, aux_in):
        """""" Returns the voltage of the specified auxiliary input.

        aux_in should be of type AuxIn  """"""
        command_string = 'OAUX?{}'.format(aux_in.value)
        return self._get(command_string, 'V', QM=False)

    @check_enums(trigger_start_scan_mode=TriggerStartScanMode)
    def set_trigger_start_scan_mode(self, trigger_start_scan_mode):
        """""" Sets the mode in which the trigger initiates a scan.

        Use the enumerator TriggerStartScanMode. """"""
        return self._set_enum('TSTR', trigger_start_scan_mode)

    def get_trigger_start_scan_mode(self):
        """"""Returns the mode in which the trigger initiates a scan.""""""
        return self._get_enum('TSTR', TriggerStartScanMode)

    def start_scan(self):
        """""" Starts or resumes a scan/sweep.

        Has no effect if a scan is already
        in progress. """"""
        self._send_command('STRT')

    def pause_scan(self):
        """""" Pauses a scan or sweep.

        Has no effect is no scans are in progress.""""""
        self._send_command('PAUS')

    def reset_scan(self):
        """""" Resets a scan.

        This works whether a scan is in progress, finished, or paused.
        Note that the data buffer is erased. """"""
        self._send_command('REST')

    def auto_gain(self):
        """""" Performs the auto-gain function.

        Note that this function does not
        return until the process has completed.""""""
        self._send_command('AGAN')

    def auto_reserve(self):
        """""" Performs the auto-reserve function """"""
        self._send_command('ARSV')

    def auto_phase(self):
        """""" Performs the auto-phase function """"""
        self._send_command('APHS')

    @check_enums(output_type=OutputType)
    def read_output(self, output_type):
        """""" Returns the value of the indicated output

        use type OutputType. """"""
        command_string = ""OUTP?{}"".format(output_type.value)
        if output_type in [OutputType.X, OutputType.Y, OutputType.R]:
            units = 'V'
        else:
            units = 'degrees'
        return self._get(command_string, units, QM=False)

    @check_enums(trace_number=TraceNumber)
    def read_trace_value(self, trace_number, units=None):
        """""" Returns the current value of indicated trace

        trace_number should be of enumeraror class TraceNumber.
        If specified, units are added to the returned value.
        units should be a string.""""""
        command_string = ""OUTR? {}"".format(trace_number.value)
        return self._get(command_string, units, QM=False)

    @check_enums(aux_input=AuxInput)
    def read_aux_input(self, aux_input):
        """""" Returns the value of the specified aux input

        use type AuxInput""""""
        command_string = ""OAUX? {}"".format(aux_input.value)
        return self._get(command_string, 'V', QM=False)

    def read_simultaneously(self, parameters):
        """""" Returns simultaneously the values of the given parameters

        the list parameters should have between two and six elements of the type
        Parameter""""""
        command_string = ""SNAP?""
        i = 0
        for parameter in parameters:
            if i == 0:
                command_string = command_string + '{}'.format(parameter.value)
            else:
                command_string = command_string + ',{}'.format(parameter.value)
            i = i + 1
        value = self._rsrc.query(command_string)
        outputs = value.split(',')
        for i in range(len(outputs)):
            parameter = parameters[i]
            outputs[i] = Q_(outputs[i], parameter.units())
        return outputs

    @check_enums(trace_number=TraceNumber)
    def trace_length(self, trace_number):
        """""" Returns the number of points in the specified trace

        use the enumerator TraceNumber """"""
        command_string = ""SPTS? {}"".format(trace_number.value)
        return self._get(command_string, None, QM=False).magnitude

    @check_enums(trace_number=TraceNumber)
    def get_trace(self, trace_number, points=None, units=None, binary=True):
        """""" Returns a vector of the values stored in the indicated trace

        If get_trace times out while transferring data, the constants
        BINARY_TIME_PER_POINT and or ASCII_TIME_PER_POINT may need to be
        increased

        Parameters
        ----------

        trace_number should be an element of TraceNumber.

        points is a list of two integers - the first indicates the position
        of the first value to be read, while the second indicates the number
        of values to be read.  By default, all points are read.

        units - string indicating the proper units of the trace
        binary - boolean indicating the method of data transfer.  Using binary
        is usually about 4 times faster.
        """"""
        if points is None:
            points = [0, self.trace_length(trace_number)]
        if binary:
            command = 'TRCB'
        else:
            command = 'TRCA'
        command_string = ""{}? {}, {}, {}"".format(command, trace_number.value,
                                                 points[0], points[1])
        if binary:
            self._send_command(command_string)
            timeout = self._rsrc.timeout
            read_termination = self._rsrc.read_termination
            end_input = self._rsrc.end_input

            #Factor of 2 is so that the transfer completes before timing out
            self._rsrc.timeout = 2*BINARY_TIME_PER_POINT.to('ms').magnitude*points[1] + timeout
            self._rsrc.read_termination = None
            self._rsrc.end_input = visa.constants.SerialTermination.none
            with self._rsrc.ignore_warning(visa.constants.VI_SUCCESS_MAX_CNT):
                raw_binary, _ = self._rsrc.visalib.read(self._rsrc.session,
                                                        points[1]*BYTES_PER_POINT)
            trace = fromstring(raw_binary, dtype=float32)
            trace = trace.astype(float)
            self._rsrc.read_termination = read_termination
            self._rsrc.end_input = end_input
            self._rsrc.timeout = timeout
        else:
            timeout = self._rsrc.timeout

            #Factor of 2 is so that the transfer completes before timing out
            self._rsrc.timeout = 2*ASCII_TIME_PER_POINT.to('ms').magnitude*points[1] + timeout
            value = self._rsrc.query(command_string)
            trace = fromstring(value, sep=',')
            self._rsrc.timeout = timeout
        assert len(trace) == points[1]
        return Q_(trace, units)

    @check_enums(alarm_mode=AlarmMode)
    def set_alarm_mode(self, alarm_mode):
        """""" Sets the audible alarm on or off.

        Use the enumerator AlarmMode. """"""
        return self._set_enum('ALRM', alarm_mode)

    def get_alarm_mode(self):
        """"""Returns whether the audible alarm is on or off.""""""
        return self._get_enum('ALRM', AlarmMode)

    def scan_in_progress(self):
        """"""Indicates if a scan is in progress.

        Note that a paused scan is counted as being in progress """"""
        status_byte = StatusByte.no_scan_in_progress
        return not self._read_status_byte(status_byte)

    def command_execution_in_progress(self):
        """""" Indicates if a command is currently being executed. """"""
        status_byte = StatusByte.no_command_execution_in_progress
        return not self._read_status_byte(status_byte)

    def _reset(self):
        """""" Resets the machine to its defaults. """"""
        self._send_command(""*rst"")

    def clear_registers(self):
        """""" Clears all status registers, except for status enable registers.
        """"""
        self._send_command(""*CLS"")

    def _get(self, command_string, unit_string, QM=True):
        if QM:
            command_string = command_string + '?'
        value = self._rsrc.query(command_string)
        return Q_(value, unit_string)

    def _set(self, command_string, unit_string, value):
        value = Q_(value)
        command_string = ""{} {}"".format(command_string,
                                        value.to(unit_string).magnitude)
        self._send_command(command_string)

    def _get_enum(self, command_string, enum_class, QM=True):
        value = self._get(command_string, None, QM=QM)
        return enum_class(value.magnitude)

    def _set_enum(self, command_string, enum_value):
        enum_value = enum_value.value
        command_string = ""{} {}"".format(command_string, enum_value)
        self._send_command(command_string)

    @check_enums(status_byte=StatusByte)
    def _read_status_byte(self, status_byte):
        """""" Returns a bool indicating the status byte indicated by status_byte,
        which should be a member of enumerator class StatusByte """"""
        command_string = ""*STB? {}"".format(status_byte.value)
        value = self._rsrc.query(command_string)
        return bool(int(value))

    def _send_command(self, command_string):
        self._rsrc.write(command_string)

    def close(self):
        self._rsrc.close()
"
299,,Newmark,"Newmark - NSC-A1
",Instrumental,The NSC-A1 Series motion controller is a powerful single axis stepper motor control system which combines a microstepping driver with a programmable controller into a compact envelope,https://github.com/mabuchilab/Instrumental/tree/master/docs,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/motion/newmark.py,"Newmark - NSC-A1
","[OrderedDict([('id', 'attus90HqEIevMPuI'), ('width', 810), ('height', 460), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/d279uKmc8SrVi0aRwOMM_A/1Sv1kLmsAeLO0NrwRXN46Rr7F0F3R8LPobvo-1i9-_DEHbC1rh2HneacXMC1NoNZ6_gHgKobYPVSHRbTHBe2qALG4_2ANNHkn6JrvT-MH52gMyCptvqMEXIonUX9OZPbru9Z9ckT_Y4tFjJR9NFIug/F2BRJiIfwoF84kAJEOUFcXCeX8TtPJLqrULMnOcP9mY'), ('filename', 'nsc-a1_stepper-motor-controller-main.webp'), ('size', 21528), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ciWHRFEfvpQFEMYNlknGCw/nEyJ2R92IC5v_y1e8hqaTL4NV-R9S3URp0-lXsx17iCzpEswSWJv4o8-OgyAmPm81-oPhDB9SX5hzTAIEOJDlJTBq4SBVStOeTS2KrPOISU/r9BienZhFROk-M_LsvtXt5tTLGAQ8cRwWdn4ib-HISk'), ('width', 63), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/atzI_3PvkNmJdehFjZ-X-Q/CAsCxIkqVMeQIDMzxnllRRub0wdkBlbysWjTvnFchZbuLikWLNNPbUHe99vF9YwePd-ak_DxcIYLIGMlQWqC3_3eIn8GoD1sA4Oi_3yh2Mo/Nm3RUMSY4jb1gFEMs9uG5HQ4FiLjdrHpARozi2rsems'), ('width', 810), ('height', 460)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/7a_9ad7BJbnqU6UuOYrdFQ/vz138zFO-b9KQ-CjdqlSThJH6PYr4rD0TR2KLuzRs4yDYix1otpIOdFscN_x9OxGjml0bCIz3Xo-ehWfb63TIq9GqtFMDnTEThU0WmYpuyw/C6z6dOWH-MHSWU6lmzgD7iv95i4GLUfL8uAwHPTXrh8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newmarksystems.com/motion-controllers/nsc-a1/,['Motion'],"[OrderedDict([('id', 'attM3smOnSeuTOvf4'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/2OPnA-nqhxD3SfIRUuJajw/ehojw7oHzs5bFdDpTgzfwGS0MM50C8SGNAAkiOw1FeA_Ap7QrCTJE_itXb_Ea5dLmTcHhQ1D36HXPCrQVR7Kh2kHBxZfi48uM3npjIZIUfVL8IPzmoMvUKNOQ4PZ_SBbTrYL2ipCEoAauv14mkz3-A/35dG4keBVLjeOYB-G9BusN6E5G7o8ULWlpdtHYer-YM'), ('filename', '9fa1c4833c1536f10e254a8bbe497e6c_400x400.png'), ('size', 60219), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/OQEAk_zXuYhx-WeJkQslfA/7hTNkInkgkSrRTe-WnAqaj2edUBUShCvzU_fPSEZmZ-0gnBve4fUw3RzWjru-BFrrFLWRYUEetjoSgpoV_k8Jg/tzPbi2CDh8fhcOCB3m6p1E-we9RJNSzVB1-0Py0IcyU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/q--RTo1_1dTTgN4aijDkwQ/z2W7VRaqGxptTQSmtEW5ZvhOzB37AFaJfJA1IX80c_RFopfRDH2a5mYDSS97vigSISvGw2heQpaXA2Am79wvRQ/Czrfh8w0cgpdv8qFnCxifk2H0xSkSuf5Al-RvbkDuTU'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ijfLXVyYCfrinBBmbEX1PA/pc93tp4PVTa6CselXe-z_csE55gL9GYkmqLcqawHBL9u-mI1KAd0pFP0hA9VuOzoYcSFLrrdi2K6U1bx1634qQ/Kro8mo6Jl8okerY1S2wqpmrgPUz3dZjxtpMl0sSkQRg'), ('width', 3000), ('height', 3000)]))]))])]","**Newmark Systems** is a world leader in precision rotary table technology designed for critical positioning applications
",https://www.newmarksystems.com/,https://www.newmarksystems.com/downloads/software/NSC-A/NSC-A1/NSC-A1_Manual_Rev_1.3.0.pdf,USA,12.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumental to connect to a {Device name} Motion,1300.0,,,,"# -*- coding: utf-8 -*-
""""""
Drive for controlling Newmark rotation stages
""""""

from . import Motion
from .. import ParamSet
from ...log import get_logger
from .. import VisaMixin
from ..util import check_units
from ... import u
import visa

log = get_logger(__name__)

__all__ = ['NSCA1']


# TODO: There should be a function wrapper
class ImplicitUnitsException(Exception):
    pass


class NSCA1(Motion):
    """""" Class for controlling Newmark NSC AI.

    """"""
    _INST_PARAMS_ = ['serial']

    def _initialize(self):
        self.serial = self._paramset['serial']
        # I only ever use channel 1, but maybe there are needs for more.
        self.channel = 1
        self._rsrc = visa.ResourceManager().open_resource(
            self.serial,
            read_termination='\r',
            write_termination='\r')

    def _cmd(self, cmd):
        self._rsrc.write('@%02d%s' % (self.channel, cmd))
        ret = self._rsrc.read()
        return ret

    def close(self):
        self._rsrc.close()

    @check_units(val='deg')
    def _get_ticks(self, val):
        if val.u not in [u.rad, u.deg]:
            raise ImplicitUnitsException('Mark as degrees or radians')
        return val.to('deg').m * 1e4

    @property
    def angle(self):
        angle = float(self._cmd('PX'))/1e4
        return angle * u.deg

    @angle.setter
    @check_units(angle='deg')
    def angle(self, angle):
        if angle.u not in [u.rad, u.deg]:
            raise ImplicitUnitsException('Mark as degrees or radians')
        self._cmd('ABS')
        self._cmd('X%i' % self._get_ticks(angle))
        self.wait_until_motor_is_idle()

    @check_units(angle='deg')
    def cw(self, angle, background=False):
        """"""
        Rotate clockwise through a specified angle

        Args:
            angle (Quantity): The amount to rotate
            background (bool, optional): If true, the rotation will occur in
                the background to allow other commands to happen while the
                stage rotates
        """"""
        if angle.u not in [u.rad, u.deg]:
            raise ImplicitUnitsException('Mark as degrees or radians')
        val = self._get_ticks(angle)
        #if not self._is_safe(self.x + val):
        #    return

        self._cmd('INC')
        self._cmd('X{}'.format(val))

        if background:
            self.wait_until_motor_is_idle()

    @check_units(angle='deg')
    def ccw(self, angle, background=False):
        """"""
        Rotate counter-clockwise through a specified angle

        Args:
            angle (Quantity): The amount to rotate
            background (bool, optional): If true, the rotation will occur in
                the background to allow other commands to happen while the
                stage rotates
        """"""
        self.cw(-angle, background)

    def wait_until_motor_is_idle(self):
        try:
            while self.is_moving():
                pass
        except KeyboardInterrupt:
            self._cmd('STOP')
            raise KeyboardInterrupt

    def is_stationary(self):
        return int(self._cmd('MST')) == 0

    def is_moving(self):
        return not self.is_stationary()

    @property
    def velocity(self):
        return int(self._cmd('HSPD')) / 1e4 * u.deg / u.s

    @velocity.setter
    @check_units(velocity='deg/s')
    def velocity(self, velocity):
        ticks_per_second = self._get_ticks((velocity * u.s).to('deg'))
        self._cmd('HSPD=%i' % (ticks_per_second))
"
332,,Bristol,Bristol,Instrumental,The 771 Series Laser Spectrum Analyzer combines proven Michelson interferometer technology with fast Fourier transform analysis resulting in a unique instrument that operates as both a high-resolution spectrum analyzer and a high-accuracy wavelength meter.,https://instrumental-lib.readthedocs.io/en/stable/spectrometers-bristol.html,https://github.com/mabuchilab/Instrumental/blob/master/instrumental/drivers/spectrometers/bristol.py,Bristol 771 ,"[OrderedDict([('id', 'attibm1oQTNYNoysV'), ('width', 590), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/GvvKhDpqk00r5gLGeest3Q/LPuIIzHUiskIXJ8moYpv0SGH2jhsx8r3USPNQcVh4tS8mOBvbn1QVJ4EjPYEW1t1yP4ec32EW-cljI-Vd3uoc-dLoks2DFlDt8Z43PKaHiA/WYHcT-bmFxFZXTEDa2l3BgaM64dRO_3XwM4IrZVmw4E'), ('filename', 'thumbnail_63095.png'), ('size', 92197), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Q93ooWXwMab7uW3lOlYTkg/DkLuo4aAiSWuuXdVmEVPhtci_HNbd5GlXBH0_ad1FYpwKujUFO0NN1UABpZnIjP7V65byXlUVa7hDMIj75fqPA/MGjp3tQcUzcE83nsirV8pZNoFpAWSMbJANAn8SOtbHU'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/31izsvLVLyueCHENeDCV5w/ZMwmTjW2BQ3dSUceoO42hwFZxm_fhtBel4YLqOwd8JXXVwLYjTIkqJ8YlSzIdNdTQ8CnzW5CuSiuuuc8wOt09Q/APfm2deRo11c45PYdekrlA6cneJ6bp6Jg5S8qGWmfaM'), ('width', 590), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ACm9ZVNA941Yxz5Sfa3nrg/PLMLdAeVSpz1BOMESrtcPz1GI0TOFs2dp_7EZ2kA7vB1LE7eYvmNqFKfLJqfgYHGXj4T-kmQE7zwaZvpF2pf5g/7zSgU80jJ0XH5Ums7vGfEWE-Lc4s5KtkSVUef6Xi36U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.bristol-inst.com/bristol-instruments-products/spectrum-analyzers/771-series-laser-spectrum-analyzer/,['Spectrum Analyzers'],"[OrderedDict([('id', 'attEnd6xRSoAmFpME'), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/bS4Nbmblk9q6Es1bzyUkyg/I_FrjnLVvPH6OaE2EtYv_G0jk3VHSGADXSZHIaIycoC-mBP48_YXBJOyu3LLzFvLizIEyUBo7Dt1o3VVglQiYJ38n1hoQ3xrwj568XR2s7tSYiXW6m-HOm8Ldhns5bepmY5Mzw5fNKB1isRE2JY0nQ/XndbVn0SU5wDhO_K5W_w_uSzrJZjbXZtTSRGAEkH7Es'), ('filename', 'Bristol_logo_BRIGHT_official_2x.5df1145a1c08b.avif'), ('size', 5617), ('type', 'image/avif')])]","**Bristol Instruments**' Wavelength Meters Are For Scientists And Engineers. Precise laser wavelength measurement and complete spectral analysis. Reliable accuracy.

",https://www.bristol-inst.com/,https://bristolinst.wpenginepowered.com//wp-content/uploads/2020/01/Bristol-771-Series-Laser-Spectrum-Analyzer-Specifications.pdf,USA,7.1,"A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument
",https://en.wikipedia.org/wiki/Spectrum_analyzer,Write a Python script that uses Instrumental to connect to a Bristol 771  Spectrum Analyzers,,,,,"# -*- coding: utf-8 -*-
# Copyright 2014-2017 Nikolas Tezak, Nate Bogdanowicz
""""""
Driver for Bristol 721 spectrum analyzers.
""""""
import os
import sys
from contextlib import contextmanager
from functools import wraps
import ctypes
import numpy as np
from numpy.ctypeslib import ndpointer

from . import Spectrometer
from .. import ParamSet
from ... import u

_INST_PARAMS = ['port']
_INST_CLASSES = ['Bristol_721']

bristol_dll = ctypes.WinDLL(""BristolFFT.dll"", use_errno=True, use_last_error=True)
bristol_lv_dll = ctypes.WinDLL(""BristolLV.dll"", use_errno=True, use_last_error=True)

# Set DLL function signatures
find_comm_port = bristol_lv_dll.CLFindBristolCommPort
find_comm_port.restype = ctypes.c_int

open_device = bristol_dll.CLOpenUSBSerialDevice
open_device.argtypes = [ctypes.c_int]
open_device.restype = ctypes.c_int

get_lambda = bristol_dll.CLGetLambdaReading
get_lambda.argtypes = [ctypes.c_int]
get_lambda.restype = ctypes.c_double

bristol_dll.CLGetPowerReading.argtypes = [ctypes.c_int]
bristol_dll.CLGetPowerReading.restype = ctypes.c_float

bristol_lv_dll.CLGetNextSpectrum.argtypes = [
    ctypes.c_int,
    ndpointer(np.float32, ndim=1, flags='C_CONTIGUOUS'),
    ndpointer(np.float32, ndim=1, flags='C_CONTIGUOUS'),
    ctypes.c_int
]


# Adapted from <http://stackoverflow.com/a/17954769>
@contextmanager
def stderr_redirected(to=os.devnull):
    fd = sys.stderr.fileno()

    def _redirect_stderr(to):
        sys.stderr.close()
        os.dup2(to.fileno(), fd)
        sys.stderr = os.fdopen(fd, 'w')

    with os.fdopen(os.dup(fd), 'w') as old_stderr:
        with open(to, 'w') as file:
            _redirect_stderr(to=file)
        try:
            yield
        finally:
            _redirect_stderr(to=old_stderr)


# Decorator for redirecting stderr to /dev/null for the function's duration
def ignore_stderr(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        with stderr_redirected():
            return f(*args, **kwargs)
    return wrapper


# Table obtained from Bristol technical support
FFT_INFO = {
    ('VIS', 0): (131072, 1, 3, 350, 421),
    ('VIS', 1): (131072, 1, 2, 423, 632),
    ('VIS', 2): (131072, 1, 1, 632, 1100),
    ('NIR', 0): (131072, 1, 2, 500, 632),
    ('NIR', 1): (131072, 1, 1, 633, 1265),
    ('NIR', 2): (32768,  4, 3, 1266, 1685),
    ('IR',  0): (65536,  1, 0, 1266, 5000),
    ('MIR', 0): (32768,  5, 1, 4000, 6329),
    ('MIR', 1): (16384,  9, 1, 5700, 11000),
    ('XIR', 0): (131072, 1, 0, 1500, 12000),
}


def bin_index(fft_size, dec, fold, lamb):
    if fold % 2 == 0:
        bin = ((2*dec*632.9914)/lamb - fold) * fft_size
    else:
        bin = (fold + 1 - (2*dec*632.9914)/lamb) * fft_size
    return bin


class Bristol_721(Spectrometer):
    def _initialize(self):
        self._com_port = self._paramset.get('port') or find_comm_port()
        self._dll = bristol_dll
        self._lv = bristol_lv_dll
        self._handle = open_device(self._com_port)

        if self._handle < 0:
            raise Exception(""Failed to open connection to spectrum analyzer"")
        elif self._handle == 0:
            raise Exception(""You must have already opened the port"")

        self._lv.CLRegister(self._handle)

        # Hard-coded for now, ideally we'd auto-detect this via a model byte or something
        self._model = 'IR'
        self._range_num = 0

    def _fft_range(self):
        fft_size, dec, fold, low_wav, hi_wav = FFT_INFO[(self._model, self._range_num)]
        low_index = bin_index(fft_size, dec, fold, low_wav)
        high_index = bin_index(fft_size, dec, fold, hi_wav)
        if low_index > high_index:
            low_index, high_index = high_index, low_index
        return int(low_index+1), int(high_index-1)  # Exclude edge of the range to be safe

    def get_wavelength(self):
        """"""Get the vacuum wavelength of the tallest peak in the spectrum

        Returns
        -------
        wavelength : Quantity
            The peak wavelength, in nm
        """"""
        return self._dll.CLGetLambdaReading(self._handle) * u.nm

    def get_spectrum(self):
        """"""Get a spectrum.

        Returns
        -------
        x : array Quantity
            Wavelength of the bins, in nm
        y : array
            Power in each bin, in arbitrary units
        """"""
        start, stop = self._fft_range()
        size = stop-start
        self._dll.CLGetFullSpectrum(self._handle, start, stop)

        wavenumber = np.zeros(size, np.float32)
        power = np.zeros(size, np.float32)

        ret = 0
        while not ret:
            ret = self._lv.CLGetNextSpectrum(self._handle, power, wavenumber, size)

        # For some reason, x is not sorted already...
        indices = np.argsort(wavenumber)
        return 1e10/wavenumber[indices] * u.nm, power[indices]  # Is this scaling right?

    def close(self):
        self._dll.CLCloseDevice(self._handle)


def list_instruments():
    com_ports = [find_comm_port()]  # TODO: Add support for multiple connected devices
    return [ParamSet(Bristol_721, port=port) for port in com_ports]
"
341,,Smaract,"Smaract (MCS and SDC
)",Instrumental,"The MCS2 is SmarAct’s most versatile and modular control system.

Its stringent modular design approach makes it the perfect choice for all field of applications
",https://instrumental-lib.readthedocs.io/en/latest/smaract.html,https://github.com/mabuchilab/Instrumental/blob/029647a974eb9cf5ae9c21fe0c2eb06d204f3da7/instrumental/drivers/motion/_smaract/scu.py,Smaract - MCS2,"[OrderedDict([('id', 'attfpiboz0V74uoiM'), ('width', 275), ('height', 183), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/v8zwxkaf-M7uAK6yw5BD_Q/RDb_9DywmtOYork5XpDtlf0w6PA1o6ma8ynvJoxoxPjGUYKIur38nS0cecpRDdEUwSBS2Te_FhTy7nn6Lg1w5v4UhP4npnstcqQPmLb_U4s/KbNMiFM3XV5TkZlqceGUXj28NSlGKHbWOUlFDXHoZ1I'), ('filename', 'téléchargement (3).jpeg'), ('size', 4112), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Xp5tIRgJ7hheAPf4_R5mnQ/KQ46O2qIG_2IP8qp4xQJNGg8UnypqhUHbHUqH-c8AVCUQbwb2Eov97Sz40xNlHLfEVR2AEMDZSTuqyzdKnmGXw/DAc1YZTj0qiJdjiSQk1IyZ7dhrGe7apFpvylG5x3oIc'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/9EJLrLJFvzamen7A1fCF7Q/51XpUANwdIYE8e8C3acbHlmQELezQA3amzjTljZAeSlb9czERtm7i_fwi3-urctgT2OI3hnFBqBPR9T-bq8Kkg/Iauu9ALwHzs2Hle80FwEw4exROdXic0lYxrNhQTQPBQ'), ('width', 275), ('height', 183)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/R8ykjg_xW_iOfJpNtGn7LA/fbmYG2gtxTn7jCeV7Zrm-P5nXIXwuHv54ixz_69XuAAwOYi3_0FuWxcfwTJ4bKO7ZpZv7YehFMDprD9oLouxeQ/ZbwGHh2HgXh1NDwOk3m0r9IW1Hw8qPqV9nAO3TDzyVs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.smaract.com/en/control-systems-and-software/product/mcs2#description,['Motion'],"[OrderedDict([('id', 'att0tQm23j3IZTujq'), ('width', 455), ('height', 111), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/GRM5V6VxGC6OXVNcarZsyg/vWpjxcgPff-FBneD-w6X8UUlVsD4fNljvq_fp4rn324nehsPbxPBOFzg01EKJJPwfBQVlyA1jK4UsRmTQbMHsg05wL38u6ZR9g5wJJ8mAKs/iu77EjeCIJvf8BtP1LobCwrFW6ysQefqMt9PtdgRRpU'), ('filename', 'images (1).png'), ('size', 5259), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ekPUx8pb08OpnKLo8gLt_A/QWTH8WtW2Mz52olME7peXKiQ_RROlUt6fliUM3lMZhHTyibbk1FwLItfRbqcSrMM1ULEvgtLb1_oClFhsjHdXw/C_H5IVjsQ1VoOnN8wEmqOj5RO6ouvWbmv_fiaBLUC2g'), ('width', 148), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/gyr5xwiD0wjZwAYxRNA7gw/a-mLHXIgf2AkekbKj3_NAshD0ddxSDtz3sHt22mtWOKTKGx59aqwY8U6fOzjmmf7UZD1vV5SbkieksvRiNHBVA/qvRjtspk8fFIClusfV3mXtPVI1QBErPVt5Tro_9kGmo'), ('width', 455), ('height', 111)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/I0BwzpntyzppW4pnlTFeJA/qKQ2Ds7Q2J5cGd71oHZ7t_tV9kaRLVvv67KKWiEZIm67zOCHEOPT_eOgivCtOFbQL0CqDnSq5K3T5-s7E0xJ-A/RuQD43EdAHl4bPX7orerSNY4MO22ExVybbLBCMFL83o'), ('width', 3000), ('height', 3000)]))]))])]","In our [Motion](https://www.smaract.com/en/motion) business unit, we develop and produce high-precision, compact products for nano-positioning that meet the highest demands while being easy to handle

",https://www.smaract.com/en/,https://www.smaract.com/en/control-systems-and-software/product/mcs2?download=files/media/files/MCS2_Modular_Concept.pdf,USA,15.0,"Motion controller calculates and controls the mechanical trajectories (motion profile) an actuator must follow (i.e., motion planning) and, in closed loop systems, employs feedback to make control corrections and thus implement closed-loop control.",https://en.wikipedia.org/wiki/Motion_control,Write a Python script that uses Instrumental to connect to a Smaract - MCS2 Motion,,,,,"""""""Driver module for Smaract SCU controller.

This module allows controls of linear SLC stages or rotary ones using the SCU controller

The smaract libraries must be known by the system, adding their location on the system path
""""""

from __future__ import division

from instrumental import u, Q_
from instrumental.log import get_logger
from instrumental.drivers import Facet
from instrumental.drivers import ParamSet
from instrumental.drivers.motion.smaract import SmaractDevice
from instrumental.drivers.motion._smaract.scu_midlib import NiceSCU, SmarActError, OPERATING_MODES
from instrumental.drivers.util import check_units

log = get_logger(__name__)


def list_instruments():
    ids, Nids = NiceSCU.GetAvailableDevices(2048)
    pset = []
    if Nids > 0:
        if Nids == 1:
            ids = [ids]
        NiceSCU.InitDevices(OPERATING_MODES['SA_SYNCHRONOUS_COMMUNICATION'])

        for ind, idd in enumerate(ids):
            try:
                rotation = False
                ind_channel = 0
                while True:
                    act = NiceSCU.Actuator(ind, ind_channel)
                    try:
                        act.GetStatus_S()
                    except SmarActError as e:
                        # will fire an error if the ind_channel is invalid
                        break
                    try:
                        sensor = bool(act.GetSensorPresent_S())
                    except SmarActError as e:
                        sensor = False
                    if sensor:
                        try:
                            act.GetAngle_S()
                            rotation = True
                        except SmarActError:
                            rotation = False
                    ind_channel += 1
            except SmarActError as e:
                pass
            for ind_channel in range(ind_channel):
                pset.append(ParamSet(SCU if not sensor else SCURotation if rotation else SCULinear,
                                     id=idd, index=ind_channel, sensor=sensor,
                                     rotation=rotation, nchannels=ind_channel+1,
                                     units='steps' if not sensor else 'deg' if rotation else 'µm'))
        NiceSCU.ReleaseDevices()

    return pset


FREQ_LIMITS = Q_((1, 18500), units='Hz')  # Hz
AMP_LIMITS = Q_((15, 100), units='V')  # V


class SCU(SmaractDevice):
    """""" Class for controlling actuators from smaract using the SCU controller

    Takes the device index and channel index as init parameters

    """"""
    _INST_PARAMS_ = ['id', 'index']
    dev_type = 'stepper'
    units = 'steps'

    def _initialize(self):
        """"""

        Returns
        -------

        """"""
        self.device_id = self._paramset['id']
        self.channel_index = self._paramset['index']
        self.nchannels = self._paramset['nchannels']
        self._hold_time = 0
        self._actuator = None
        self._internal_counter = 0
        self._frequency = 100
        self._open(self.device_id)

    def _open(self, device_id):
        try:
            NiceSCU.ReleaseDevices()
        except SmarActError as e:
            log.info('Cannot release SCU controller devices as none have been initialized yet')

        NiceSCU.AddDeviceToInitDevicesList(device_id)
        NiceSCU.InitDevices(OPERATING_MODES['SA_SYNCHRONOUS_COMMUNICATION'])

        self._actuator = NiceSCU.Actuator(0, self.channel_index)

    def close(self):
        NiceSCU.ReleaseDevices()

    def stop(self):
        self._actuator.Stop_S()

    @classmethod
    def get_devices(cls):
        devs, Ndevs = NiceSCU.GetAvailableDevices(2048)
        if Ndevs == 1:
            return [devs]
        else:
            return devs

    def has_sensor(self):
        ret = self._actuator.GetSensorPresent_S()
        if ret == NiceSCU._defs['SA_SENSOR_PRESENT']:
            return True
        else:
            return False

    @Facet(units='ms')
    def hold_time(self):
        return self._hold_time

    @hold_time.setter
    def hold_time(self, time):
        self._hold_time = time

    @Facet(units='Hz', limits=(0, 18500))
    def max_frequency(self):
        return self._actuator.GetClosedLoopMaxFrequency_S()

    @max_frequency.setter
    def max_frequency(self, frequency):
        return self._actuator.SetClosedLoopMaxFrequency_S(frequency)

    @Facet
    def is_referenced(self):
        ret = self._actuator.GetPhysicalPositionKnown_S()
        if ret == NiceSCU._defs['SA_PHYSICAL_POSITION_KNOWN.']:
            return True
        else:
            return False

    @Facet(units='V', limits=AMP_LIMITS.m_as('V'))
    def amplitude(self):

        return self._actuator.GetAmplitude_S() / 10

    @property
    def amplitude_limits(self):
        return AMP_LIMITS

    @amplitude.setter
    def amplitude(self, amp):
        self._internal_counter = 0  # reset the internal counter as it has no meaning if amplitude change
        self._actuator.SetAmplitude_S(int(amp * 10))

    @Facet(units='Hz', limits=FREQ_LIMITS.m_as('Hz'))
    def frequency(self):
        return self._frequency

    @frequency.setter
    def frequency(self, freq):
        self._frequency = freq

    @property
    def frequency_limits(self):
        return FREQ_LIMITS

    def move_to(self, value, move_type='rel'):
        """"""

        Parameters
        ----------
        value: (float) position in steps
        move_type: (str) without sensor can only be 'rel' for relative motion fro a given number of steps
        """"""
        if isinstance(value, Q_):
            value = value.magnitude

        if move_type == 'abs':
            log.info('No Absolute Move possible, only relative stepping is available using a relative move using'
                     'internal counter')
            rel_value = value-self._internal_counter
            self._actuator.MoveStep_S(int(rel_value), int(self.amplitude.magnitude * 10),
                                      int(self.frequency.magnitude))
            self._internal_counter += rel_value
        else:
            self._actuator.MoveStep_S(int(value), int(self.amplitude.magnitude * 10),
                                      int(self.frequency.magnitude))
            self._internal_counter += value

    def move_home(self, autozero=True):
        if not self.has_sensor:

            log.info('No possible homing as no sensor is present, trying to go to 0 internal counter')
            self.move_to(Q_(-self._internal_counter, ''), 'rel')

        else:
            self._actuator.MoveToReference_S(self.hold_time.magnitude,
                                           NiceSCU._defs['SA_AUTO_ZERO'] if autozero else
                                           NiceSCU._defs['SA_NO_AUTO_ZERO'])

    def check_position(self):
        return Q_(self._internal_counter, '')


class SCULinear(SCU):
    _INST_PARAMS_ = ['id', 'index']
    dev_type = 'linear'
    units = 'µm'

    @check_units(value='µm')
    def move_to(self, value, move_type='abs'):
        """"""

        Parameters
        ----------
        value: (float) position in µm
        move_type: (str) either 'rel' for relative motion or 'abs' for absolute positioning
        """"""

        if move_type == 'abs':
            self._actuator.MovePositionAbsolute_S(value.m_as('µm') * 10, self.hold_time.magnitude)  # takes value in 1/10 of µm
        else:
            self._actuator.MovePositionRelative_S(value.m_as('µm') * 10, self.hold_time.magnitude)   # takes value in 1/10 of µm

    def check_position(self):
        return Q_(0.1 * self._actuator.GetPosition_S(), 'µm')


class SCURotation(SCU):
    _INST_PARAMS_ = ['id', 'index']
    dev_type = 'rotation'
    units = 'deg'

    @check_units(value='deg')
    def move_to(self, value, move_type='abs'):
        """"""

        Parameters
        ----------
        value: (float) rotation in deg
        move_type: (str) either 'rel' for relative motion or 'abs' for absolute positioning
        """"""

        if move_type == 'abs':
            self._actuator.MoveAngleAbsolute_S(value.m_as('mdeg') * 10, self.hold_time.magnitude)  # takes value in 1/10 of µm
        else:
            self._actuator.MoveAngleRelative_S(value.m_as('mdeg') * 10, self.hold_time.magnitude)  # takes value in 1/10 of µm

    def check_position(self):
        return Q_(self._actuator.GetAngle_S(), 'deg')


if __name__ == '__main__':
    from instrumental import instrument
    paramsets = list_instruments()
    # inst = instrument(paramsets[0])
    # try:
    #     NiceSCU.ReleaseDevices()
    # except SmarActError as e:
    #     print(e)
    ids = SCU.get_devices()
    dev = instrument(paramsets[0])
    dev.move_home()
    pos = dev.check_position()
    pass
    dev.close()

"
